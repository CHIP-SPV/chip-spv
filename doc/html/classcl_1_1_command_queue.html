<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CHIP-SPV: cl::CommandQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CHIP-SPV<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Multiple backend interface for HIP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecl.html">cl</a></li><li class="navelem"><a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcl_1_1_command_queue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">cl::CommandQueue Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classcl_1_1_command_queue.html" title="CommandQueue interface for cl_command_queue.">CommandQueue</a> interface for cl_command_queue.  
 <a href="classcl_1_1_command_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cl_8hpp_source.html">cl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cl::CommandQueue:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcl_1_1_command_queue.png" usemap="#cl::CommandQueue_map" alt=""/>
  <map id="cl::CommandQueue_map" name="cl::CommandQueue_map">
<area href="classcl_1_1detail_1_1_wrapper.html" alt="cl::detail::Wrapper&lt; cl_command_queue &gt;" shape="rect" coords="0,0,248,24"/>
<area href="classcl_1_1detail_1_1_wrapper.html" alt="cl::detail::Wrapper&lt; cl_command_queue &gt;" shape="rect" coords="258,0,506,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8462de408ebfaf6332429a92b7938490"><td class="memItemLeft" align="right" valign="top"><a id="a8462de408ebfaf6332429a92b7938490" name="a8462de408ebfaf6332429a92b7938490"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CommandQueue</b> (cl_command_queue_properties properties, cl_int *err=NULL)</td></tr>
<tr class="separator:a8462de408ebfaf6332429a92b7938490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb116a4e1a53417dad3d3850c33d42f"><td class="memItemLeft" align="right" valign="top"><a id="adcb116a4e1a53417dad3d3850c33d42f" name="adcb116a4e1a53417dad3d3850c33d42f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CommandQueue</b> (const <a class="el" href="classcl_1_1_context.html">Context</a> &amp;context, cl_command_queue_properties properties=0, cl_int *err=NULL)</td></tr>
<tr class="memdesc:adcb116a4e1a53417dad3d3850c33d42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classcl_1_1_command_queue.html" title="CommandQueue interface for cl_command_queue.">CommandQueue</a> for an implementation defined device in the given context. <br /></td></tr>
<tr class="separator:adcb116a4e1a53417dad3d3850c33d42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887826e515b03224aec87b33ac59f327"><td class="memItemLeft" align="right" valign="top"><a id="a887826e515b03224aec87b33ac59f327" name="a887826e515b03224aec87b33ac59f327"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CommandQueue</b> (const <a class="el" href="classcl_1_1_context.html">Context</a> &amp;context, const <a class="el" href="classcl_1_1_device.html">Device</a> &amp;device, cl_command_queue_properties properties=0, cl_int *err=NULL)</td></tr>
<tr class="separator:a887826e515b03224aec87b33ac59f327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ce434c5100e5b467ea8c6561e1f11e"><td class="memItemLeft" align="right" valign="top"><a id="ae2ce434c5100e5b467ea8c6561e1f11e" name="ae2ce434c5100e5b467ea8c6561e1f11e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CommandQueue</b> (const <a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;queue)</td></tr>
<tr class="memdesc:ae2ce434c5100e5b467ea8c6561e1f11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor to forward copy to the superclass correctly. Required for MSVC. <br /></td></tr>
<tr class="separator:ae2ce434c5100e5b467ea8c6561e1f11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc310b23c19aefa6e129ade1cdfbebb"><td class="memItemLeft" align="right" valign="top"><a id="adcc310b23c19aefa6e129ade1cdfbebb" name="adcc310b23c19aefa6e129ade1cdfbebb"></a>
<a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;queue)</td></tr>
<tr class="memdesc:adcc310b23c19aefa6e129ade1cdfbebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment to forward copy to the superclass correctly. Required for MSVC. <br /></td></tr>
<tr class="separator:adcc310b23c19aefa6e129ade1cdfbebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e10c9b69745d22107da40e4c3511884"><td class="memItemLeft" align="right" valign="top"><a id="a5e10c9b69745d22107da40e4c3511884" name="a5e10c9b69745d22107da40e4c3511884"></a>
__CL_EXPLICIT_CONSTRUCTORS&#160;</td><td class="memItemRight" valign="bottom"><b>CommandQueue</b> (const cl_command_queue &amp;commandQueue)</td></tr>
<tr class="separator:a5e10c9b69745d22107da40e4c3511884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb39cfb0887f0b06ba96657fce73f10a"><td class="memItemLeft" align="right" valign="top"><a id="abb39cfb0887f0b06ba96657fce73f10a" name="abb39cfb0887f0b06ba96657fce73f10a"></a>
<a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const cl_command_queue &amp;rhs)</td></tr>
<tr class="separator:abb39cfb0887f0b06ba96657fce73f10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ba91cef5c88b386b5ecad998501503"><td class="memTemplParams" colspan="2"><a id="a24ba91cef5c88b386b5ecad998501503" name="a24ba91cef5c88b386b5ecad998501503"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24ba91cef5c88b386b5ecad998501503"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getInfo</b> (cl_command_queue_info name, T *param) const</td></tr>
<tr class="separator:a24ba91cef5c88b386b5ecad998501503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534566b65dae3f2a60034fe2bdac9258"><td class="memTemplParams" colspan="2"><a id="a534566b65dae3f2a60034fe2bdac9258" name="a534566b65dae3f2a60034fe2bdac9258"></a>
template&lt;cl_int name&gt; </td></tr>
<tr class="memitem:a534566b65dae3f2a60034fe2bdac9258"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcl_1_1detail_1_1param__traits.html">detail::param_traits</a>&lt; detail::cl_command_queue_info, name &gt;::param_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getInfo</b> (cl_int *err=NULL) const</td></tr>
<tr class="separator:a534566b65dae3f2a60034fe2bdac9258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb669c90c6401c97fd8ea2a517c8530"><td class="memItemLeft" align="right" valign="top"><a id="a3bb669c90c6401c97fd8ea2a517c8530" name="a3bb669c90c6401c97fd8ea2a517c8530"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueReadBuffer</b> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;buffer, cl_bool blocking, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> offset, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> size, void *ptr, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a3bb669c90c6401c97fd8ea2a517c8530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf3a8168953cabd884d2edd5daba475"><td class="memItemLeft" align="right" valign="top"><a id="a6bf3a8168953cabd884d2edd5daba475" name="a6bf3a8168953cabd884d2edd5daba475"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueWriteBuffer</b> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;buffer, cl_bool blocking, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> offset, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> size, const void *ptr, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a6bf3a8168953cabd884d2edd5daba475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dcba0fb4fa539bc49df0f315d8ea34"><td class="memItemLeft" align="right" valign="top"><a id="a84dcba0fb4fa539bc49df0f315d8ea34" name="a84dcba0fb4fa539bc49df0f315d8ea34"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueCopyBuffer</b> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;src, const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;dst, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> src_offset, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> dst_offset, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> size, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a84dcba0fb4fa539bc49df0f315d8ea34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17906d86ff37d96b170c063576cd89a1"><td class="memItemLeft" align="right" valign="top"><a id="a17906d86ff37d96b170c063576cd89a1" name="a17906d86ff37d96b170c063576cd89a1"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueReadImage</b> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;image, cl_bool blocking, const <a class="el" href="classcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;origin, const <a class="el" href="classcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;region, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> row_pitch, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> slice_pitch, void *ptr, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a17906d86ff37d96b170c063576cd89a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d38a67846800f96eccbd61c8148969"><td class="memItemLeft" align="right" valign="top"><a id="ac7d38a67846800f96eccbd61c8148969" name="ac7d38a67846800f96eccbd61c8148969"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueWriteImage</b> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;image, cl_bool blocking, const <a class="el" href="classcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;origin, const <a class="el" href="classcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;region, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> row_pitch, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> slice_pitch, const void *ptr, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:ac7d38a67846800f96eccbd61c8148969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec22426d08ac1b1f660eb6642bfdfa9e"><td class="memItemLeft" align="right" valign="top"><a id="aec22426d08ac1b1f660eb6642bfdfa9e" name="aec22426d08ac1b1f660eb6642bfdfa9e"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueCopyImage</b> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;src, const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;dst, const <a class="el" href="classcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;src_origin, const <a class="el" href="classcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;dst_origin, const <a class="el" href="classcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;region, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:aec22426d08ac1b1f660eb6642bfdfa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1eb5c89523128ac01687a03f2e4cd88"><td class="memItemLeft" align="right" valign="top"><a id="ae1eb5c89523128ac01687a03f2e4cd88" name="ae1eb5c89523128ac01687a03f2e4cd88"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueCopyImageToBuffer</b> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;src, const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;dst, const <a class="el" href="classcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;src_origin, const <a class="el" href="classcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;region, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> dst_offset, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:ae1eb5c89523128ac01687a03f2e4cd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9026c21b63963fbe803d351640c6ed1"><td class="memItemLeft" align="right" valign="top"><a id="ae9026c21b63963fbe803d351640c6ed1" name="ae9026c21b63963fbe803d351640c6ed1"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueCopyBufferToImage</b> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;src, const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;dst, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> src_offset, const <a class="el" href="classcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;dst_origin, const <a class="el" href="classcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;region, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:ae9026c21b63963fbe803d351640c6ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce8313a1d76ba737b954c143a4f3d62"><td class="memItemLeft" align="right" valign="top"><a id="a9ce8313a1d76ba737b954c143a4f3d62" name="a9ce8313a1d76ba737b954c143a4f3d62"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueMapBuffer</b> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;buffer, cl_bool blocking, cl_map_flags flags, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> offset, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> size, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL, cl_int *err=NULL) const</td></tr>
<tr class="separator:a9ce8313a1d76ba737b954c143a4f3d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b6f9e3f65e14b87b64e59ab38258f4"><td class="memItemLeft" align="right" valign="top"><a id="a78b6f9e3f65e14b87b64e59ab38258f4" name="a78b6f9e3f65e14b87b64e59ab38258f4"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueMapImage</b> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;buffer, cl_bool blocking, cl_map_flags flags, const <a class="el" href="classcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;origin, const <a class="el" href="classcl_1_1size__t.html">size_t</a>&lt; 3 &gt; &amp;region, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> *row_pitch, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> *slice_pitch, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL, cl_int *err=NULL) const</td></tr>
<tr class="separator:a78b6f9e3f65e14b87b64e59ab38258f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe83c05e5e3164cab113a17ef78428a"><td class="memItemLeft" align="right" valign="top"><a id="adbe83c05e5e3164cab113a17ef78428a" name="adbe83c05e5e3164cab113a17ef78428a"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueUnmapMemObject</b> (const <a class="el" href="classcl_1_1_memory.html">Memory</a> &amp;memory, void *mapped_ptr, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:adbe83c05e5e3164cab113a17ef78428a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5202fefbf8783e3626808ac2e95e18e"><td class="memItemLeft" align="right" valign="top"><a id="ad5202fefbf8783e3626808ac2e95e18e" name="ad5202fefbf8783e3626808ac2e95e18e"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueNDRangeKernel</b> (const <a class="el" href="classcl_1_1_kernel.html">Kernel</a> &amp;kernel, const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;offset, const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;global, const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;local=NullRange, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:ad5202fefbf8783e3626808ac2e95e18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d183e8a1a021f0da6b2bbf1d1cda36"><td class="memItemLeft" align="right" valign="top"><a id="ad4d183e8a1a021f0da6b2bbf1d1cda36" name="ad4d183e8a1a021f0da6b2bbf1d1cda36"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueTask</b> (const <a class="el" href="classcl_1_1_kernel.html">Kernel</a> &amp;kernel, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:ad4d183e8a1a021f0da6b2bbf1d1cda36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bdff1b49e27cf0ff29de5fc7156cf2"><td class="memItemLeft" align="right" valign="top"><a id="a21bdff1b49e27cf0ff29de5fc7156cf2" name="a21bdff1b49e27cf0ff29de5fc7156cf2"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueNativeKernel</b> (void(CL_CALLBACK *userFptr)(void *), std::pair&lt; void *, ::<a class="el" href="classcl_1_1size__t.html">size_t</a> &gt; args, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_memory.html">Memory</a> &gt; *mem_objects=NULL, const VECTOR_CLASS&lt; const void * &gt; *mem_locs=NULL, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a21bdff1b49e27cf0ff29de5fc7156cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab987adc2e00f12c74b554ee708ed5b3f"><td class="memItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#ab987adc2e00f12c74b554ee708ed5b3f">enqueueAcquireGLObjects</a> (const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_memory.html">Memory</a> &gt; *mem_objects=NULL, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:ab987adc2e00f12c74b554ee708ed5b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690e590ad8f3f70a5f916cf30ca1436d"><td class="memItemLeft" align="right" valign="top"><a id="a690e590ad8f3f70a5f916cf30ca1436d" name="a690e590ad8f3f70a5f916cf30ca1436d"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueReleaseGLObjects</b> (const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_memory.html">Memory</a> &gt; *mem_objects=NULL, const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a690e590ad8f3f70a5f916cf30ca1436d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cba88b51715610d76b0956140be9655"><td class="memItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a3cba88b51715610d76b0956140be9655">flush</a> () const</td></tr>
<tr class="separator:a3cba88b51715610d76b0956140be9655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511d461b0f5fabc8d737f4f29a4f346e"><td class="memItemLeft" align="right" valign="top"><a id="a511d461b0f5fabc8d737f4f29a4f346e" name="a511d461b0f5fabc8d737f4f29a4f346e"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>finish</b> () const</td></tr>
<tr class="separator:a511d461b0f5fabc8d737f4f29a4f346e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8462de408ebfaf6332429a92b7938490"><td class="memItemLeft" align="right" valign="top"><a id="a8462de408ebfaf6332429a92b7938490" name="a8462de408ebfaf6332429a92b7938490"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CommandQueue</b> (cl_command_queue_properties properties, cl_int *err=NULL)</td></tr>
<tr class="memdesc:a8462de408ebfaf6332429a92b7938490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classcl_1_1_command_queue.html" title="CommandQueue interface for cl_command_queue.">CommandQueue</a> based on passed properties. Will return an CL_INVALID_QUEUE_PROPERTIES error if CL_QUEUE_ON_DEVICE is specified. <br /></td></tr>
<tr class="separator:a8462de408ebfaf6332429a92b7938490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ae8e9e44e9b28fc755937490535550"><td class="memItemLeft" align="right" valign="top"><a id="a05ae8e9e44e9b28fc755937490535550" name="a05ae8e9e44e9b28fc755937490535550"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CommandQueue</b> (QueueProperties properties, cl_int *err=NULL)</td></tr>
<tr class="memdesc:a05ae8e9e44e9b28fc755937490535550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classcl_1_1_command_queue.html" title="CommandQueue interface for cl_command_queue.">CommandQueue</a> based on passed properties. Will return an CL_INVALID_QUEUE_PROPERTIES error if CL_QUEUE_ON_DEVICE is specified. <br /></td></tr>
<tr class="separator:a05ae8e9e44e9b28fc755937490535550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb116a4e1a53417dad3d3850c33d42f"><td class="memItemLeft" align="right" valign="top"><a id="adcb116a4e1a53417dad3d3850c33d42f" name="adcb116a4e1a53417dad3d3850c33d42f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CommandQueue</b> (const <a class="el" href="classcl_1_1_context.html">Context</a> &amp;context, cl_command_queue_properties properties=0, cl_int *err=NULL)</td></tr>
<tr class="memdesc:adcb116a4e1a53417dad3d3850c33d42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classcl_1_1_command_queue.html" title="CommandQueue interface for cl_command_queue.">CommandQueue</a> for an implementation defined device in the given context Will return an CL_INVALID_QUEUE_PROPERTIES error if CL_QUEUE_ON_DEVICE is specified. <br /></td></tr>
<tr class="separator:adcb116a4e1a53417dad3d3850c33d42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975c3dce399cb77a5c6b0e294e4778fe"><td class="memItemLeft" align="right" valign="top"><a id="a975c3dce399cb77a5c6b0e294e4778fe" name="a975c3dce399cb77a5c6b0e294e4778fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CommandQueue</b> (const <a class="el" href="classcl_1_1_context.html">Context</a> &amp;context, QueueProperties properties, cl_int *err=NULL)</td></tr>
<tr class="memdesc:a975c3dce399cb77a5c6b0e294e4778fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classcl_1_1_command_queue.html" title="CommandQueue interface for cl_command_queue.">CommandQueue</a> for an implementation defined device in the given context Will return an CL_INVALID_QUEUE_PROPERTIES error if CL_QUEUE_ON_DEVICE is specified. <br /></td></tr>
<tr class="separator:a975c3dce399cb77a5c6b0e294e4778fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887826e515b03224aec87b33ac59f327"><td class="memItemLeft" align="right" valign="top"><a id="a887826e515b03224aec87b33ac59f327" name="a887826e515b03224aec87b33ac59f327"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CommandQueue</b> (const <a class="el" href="classcl_1_1_context.html">Context</a> &amp;context, const <a class="el" href="classcl_1_1_device.html">Device</a> &amp;device, cl_command_queue_properties properties=0, cl_int *err=NULL)</td></tr>
<tr class="memdesc:a887826e515b03224aec87b33ac59f327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classcl_1_1_command_queue.html" title="CommandQueue interface for cl_command_queue.">CommandQueue</a> for a passed device and context Will return an CL_INVALID_QUEUE_PROPERTIES error if CL_QUEUE_ON_DEVICE is specified. <br /></td></tr>
<tr class="separator:a887826e515b03224aec87b33ac59f327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd467bd94839921b7318cb30f92b5a4"><td class="memItemLeft" align="right" valign="top"><a id="a8dd467bd94839921b7318cb30f92b5a4" name="a8dd467bd94839921b7318cb30f92b5a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CommandQueue</b> (const <a class="el" href="classcl_1_1_context.html">Context</a> &amp;context, const <a class="el" href="classcl_1_1_device.html">Device</a> &amp;device, QueueProperties properties, cl_int *err=NULL)</td></tr>
<tr class="memdesc:a8dd467bd94839921b7318cb30f92b5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classcl_1_1_command_queue.html" title="CommandQueue interface for cl_command_queue.">CommandQueue</a> for a passed device and context Will return an CL_INVALID_QUEUE_PROPERTIES error if CL_QUEUE_ON_DEVICE is specified. <br /></td></tr>
<tr class="separator:a8dd467bd94839921b7318cb30f92b5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09be675998c51f36aa7744b47eabebd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a09be675998c51f36aa7744b47eabebd3">CommandQueue</a> (const cl_command_queue &amp;commandQueue, bool retainObject=false)</td></tr>
<tr class="memdesc:a09be675998c51f36aa7744b47eabebd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from cl_command_queue - takes ownership.  <a href="classcl_1_1_command_queue.html#a09be675998c51f36aa7744b47eabebd3">More...</a><br /></td></tr>
<tr class="separator:a09be675998c51f36aa7744b47eabebd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb39cfb0887f0b06ba96657fce73f10a"><td class="memItemLeft" align="right" valign="top"><a id="abb39cfb0887f0b06ba96657fce73f10a" name="abb39cfb0887f0b06ba96657fce73f10a"></a>
<a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const cl_command_queue &amp;rhs)</td></tr>
<tr class="separator:abb39cfb0887f0b06ba96657fce73f10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ce434c5100e5b467ea8c6561e1f11e"><td class="memItemLeft" align="right" valign="top"><a id="ae2ce434c5100e5b467ea8c6561e1f11e" name="ae2ce434c5100e5b467ea8c6561e1f11e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CommandQueue</b> (const <a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;queue)</td></tr>
<tr class="memdesc:ae2ce434c5100e5b467ea8c6561e1f11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor to forward copy to the superclass correctly. Required for MSVC. <br /></td></tr>
<tr class="separator:ae2ce434c5100e5b467ea8c6561e1f11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc310b23c19aefa6e129ade1cdfbebb"><td class="memItemLeft" align="right" valign="top"><a id="adcc310b23c19aefa6e129ade1cdfbebb" name="adcc310b23c19aefa6e129ade1cdfbebb"></a>
<a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;queue)</td></tr>
<tr class="memdesc:adcc310b23c19aefa6e129ade1cdfbebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment to forward copy to the superclass correctly. Required for MSVC. <br /></td></tr>
<tr class="separator:adcc310b23c19aefa6e129ade1cdfbebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5830678be567e34dccbb0065c89b21"><td class="memItemLeft" align="right" valign="top"><a id="a1c5830678be567e34dccbb0065c89b21" name="a1c5830678be567e34dccbb0065c89b21"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CommandQueue</b> (<a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;&amp;queue) CL_HPP_NOEXCEPT_</td></tr>
<tr class="memdesc:a1c5830678be567e34dccbb0065c89b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor to forward move to the superclass correctly. Required for MSVC. <br /></td></tr>
<tr class="separator:a1c5830678be567e34dccbb0065c89b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678df8cbf6547ae2c772cd6d2d96f96f"><td class="memItemLeft" align="right" valign="top"><a id="a678df8cbf6547ae2c772cd6d2d96f96f" name="a678df8cbf6547ae2c772cd6d2d96f96f"></a>
<a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;&amp;queue)</td></tr>
<tr class="memdesc:a678df8cbf6547ae2c772cd6d2d96f96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment to forward move to the superclass correctly. Required for MSVC. <br /></td></tr>
<tr class="separator:a678df8cbf6547ae2c772cd6d2d96f96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ba91cef5c88b386b5ecad998501503"><td class="memTemplParams" colspan="2"><a id="a24ba91cef5c88b386b5ecad998501503" name="a24ba91cef5c88b386b5ecad998501503"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24ba91cef5c88b386b5ecad998501503"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getInfo</b> (cl_command_queue_info name, T *param) const</td></tr>
<tr class="separator:a24ba91cef5c88b386b5ecad998501503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534566b65dae3f2a60034fe2bdac9258"><td class="memTemplParams" colspan="2"><a id="a534566b65dae3f2a60034fe2bdac9258" name="a534566b65dae3f2a60034fe2bdac9258"></a>
template&lt;cl_command_queue_info name&gt; </td></tr>
<tr class="memitem:a534566b65dae3f2a60034fe2bdac9258"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcl_1_1detail_1_1param__traits.html">detail::param_traits</a>&lt; detail::cl_command_queue_info, name &gt;::param_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getInfo</b> (cl_int *err=NULL) const</td></tr>
<tr class="separator:a534566b65dae3f2a60034fe2bdac9258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f78df7eadfd5202e1e670aacb16014"><td class="memItemLeft" align="right" valign="top"><a id="a81f78df7eadfd5202e1e670aacb16014" name="a81f78df7eadfd5202e1e670aacb16014"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueReadBuffer</b> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;buffer, cl_bool blocking, <a class="el" href="classcl_1_1size__t.html">size_type</a> offset, <a class="el" href="classcl_1_1size__t.html">size_type</a> size, void *ptr, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a81f78df7eadfd5202e1e670aacb16014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee8965ec3b645fd416d6448516b346c"><td class="memItemLeft" align="right" valign="top"><a id="acee8965ec3b645fd416d6448516b346c" name="acee8965ec3b645fd416d6448516b346c"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueWriteBuffer</b> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;buffer, cl_bool blocking, <a class="el" href="classcl_1_1size__t.html">size_type</a> offset, <a class="el" href="classcl_1_1size__t.html">size_type</a> size, const void *ptr, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:acee8965ec3b645fd416d6448516b346c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5708cb52ca4ef7dd61d774e7aad2ef95"><td class="memItemLeft" align="right" valign="top"><a id="a5708cb52ca4ef7dd61d774e7aad2ef95" name="a5708cb52ca4ef7dd61d774e7aad2ef95"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueCopyBuffer</b> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;src, const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;dst, <a class="el" href="classcl_1_1size__t.html">size_type</a> src_offset, <a class="el" href="classcl_1_1size__t.html">size_type</a> dst_offset, <a class="el" href="classcl_1_1size__t.html">size_type</a> size, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a5708cb52ca4ef7dd61d774e7aad2ef95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b7b02623f13b393a79e3ff9916d270"><td class="memItemLeft" align="right" valign="top"><a id="ae8b7b02623f13b393a79e3ff9916d270" name="ae8b7b02623f13b393a79e3ff9916d270"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueReadBufferRect</b> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;buffer, cl_bool blocking, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;buffer_offset, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;host_offset, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;region, <a class="el" href="classcl_1_1size__t.html">size_type</a> buffer_row_pitch, <a class="el" href="classcl_1_1size__t.html">size_type</a> buffer_slice_pitch, <a class="el" href="classcl_1_1size__t.html">size_type</a> host_row_pitch, <a class="el" href="classcl_1_1size__t.html">size_type</a> host_slice_pitch, void *ptr, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:ae8b7b02623f13b393a79e3ff9916d270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84669123946c99690f32c08276b9512a"><td class="memItemLeft" align="right" valign="top"><a id="a84669123946c99690f32c08276b9512a" name="a84669123946c99690f32c08276b9512a"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueWriteBufferRect</b> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;buffer, cl_bool blocking, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;buffer_offset, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;host_offset, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;region, <a class="el" href="classcl_1_1size__t.html">size_type</a> buffer_row_pitch, <a class="el" href="classcl_1_1size__t.html">size_type</a> buffer_slice_pitch, <a class="el" href="classcl_1_1size__t.html">size_type</a> host_row_pitch, <a class="el" href="classcl_1_1size__t.html">size_type</a> host_slice_pitch, const void *ptr, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a84669123946c99690f32c08276b9512a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83096c6bf792527c8c606a653d6b308b"><td class="memItemLeft" align="right" valign="top"><a id="a83096c6bf792527c8c606a653d6b308b" name="a83096c6bf792527c8c606a653d6b308b"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueCopyBufferRect</b> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;src, const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;dst, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;src_origin, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;dst_origin, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;region, <a class="el" href="classcl_1_1size__t.html">size_type</a> src_row_pitch, <a class="el" href="classcl_1_1size__t.html">size_type</a> src_slice_pitch, <a class="el" href="classcl_1_1size__t.html">size_type</a> dst_row_pitch, <a class="el" href="classcl_1_1size__t.html">size_type</a> dst_slice_pitch, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a83096c6bf792527c8c606a653d6b308b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f546d77b717ce26606c462c0ca9d1c"><td class="memTemplParams" colspan="2">template&lt;typename PatternType &gt; </td></tr>
<tr class="memitem:a09f546d77b717ce26606c462c0ca9d1c"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a09f546d77b717ce26606c462c0ca9d1c">enqueueFillBuffer</a> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;buffer, PatternType pattern, <a class="el" href="classcl_1_1size__t.html">size_type</a> offset, <a class="el" href="classcl_1_1size__t.html">size_type</a> size, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a09f546d77b717ce26606c462c0ca9d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd7ead0f68caafafffae2cb7be75c0b"><td class="memItemLeft" align="right" valign="top"><a id="abcd7ead0f68caafafffae2cb7be75c0b" name="abcd7ead0f68caafafffae2cb7be75c0b"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueReadImage</b> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;image, cl_bool blocking, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;origin, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;region, <a class="el" href="classcl_1_1size__t.html">size_type</a> row_pitch, <a class="el" href="classcl_1_1size__t.html">size_type</a> slice_pitch, void *ptr, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:abcd7ead0f68caafafffae2cb7be75c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e335f69c0e65b624c670e0dfe10e59"><td class="memItemLeft" align="right" valign="top"><a id="a88e335f69c0e65b624c670e0dfe10e59" name="a88e335f69c0e65b624c670e0dfe10e59"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueWriteImage</b> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;image, cl_bool blocking, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;origin, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;region, <a class="el" href="classcl_1_1size__t.html">size_type</a> row_pitch, <a class="el" href="classcl_1_1size__t.html">size_type</a> slice_pitch, const void *ptr, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a88e335f69c0e65b624c670e0dfe10e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e4e3e6c2183aa6254901dc62ed1e0e"><td class="memItemLeft" align="right" valign="top"><a id="a97e4e3e6c2183aa6254901dc62ed1e0e" name="a97e4e3e6c2183aa6254901dc62ed1e0e"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueCopyImage</b> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;src, const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;dst, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;src_origin, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;dst_origin, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;region, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a97e4e3e6c2183aa6254901dc62ed1e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3230b644ad638973be7199e0451e46"><td class="memItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a9c3230b644ad638973be7199e0451e46">enqueueFillImage</a> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;image, <a class="el" href="unioncl__float4.html">cl_float4</a> fillColor, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;origin, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;region, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a9c3230b644ad638973be7199e0451e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2c278ef4f177c5d01035c008a5cb3e"><td class="memItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#acb2c278ef4f177c5d01035c008a5cb3e">enqueueFillImage</a> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;image, <a class="el" href="unioncl__int4.html">cl_int4</a> fillColor, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;origin, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;region, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:acb2c278ef4f177c5d01035c008a5cb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3081328f7b10be88e87eb719d3ad6307"><td class="memItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a3081328f7b10be88e87eb719d3ad6307">enqueueFillImage</a> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;image, <a class="el" href="unioncl__uint4.html">cl_uint4</a> fillColor, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;origin, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;region, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a3081328f7b10be88e87eb719d3ad6307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaaa991a224cae832f2fe743e66b3773"><td class="memItemLeft" align="right" valign="top"><a id="acaaa991a224cae832f2fe743e66b3773" name="acaaa991a224cae832f2fe743e66b3773"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueCopyImageToBuffer</b> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;src, const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;dst, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;src_origin, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;region, <a class="el" href="classcl_1_1size__t.html">size_type</a> dst_offset, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:acaaa991a224cae832f2fe743e66b3773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf243bc86af453851faa779d5aa3c9e"><td class="memItemLeft" align="right" valign="top"><a id="a4bf243bc86af453851faa779d5aa3c9e" name="a4bf243bc86af453851faa779d5aa3c9e"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueCopyBufferToImage</b> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;src, const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;dst, <a class="el" href="classcl_1_1size__t.html">size_type</a> src_offset, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;dst_origin, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;region, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a4bf243bc86af453851faa779d5aa3c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b20f90a3e6aeafebc63940975bdc22d"><td class="memItemLeft" align="right" valign="top"><a id="a4b20f90a3e6aeafebc63940975bdc22d" name="a4b20f90a3e6aeafebc63940975bdc22d"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueMapBuffer</b> (const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;buffer, cl_bool blocking, cl_map_flags flags, <a class="el" href="classcl_1_1size__t.html">size_type</a> offset, <a class="el" href="classcl_1_1size__t.html">size_type</a> size, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL, cl_int *err=NULL) const</td></tr>
<tr class="separator:a4b20f90a3e6aeafebc63940975bdc22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a0fda156ff746bd684c698b7851f67"><td class="memItemLeft" align="right" valign="top"><a id="a67a0fda156ff746bd684c698b7851f67" name="a67a0fda156ff746bd684c698b7851f67"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueMapImage</b> (const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;buffer, cl_bool blocking, cl_map_flags flags, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;origin, const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;region, <a class="el" href="classcl_1_1size__t.html">size_type</a> *row_pitch, <a class="el" href="classcl_1_1size__t.html">size_type</a> *slice_pitch, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL, cl_int *err=NULL) const</td></tr>
<tr class="separator:a67a0fda156ff746bd684c698b7851f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8211d19eb2ffbb8adc7f565fe61c3c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec8211d19eb2ffbb8adc7f565fe61c3c"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#aec8211d19eb2ffbb8adc7f565fe61c3c">enqueueMapSVM</a> (T *ptr, cl_bool blocking, cl_map_flags flags, <a class="el" href="classcl_1_1size__t.html">size_type</a> size, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:aec8211d19eb2ffbb8adc7f565fe61c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d16044448bcb2797f490a33e450bde"><td class="memTemplParams" colspan="2">template&lt;typename T , class D &gt; </td></tr>
<tr class="memitem:a58d16044448bcb2797f490a33e450bde"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a58d16044448bcb2797f490a33e450bde">enqueueMapSVM</a> (cl::pointer&lt; T, D &gt; &amp;ptr, cl_bool blocking, cl_map_flags flags, <a class="el" href="classcl_1_1size__t.html">size_type</a> size, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a58d16044448bcb2797f490a33e450bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fcb95415b760f23b2abba6e0842125"><td class="memTemplParams" colspan="2">template&lt;typename T , class Alloc &gt; </td></tr>
<tr class="memitem:a30fcb95415b760f23b2abba6e0842125"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a30fcb95415b760f23b2abba6e0842125">enqueueMapSVM</a> (cl::vector&lt; T, Alloc &gt; &amp;container, cl_bool blocking, cl_map_flags flags, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a30fcb95415b760f23b2abba6e0842125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf59626241152db7c2c986198ad32bba"><td class="memItemLeft" align="right" valign="top"><a id="abf59626241152db7c2c986198ad32bba" name="abf59626241152db7c2c986198ad32bba"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueUnmapMemObject</b> (const <a class="el" href="classcl_1_1_memory.html">Memory</a> &amp;memory, void *mapped_ptr, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:abf59626241152db7c2c986198ad32bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affae2ea7a86c23e01c11fbdcdc149300"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:affae2ea7a86c23e01c11fbdcdc149300"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#affae2ea7a86c23e01c11fbdcdc149300">enqueueUnmapSVM</a> (T *ptr, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:affae2ea7a86c23e01c11fbdcdc149300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8818c06a2f28a319d5259be7374c93fc"><td class="memTemplParams" colspan="2">template&lt;typename T , class D &gt; </td></tr>
<tr class="memitem:a8818c06a2f28a319d5259be7374c93fc"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a8818c06a2f28a319d5259be7374c93fc">enqueueUnmapSVM</a> (cl::pointer&lt; T, D &gt; &amp;ptr, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a8818c06a2f28a319d5259be7374c93fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e83f7dec93b2700b8ce4380d81bfcb"><td class="memTemplParams" colspan="2">template&lt;typename T , class Alloc &gt; </td></tr>
<tr class="memitem:af7e83f7dec93b2700b8ce4380d81bfcb"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#af7e83f7dec93b2700b8ce4380d81bfcb">enqueueUnmapSVM</a> (cl::vector&lt; T, Alloc &gt; &amp;container, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:af7e83f7dec93b2700b8ce4380d81bfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a3f83c5546fbfa71a38f4ea02e264d"><td class="memItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a76a3f83c5546fbfa71a38f4ea02e264d">enqueueMarkerWithWaitList</a> (const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=0, <a class="el" href="classcl_1_1_event.html">Event</a> *event=0) const</td></tr>
<tr class="separator:a76a3f83c5546fbfa71a38f4ea02e264d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf92038ba0d015824a7488091fc8f5a1"><td class="memItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#acf92038ba0d015824a7488091fc8f5a1">enqueueBarrierWithWaitList</a> (const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=0, <a class="el" href="classcl_1_1_event.html">Event</a> *event=0) const</td></tr>
<tr class="separator:acf92038ba0d015824a7488091fc8f5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9a4f084dc7634d3c73f5bf7f680b65"><td class="memItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a3a9a4f084dc7634d3c73f5bf7f680b65">enqueueMigrateMemObjects</a> (const vector&lt; <a class="el" href="classcl_1_1_memory.html">Memory</a> &gt; &amp;memObjects, cl_mem_migration_flags flags, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a3a9a4f084dc7634d3c73f5bf7f680b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8470ceddefdc40c796d83a41ace25442"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8470ceddefdc40c796d83a41ace25442"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a8470ceddefdc40c796d83a41ace25442">enqueueMigrateSVM</a> (const cl::vector&lt; T * &gt; &amp;svmRawPointers, const cl::vector&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a> &gt; &amp;sizes, cl_mem_migration_flags flags=0, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a8470ceddefdc40c796d83a41ace25442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7349f54501b3967c55337635f22e01fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7349f54501b3967c55337635f22e01fc"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a7349f54501b3967c55337635f22e01fc">enqueueMigrateSVM</a> (const cl::vector&lt; T * &gt; &amp;svmRawPointers, cl_mem_migration_flags flags=0, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a7349f54501b3967c55337635f22e01fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489734f6158231262d0b79553192af5a"><td class="memTemplParams" colspan="2">template&lt;typename T , class D &gt; </td></tr>
<tr class="memitem:a489734f6158231262d0b79553192af5a"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a489734f6158231262d0b79553192af5a">enqueueMigrateSVM</a> (const cl::vector&lt; cl::pointer&lt; T, D &gt; &gt; &amp;svmPointers, const cl::vector&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a> &gt; &amp;sizes, cl_mem_migration_flags flags=0, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a489734f6158231262d0b79553192af5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7d9e7c851eb31e9b4be0955e9d6e0a"><td class="memTemplParams" colspan="2">template&lt;typename T , class D &gt; </td></tr>
<tr class="memitem:a2b7d9e7c851eb31e9b4be0955e9d6e0a"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a2b7d9e7c851eb31e9b4be0955e9d6e0a">enqueueMigrateSVM</a> (const cl::vector&lt; cl::pointer&lt; T, D &gt; &gt; &amp;svmPointers, cl_mem_migration_flags flags=0, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a2b7d9e7c851eb31e9b4be0955e9d6e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21737d533444623d0f299fb6d6406785"><td class="memTemplParams" colspan="2">template&lt;typename T , class Alloc &gt; </td></tr>
<tr class="memitem:a21737d533444623d0f299fb6d6406785"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a21737d533444623d0f299fb6d6406785">enqueueMigrateSVM</a> (const cl::vector&lt; cl::vector&lt; T, Alloc &gt; &gt; &amp;svmContainers, const cl::vector&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a> &gt; &amp;sizes, cl_mem_migration_flags flags=0, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a21737d533444623d0f299fb6d6406785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d49a784a2d7021f5c8df2dbbab9d8c"><td class="memTemplParams" colspan="2">template&lt;typename T , class Alloc &gt; </td></tr>
<tr class="memitem:a79d49a784a2d7021f5c8df2dbbab9d8c"><td class="memTemplItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a79d49a784a2d7021f5c8df2dbbab9d8c">enqueueMigrateSVM</a> (const cl::vector&lt; cl::vector&lt; T, Alloc &gt; &gt; &amp;svmContainers, cl_mem_migration_flags flags=0, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a79d49a784a2d7021f5c8df2dbbab9d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6d2ed1031239edaf9134a15ad1a816"><td class="memItemLeft" align="right" valign="top"><a id="a0e6d2ed1031239edaf9134a15ad1a816" name="a0e6d2ed1031239edaf9134a15ad1a816"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueNDRangeKernel</b> (const <a class="el" href="classcl_1_1_kernel.html">Kernel</a> &amp;kernel, const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;offset, const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;global, const <a class="el" href="classcl_1_1_n_d_range.html">NDRange</a> &amp;local=NullRange, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a0e6d2ed1031239edaf9134a15ad1a816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ff05e345b2160cceae073b0e56f7ab"><td class="memItemLeft" align="right" valign="top"><a id="a53ff05e345b2160cceae073b0e56f7ab" name="a53ff05e345b2160cceae073b0e56f7ab"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueNativeKernel</b> (void(CL_CALLBACK *userFptr)(void *), std::pair&lt; void *, <a class="el" href="classcl_1_1size__t.html">size_type</a> &gt; args, const vector&lt; <a class="el" href="classcl_1_1_memory.html">Memory</a> &gt; *mem_objects=NULL, const vector&lt; const void * &gt; *mem_locs=NULL, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:a53ff05e345b2160cceae073b0e56f7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b8fbe11859b0d9b2ad317fcfdcaced"><td class="memItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#ae9b8fbe11859b0d9b2ad317fcfdcaced">enqueueAcquireGLObjects</a> (const vector&lt; <a class="el" href="classcl_1_1_memory.html">Memory</a> &gt; *mem_objects=NULL, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:ae9b8fbe11859b0d9b2ad317fcfdcaced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea30fd364c0ba14f3fd9f260b8a9ad1f"><td class="memItemLeft" align="right" valign="top"><a id="aea30fd364c0ba14f3fd9f260b8a9ad1f" name="aea30fd364c0ba14f3fd9f260b8a9ad1f"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueReleaseGLObjects</b> (const vector&lt; <a class="el" href="classcl_1_1_memory.html">Memory</a> &gt; *mem_objects=NULL, const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *events=NULL, <a class="el" href="classcl_1_1_event.html">Event</a> *event=NULL) const</td></tr>
<tr class="separator:aea30fd364c0ba14f3fd9f260b8a9ad1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cba88b51715610d76b0956140be9655"><td class="memItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a3cba88b51715610d76b0956140be9655">flush</a> () const</td></tr>
<tr class="separator:a3cba88b51715610d76b0956140be9655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511d461b0f5fabc8d737f4f29a4f346e"><td class="memItemLeft" align="right" valign="top"><a id="a511d461b0f5fabc8d737f4f29a4f346e" name="a511d461b0f5fabc8d737f4f29a4f346e"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>finish</b> () const</td></tr>
<tr class="separator:a511d461b0f5fabc8d737f4f29a4f346e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcl_1_1detail_1_1_wrapper"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcl_1_1detail_1_1_wrapper')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcl_1_1detail_1_1_wrapper.html">cl::detail::Wrapper&lt; cl_command_queue &gt;</a></td></tr>
<tr class="memitem:a514167f4ed7af4cc0ff0002bf082798f inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a514167f4ed7af4cc0ff0002bf082798f" name="a514167f4ed7af4cc0ff0002bf082798f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Wrapper</b> (const cl_type &amp;obj)</td></tr>
<tr class="separator:a514167f4ed7af4cc0ff0002bf082798f inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91bafdf8593c34e0d0722cdd93010be inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="af91bafdf8593c34e0d0722cdd93010be" name="af91bafdf8593c34e0d0722cdd93010be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Wrapper</b> (const <a class="el" href="classcl_1_1detail_1_1_wrapper.html">Wrapper</a>&lt; cl_type &gt; &amp;rhs)</td></tr>
<tr class="separator:af91bafdf8593c34e0d0722cdd93010be inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dce667e0f400f2ba15a8a8d65fdea0 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a98dce667e0f400f2ba15a8a8d65fdea0" name="a98dce667e0f400f2ba15a8a8d65fdea0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Wrapper</b> (const cl_type &amp;obj, bool retainObject)</td></tr>
<tr class="separator:a98dce667e0f400f2ba15a8a8d65fdea0 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91bafdf8593c34e0d0722cdd93010be inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="af91bafdf8593c34e0d0722cdd93010be" name="af91bafdf8593c34e0d0722cdd93010be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Wrapper</b> (const <a class="el" href="classcl_1_1detail_1_1_wrapper.html">Wrapper</a>&lt; cl_type &gt; &amp;rhs)</td></tr>
<tr class="separator:af91bafdf8593c34e0d0722cdd93010be inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115618e2baf10ec5c09513394d985ea6 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a115618e2baf10ec5c09513394d985ea6" name="a115618e2baf10ec5c09513394d985ea6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Wrapper</b> (<a class="el" href="classcl_1_1detail_1_1_wrapper.html">Wrapper</a>&lt; cl_type &gt; &amp;&amp;rhs) CL_HPP_NOEXCEPT_</td></tr>
<tr class="separator:a115618e2baf10ec5c09513394d985ea6 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b3fcc3a16d0e2ad3295b3e38fb1bf8 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a49b3fcc3a16d0e2ad3295b3e38fb1bf8" name="a49b3fcc3a16d0e2ad3295b3e38fb1bf8"></a>
<a class="el" href="classcl_1_1detail_1_1_wrapper.html">Wrapper</a>&lt; cl_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcl_1_1detail_1_1_wrapper.html">Wrapper</a>&lt; cl_type &gt; &amp;rhs)</td></tr>
<tr class="separator:a49b3fcc3a16d0e2ad3295b3e38fb1bf8 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26baf27de5ef59dfea529a09313f7a75 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a26baf27de5ef59dfea529a09313f7a75" name="a26baf27de5ef59dfea529a09313f7a75"></a>
<a class="el" href="classcl_1_1detail_1_1_wrapper.html">Wrapper</a>&lt; cl_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const cl_type &amp;rhs)</td></tr>
<tr class="separator:a26baf27de5ef59dfea529a09313f7a75 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b3fcc3a16d0e2ad3295b3e38fb1bf8 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a49b3fcc3a16d0e2ad3295b3e38fb1bf8" name="a49b3fcc3a16d0e2ad3295b3e38fb1bf8"></a>
<a class="el" href="classcl_1_1detail_1_1_wrapper.html">Wrapper</a>&lt; cl_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcl_1_1detail_1_1_wrapper.html">Wrapper</a>&lt; cl_type &gt; &amp;rhs)</td></tr>
<tr class="separator:a49b3fcc3a16d0e2ad3295b3e38fb1bf8 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00282b2612d45be8f4857ee5f0b002b9 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a00282b2612d45be8f4857ee5f0b002b9" name="a00282b2612d45be8f4857ee5f0b002b9"></a>
<a class="el" href="classcl_1_1detail_1_1_wrapper.html">Wrapper</a>&lt; cl_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classcl_1_1detail_1_1_wrapper.html">Wrapper</a>&lt; cl_type &gt; &amp;&amp;rhs)</td></tr>
<tr class="separator:a00282b2612d45be8f4857ee5f0b002b9 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26baf27de5ef59dfea529a09313f7a75 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a26baf27de5ef59dfea529a09313f7a75" name="a26baf27de5ef59dfea529a09313f7a75"></a>
<a class="el" href="classcl_1_1detail_1_1_wrapper.html">Wrapper</a>&lt; cl_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const cl_type &amp;rhs)</td></tr>
<tr class="separator:a26baf27de5ef59dfea529a09313f7a75 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83936d9a0be85837d0d2603bce850b31 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a83936d9a0be85837d0d2603bce850b31" name="a83936d9a0be85837d0d2603bce850b31"></a>
cl_type&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> () const</td></tr>
<tr class="separator:a83936d9a0be85837d0d2603bce850b31 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30993cd6ba246771306e4164ce2202eb inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a30993cd6ba246771306e4164ce2202eb" name="a30993cd6ba246771306e4164ce2202eb"></a>
cl_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> ()</td></tr>
<tr class="separator:a30993cd6ba246771306e4164ce2202eb inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62b1a8325e7c06fd2cb125a1730bf34 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="ac62b1a8325e7c06fd2cb125a1730bf34" name="ac62b1a8325e7c06fd2cb125a1730bf34"></a>
const cl_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> () const</td></tr>
<tr class="separator:ac62b1a8325e7c06fd2cb125a1730bf34 inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30993cd6ba246771306e4164ce2202eb inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a30993cd6ba246771306e4164ce2202eb" name="a30993cd6ba246771306e4164ce2202eb"></a>
cl_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> ()</td></tr>
<tr class="separator:a30993cd6ba246771306e4164ce2202eb inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc64140f053332174a28ea24db94842c inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="adc64140f053332174a28ea24db94842c" name="adc64140f053332174a28ea24db94842c"></a>
cl_type&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> () const</td></tr>
<tr class="separator:adc64140f053332174a28ea24db94842c inherit pub_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a24444b0dbd7cc0eb2bce126c9ccbac4c"><td class="memItemLeft" align="right" valign="top"><a id="a24444b0dbd7cc0eb2bce126c9ccbac4c" name="a24444b0dbd7cc0eb2bce126c9ccbac4c"></a>
static <a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getDefault</b> (cl_int *err=NULL)</td></tr>
<tr class="separator:a24444b0dbd7cc0eb2bce126c9ccbac4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24444b0dbd7cc0eb2bce126c9ccbac4c"><td class="memItemLeft" align="right" valign="top"><a id="a24444b0dbd7cc0eb2bce126c9ccbac4c" name="a24444b0dbd7cc0eb2bce126c9ccbac4c"></a>
static <a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getDefault</b> (cl_int *err=NULL)</td></tr>
<tr class="separator:a24444b0dbd7cc0eb2bce126c9ccbac4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736a138dd72e39056e8a9aa3dec5d132"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1_command_queue.html#a736a138dd72e39056e8a9aa3dec5d132">setDefault</a> (const <a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;default_queue)</td></tr>
<tr class="separator:a736a138dd72e39056e8a9aa3dec5d132"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classcl_1_1detail_1_1_wrapper"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcl_1_1detail_1_1_wrapper')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classcl_1_1detail_1_1_wrapper.html">cl::detail::Wrapper&lt; cl_command_queue &gt;</a></td></tr>
<tr class="memitem:a83841267bac5ad4411ec8935f78315d8 inherit pub_types_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a83841267bac5ad4411ec8935f78315d8" name="a83841267bac5ad4411ec8935f78315d8"></a>
typedef cl_command_queue&#160;</td><td class="memItemRight" valign="bottom"><b>cl_type</b></td></tr>
<tr class="separator:a83841267bac5ad4411ec8935f78315d8 inherit pub_types_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83841267bac5ad4411ec8935f78315d8 inherit pub_types_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a83841267bac5ad4411ec8935f78315d8" name="a83841267bac5ad4411ec8935f78315d8"></a>
typedef cl_command_queue&#160;</td><td class="memItemRight" valign="bottom"><b>cl_type</b></td></tr>
<tr class="separator:a83841267bac5ad4411ec8935f78315d8 inherit pub_types_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcl_1_1detail_1_1_wrapper"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcl_1_1detail_1_1_wrapper')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcl_1_1detail_1_1_wrapper.html">cl::detail::Wrapper&lt; cl_command_queue &gt;</a></td></tr>
<tr class="memitem:adfdff8a6c98ca62fedc6a9ffced47a06 inherit pro_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="adfdff8a6c98ca62fedc6a9ffced47a06" name="adfdff8a6c98ca62fedc6a9ffced47a06"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>retain</b> () const</td></tr>
<tr class="separator:adfdff8a6c98ca62fedc6a9ffced47a06 inherit pro_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdff8a6c98ca62fedc6a9ffced47a06 inherit pro_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="adfdff8a6c98ca62fedc6a9ffced47a06" name="adfdff8a6c98ca62fedc6a9ffced47a06"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>retain</b> () const</td></tr>
<tr class="separator:adfdff8a6c98ca62fedc6a9ffced47a06 inherit pro_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207374e201c6c33c01bdc7ee09e92d76 inherit pro_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a207374e201c6c33c01bdc7ee09e92d76" name="a207374e201c6c33c01bdc7ee09e92d76"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>release</b> () const</td></tr>
<tr class="separator:a207374e201c6c33c01bdc7ee09e92d76 inherit pro_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207374e201c6c33c01bdc7ee09e92d76 inherit pro_methods_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a207374e201c6c33c01bdc7ee09e92d76" name="a207374e201c6c33c01bdc7ee09e92d76"></a>
cl_int&#160;</td><td class="memItemRight" valign="bottom"><b>release</b> () const</td></tr>
<tr class="separator:a207374e201c6c33c01bdc7ee09e92d76 inherit pro_methods_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcl_1_1detail_1_1_wrapper"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcl_1_1detail_1_1_wrapper')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcl_1_1detail_1_1_wrapper.html">cl::detail::Wrapper&lt; cl_command_queue &gt;</a></td></tr>
<tr class="memitem:a1292547dd0c591aa972e25b793481583 inherit pro_attribs_classcl_1_1detail_1_1_wrapper"><td class="memItemLeft" align="right" valign="top"><a id="a1292547dd0c591aa972e25b793481583" name="a1292547dd0c591aa972e25b793481583"></a>
cl_type&#160;</td><td class="memItemRight" valign="bottom"><b>object_</b></td></tr>
<tr class="separator:a1292547dd0c591aa972e25b793481583 inherit pro_attribs_classcl_1_1detail_1_1_wrapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><a class="el" href="classcl_1_1_command_queue.html" title="CommandQueue interface for cl_command_queue.">CommandQueue</a> interface for cl_command_queue. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a09be675998c51f36aa7744b47eabebd3" name="a09be675998c51f36aa7744b47eabebd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09be675998c51f36aa7744b47eabebd3">&#9670;&nbsp;</a></span>CommandQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::CommandQueue::CommandQueue </td>
          <td>(</td>
          <td class="paramtype">const cl_command_queue &amp;&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retainObject</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from cl_command_queue - takes ownership. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">retainObject</td><td>will cause the constructor to retain its cl object. Defaults to false to maintain compatibility with earlier versions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae9b8fbe11859b0d9b2ad317fcfdcaced" name="ae9b8fbe11859b0d9b2ad317fcfdcaced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b8fbe11859b0d9b2ad317fcfdcaced">&#9670;&nbsp;</a></span>enqueueAcquireGLObjects() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueAcquireGLObjects </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_memory.html">Memory</a> &gt; *&#160;</td>
          <td class="paramname"><em>mem_objects</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deprecated APIs for 1.2 </p>

</div>
</div>
<a id="ab987adc2e00f12c74b554ee708ed5b3f" name="ab987adc2e00f12c74b554ee708ed5b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab987adc2e00f12c74b554ee708ed5b3f">&#9670;&nbsp;</a></span>enqueueAcquireGLObjects() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueAcquireGLObjects </td>
          <td>(</td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_memory.html">Memory</a> &gt; *&#160;</td>
          <td class="paramname"><em>mem_objects</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR_CLASS&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deprecated APIs for 1.2 </p>

</div>
</div>
<a id="acf92038ba0d015824a7488091fc8f5a1" name="acf92038ba0d015824a7488091fc8f5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf92038ba0d015824a7488091fc8f5a1">&#9670;&nbsp;</a></span>enqueueBarrierWithWaitList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueBarrierWithWaitList </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="class_a.html">A</a> synchronization point that enqueues a barrier operation.</p>
<p >Enqueues a barrier command which waits for either a list of events to complete, or if the list is empty it waits for all commands previously enqueued in command_queue to complete before it completes. This command blocks command execution, that is, any following commands enqueued after it do not execute until it completes. This command returns an event which can be waited on, i.e. this event can be waited on to insure that all events either in the event_wait_list or all previously enqueued commands, queued before this command to command_queue, have completed. </p>

</div>
</div>
<a id="a09f546d77b717ce26606c462c0ca9d1c" name="a09f546d77b717ce26606c462c0ca9d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f546d77b717ce26606c462c0ca9d1c">&#9670;&nbsp;</a></span>enqueueFillBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueFillBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_buffer.html">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PatternType&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1size__t.html">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1size__t.html">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="struct_enqueue.html">Enqueue</a> a command to fill a buffer object with a pattern of a given size. The pattern is specified as a vector type. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PatternType</td><td>The datatype of the pattern field. The pattern type must be an accepted OpenCL data type. </td></tr>
    <tr><td class="paramname">offset</td><td>Is the offset in bytes into the buffer at which to start filling. This must be a multiple of the pattern size. </td></tr>
    <tr><td class="paramname">size</td><td>Is the size in bytes of the region to fill. This must be a multiple of the pattern size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c3230b644ad638973be7199e0451e46" name="a9c3230b644ad638973be7199e0451e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3230b644ad638973be7199e0451e46">&#9670;&nbsp;</a></span>enqueueFillImage() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueFillImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unioncl__float4.html">cl_float4</a>&#160;</td>
          <td class="paramname"><em>fillColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="struct_enqueue.html">Enqueue</a> a command to fill an image object with a specified color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillColor</td><td>is the color to use to fill the image. This is a four component RGBA floating-point color value if the image channel data type is not an unnormalized signed or unsigned data type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb2c278ef4f177c5d01035c008a5cb3e" name="acb2c278ef4f177c5d01035c008a5cb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2c278ef4f177c5d01035c008a5cb3e">&#9670;&nbsp;</a></span>enqueueFillImage() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueFillImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unioncl__int4.html">cl_int4</a>&#160;</td>
          <td class="paramname"><em>fillColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="struct_enqueue.html">Enqueue</a> a command to fill an image object with a specified color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillColor</td><td>is the color to use to fill the image. This is a four component RGBA signed integer color value if the image channel data type is an unnormalized signed integer type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3081328f7b10be88e87eb719d3ad6307" name="a3081328f7b10be88e87eb719d3ad6307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3081328f7b10be88e87eb719d3ad6307">&#9670;&nbsp;</a></span>enqueueFillImage() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueFillImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unioncl__uint4.html">cl_uint4</a>&#160;</td>
          <td class="paramname"><em>fillColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const array&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="struct_enqueue.html">Enqueue</a> a command to fill an image object with a specified color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillColor</td><td>is the color to use to fill the image. This is a four component RGBA unsigned integer color value if the image channel data type is an unnormalized unsigned integer type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58d16044448bcb2797f490a33e450bde" name="a58d16044448bcb2797f490a33e450bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d16044448bcb2797f490a33e450bde">&#9670;&nbsp;</a></span>enqueueMapSVM() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueMapSVM </td>
          <td>(</td>
          <td class="paramtype">cl::pointer&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_bool&#160;</td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_map_flags&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1size__t.html">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enqueues a command that will allow the host to update a region of a coarse-grained SVM buffer. This variant takes a cl::pointer instance. </p>

</div>
</div>
<a id="a30fcb95415b760f23b2abba6e0842125" name="a30fcb95415b760f23b2abba6e0842125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30fcb95415b760f23b2abba6e0842125">&#9670;&nbsp;</a></span>enqueueMapSVM() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueMapSVM </td>
          <td>(</td>
          <td class="paramtype">cl::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_bool&#160;</td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_map_flags&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enqueues a command that will allow the host to update a region of a coarse-grained SVM buffer. This variant takes a cl::vector instance. </p>

</div>
</div>
<a id="aec8211d19eb2ffbb8adc7f565fe61c3c" name="aec8211d19eb2ffbb8adc7f565fe61c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8211d19eb2ffbb8adc7f565fe61c3c">&#9670;&nbsp;</a></span>enqueueMapSVM() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueMapSVM </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_bool&#160;</td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_map_flags&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1size__t.html">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enqueues a command that will allow the host to update a region of a coarse-grained SVM buffer. This variant takes a raw SVM pointer. </p>

</div>
</div>
<a id="a76a3f83c5546fbfa71a38f4ea02e264d" name="a76a3f83c5546fbfa71a38f4ea02e264d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a3f83c5546fbfa71a38f4ea02e264d">&#9670;&nbsp;</a></span>enqueueMarkerWithWaitList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueMarkerWithWaitList </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enqueues a marker command which waits for either a list of events to complete, or all previously enqueued commands to complete.</p>
<p >Enqueues a marker command which waits for either a list of events to complete, or if the list is empty it waits for all commands previously enqueued in command_queue to complete before it completes. This command returns an event which can be waited on, i.e. this event can be waited on to insure that all events either in the event_wait_list or all previously enqueued commands, queued before this command to command_queue, have completed. </p>

</div>
</div>
<a id="a3a9a4f084dc7634d3c73f5bf7f680b65" name="a3a9a4f084dc7634d3c73f5bf7f680b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9a4f084dc7634d3c73f5bf7f680b65">&#9670;&nbsp;</a></span>enqueueMigrateMemObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueMigrateMemObjects </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_memory.html">Memory</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>memObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem_migration_flags&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enqueues a command to indicate with which device a set of memory objects should be associated. </p>

</div>
</div>
<a id="a2b7d9e7c851eb31e9b4be0955e9d6e0a" name="a2b7d9e7c851eb31e9b4be0955e9d6e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7d9e7c851eb31e9b4be0955e9d6e0a">&#9670;&nbsp;</a></span>enqueueMigrateSVM() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueMigrateSVM </td>
          <td>(</td>
          <td class="paramtype">const cl::vector&lt; cl::pointer&lt; T, D &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>svmPointers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem_migration_flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enqueues a command that will allow the host associate a set of SVM allocations with a device. </p>

</div>
</div>
<a id="a489734f6158231262d0b79553192af5a" name="a489734f6158231262d0b79553192af5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489734f6158231262d0b79553192af5a">&#9670;&nbsp;</a></span>enqueueMigrateSVM() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueMigrateSVM </td>
          <td>(</td>
          <td class="paramtype">const cl::vector&lt; cl::pointer&lt; T, D &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>svmPointers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl::vector&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem_migration_flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enqueues a command that will allow the host associate ranges within a set of SVM allocations with a device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>- The length from each pointer to migrate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79d49a784a2d7021f5c8df2dbbab9d8c" name="a79d49a784a2d7021f5c8df2dbbab9d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d49a784a2d7021f5c8df2dbbab9d8c">&#9670;&nbsp;</a></span>enqueueMigrateSVM() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueMigrateSVM </td>
          <td>(</td>
          <td class="paramtype">const cl::vector&lt; cl::vector&lt; T, Alloc &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>svmContainers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem_migration_flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enqueues a command that will allow the host associate a set of SVM allocations with a device. </p>

</div>
</div>
<a id="a21737d533444623d0f299fb6d6406785" name="a21737d533444623d0f299fb6d6406785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21737d533444623d0f299fb6d6406785">&#9670;&nbsp;</a></span>enqueueMigrateSVM() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueMigrateSVM </td>
          <td>(</td>
          <td class="paramtype">const cl::vector&lt; cl::vector&lt; T, Alloc &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>svmContainers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl::vector&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem_migration_flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enqueues a command that will allow the host associate ranges within a set of SVM allocations with a device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>- The length from the beginning of each container to migrate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7349f54501b3967c55337635f22e01fc" name="a7349f54501b3967c55337635f22e01fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7349f54501b3967c55337635f22e01fc">&#9670;&nbsp;</a></span>enqueueMigrateSVM() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueMigrateSVM </td>
          <td>(</td>
          <td class="paramtype">const cl::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>svmRawPointers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem_migration_flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enqueues a command that will allow the host associate a set of SVM allocations with a device. </p>

</div>
</div>
<a id="a8470ceddefdc40c796d83a41ace25442" name="a8470ceddefdc40c796d83a41ace25442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8470ceddefdc40c796d83a41ace25442">&#9670;&nbsp;</a></span>enqueueMigrateSVM() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueMigrateSVM </td>
          <td>(</td>
          <td class="paramtype">const cl::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>svmRawPointers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl::vector&lt; <a class="el" href="classcl_1_1size__t.html">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem_migration_flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enqueues a command that will allow the host associate ranges within a set of SVM allocations with a device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>- The length from each pointer to migrate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8818c06a2f28a319d5259be7374c93fc" name="a8818c06a2f28a319d5259be7374c93fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8818c06a2f28a319d5259be7374c93fc">&#9670;&nbsp;</a></span>enqueueUnmapSVM() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueUnmapSVM </td>
          <td>(</td>
          <td class="paramtype">cl::pointer&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enqueues a command that will release a coarse-grained SVM buffer back to the OpenCL runtime. This variant takes a cl::pointer instance. </p>

</div>
</div>
<a id="af7e83f7dec93b2700b8ce4380d81bfcb" name="af7e83f7dec93b2700b8ce4380d81bfcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e83f7dec93b2700b8ce4380d81bfcb">&#9670;&nbsp;</a></span>enqueueUnmapSVM() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueUnmapSVM </td>
          <td>(</td>
          <td class="paramtype">cl::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enqueues a command that will release a coarse-grained SVM buffer back to the OpenCL runtime. This variant takes a cl::vector instance. </p>

</div>
</div>
<a id="affae2ea7a86c23e01c11fbdcdc149300" name="affae2ea7a86c23e01c11fbdcdc149300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affae2ea7a86c23e01c11fbdcdc149300">&#9670;&nbsp;</a></span>enqueueUnmapSVM() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::enqueueUnmapSVM </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcl_1_1_event.html">Event</a> &gt; *&#160;</td>
          <td class="paramname"><em>events</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1_event.html">Event</a> *&#160;</td>
          <td class="paramname"><em>event</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enqueues a command that will release a coarse-grained SVM buffer back to the OpenCL runtime. This variant takes a raw SVM pointer. </p>

</div>
</div>
<a id="a3cba88b51715610d76b0956140be9655" name="a3cba88b51715610d76b0956140be9655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cba88b51715610d76b0956140be9655">&#9670;&nbsp;</a></span>flush() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deprecated APIs for 1.2 </p>

</div>
</div>
<a id="a3cba88b51715610d76b0956140be9655" name="a3cba88b51715610d76b0956140be9655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cba88b51715610d76b0956140be9655">&#9670;&nbsp;</a></span>flush() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int cl::CommandQueue::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deprecated APIs for 1.2 </p>

</div>
</div>
<a id="a736a138dd72e39056e8a9aa3dec5d132" name="a736a138dd72e39056e8a9aa3dec5d132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736a138dd72e39056e8a9aa3dec5d132">&#9670;&nbsp;</a></span>setDefault()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> cl::CommandQueue::setDefault </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1_command_queue.html">CommandQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>default_queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Modify the default command queue to be used by subsequent operations. Will only set the default if no default was previously created. </p><dl class="section return"><dt>Returns</dt><dd>updated default command queue. Should be compared to the passed value to ensure that it was updated. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/pvelesko/local/CHIP-SPV/include/CL/<a class="el" href="cl_8hpp_source.html">cl.hpp</a></li>
<li>/Users/pvelesko/local/CHIP-SPV/include/CL/<a class="el" href="opencl_8hpp_source.html">opencl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
