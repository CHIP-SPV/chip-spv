<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CHIP-SPV: Porting CUDA Driver API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CHIP-SPV<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Multiple backend interface for HIP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Porting CUDA Driver API </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md696"></a>
Introduction to the CUDA Driver and Runtime APIs</h1>
<p >CUDA provides a separate CUDA Driver and Runtime APIs. The two APIs have significant overlap in functionality:</p><ul>
<li>Both APIs support events, streams, memory management, memory copy, and error handling.</li>
<li>Both APIs deliver similar performance.</li>
<li>Driver APIs calls begin with the prefix <code>cu</code> while Runtime APIs begin with the prefix <code>cuda</code>. For example, the Driver API API contains <code>cuEventCreate</code> while the Runtime API contains <code>cudaEventCreate</code>, with similar functionality.</li>
<li>The Driver API defines a different but largely overlapping error code space than the Runtime API, and uses a different coding convention. For example, Driver API defines <code>CUDA_ERROR_INVALID_VALUE</code> while the Runtime API defines <code>cudaErrorInvalidValue</code></li>
</ul>
<p >The Driver API offers two additional pieces of functionality not provided by the Runtime API: cuModule and cuCtx APIs.</p>
<h2><a class="anchor" id="autotoc_md697"></a>
cuModule API</h2>
<p >The Module section of the Driver API provides additional control over how and when accelerator code objects are loaded. For example, the driver API allows code objects to be loaded from files or memory pointers. Symbols for kernels or global data can be extracted from the loaded code objects. In contrast, the Runtime API automatically loads and (if necessary) compiles all of the kernels from an executable binary when run. In this mode, NVCC must be used to compile kernel code so the automatic loading can function correctly.</p>
<p >Both Driver and Runtime APIs define a function for launching kernels (called <code>cuLaunchKernel</code> or <code>cudaLaunchKernel</code>. The kernel arguments and the execution configuration (grid dimensions, group dimensions, dynamic shared memory, and stream) are passed as arguments to the launch function. The Runtime additionally provides the <code>&lt;&lt;&lt; &gt;&gt;&gt;</code> syntax for launching kernels, which resembles a special function call and is easier to use than explicit launch API (in particular with respect to handling of kernel arguments). However, this syntax is not standard C++ and is available only when NVCC is used to compile the host code.</p>
<p >The Module features are useful in an environment which generates the code objects directly, such as a new accelerator language front-end. Here, NVCC is not used. Instead, the environment may have a different kernel language or different compilation flow. Other environments have many kernels and do not want them to be all loaded automatically. The Module functions can be used to load the generated code objects and launch kernels. As we will see below, HIP defines a Module API which provides similar explicit control over code object management.</p>
<h2><a class="anchor" id="autotoc_md698"></a>
cuCtx API</h2>
<p >The Driver API defines "Context" and "Devices" as separate entities. Contexts contain a single device, and a device can theoretically have multiple contexts. Each context contains a set of streams and events specific to the context. Historically contexts also defined a unique address space for the GPU, though this may no longer be the case in Unified Memory platforms (since the CPU and all the devices in the same process share a single unified address space). The Context APIs also provide a mechanism to switch between devices, which allowed a single CPU thread to send commands to different GPUs. HIP as well as a recent versions of CUDA Runtime provide other mechanisms to accomplish this feat - for example using streams or <code>cudaSetDevice</code>.</p>
<p >The CUDA Runtime API unifies the Context API with the Device API. This simplifies the APIs and has little loss of functionality since each Context can contain a single device, and the benefits of multiple contexts has been replaced with other interfaces. HIP provides a context API to facilitate easy porting from existing Driver codes. In HIP, the Ctx functions largely provide an alternate syntax for changing the active device.</p>
<p >Most new applications will prefer to use <code>hipSetDevice</code> or the stream APIs , therefore HIP has marked hipCtx APIs as <b>deprecated</b>. Support for these APIs may not be available in future releases. For more details on deprecated APIs please refer <a href="https://github.com/ROCm-Developer-Tools/HIP/tree/master/docs/markdown/hip_deprecated_api_list.md">HIP deprecated APIs</a>.</p>
<h1><a class="anchor" id="autotoc_md699"></a>
HIP Module and Ctx APIs</h1>
<p >Rather than present two separate APIs, HIP extends the HIP API with new APIs for Modules and Ctx control.</p>
<h2><a class="anchor" id="autotoc_md700"></a>
hipModule API</h2>
<p >Like the CUDA Driver API, the Module API provides additional control over how code is loaded, including options to load code from files or from in-memory pointers. NVCC and HIP-Clang target different architectures and use different code object formats: NVCC is <code>cubin</code> or <code>ptx</code> files, while the HIP-Clang path is the <code>hsaco</code> format. The external compilers which generate these code objects are responsible for generating and loading the correct code object for each platform. Notably, there is not a fat binary format that can contain code for both NVCC and HIP-Clang platforms. The following table summarizes the formats used on each platform:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Format   </th><th class="markdownTableHeadNone">APIs   </th><th class="markdownTableHeadNone">NVCC   </th><th class="markdownTableHeadNone">HIP-CLANG    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Code Object   </td><td class="markdownTableBodyNone">hipModuleLoad, hipModuleLoadData   </td><td class="markdownTableBodyNone">.cubin or PTX text   </td><td class="markdownTableBodyNone">.hsaco    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Fat Binary   </td><td class="markdownTableBodyNone">hipModuleLoadFatBin   </td><td class="markdownTableBodyNone">.fatbin   </td><td class="markdownTableBodyNone">.hip_fatbin   </td></tr>
</table>
<p ><code>hipcc</code> uses HIP-Clang or NVCC to compile host codes. Both of these may embed code objects into the final executable, and these code objects will be automatically loaded when the application starts. The hipModule API can be used to load additional code objects, and in this way provides an extended capability to the automatically loaded code objects. HIP-Clang allows both of these capabilities to be used together, if desired. Of course it is possible to create a program with no kernels and thus no automatic loading.</p>
<h2><a class="anchor" id="autotoc_md701"></a>
hipCtx API</h2>
<p >HIP provides a <code>Ctx</code> API as a thin layer over the existing Device functions. This Ctx API can be used to set the current context, or to query properties of the device associated with the context. The current context is implicitly used by other APIs such as <code>hipStreamCreate</code>.</p>
<h2><a class="anchor" id="autotoc_md702"></a>
hipify translation of CUDA Driver API</h2>
<p >The HIPIFY tools convert CUDA Driver APIs for streams, events, modules, devices, memory management, context, profiler to the equivalent HIP driver calls. For example, <code>cuEventCreate</code> will be translated to <code>hipEventCreate</code>. HIPIFY tools also convert error codes from the Driver namespace and coding convention to the equivalent HIP error code. Thus, HIP unifies the APIs for these common functions.</p>
<p >The memory copy API requires additional explanation. The CUDA driver includes the memory direction in the name of the API (ie <code>cuMemcpyH2D</code>) while the CUDA driver API provides a single memory copy API with a parameter that specifies the direction and additionally supports a "default" direction where the runtime determines the direction automatically. HIP provides APIs with both styles: for example, <code>hipMemcpyH2D</code> as well as <code>hipMemcpy</code>. The first flavor may be faster in some cases since they avoid host overhead to detect the different memory directions.</p>
<p >HIP defines a single error space, and uses camel-case for all errors (i.e. <code>hipErrorInvalidValue</code>).</p>
<h3><a class="anchor" id="autotoc_md703"></a>
Address Spaces</h3>
<p >HIP-Clang defines a process-wide address space where the CPU and all devices allocate addresses from a single unified pool. Thus addresses may be shared between contexts, and unlike the original CUDA definition a new context does not create a new address space for the device.</p>
<h3><a class="anchor" id="autotoc_md704"></a>
Using hipModuleLaunchKernel</h3>
<p ><code>hipModuleLaunchKernel</code> is <code>cuLaunchKernel</code> in HIP world. It takes the same arguments as <code>cuLaunchKernel</code>.</p>
<h3><a class="anchor" id="autotoc_md705"></a>
Additional Information</h3>
<ul>
<li>HIP-Clang creates a primary context when the HIP API is called. So in a pure driver API code, HIP-Clang will create a primary context while HIP/NVCC will have empty context stack. HIP-Clang will push primary context to context stack when it is empty. This can have subtle differences on applications which mix the runtime and driver APIs.</li>
</ul>
<h2><a class="anchor" id="autotoc_md706"></a>
hip-clang Implementation Notes</h2>
<h3><a class="anchor" id="autotoc_md707"></a>
.hip_fatbin</h3>
<p >hip-clang links device code from different translation units together. For each device target, a code object is generated. Code objects for different device targets are bundled by clang-offload-bundler as one fatbinary, which is embeded as a global symbol <code>__hip_fatbin</code> in the .hip_fatbin section of the ELF file of the executable or shared object.</p>
<h3><a class="anchor" id="autotoc_md708"></a>
Initialization and Termination Functions</h3>
<p >hip-clang generates initializatiion and termination functions for each translation unit for host code compilation. The initialization functions call <code>__hipRegisterFatBinary</code> to register the fatbinary embeded in the ELF file. They also call <code>__hipRegisterFunction</code> and <code>__hipRegisterVar</code> to register kernel functions and device side global variables. The termination functions call <code>__hipUnregisterFatBinary</code>. hip-clang emits a global variable <code>__hip_gpubin_handle</code> of void** type with linkonce linkage and inital value 0 for each host translation unit. Each initialization function checks <code>__hip_gpubin_handle</code> and register the fatbinary only if <code>__hip_gpubin_handle</code> is 0 and saves the return value of <code>__hip_gpubin_handle</code> to <code>__hip_gpubin_handle</code>. This is to guarantee that the fatbinary is only registered once. Similar check is done in the termination functions.</p>
<h3><a class="anchor" id="autotoc_md709"></a>
Kernel Launching</h3>
<p >hip-clang supports kernel launching by CUDA <code>&lt;&lt;&lt;&gt;&gt;&gt;</code> syntax, hipLaunchKernel, and hipLaunchKernelGGL. The latter two are macros which expand to CUDA <code>&lt;&lt;&lt;&gt;&gt;&gt;</code> syntax.</p>
<p >When the executable or shared library is loaded by the dynamic linker, the initilization functions are called. In the initialization functions, when <code>__hipRegisterFatBinary</code> is called, the code objects containing all kernels are loaded; when <code>__hipRegisterFunction</code> is called, the stub functions are associated with the corresponding kernels in code objects.</p>
<p >hip-clang implements two sets of kernel launching APIs.</p>
<p >By default, in the host code, for the <code>&lt;&lt;&lt;&gt;&gt;&gt;</code> statement, hip-clang first emits call of hipConfigureCall to set up the threads and grids, then emits call of the stub function with the given arguments. In the stub function, hipSetupArgument is called for each kernel argument, then hipLaunchByPtr is called with a function pointer to the stub function. In hipLaunchByPtr, the real kernel associated with the stub function is launched.</p>
<p >If HIP program is compiled with -fhip-new-launch-api, in the host code, for the <code>&lt;&lt;&lt;&gt;&gt;&gt;</code> statement, hip-clang first emits call of <code>__hipPushCallConfiguration</code> to save the grid dimension, block dimension, shared memory usage and stream to a stack, then emits call of the stub function with the given arguments. In the stub function, <code>__hipPopCallConfiguration</code> is called to get the saved grid dimension, block dimension, shared memory usage and stream, then hipLaunchKernel is called with a function pointer to the stub function. In hipLaunchKernel, the real kernel associated with the stub function is launched.</p>
<h2><a class="anchor" id="autotoc_md710"></a>
NVCC Implementation Notes</h2>
<h3><a class="anchor" id="autotoc_md711"></a>
Interoperation between HIP and CUDA Driver</h3>
<p >CUDA applications may want to mix CUDA driver code with HIP code (see example below). This table shows the type equivalence to enable this interaction.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>HIP Type</b>   </th><th class="markdownTableHeadNone"><b>CU Driver Type</b>   </th><th class="markdownTableHeadNone"><b>CUDA Runtime Type</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">hipModule_t   </td><td class="markdownTableBodyNone">CUmodule   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">hipFunction_t   </td><td class="markdownTableBodyNone">CUfunction   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">hipCtx_t   </td><td class="markdownTableBodyNone">CUcontext   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">hipDevice_t   </td><td class="markdownTableBodyNone">CUdevice   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">hipStream_t   </td><td class="markdownTableBodyNone">CUstream   </td><td class="markdownTableBodyNone">cudaStream_t    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">hipEvent_t   </td><td class="markdownTableBodyNone">CUevent   </td><td class="markdownTableBodyNone">cudaEvent_t    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">hipArray   </td><td class="markdownTableBodyNone">CUarray   </td><td class="markdownTableBodyNone">cudaArray   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md712"></a>
Compilation Options</h3>
<p >The <code>hipModule_t</code> interface does not support <code>cuModuleLoadDataEx</code> function, which is used to control PTX compilation options. HIP-Clang does not use PTX and does not support these compilation options. In fact, HIP-Clang code objects always contain fully compiled ISA and do not require additional compilation as a part of the load step. The corresponding HIP function <code>hipModuleLoadDataEx</code> behaves as <code>hipModuleLoadData</code> on HIP-Clang path (compilation options are not used) and as <code>cuModuleLoadDataEx</code> on NVCC path. For example (CUDA): </p><div class="fragment"><div class="line">CUmodule module;</div>
<div class="line">void *imagePtr = ...;  // Somehow populate data pointer with code object</div>
<div class="line"> </div>
<div class="line">const int numOptions = 1;</div>
<div class="line">CUJit_option options[numOptions];</div>
<div class="line">void * optionValues[numOptions];</div>
<div class="line"> </div>
<div class="line">options[0] = CU_JIT_MAX_REGISTERS;</div>
<div class="line">unsigned maxRegs = 15;</div>
<div class="line">optionValues[0] = (void*)(&amp;maxRegs);</div>
<div class="line"> </div>
<div class="line">cuModuleLoadDataEx(module, imagePtr, numOptions, options, optionValues);</div>
<div class="line"> </div>
<div class="line">CUfunction k;</div>
<div class="line">cuModuleGetFunction(&amp;k, module, &quot;myKernel&quot;);</div>
</div><!-- fragment --><p> HIP: </p><div class="fragment"><div class="line">hipModule_t module;</div>
<div class="line">void *imagePtr = ...;  // Somehow populate data pointer with code object</div>
<div class="line"> </div>
<div class="line">const int numOptions = 1;</div>
<div class="line">hipJitOption options[numOptions];</div>
<div class="line">void * optionValues[numOptions];</div>
<div class="line"> </div>
<div class="line">options[0] = hipJitOptionMaxRegisters;</div>
<div class="line">unsigned maxRegs = 15;</div>
<div class="line">optionValues[0] = (void*)(&amp;maxRegs);</div>
<div class="line"> </div>
<div class="line">// hipModuleLoadData(module, imagePtr) will be called on HIP-Clang path, JIT options will not be used, and</div>
<div class="line">// cupModuleLoadDataEx(module, imagePtr, numOptions, options, optionValues) will be called on NVCC path</div>
<div class="line">hipModuleLoadDataEx(module, imagePtr, numOptions, options, optionValues);</div>
<div class="line"> </div>
<div class="line">hipFunction_t k;</div>
<div class="line">hipModuleGetFunction(&amp;k, module, &quot;myKernel&quot;);</div>
</div><!-- fragment --><p >The below sample shows how to use <code>hipModuleGetFunction</code>.</p>
<div class="fragment"><div class="line">#include&lt;hip_runtime.h&gt;</div>
<div class="line">#include&lt;hip_runtime_api.h&gt;</div>
<div class="line">#include&lt;iostream&gt;</div>
<div class="line">#include&lt;fstream&gt;</div>
<div class="line">#include&lt;vector&gt;</div>
<div class="line"> </div>
<div class="line">#define LEN 64</div>
<div class="line">#define SIZE LEN&lt;&lt;2</div>
<div class="line"> </div>
<div class="line">#ifdef __HIP_PLATFORM_AMD__</div>
<div class="line">#define fileName &quot;vcpy_isa.co&quot;</div>
<div class="line">#endif</div>
<div class="line"> </div>
<div class="line">#ifdef __HIP_PLATFORM_NVIDIA__</div>
<div class="line">#define fileName &quot;vcpy_isa.ptx&quot;</div>
<div class="line">#endif</div>
<div class="line"> </div>
<div class="line">#define kernel_name &quot;hello_world&quot;</div>
<div class="line"> </div>
<div class="line">int main(){</div>
<div class="line">    float *A, *B;</div>
<div class="line">    hipDeviceptr_t Ad, Bd;</div>
<div class="line">    A = new float[LEN];</div>
<div class="line">    B = new float[LEN];</div>
<div class="line"> </div>
<div class="line">    for(uint32_t i=0;i&lt;LEN;i++){</div>
<div class="line">        A[i] = i*1.0f;</div>
<div class="line">        B[i] = 0.0f;</div>
<div class="line">        std::cout&lt;&lt;A[i] &lt;&lt; &quot; &quot;&lt;&lt;B[i]&lt;&lt;std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">#ifdef __HIP_PLATFORM_NVIDIA__</div>
<div class="line">          hipInit(0);</div>
<div class="line">          hipDevice_t device;</div>
<div class="line">          hipCtx_t context;</div>
<div class="line">          hipDeviceGet(&amp;device, 0);</div>
<div class="line">          hipCtxCreate(&amp;context, 0, device);</div>
<div class="line">#endif</div>
<div class="line"> </div>
<div class="line">    hipMalloc((void**)&amp;Ad, SIZE);</div>
<div class="line">    hipMalloc((void**)&amp;Bd, SIZE);</div>
<div class="line"> </div>
<div class="line">    hipMemcpyHtoD(Ad, A, SIZE);</div>
<div class="line">    hipMemcpyHtoD(Bd, B, SIZE);</div>
<div class="line">    hipModule_t Module;</div>
<div class="line">    hipFunction_t Function;</div>
<div class="line">    hipModuleLoad(&amp;Module, fileName);</div>
<div class="line">    hipModuleGetFunction(&amp;Function, Module, kernel_name);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;void*&gt;argBuffer(2);</div>
<div class="line">    memcpy(&amp;argBuffer[0], &amp;Ad, sizeof(void*));</div>
<div class="line">    memcpy(&amp;argBuffer[1], &amp;Bd, sizeof(void*));</div>
<div class="line"> </div>
<div class="line">    size_t size = argBuffer.size()*sizeof(void*);</div>
<div class="line"> </div>
<div class="line">    void *config[] = {</div>
<div class="line">      HIP_LAUNCH_PARAM_BUFFER_POINTER, &amp;argBuffer[0],</div>
<div class="line">      HIP_LAUNCH_PARAM_BUFFER_SIZE, &amp;size,</div>
<div class="line">      HIP_LAUNCH_PARAM_END</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    hipModuleLaunchKernel(Function, 1, 1, 1, LEN, 1, 1, 0, 0, NULL, (void**)&amp;config);</div>
<div class="line"> </div>
<div class="line">    hipMemcpyDtoH(B, Bd, SIZE);</div>
<div class="line">    for(uint32_t i=0;i&lt;LEN;i++){</div>
<div class="line">        std::cout&lt;&lt;A[i]&lt;&lt;&quot; - &quot;&lt;&lt;B[i]&lt;&lt;std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">#ifdef __HIP_PLATFORM_NVIDIA__</div>
<div class="line">          hipCtxDetach(context);</div>
<div class="line">#endif</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md713"></a>
HIP Module and Texture Driver API</h1>
<p >HIP supports texture driver APIs however texture reference should be declared in host scope. Following code explains the use of texture reference for <b>HIP_PLATFORM_AMD</b> platform.</p>
<div class="fragment"><div class="line">// Code to generate code object</div>
<div class="line"> </div>
<div class="line">#include &quot;hip/hip_runtime.h&quot;</div>
<div class="line">extern texture&lt;float, 2, hipReadModeElementType&gt; tex;</div>
<div class="line"> </div>
<div class="line">__global__ void tex2dKernel(hipLaunchParm lp, float* outputData,</div>
<div class="line">                             int width,</div>
<div class="line">                             int height)</div>
<div class="line">{</div>
<div class="line">    int x = blockIdx.x*blockDim.x + threadIdx.x;</div>
<div class="line">    int y = blockIdx.y*blockDim.y + threadIdx.y;</div>
<div class="line">    outputData[y*width + x] = tex2D(tex, x, y);</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">// Host code:</div>
<div class="line"> </div>
<div class="line">texture&lt;float, 2, hipReadModeElementType&gt; tex;</div>
<div class="line"> </div>
<div class="line">void myFunc ()</div>
<div class="line">{</div>
<div class="line">    // ...</div>
<div class="line"> </div>
<div class="line">    textureReference* texref;</div>
<div class="line">    hipModuleGetTexRef(&amp;texref, Module1, &quot;tex&quot;);</div>
<div class="line">    hipTexRefSetAddressMode(texref, 0, hipAddressModeWrap);</div>
<div class="line">    hipTexRefSetAddressMode(texref, 1, hipAddressModeWrap);</div>
<div class="line">    hipTexRefSetFilterMode(texref, hipFilterModePoint);</div>
<div class="line">    hipTexRefSetFlags(texref, 0);</div>
<div class="line">    hipTexRefSetFormat(texref, HIP_AD_FORMAT_FLOAT, 1);</div>
<div class="line">    hipTexRefSetArray(texref, array, HIP_TRSA_OVERRIDE_FORMAT);</div>
<div class="line"> </div>
<div class="line">   // ...</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
