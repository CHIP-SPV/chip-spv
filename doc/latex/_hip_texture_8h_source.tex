\hypertarget{_hip_texture_8h_source}{}\doxysection{Hip\+Texture.\+h}
\label{_hip_texture_8h_source}\index{/Users/pvelesko/local/CHIP-\/SPV/llvm\_passes/HipTexture.h@{/Users/pvelesko/local/CHIP-\/SPV/llvm\_passes/HipTexture.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// LLVM Pass to wrap kernels that take texture objects into new kernels that take}}
\DoxyCodeLine{2 \textcolor{comment}{// OpenCL texture and sampler arguments}}
\DoxyCodeLine{3 }
\DoxyCodeLine{4 \textcolor{preprocessor}{\#ifndef LLVM\_PASSES\_HIP\_TEXTURE}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#define LLVM\_PASSES\_HIP\_TEXTURE}}
\DoxyCodeLine{6 }
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include "{}llvm/ADT/SmallPtrSet.h"{}}}
\DoxyCodeLine{8 \textcolor{preprocessor}{\#include "{}llvm/ADT/Statistic.h"{}}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include "{}llvm/IR/Function.h"{}}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include "{}llvm/IR/GlobalValue.h"{}}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include "{}llvm/IR/GlobalVariable.h"{}}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include "{}llvm/IR/IRBuilder.h"{}}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include "{}llvm/IR/Instructions.h"{}}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include "{}llvm/IR/Module.h"{}}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include "{}llvm/IR/Operator.h"{}}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include "{}llvm/IR/ValueSymbolTable.h"{}}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include "{}llvm/Pass.h"{}}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include "{}llvm/Support/raw\_ostream.h"{}}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include "{}llvm/Transforms/Utils/Cloning.h"{}}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include "{}llvm/Transforms/Utils/ValueMapper.h"{}}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include "{}llvm/IR/TypeFinder.h"{}}}
\DoxyCodeLine{23 }
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{keyword}{using namespace }llvm;}
\DoxyCodeLine{31 \textcolor{keyword}{using namespace }std;}
\DoxyCodeLine{32 }
\DoxyCodeLine{33 \textcolor{preprocessor}{\#define SPIR\_GLOBAL\_AS 1}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#define SPIR\_LOCAL\_AS  3}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#define GENERIC\_AS     4}}
\DoxyCodeLine{36 }
\DoxyCodeLine{37 \textcolor{preprocessor}{\#define DEFAULT\_AS     0}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#define OCL\_IMAGE\_AS   1}}
\DoxyCodeLine{39 \textcolor{preprocessor}{\#define OCL\_SAMPLER\_AS 2}}
\DoxyCodeLine{40 }
\DoxyCodeLine{41 \textcolor{comment}{// Identify and maintain the OpenCL image, sample and Hip Texture related types}}
\DoxyCodeLine{42 \textcolor{keyword}{class }\mbox{\hyperlink{class_texture_types}{TextureTypes}} \{}
\DoxyCodeLine{43 \textcolor{keyword}{protected}:}
\DoxyCodeLine{44   \textcolor{comment}{// HIP texture type}}
\DoxyCodeLine{45   Type* hipTextureTy;}
\DoxyCodeLine{46 }
\DoxyCodeLine{47   \textcolor{comment}{// OCL image type}}
\DoxyCodeLine{48   Type* oclImageTy;}
\DoxyCodeLine{49 }
\DoxyCodeLine{50   \textcolor{comment}{// OCL sampler type}}
\DoxyCodeLine{51   Type* oclSamplerTy;}
\DoxyCodeLine{52   }
\DoxyCodeLine{53 \textcolor{keyword}{public}:}
\DoxyCodeLine{54   \mbox{\hyperlink{class_texture_types}{TextureTypes}}(Module \&M) \{}
\DoxyCodeLine{55     \textcolor{comment}{// Check through struct types}}
\DoxyCodeLine{56     TypeFinder OCLTypes;}
\DoxyCodeLine{57     OCLTypes.run(M, \textcolor{keyword}{true});}
\DoxyCodeLine{58 }
\DoxyCodeLine{59     StringRef imageTyName(\textcolor{stringliteral}{"{}opencl.image2d\_ro\_t"{}});}
\DoxyCodeLine{60     StringRef samplerTyName(\textcolor{stringliteral}{"{}opencl.sampler\_t"{}});}
\DoxyCodeLine{61     StringRef textureTyName(\textcolor{stringliteral}{"{}struct.hipTextureObject\_s"{}});}
\DoxyCodeLine{62 }
\DoxyCodeLine{63     StringRef imageTyName\_(\textcolor{stringliteral}{"{}struct.OCLImage"{}});}
\DoxyCodeLine{64     StringRef samplerTyName\_(\textcolor{stringliteral}{"{}struct.OCLSampler"{}});}
\DoxyCodeLine{65     StringRef textureTyName\_(\textcolor{stringliteral}{"{}struct.hipTextureObject\_st"{}});}
\DoxyCodeLine{66     }
\DoxyCodeLine{67     \textcolor{keywordflow}{for} (TypeFinder::iterator ti = OCLTypes.begin(), te = OCLTypes.end(); ti != te; ti ++) \{}
\DoxyCodeLine{68       StringRef structName = (* ti)-\/>getStructName();}
\DoxyCodeLine{69       \textcolor{keywordflow}{if} (structName.equals(imageTyName)) \{}
\DoxyCodeLine{70     this-\/>oclImageTy = * ti;}
\DoxyCodeLine{71       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (structName.equals(samplerTyName)) \{}
\DoxyCodeLine{72     this-\/>oclSamplerTy = * ti;}
\DoxyCodeLine{73       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (structName.equals(textureTyName)) \{}
\DoxyCodeLine{74     this-\/>hipTextureTy = * ti;}
\DoxyCodeLine{75       \}}
\DoxyCodeLine{76     \}}
\DoxyCodeLine{77   \}}
\DoxyCodeLine{78 }
\DoxyCodeLine{79   Type* GetOCLImageType() \{}
\DoxyCodeLine{80     \textcolor{keywordflow}{return} this-\/>oclImageTy;}
\DoxyCodeLine{81   \}}
\DoxyCodeLine{82 }
\DoxyCodeLine{83   \textcolor{comment}{// Retrieve the image pointer type with a specified address space}}
\DoxyCodeLine{84   Type* GetOCLImagePtrType(\textcolor{keywordtype}{int} as) \{}
\DoxyCodeLine{85     \textcolor{keywordflow}{return} PointerType::get(this-\/>oclImageTy, as);}
\DoxyCodeLine{86   \}}
\DoxyCodeLine{87   }
\DoxyCodeLine{88   Type* GetOCLSamplerType() \{}
\DoxyCodeLine{89     \textcolor{keywordflow}{return} this-\/>oclSamplerTy;}
\DoxyCodeLine{90   \}}
\DoxyCodeLine{91 }
\DoxyCodeLine{92   \textcolor{comment}{// Retrieve the sampler pointer type with a specified address space  }}
\DoxyCodeLine{93   Type* GetOCLSamplerPtrType(\textcolor{keywordtype}{int} as) \{}
\DoxyCodeLine{94     \textcolor{keywordflow}{return} PointerType::get(this-\/>oclSamplerTy, as); }
\DoxyCodeLine{95   \}}
\DoxyCodeLine{96   }
\DoxyCodeLine{97   Type* GetHipTextureType() \{}
\DoxyCodeLine{98     \textcolor{keywordflow}{return} this-\/>hipTextureTy;}
\DoxyCodeLine{99   \}}
\DoxyCodeLine{100 }
\DoxyCodeLine{101   \textcolor{comment}{// Retrieve the texture pointer type with a specified address space  }}
\DoxyCodeLine{102   Type* GetHipTexturePtrType(\textcolor{keywordtype}{int} as) \{}
\DoxyCodeLine{103     \textcolor{keywordflow}{return} PointerType::get(this-\/>hipTextureTy, as);}
\DoxyCodeLine{104   \}}
\DoxyCodeLine{105   }
\DoxyCodeLine{106   \textcolor{keywordtype}{bool} IsOCLImageTy(Type* Ty) \{}
\DoxyCodeLine{107     \textcolor{keywordflow}{return} Ty == this-\/>oclImageTy;}
\DoxyCodeLine{108   \}}
\DoxyCodeLine{109 }
\DoxyCodeLine{110   \textcolor{keywordtype}{bool} IsOCLSamplerTy(Type* Ty) \{}
\DoxyCodeLine{111     \textcolor{keywordflow}{return} Ty == this-\/>oclSamplerTy;}
\DoxyCodeLine{112   \}}
\DoxyCodeLine{113 }
\DoxyCodeLine{114   \textcolor{keywordtype}{bool} IsHipTextureTy(Type* Ty) \{}
\DoxyCodeLine{115     \textcolor{keywordflow}{return} Ty == this-\/>hipTextureTy;}
\DoxyCodeLine{116   \}}
\DoxyCodeLine{117 }
\DoxyCodeLine{118   \textcolor{keywordtype}{bool} IsHipTexturePtrTy(Type* Ty) \{}
\DoxyCodeLine{119     \textcolor{keywordflow}{if} (!Ty-\/>isPointerTy())}
\DoxyCodeLine{120       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{121 }
\DoxyCodeLine{122     PointerType* ptrTy = dyn\_cast<PointerType>(Ty);}
\DoxyCodeLine{123     \textcolor{keywordflow}{return} IsHipTextureTy(ptrTy-\/>getElementType());}
\DoxyCodeLine{124   \}}
\DoxyCodeLine{125 \};}
\DoxyCodeLine{126 }
\DoxyCodeLine{127 \textcolor{comment}{// Generate the OpenCL type based wrapper function for hipTexture type based kernel function}}
\DoxyCodeLine{128 \textcolor{keyword}{class }\mbox{\hyperlink{class_o_c_l_wrapper_functions}{OCLWrapperFunctions}} \{}
\DoxyCodeLine{129 \textcolor{keyword}{protected}:}
\DoxyCodeLine{130   \textcolor{comment}{// The map between the original  kernel function and its wrapper}}
\DoxyCodeLine{131   map<Function* , Function* > orig2Wrapper;}
\DoxyCodeLine{132   }
\DoxyCodeLine{133   \textcolor{comment}{// The map between the wrapper kernel function and its original version}}
\DoxyCodeLine{134   map<Function* , Function* > wrapper2Orig;}
\DoxyCodeLine{135   }
\DoxyCodeLine{136   \textcolor{comment}{// The LLVM module}}
\DoxyCodeLine{137   Module\& M;}
\DoxyCodeLine{138   }
\DoxyCodeLine{139   \textcolor{comment}{// The type manager for OpenCL image, sampler and Hip Texture related types}}
\DoxyCodeLine{140   \mbox{\hyperlink{class_texture_types}{TextureTypes}}\& textureTypes;}
\DoxyCodeLine{141 }
\DoxyCodeLine{142   \textcolor{comment}{// The SPIR functions, i.e. with SPIR\_FUNC calling convention}}
\DoxyCodeLine{143   set<Function* > spirFuncs;}
\DoxyCodeLine{144   }
\DoxyCodeLine{145 \textcolor{keyword}{public}:}
\DoxyCodeLine{146   \mbox{\hyperlink{class_o_c_l_wrapper_functions}{OCLWrapperFunctions}}(Module\& M\_, \mbox{\hyperlink{class_texture_types}{TextureTypes}}\& textureTypes\_) : M(M\_), textureTypes(textureTypes\_) \{\};}
\DoxyCodeLine{147   }
\DoxyCodeLine{148   \textcolor{comment}{// The candidate kernel functions that need to be wrapped,}}
\DoxyCodeLine{149   \textcolor{comment}{// 1. the spir kernel}}
\DoxyCodeLine{150   \textcolor{comment}{// 2. the function arguments contain hipTexture type}}
\DoxyCodeLine{151    \textcolor{keywordtype}{bool} collectCandidates() \{}
\DoxyCodeLine{152     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} fi = M.begin(), fe = M.end(); fi != fe; fi ++) \{}
\DoxyCodeLine{153       StringRef funcName = fi-\/>getName();}
\DoxyCodeLine{154       Function* F = M.getFunction(funcName);}
\DoxyCodeLine{155       }
\DoxyCodeLine{156       \textcolor{keywordflow}{if} (F-\/>getCallingConv() == CallingConv::SPIR\_KERNEL) \{}
\DoxyCodeLine{157         \textcolor{comment}{// Check through function arguments                                                          }}
\DoxyCodeLine{158         \textcolor{keywordtype}{bool} HasTextureType = \textcolor{keyword}{false};}
\DoxyCodeLine{159         \textcolor{keywordflow}{for} (Function::arg\_iterator ai = F-\/>arg\_begin(), ae = F-\/>arg\_end(); ai != ae; ai ++) \{}
\DoxyCodeLine{160           \textcolor{keywordflow}{if} (textureTypes.IsHipTexturePtrTy(ai-\/>getType())) \{}
\DoxyCodeLine{161             HasTextureType = \textcolor{keyword}{true};}
\DoxyCodeLine{162                     }
\DoxyCodeLine{163             \textcolor{keywordflow}{break};}
\DoxyCodeLine{164           \}                                                                                     }
\DoxyCodeLine{165         \}}
\DoxyCodeLine{166 }
\DoxyCodeLine{167         \textcolor{keywordflow}{if} (HasTextureType) \{}
\DoxyCodeLine{168           orig2Wrapper[F] = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{169     \}}
\DoxyCodeLine{170       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(F-\/>getCallingConv() == CallingConv::SPIR\_FUNC) \{}
\DoxyCodeLine{171     \textcolor{comment}{// Check through function arguments}}
\DoxyCodeLine{172     \textcolor{keywordtype}{bool} HasTextureType = \textcolor{keyword}{false};}
\DoxyCodeLine{173         \textcolor{keywordflow}{for} (Function::arg\_iterator ai = F-\/>arg\_begin(), ae = F-\/>arg\_end(); ai != ae; ai ++) \{}
\DoxyCodeLine{174           \textcolor{keywordflow}{if} (textureTypes.IsHipTexturePtrTy(ai-\/>getType())) \{}
\DoxyCodeLine{175             HasTextureType = \textcolor{keyword}{true};}
\DoxyCodeLine{176 }
\DoxyCodeLine{177         \textcolor{keywordflow}{break};}
\DoxyCodeLine{178       \}}
\DoxyCodeLine{179     \}}
\DoxyCodeLine{180 }
\DoxyCodeLine{181     \textcolor{keywordflow}{if} (HasTextureType) \{}
\DoxyCodeLine{182       spirFuncs.insert(F);}
\DoxyCodeLine{183     \}}
\DoxyCodeLine{184       \}}
\DoxyCodeLine{185     \}}
\DoxyCodeLine{186 }
\DoxyCodeLine{187     \textcolor{keywordflow}{return} orig2Wrapper.size() > 0;}
\DoxyCodeLine{188   \}}
\DoxyCodeLine{189 }
\DoxyCodeLine{190   \textcolor{comment}{// Generate the wrapper functions for the candidate kernels}}
\DoxyCodeLine{191   \textcolor{keywordtype}{bool} wrapKernels() \{}
\DoxyCodeLine{192     \textcolor{comment}{// Reset the attributes of spir functinos}}
\DoxyCodeLine{193     \textcolor{keywordflow}{for} (Function* spirF : spirFuncs) \{}
\DoxyCodeLine{194       \textcolor{comment}{// Reset the original function's attribute by eliminating the prohibition of optimizations }}
\DoxyCodeLine{195       assignAttributes(spirF, spirF);}
\DoxyCodeLine{196     \}}
\DoxyCodeLine{197     }
\DoxyCodeLine{198     \textcolor{comment}{// Create all wrapper functions}}
\DoxyCodeLine{199     \textcolor{keywordflow}{for} (map<Function* , Function* >::iterator wi = orig2Wrapper.begin(), we = orig2Wrapper.end();}
\DoxyCodeLine{200      wi != we; ++ wi) \{}
\DoxyCodeLine{201       Function* F = wi-\/>first;}
\DoxyCodeLine{202 }
\DoxyCodeLine{203       \textcolor{comment}{// The map of argument ID from wrapper function to original function}}
\DoxyCodeLine{204       SmallVector<int, 16> argMap;}
\DoxyCodeLine{205       \textcolor{comment}{// Create the wrapper function}}
\DoxyCodeLine{206       Function* wrapperF = createWrapperFunction(F, argMap);}
\DoxyCodeLine{207       }
\DoxyCodeLine{208       \textcolor{comment}{// Fix the original function regarding its texture argument's address space}}
\DoxyCodeLine{209       F = fixTextureArgsAddrSpace(F, GENERIC\_AS, SPIR\_GLOBAL\_AS);}
\DoxyCodeLine{210 }
\DoxyCodeLine{211       \textcolor{comment}{// Fill in the content }}
\DoxyCodeLine{212       fillContent(wrapperF, F, argMap);}
\DoxyCodeLine{213       }
\DoxyCodeLine{214       \textcolor{comment}{// Register wrapper}}
\DoxyCodeLine{215       wrapper2Orig[wrapperF] = F;}
\DoxyCodeLine{216 }
\DoxyCodeLine{217       \textcolor{comment}{// Dump wrapper function}}
\DoxyCodeLine{218       \textcolor{comment}{// wrapperF-\/>dump();}}
\DoxyCodeLine{219     \}}
\DoxyCodeLine{220     }
\DoxyCodeLine{221     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{222   \}}
\DoxyCodeLine{223 }
\DoxyCodeLine{224 \textcolor{keyword}{protected}:}
\DoxyCodeLine{225   \textcolor{comment}{// Create the wrapper function}}
\DoxyCodeLine{226   Function* createWrapperFunction(Function* F, SmallVector<int, 16>\& argMap) \{}
\DoxyCodeLine{227     \textcolor{comment}{// Collect arugment types                                                                       }}
\DoxyCodeLine{228     SmallVector<Type *, 16> Parameters;}
\DoxyCodeLine{229     \textcolor{comment}{// The index mapping of the arguments from wrappe function to original function                   }}
\DoxyCodeLine{230     \textcolor{keywordtype}{int} origIdx = 0;}
\DoxyCodeLine{231     \textcolor{keywordtype}{int} wrapperIdx = 0;}
\DoxyCodeLine{232     \textcolor{keywordflow}{for} (Function::const\_arg\_iterator ai = F-\/>arg\_begin(), ae = F-\/>arg\_end(); ai != ae; ++ ai) \{}
\DoxyCodeLine{233       \textcolor{keywordflow}{if} (textureTypes.IsHipTexturePtrTy(ai-\/>getType())) \{}
\DoxyCodeLine{234         \textcolor{comment}{// Here we replace HipTexture type with OpenCL image and sampler types                        }}
\DoxyCodeLine{235         Parameters.push\_back(textureTypes.GetOCLImagePtrType(OCL\_IMAGE\_AS)); }
\DoxyCodeLine{236         Parameters.push\_back(textureTypes.GetOCLSamplerPtrType(OCL\_SAMPLER\_AS)); }
\DoxyCodeLine{237 }
\DoxyCodeLine{238         argMap.push\_back(origIdx);}
\DoxyCodeLine{239         argMap.push\_back(origIdx);}
\DoxyCodeLine{240       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{241         Parameters.push\_back(ai-\/>getType());}
\DoxyCodeLine{242 }
\DoxyCodeLine{243         argMap.push\_back(-\/1);}
\DoxyCodeLine{244       \}}
\DoxyCodeLine{245 }
\DoxyCodeLine{246       \textcolor{comment}{// Increment original function argument's ID }}
\DoxyCodeLine{247       origIdx ++;}
\DoxyCodeLine{248     \}}
\DoxyCodeLine{249 }
\DoxyCodeLine{250     \textcolor{comment}{// Create the wrapper function}}
\DoxyCodeLine{251     FunctionType * FuncTy = FunctionType::get(F-\/>getReturnType(), Parameters, F-\/>isVarArg());}
\DoxyCodeLine{252     Function * wrapperF = Function::Create(FuncTy, F-\/>getLinkage(), F-\/>getAddressSpace(), \textcolor{stringliteral}{"{}"{}}, \&M);}
\DoxyCodeLine{253     \textcolor{keywordtype}{string} wrapperName = \textcolor{stringliteral}{"{}new\_wrapper"{}};}
\DoxyCodeLine{254     \textcolor{keywordtype}{string} origName = F-\/>getName().str();}
\DoxyCodeLine{255     F-\/>setName(origName + \textcolor{stringliteral}{"{}\_impl"{}});}
\DoxyCodeLine{256   }
\DoxyCodeLine{257     wrapperF-\/>setName(origName);}
\DoxyCodeLine{258     }
\DoxyCodeLine{259     \textcolor{comment}{// Inherit the attributes from original function}}
\DoxyCodeLine{260     assignAttributes(wrapperF, F);}
\DoxyCodeLine{261   }
\DoxyCodeLine{262     \textcolor{comment}{// Set visibility}}
\DoxyCodeLine{263     wrapperF-\/>setVisibility(GlobalValue::VisibilityTypes::HiddenVisibility);}
\DoxyCodeLine{264     }
\DoxyCodeLine{265     \textcolor{comment}{// Set wrapper function's calling convention}}
\DoxyCodeLine{266     wrapperF-\/>setCallingConv(CallingConv::SPIR\_KERNEL);}
\DoxyCodeLine{267 }
\DoxyCodeLine{268     \textcolor{comment}{// Add wrapper function into module}}
\DoxyCodeLine{269     M.getOrInsertFunction(wrapperF-\/>getName(), wrapperF-\/>getFunctionType(), wrapperF-\/>getAttributes());}
\DoxyCodeLine{270     }
\DoxyCodeLine{271     \textcolor{comment}{// Switch the oirignal function to implemmentation function by reset the name and calling convention}}
\DoxyCodeLine{272     \textcolor{comment}{// Reset the calling convention to SPIR\_FUNC}}
\DoxyCodeLine{273     F-\/>setCallingConv(CallingConv::SPIR\_FUNC);}
\DoxyCodeLine{274 }
\DoxyCodeLine{275     \textcolor{comment}{// Reset the original function's attribute by eliminating the prohibition of optimizations}}
\DoxyCodeLine{276     assignAttributes(F, F);}
\DoxyCodeLine{277     }
\DoxyCodeLine{278     \textcolor{keywordflow}{return} wrapperF;}
\DoxyCodeLine{279   \}}
\DoxyCodeLine{280 }
\DoxyCodeLine{281   \textcolor{comment}{// Get function argument                                            }}
\DoxyCodeLine{282   Argument* GetFunctionArg(Function* F, \textcolor{keywordtype}{int} idx) \{}
\DoxyCodeLine{283     Function::arg\_iterator iter = F-\/>arg\_begin();}
\DoxyCodeLine{284     \textcolor{keywordflow}{return} iter += idx;}
\DoxyCodeLine{285   \}}
\DoxyCodeLine{286 }
\DoxyCodeLine{287   \textcolor{comment}{// Fill in the content                                            }}
\DoxyCodeLine{288   \textcolor{keywordtype}{void} fillContent(Function* wrapperF, Function* origF, SmallVector<int, 16>\& argMap) \{}
\DoxyCodeLine{289     IRBuilder<> B(M.getContext());}
\DoxyCodeLine{290 }
\DoxyCodeLine{291     \textcolor{comment}{// Create the basic block                                                       }}
\DoxyCodeLine{292     BasicBlock* contentBB = BasicBlock::Create(wrapperF-\/>getContext(), \textcolor{stringliteral}{"{}wrap.texture.struct"{}},}
\DoxyCodeLine{293                                                wrapperF);}
\DoxyCodeLine{294 }
\DoxyCodeLine{295     \textcolor{comment}{// Fill in the texture struct creation                                            }}
\DoxyCodeLine{296     \textcolor{comment}{// Collect the argument to call implementationn function                                   }}
\DoxyCodeLine{297     SmallVector<Value *, 16> Args;}
\DoxyCodeLine{298     Instruction* prevTextureAlloc = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{299     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < argMap.size(); i ++) \{}
\DoxyCodeLine{300       \textcolor{keywordflow}{if} (argMap[i] >= 0) \{}
\DoxyCodeLine{301         Argument* imageArg = GetFunctionArg(wrapperF, i ++); \textcolor{comment}{// argMap[i ++]);}}
\DoxyCodeLine{302         Argument* samplerArg = GetFunctionArg(wrapperF, i); \textcolor{comment}{// argMap[i]);}}
\DoxyCodeLine{303 }
\DoxyCodeLine{304         \textcolor{comment}{// Alloc texture struct                                             }}
\DoxyCodeLine{305         Instruction* textureAlloc = allocTextureStruct(wrapperF, contentBB, prevTextureAlloc, i);}
\DoxyCodeLine{306 }
\DoxyCodeLine{307         \textcolor{comment}{// Initialize texture struct with image and sampler                             }}
\DoxyCodeLine{308         initTextureStruct(wrapperF, contentBB, textureAlloc, imageArg, samplerArg);}
\DoxyCodeLine{309 }
\DoxyCodeLine{310     \textcolor{comment}{// Cast texture object's address space}}
\DoxyCodeLine{311     Instruction* textureASCast = castAddrSpace(textureAlloc, GENERIC\_AS, SPIR\_GLOBAL\_AS, \textcolor{comment}{// DEFAULT\_AS,}}
\DoxyCodeLine{312                            contentBB);}
\DoxyCodeLine{313     }
\DoxyCodeLine{314         \textcolor{comment}{// Carry the HipTexture\_t argument                                   }}
\DoxyCodeLine{315         \textcolor{comment}{// Args.push\_back(textureAlloc);}}
\DoxyCodeLine{316     Args.push\_back(textureASCast);}
\DoxyCodeLine{317     }
\DoxyCodeLine{318         \textcolor{comment}{// Set current texture allocation instruction as previou texture allocation instruction    }}
\DoxyCodeLine{319         prevTextureAlloc = textureAlloc;}
\DoxyCodeLine{320       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{321         Argument* arg = GetFunctionArg(wrapperF, i);}
\DoxyCodeLine{322         \textcolor{comment}{// Carry normal argument                                                }}
\DoxyCodeLine{323         Args.push\_back(arg);}
\DoxyCodeLine{324       \}}
\DoxyCodeLine{325     \}}
\DoxyCodeLine{326 }
\DoxyCodeLine{327     \textcolor{comment}{// Create the call site for the original/implementation function}}
\DoxyCodeLine{328     callImplementation(wrapperF, origF, contentBB, Args);}
\DoxyCodeLine{329     \textcolor{comment}{// ReturnInst* retInst = ReturnInst::Create(wrapperF-\/>getContext(), nullptr, contentBB);}}
\DoxyCodeLine{330     \textcolor{comment}{// callDummy(wrapperF, origF, contentBB, Args);}}
\DoxyCodeLine{331   \}}
\DoxyCodeLine{332   }
\DoxyCodeLine{333   \textcolor{comment}{// Alloc texture struct}}
\DoxyCodeLine{334   Instruction* allocTextureStruct(Function* wrapperF, BasicBlock* contentBB,}
\DoxyCodeLine{335                                   Instruction* prevTextureAlloc, \textcolor{keywordtype}{int} idx) \{}
\DoxyCodeLine{336     Instruction* textureAlloc = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{337     \textcolor{comment}{// Create the alloc instruction                                     }}
\DoxyCodeLine{338     textureAlloc = \textcolor{keyword}{new} AllocaInst(textureTypes.GetHipTextureType(), \textcolor{comment}{// GENERIC\_AS, }}
\DoxyCodeLine{339                   \textcolor{comment}{// DEFAULT\_AS,}}
\DoxyCodeLine{340                   SPIR\_GLOBAL\_AS,}
\DoxyCodeLine{341                   \textcolor{stringliteral}{"{}create texture object"{}}, contentBB);}
\DoxyCodeLine{342 }
\DoxyCodeLine{343     \textcolor{keywordflow}{return} textureAlloc;}
\DoxyCodeLine{344   \}}
\DoxyCodeLine{345 }
\DoxyCodeLine{346   \textcolor{comment}{// Initialize texture struct with image and sampler}}
\DoxyCodeLine{347   \textcolor{keywordtype}{bool} initTextureStruct(Function* wrapperF, BasicBlock* contentBB, Instruction* textureAlloc,}
\DoxyCodeLine{348              Argument* imageArg, Argument* samplerArg) \{}
\DoxyCodeLine{349     \textcolor{comment}{// Crete the type cast for image}}
\DoxyCodeLine{350     Instruction* castImageInst = \textcolor{keyword}{new} PtrToIntInst(imageArg,}
\DoxyCodeLine{351                           Type::getInt64Ty(M.getContext()),}
\DoxyCodeLine{352                           \textcolor{stringliteral}{"{}cast\_image\_to\_int64ptr"{}},}
\DoxyCodeLine{353                           contentBB);}
\DoxyCodeLine{354     }
\DoxyCodeLine{355     \textcolor{comment}{// Create the stroe related instruction                                     }}
\DoxyCodeLine{356     Value* imageIdxList[2] = \{ConstantInt::get(Type::getInt32Ty(M.getContext()), 0),}
\DoxyCodeLine{357                               ConstantInt::get(Type::getInt32Ty(M.getContext()), 0)\};}
\DoxyCodeLine{358     Instruction* getImagePtrInst = GetElementPtrInst::Create(textureTypes.GetHipTextureType(),}
\DoxyCodeLine{359                                                              textureAlloc,}
\DoxyCodeLine{360                                                              ArrayRef<Value*>(imageIdxList, 2),}
\DoxyCodeLine{361                                                              \textcolor{stringliteral}{"{}image\_field\_address"{}},}
\DoxyCodeLine{362                                                              contentBB);}
\DoxyCodeLine{363     }
\DoxyCodeLine{364     Instruction* storeImageInst = \textcolor{keyword}{new} StoreInst(castImageInst, getImagePtrInst, contentBB);}
\DoxyCodeLine{365 }
\DoxyCodeLine{366     \textcolor{comment}{// Create the type cast for sampler}}
\DoxyCodeLine{367      Instruction* castSamplerInst = \textcolor{keyword}{new} PtrToIntInst(samplerArg,}
\DoxyCodeLine{368                             Type::getInt64Ty(M.getContext()),}
\DoxyCodeLine{369                             \textcolor{stringliteral}{"{}cast\_sampler\_to\_int64ptr"{}},}
\DoxyCodeLine{370                             contentBB);}
\DoxyCodeLine{371     }
\DoxyCodeLine{372     \textcolor{comment}{// Create the store related instruction}}
\DoxyCodeLine{373     Value* samplerIdxList[2] = \{ConstantInt::get(Type::getInt32Ty(M.getContext()), 0),}
\DoxyCodeLine{374                                 ConstantInt::get(Type::getInt32Ty(M.getContext()), 1)\};}
\DoxyCodeLine{375     Instruction* getSamplerPtrInst = GetElementPtrInst::Create(textureTypes.GetHipTextureType(),}
\DoxyCodeLine{376                                                        textureAlloc,}
\DoxyCodeLine{377                                                                ArrayRef<Value*>(samplerIdxList, 2),}
\DoxyCodeLine{378                                                                \textcolor{stringliteral}{"{}sampler\_field\_address"{}},}
\DoxyCodeLine{379                                                                contentBB); }
\DoxyCodeLine{380     }
\DoxyCodeLine{381     Instruction* storeSamplerInst = \textcolor{keyword}{new} StoreInst(castSamplerInst, getSamplerPtrInst, contentBB);}
\DoxyCodeLine{382 }
\DoxyCodeLine{383     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{384   \}}
\DoxyCodeLine{385 }
\DoxyCodeLine{386   \textcolor{comment}{// Create the call site for the original/implementation function}}
\DoxyCodeLine{387   Instruction* callImplementation(Function* wrapperF, Function* origF, BasicBlock* contentBB,}
\DoxyCodeLine{388                   SmallVector<Value *, 16>\& Args) \{}
\DoxyCodeLine{389     Value* ArgVals[16];}
\DoxyCodeLine{390     \textcolor{keywordtype}{int} count = 0;}
\DoxyCodeLine{391     \textcolor{keywordflow}{for} (Value* Arg : Args) \{}
\DoxyCodeLine{392       ArgVals[count ++] = Arg;}
\DoxyCodeLine{393     \}}
\DoxyCodeLine{394  }
\DoxyCodeLine{395     }
\DoxyCodeLine{396     \textcolor{comment}{// Create the call site for the original function (i.e. the implementtion function) and append it to}}
\DoxyCodeLine{397     \textcolor{comment}{// the end of basic block}}
\DoxyCodeLine{398     CallInst* callInst = CallInst::Create(origF, ArrayRef<Value* >(ArgVals, count), \textcolor{stringliteral}{"{}"{}}, contentBB);}
\DoxyCodeLine{399     \textcolor{comment}{// Set the calling convention flag}}
\DoxyCodeLine{400     callInst-\/>setCallingConv(CallingConv::SPIR\_FUNC);}
\DoxyCodeLine{401     }
\DoxyCodeLine{402     \textcolor{comment}{// Create the return instruction}}
\DoxyCodeLine{403     ReturnInst* retInst = ReturnInst::Create(wrapperF-\/>getContext(), \textcolor{keyword}{nullptr}, contentBB);}
\DoxyCodeLine{404 }
\DoxyCodeLine{405     \textcolor{keywordflow}{return} retInst;}
\DoxyCodeLine{406   \}}
\DoxyCodeLine{407 }
\DoxyCodeLine{408   \textcolor{comment}{// Assign attributes, the attributes are from the original funciton, and the attributes related to}}
\DoxyCodeLine{409   \textcolor{comment}{// prohibite code optimization are removed}}
\DoxyCodeLine{410   \textcolor{keywordtype}{bool} assignAttributes(Function* destF, Function* srcF) \{}
\DoxyCodeLine{411     AttributeList attrs = srcF-\/>getAttributes();}
\DoxyCodeLine{412     attrs = attrs.removeAttribute(M.getContext(), AttributeList::FunctionIndex, Attribute::OptimizeNone);}
\DoxyCodeLine{413     attrs = attrs.removeAttribute(M.getContext(), AttributeList::FunctionIndex, Attribute::NoInline);}
\DoxyCodeLine{414     attrs = attrs.removeAttribute(M.getContext(), AttributeList::FunctionIndex, \textcolor{stringliteral}{"{}frame-\/pointer"{}});}
\DoxyCodeLine{415 }
\DoxyCodeLine{416     \textcolor{comment}{// Inherit the attributes from original function   }}
\DoxyCodeLine{417     destF-\/>setAttributes(attrs);}
\DoxyCodeLine{418 }
\DoxyCodeLine{419     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{420   \}}
\DoxyCodeLine{421 }
\DoxyCodeLine{422   \textcolor{comment}{// Cast the address space }}
\DoxyCodeLine{423   Instruction* castAddrSpace(Value* ptrVal, \textcolor{keywordtype}{unsigned} newAS, \textcolor{keywordtype}{unsigned} origAS, BasicBlock* contentBB) \{}
\DoxyCodeLine{424     PointerType* ptrTy = dyn\_cast<PointerType>(ptrVal-\/>getType());}
\DoxyCodeLine{425     \textcolor{keywordflow}{if} (!ptrTy)}
\DoxyCodeLine{426       \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{427     }
\DoxyCodeLine{428     Type* elemTy = ptrTy-\/>getElementType();}
\DoxyCodeLine{429     \textcolor{keywordflow}{if} (origAS != ptrTy-\/>getAddressSpace())}
\DoxyCodeLine{430       \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{431     }
\DoxyCodeLine{432     Type* newTy = PointerType::get(elemTy, newAS);}
\DoxyCodeLine{433     }
\DoxyCodeLine{434     \textcolor{keywordflow}{return} \textcolor{keyword}{new} AddrSpaceCastInst(ptrVal, newTy, \textcolor{stringliteral}{"{}newASVal"{}}, contentBB);}
\DoxyCodeLine{435   \}}
\DoxyCodeLine{436 }
\DoxyCodeLine{437   \textcolor{comment}{// Fix the original function regarding its texture argument's address space}}
\DoxyCodeLine{438   Function* fixTextureArgsAddrSpace(Function* origF, \textcolor{keywordtype}{unsigned} newAS, \textcolor{keywordtype}{unsigned} origAS) \{}
\DoxyCodeLine{439     \textcolor{keywordflow}{if} (newAS != GENERIC\_AS || origAS != SPIR\_GLOBAL\_AS)}
\DoxyCodeLine{440       \textcolor{keywordflow}{return} origF;}
\DoxyCodeLine{441 }
\DoxyCodeLine{442     SmallVector<Type *, 16> ParamTys;}
\DoxyCodeLine{443     \textcolor{keywordtype}{bool} hasMutation = \textcolor{keyword}{false};}
\DoxyCodeLine{444     \textcolor{keywordflow}{for} (Function::const\_arg\_iterator ai = origF-\/>arg\_begin(), ae = origF-\/>arg\_end(); ai != ae; ++ ai) \{}
\DoxyCodeLine{445       Argument * arg = (Argument *)ai;}
\DoxyCodeLine{446 }
\DoxyCodeLine{447       \textcolor{keywordflow}{if} (arg-\/>getType() == textureTypes.GetHipTexturePtrType(origAS)) \{}
\DoxyCodeLine{448     \textcolor{comment}{// Mutate argument type}}
\DoxyCodeLine{449     arg-\/>mutateType(textureTypes.GetHipTexturePtrType(newAS));}
\DoxyCodeLine{450 }
\DoxyCodeLine{451     \textcolor{comment}{// Collect uses }}
\DoxyCodeLine{452     SmallVector<Instruction *, 16> ascasts;}
\DoxyCodeLine{453     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} au : arg-\/>users()) \{}
\DoxyCodeLine{454           \textcolor{keywordflow}{if} (\textcolor{keyword}{const} AddrSpaceCastInst* ascast = dyn\_cast<AddrSpaceCastInst>(au)) \{}
\DoxyCodeLine{455         AddrSpaceCastInst* ascastInst = (AddrSpaceCastInst *)ascast;}
\DoxyCodeLine{456        }
\DoxyCodeLine{457         \textcolor{comment}{// Record addresss cast instruction}}
\DoxyCodeLine{458         ascasts.push\_back(ascastInst);}
\DoxyCodeLine{459         hasMutation = \textcolor{keyword}{true};}
\DoxyCodeLine{460       \}}
\DoxyCodeLine{461     \}}
\DoxyCodeLine{462 }
\DoxyCodeLine{463     \textcolor{comment}{// Replace uses}}
\DoxyCodeLine{464     \textcolor{keywordflow}{for} (Instruction* ascast : ascasts) \{}
\DoxyCodeLine{465       ascast-\/>replaceAllUsesWith(arg);}
\DoxyCodeLine{466       \textcolor{comment}{// Erase address cast instruction}}
\DoxyCodeLine{467       ascast-\/>eraseFromParent();}
\DoxyCodeLine{468     \}}
\DoxyCodeLine{469 }
\DoxyCodeLine{470     \textcolor{comment}{// Record new type}}
\DoxyCodeLine{471     ParamTys.push\_back(textureTypes.GetHipTexturePtrType(newAS));}
\DoxyCodeLine{472       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{473     \textcolor{comment}{// Record function argument types}}
\DoxyCodeLine{474     ParamTys.push\_back(arg-\/>getType());}
\DoxyCodeLine{475       \}}
\DoxyCodeLine{476     \}}
\DoxyCodeLine{477 }
\DoxyCodeLine{478     \textcolor{comment}{// Create the new function}}
\DoxyCodeLine{479     \textcolor{keywordflow}{if} (hasMutation) \{}
\DoxyCodeLine{480       FunctionType * FuncTy = FunctionType::get(origF-\/>getReturnType(), ParamTys, origF-\/>isVarArg());}
\DoxyCodeLine{481       Function *NewF = Function::Create(FuncTy, origF-\/>getLinkage(), origF-\/>getAddressSpace(), \textcolor{stringliteral}{"{}"{}}, \&M);}
\DoxyCodeLine{482       NewF-\/>takeName(origF);}
\DoxyCodeLine{483 }
\DoxyCodeLine{484       Function::arg\_iterator AI = NewF-\/>arg\_begin();}
\DoxyCodeLine{485       ValueToValueMapTy VV;}
\DoxyCodeLine{486       \textcolor{keywordflow}{for} (Function::const\_arg\_iterator i = origF-\/>arg\_begin(), e = origF-\/>arg\_end(); i != e; ++i) \{}
\DoxyCodeLine{487     AI-\/>setName(i-\/>getName());}
\DoxyCodeLine{488     VV[\&*i] = \&*AI;}
\DoxyCodeLine{489     ++ AI;}
\DoxyCodeLine{490       \}}
\DoxyCodeLine{491 }
\DoxyCodeLine{492       \textcolor{comment}{// Clone the function content}}
\DoxyCodeLine{493       SmallVector<ReturnInst *, 1> RI;}
\DoxyCodeLine{494       CloneFunctionInto(NewF, origF, VV, CloneFunctionChangeType::GlobalChanges, RI);}
\DoxyCodeLine{495 }
\DoxyCodeLine{496       \textcolor{comment}{// Reset the function attribute}}
\DoxyCodeLine{497       assignAttributes(NewF, origF);}
\DoxyCodeLine{498       }
\DoxyCodeLine{499       \textcolor{comment}{// Add new function into module}}
\DoxyCodeLine{500       M.getOrInsertFunction(NewF-\/>getName(), NewF-\/>getFunctionType(), NewF-\/>getAttributes());}
\DoxyCodeLine{501       \textcolor{comment}{// Erase original function}}
\DoxyCodeLine{502       origF-\/>eraseFromParent();}
\DoxyCodeLine{503 }
\DoxyCodeLine{504       \textcolor{keywordflow}{return} NewF;}
\DoxyCodeLine{505     \}}
\DoxyCodeLine{506     }
\DoxyCodeLine{507     \textcolor{keywordflow}{return} origF;}
\DoxyCodeLine{508   \}}
\DoxyCodeLine{509   }
\DoxyCodeLine{510   \textcolor{comment}{// Create a dummy function that is only for test}}
\DoxyCodeLine{511   Instruction* callDummy(Function* wrapperF, Function* origF, BasicBlock* contentBB,}
\DoxyCodeLine{512              SmallVector<Value *, 16>\& Args) \{}
\DoxyCodeLine{513     Value* ArgVals[16];}
\DoxyCodeLine{514     \textcolor{keywordflow}{for} (Value* Arg : Args) \{}
\DoxyCodeLine{515       \textcolor{keywordflow}{if} (Arg-\/>getType() == textureTypes.GetHipTexturePtrType(GENERIC\_AS)) \textcolor{comment}{// SPIR\_GLOBAL\_AS))}}
\DoxyCodeLine{516         ArgVals[0] = Arg;}
\DoxyCodeLine{517     \}}
\DoxyCodeLine{518 }
\DoxyCodeLine{519     \textcolor{comment}{// Create the dummy function}}
\DoxyCodeLine{520     SmallVector<Type *, 16> Parameters;}
\DoxyCodeLine{521     Parameters.push\_back(textureTypes.GetHipTexturePtrType(GENERIC\_AS)); \textcolor{comment}{// SPIR\_GLOBAL\_AS));}}
\DoxyCodeLine{522     }
\DoxyCodeLine{523     FunctionType * FuncTy = FunctionType::get(origF-\/>getReturnType(), Parameters, origF-\/>isVarArg());}
\DoxyCodeLine{524     Function * dummyF = Function::Create(FuncTy, GlobalValue::LinkageTypes::InternalLinkage,}
\DoxyCodeLine{525                      origF-\/>getAddressSpace(), \textcolor{stringliteral}{"{}"{}}, \&M);}
\DoxyCodeLine{526     \textcolor{comment}{// Set name}}
\DoxyCodeLine{527     dummyF-\/>setName(\textcolor{stringliteral}{"{}dummy\_call\_texture"{}});}
\DoxyCodeLine{528     \textcolor{comment}{// Set calling convention}}
\DoxyCodeLine{529     dummyF-\/>setCallingConv(CallingConv::SPIR\_FUNC);}
\DoxyCodeLine{530     }
\DoxyCodeLine{531     \textcolor{comment}{// Inherit the attributes from original function }}
\DoxyCodeLine{532     assignAttributes(dummyF, origF);}
\DoxyCodeLine{533     }
\DoxyCodeLine{534     \textcolor{comment}{// Create the basic block  }}
\DoxyCodeLine{535     BasicBlock* dummyBB = BasicBlock::Create(dummyF-\/>getContext(), \textcolor{stringliteral}{"{}wrap.texture.struct"{}}, dummyF);}
\DoxyCodeLine{536 }
\DoxyCodeLine{537     \textcolor{comment}{// Fill in content}}
\DoxyCodeLine{538     \textcolor{comment}{// Return void}}
\DoxyCodeLine{539     Instruction* retInst = ReturnInst::Create(dummyF-\/>getContext(), \textcolor{keyword}{nullptr}, dummyBB);}
\DoxyCodeLine{540 }
\DoxyCodeLine{541     \textcolor{comment}{// Register dummy function}}
\DoxyCodeLine{542     M.getOrInsertFunction(dummyF-\/>getName(), dummyF-\/>getFunctionType(), dummyF-\/>getAttributes());}
\DoxyCodeLine{543     }
\DoxyCodeLine{544     \textcolor{comment}{// Call the dummy function}}
\DoxyCodeLine{545     CallInst* callInst = CallInst::Create(dummyF, ArrayRef<Value* >(ArgVals, 1), \textcolor{stringliteral}{"{}"{}}, contentBB);}
\DoxyCodeLine{546     callInst-\/>setCallingConv(CallingConv::SPIR\_FUNC);}
\DoxyCodeLine{547     }
\DoxyCodeLine{548     \textcolor{comment}{// Return void}}
\DoxyCodeLine{549     retInst = ReturnInst::Create(wrapperF-\/>getContext(), \textcolor{keyword}{nullptr}, contentBB);}
\DoxyCodeLine{550     }
\DoxyCodeLine{551     \textcolor{keywordflow}{return} retInst;}
\DoxyCodeLine{552   \}}
\DoxyCodeLine{553 }
\DoxyCodeLine{554 \textcolor{keyword}{public}:}
\DoxyCodeLine{555 }
\DoxyCodeLine{556   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} runTexture(Module\& M) \{}
\DoxyCodeLine{557      \textcolor{comment}{// Collect relevant types}}
\DoxyCodeLine{558     \mbox{\hyperlink{class_texture_types}{TextureTypes}} textureTypes(M);}
\DoxyCodeLine{559 }
\DoxyCodeLine{560     \textcolor{comment}{// Create the wrapper function generator}}
\DoxyCodeLine{561     \mbox{\hyperlink{class_o_c_l_wrapper_functions}{OCLWrapperFunctions}} oclWrapper(M, textureTypes);}
\DoxyCodeLine{562     \textcolor{comment}{// Collect relevant kernel functions}}
\DoxyCodeLine{563     \textcolor{keywordflow}{if} (oclWrapper.collectCandidates()) \{}
\DoxyCodeLine{564       \textcolor{comment}{// If there is candidate kernels for wrapping, then generate wrapper functions}}
\DoxyCodeLine{565       oclWrapper.wrapKernels();}
\DoxyCodeLine{566     \}}
\DoxyCodeLine{567     }
\DoxyCodeLine{568     \textcolor{comment}{// M.dump();}}
\DoxyCodeLine{569 }
\DoxyCodeLine{570     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{571   \}}
\DoxyCodeLine{572 \};}
\DoxyCodeLine{573 }
\DoxyCodeLine{574 \textcolor{preprocessor}{\#if LLVM\_VERSION\_MAJOR > 11}}
\DoxyCodeLine{575 \textcolor{keyword}{class }HipTextureExternReplaceNewPass}
\DoxyCodeLine{576     : \textcolor{keyword}{public} PassInfoMixin<HipTextureExternReplaceNewPass> \{}
\DoxyCodeLine{577 \textcolor{keyword}{public}:}
\DoxyCodeLine{578   PreservedAnalyses run(Module \&M, ModuleAnalysisManager \&AM);}
\DoxyCodeLine{579   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} isRequired() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{580 \};}
\DoxyCodeLine{581 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{582 }
\DoxyCodeLine{583 \textcolor{preprocessor}{\#endif}}

\end{DoxyCode}
