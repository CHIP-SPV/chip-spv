\hypertarget{class_c_h_i_p_exec_item}{}\doxysection{CHIPExec\+Item Class Reference}
\label{class_c_h_i_p_exec_item}\index{CHIPExecItem@{CHIPExecItem}}


Contains kernel arguments and a queue on which to execute. Prior to kernel launch, the arguments are setup via \mbox{\hyperlink{class_c_h_i_p_backend_a9d802a4ed8ee1c36996ea05d346bdb1d}{CHIPBackend\+::configure\+Call()}}. Because of this, we get the kernel last so the kernel so the launch() takes a kernel argument as opposed to queue receiving a \mbox{\hyperlink{class_c_h_i_p_exec_item}{CHIPExec\+Item}} containing the kernel and arguments.  




{\ttfamily \#include $<$CHIPBackend.\+hh$>$}

Inheritance diagram for CHIPExec\+Item\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_c_h_i_p_exec_item}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_c_h_i_p_exec_item_a24fc5df28634179d20a9286b846215e7}\label{class_c_h_i_p_exec_item_a24fc5df28634179d20a9286b846215e7}} 
{\bfseries CHIPExec\+Item} ()=delete
\begin{DoxyCompactList}\small\item\em Deleted default constructor Doesn\textquotesingle{}t make sense for \mbox{\hyperlink{class_c_h_i_p_exec_item}{CHIPExec\+Item}} to exist without arguments. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_h_i_p_exec_item_ad240eeebfcca8d53597798e3399971f8}{CHIPExec\+Item}} (dim3 grid\+\_\+dim\+\_\+, dim3 block\+\_\+dim\+\_\+, size\+\_\+t shared\+\_\+mem\+\_\+, hip\+Stream\+\_\+t chip\+\_\+queue\+\_\+)
\begin{DoxyCompactList}\small\item\em Construct a new \mbox{\hyperlink{class_c_h_i_p_exec_item}{CHIPExec\+Item}} object. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_h_i_p_exec_item_ada66af43814c2b105cf1581d22eee8ae}\label{class_c_h_i_p_exec_item_ada66af43814c2b105cf1581d22eee8ae}} 
{\bfseries $\sim$\+CHIPExec\+Item} ()
\begin{DoxyCompactList}\small\item\em Destroy the \mbox{\hyperlink{class_c_h_i_p_exec_item}{CHIPExec\+Item}} object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_h_i_p_kernel}{CHIPKernel}} $\ast$ \mbox{\hyperlink{class_c_h_i_p_exec_item_a1cf75c746f3f05b653a577748c77bc44}{get\+Kernel}} ()
\begin{DoxyCompactList}\small\item\em Get the Kernel object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$ \mbox{\hyperlink{class_c_h_i_p_exec_item_a0ab70870d2c58e6fa2a3e03762a5134a}{get\+Queue}} ()
\begin{DoxyCompactList}\small\item\em Get the Queue object. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_h_i_p_exec_item_ab59740e00d1f2d40b25e0368ff91440c}\label{class_c_h_i_p_exec_item_ab59740e00d1f2d40b25e0368ff91440c}} 
std\+::vector$<$ uint8\+\_\+t $>$ {\bfseries get\+Arg\+Data} ()
\item 
dim3 \mbox{\hyperlink{class_c_h_i_p_exec_item_aa77c523d9cd1b910bbbc09f1099b2f5d}{get\+Grid}} ()
\begin{DoxyCompactList}\small\item\em Get the Grid object. \end{DoxyCompactList}\item 
dim3 \mbox{\hyperlink{class_c_h_i_p_exec_item_aa7cd51c77750bf9f159a1cd6e9fa64e8}{get\+Block}} ()
\begin{DoxyCompactList}\small\item\em Get the Block object. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{class_c_h_i_p_exec_item_a14d1a06fed7ed4204cd3a66b50ca0eea}{get\+Shared\+Mem}} ()
\begin{DoxyCompactList}\small\item\em Get the Shared\+Mem. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_c_h_i_p_exec_item_ab095e25ece8b9edba9afee4db705f68e}{set\+Arg}} (const void $\ast$arg, size\+\_\+t size, size\+\_\+t offset)
\begin{DoxyCompactList}\small\item\em Setup a single argument. gets called by hip\+Setup\+Argument calls to which are emitted by hip-\/clang. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_c_h_i_p_exec_item_a662d2529f1b5aa74a9b530d1dc88edb5}{set\+Arg\+Pointer}} (void $\ast$$\ast$args)
\begin{DoxyCompactList}\small\item\em Set the Arg Pointer object for launching kernels via new HIP API. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_h_i_p_exec_item_ad1bdab25f8dd647ea0ba0db925b2d21f}\label{class_c_h_i_p_exec_item_ad1bdab25f8dd647ea0ba0db925b2d21f}} 
void {\bfseries setup\+All\+Args} ()
\begin{DoxyCompactList}\small\item\em Sets up the kernel arguments via backend API calls. Called after all the arugments are setup either via hip\+Setup\+Arg() (old HIP kernel launch API) Or after hip\+Launch\+Kernel (new HIP kernel launch API) \end{DoxyCompactList}\item 
hip\+Error\+\_\+t \mbox{\hyperlink{class_c_h_i_p_exec_item_a4f2b77c74962ea43bc49349e8639257a}{launch\+By\+Host\+Ptr}} (const void $\ast$host\+Ptr)
\begin{DoxyCompactList}\small\item\em Launch a kernel associated with a host function pointer. Looks up the \mbox{\hyperlink{class_c_h_i_p_kernel}{CHIPKernel}} associated with this pointer and calls launch() \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_c_h_i_p_exec_item_ab0fe5b6b2373c1a9b2615fba5a943736}\label{class_c_h_i_p_exec_item_ab0fe5b6b2373c1a9b2615fba5a943736}} 
size\+\_\+t {\bfseries shared\+\_\+mem}
\item 
\mbox{\Hypertarget{class_c_h_i_p_exec_item_a2d05ca5b8eb2754d50c5fbcdea59441d}\label{class_c_h_i_p_exec_item_a2d05ca5b8eb2754d50c5fbcdea59441d}} 
std\+::vector$<$ uint8\+\_\+t $>$ {\bfseries arg\+\_\+data}
\item 
\mbox{\Hypertarget{class_c_h_i_p_exec_item_a55e217ad479ace8625314c78b0858f22}\label{class_c_h_i_p_exec_item_a55e217ad479ace8625314c78b0858f22}} 
std\+::vector$<$ std\+::tuple$<$ size\+\_\+t, size\+\_\+t $>$ $>$ {\bfseries offset\+\_\+sizes}
\item 
\mbox{\Hypertarget{class_c_h_i_p_exec_item_a5bb4b1462df9ebaf4ff16d078fe08c06}\label{class_c_h_i_p_exec_item_a5bb4b1462df9ebaf4ff16d078fe08c06}} 
dim3 {\bfseries grid\+\_\+dim}
\item 
\mbox{\Hypertarget{class_c_h_i_p_exec_item_a05f0a2eb6b93ed11eb92be015005ced6}\label{class_c_h_i_p_exec_item_a05f0a2eb6b93ed11eb92be015005ced6}} 
dim3 {\bfseries block\+\_\+dim}
\item 
\mbox{\Hypertarget{class_c_h_i_p_exec_item_a3be4854347b920a8b6cbe15006cb18f1}\label{class_c_h_i_p_exec_item_a3be4854347b920a8b6cbe15006cb18f1}} 
\mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$ {\bfseries stream}
\item 
\mbox{\Hypertarget{class_c_h_i_p_exec_item_a2f4e6ba0970ae341e3d74e78694b1709}\label{class_c_h_i_p_exec_item_a2f4e6ba0970ae341e3d74e78694b1709}} 
\mbox{\hyperlink{class_c_h_i_p_kernel}{CHIPKernel}} $\ast$ {\bfseries chip\+\_\+kernel}
\item 
\mbox{\Hypertarget{class_c_h_i_p_exec_item_a5015853b029a5b463107ba6f68206b9e}\label{class_c_h_i_p_exec_item_a5015853b029a5b463107ba6f68206b9e}} 
\mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$ {\bfseries chip\+\_\+queue}
\item 
\mbox{\Hypertarget{class_c_h_i_p_exec_item_ae4a3e6299040a203f83c24bd93624e21}\label{class_c_h_i_p_exec_item_ae4a3e6299040a203f83c24bd93624e21}} 
void $\ast$$\ast$ {\bfseries Args\+Pointer} = nullptr
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Contains kernel arguments and a queue on which to execute. Prior to kernel launch, the arguments are setup via \mbox{\hyperlink{class_c_h_i_p_backend_a9d802a4ed8ee1c36996ea05d346bdb1d}{CHIPBackend\+::configure\+Call()}}. Because of this, we get the kernel last so the kernel so the launch() takes a kernel argument as opposed to queue receiving a \mbox{\hyperlink{class_c_h_i_p_exec_item}{CHIPExec\+Item}} containing the kernel and arguments. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_c_h_i_p_exec_item_ad240eeebfcca8d53597798e3399971f8}\label{class_c_h_i_p_exec_item_ad240eeebfcca8d53597798e3399971f8}} 
\index{CHIPExecItem@{CHIPExecItem}!CHIPExecItem@{CHIPExecItem}}
\index{CHIPExecItem@{CHIPExecItem}!CHIPExecItem@{CHIPExecItem}}
\doxysubsubsection{\texorpdfstring{CHIPExecItem()}{CHIPExecItem()}}
{\footnotesize\ttfamily CHIPExec\+Item\+::\+CHIPExec\+Item (\begin{DoxyParamCaption}\item[{dim3}]{grid\+\_\+dim\+\_\+,  }\item[{dim3}]{block\+\_\+dim\+\_\+,  }\item[{size\+\_\+t}]{shared\+\_\+mem\+\_\+,  }\item[{hip\+Stream\+\_\+t}]{chip\+\_\+queue\+\_\+ }\end{DoxyParamCaption})}



Construct a new \mbox{\hyperlink{class_c_h_i_p_exec_item}{CHIPExec\+Item}} object. 


\begin{DoxyParams}{Parameters}
{\em grid\+\_\+dim\+\_\+} & \\
\hline
{\em block\+\_\+dim\+\_\+} & \\
\hline
{\em shared\+\_\+mem\+\_\+} & \\
\hline
{\em chip\+\_\+queue\+\_\+} & \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_c_h_i_p_exec_item_aa7cd51c77750bf9f159a1cd6e9fa64e8}\label{class_c_h_i_p_exec_item_aa7cd51c77750bf9f159a1cd6e9fa64e8}} 
\index{CHIPExecItem@{CHIPExecItem}!getBlock@{getBlock}}
\index{getBlock@{getBlock}!CHIPExecItem@{CHIPExecItem}}
\doxysubsubsection{\texorpdfstring{getBlock()}{getBlock()}}
{\footnotesize\ttfamily dim3 CHIPExec\+Item\+::get\+Block (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the Block object. 

\begin{DoxyReturn}{Returns}
dim3 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_exec_item_aa77c523d9cd1b910bbbc09f1099b2f5d}\label{class_c_h_i_p_exec_item_aa77c523d9cd1b910bbbc09f1099b2f5d}} 
\index{CHIPExecItem@{CHIPExecItem}!getGrid@{getGrid}}
\index{getGrid@{getGrid}!CHIPExecItem@{CHIPExecItem}}
\doxysubsubsection{\texorpdfstring{getGrid()}{getGrid()}}
{\footnotesize\ttfamily dim3 CHIPExec\+Item\+::get\+Grid (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the Grid object. 

\begin{DoxyReturn}{Returns}
dim3 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_exec_item_a1cf75c746f3f05b653a577748c77bc44}\label{class_c_h_i_p_exec_item_a1cf75c746f3f05b653a577748c77bc44}} 
\index{CHIPExecItem@{CHIPExecItem}!getKernel@{getKernel}}
\index{getKernel@{getKernel}!CHIPExecItem@{CHIPExecItem}}
\doxysubsubsection{\texorpdfstring{getKernel()}{getKernel()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_c_h_i_p_kernel}{CHIPKernel}} $\ast$ CHIPExec\+Item\+::get\+Kernel (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the Kernel object. 

\begin{DoxyReturn}{Returns}
CHIPKernel$\ast$ Kernel to be executed 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_exec_item_a0ab70870d2c58e6fa2a3e03762a5134a}\label{class_c_h_i_p_exec_item_a0ab70870d2c58e6fa2a3e03762a5134a}} 
\index{CHIPExecItem@{CHIPExecItem}!getQueue@{getQueue}}
\index{getQueue@{getQueue}!CHIPExecItem@{CHIPExecItem}}
\doxysubsubsection{\texorpdfstring{getQueue()}{getQueue()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$ CHIPExec\+Item\+::get\+Queue (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the Queue object. 

\begin{DoxyReturn}{Returns}
CHIPQueue$\ast$ 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_exec_item_a14d1a06fed7ed4204cd3a66b50ca0eea}\label{class_c_h_i_p_exec_item_a14d1a06fed7ed4204cd3a66b50ca0eea}} 
\index{CHIPExecItem@{CHIPExecItem}!getSharedMem@{getSharedMem}}
\index{getSharedMem@{getSharedMem}!CHIPExecItem@{CHIPExecItem}}
\doxysubsubsection{\texorpdfstring{getSharedMem()}{getSharedMem()}}
{\footnotesize\ttfamily size\+\_\+t CHIPExec\+Item\+::get\+Shared\+Mem (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the Shared\+Mem. 

\begin{DoxyReturn}{Returns}
size\+\_\+t 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_exec_item_a4f2b77c74962ea43bc49349e8639257a}\label{class_c_h_i_p_exec_item_a4f2b77c74962ea43bc49349e8639257a}} 
\index{CHIPExecItem@{CHIPExecItem}!launchByHostPtr@{launchByHostPtr}}
\index{launchByHostPtr@{launchByHostPtr}!CHIPExecItem@{CHIPExecItem}}
\doxysubsubsection{\texorpdfstring{launchByHostPtr()}{launchByHostPtr()}}
{\footnotesize\ttfamily hip\+Error\+\_\+t CHIPExec\+Item\+::launch\+By\+Host\+Ptr (\begin{DoxyParamCaption}\item[{const void $\ast$}]{host\+Ptr }\end{DoxyParamCaption})}



Launch a kernel associated with a host function pointer. Looks up the \mbox{\hyperlink{class_c_h_i_p_kernel}{CHIPKernel}} associated with this pointer and calls launch() 


\begin{DoxyParams}{Parameters}
{\em host\+Ptr} & pointer to the host function \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
hip\+Error\+\_\+t possible values\+: hip\+Success, hip\+Error\+Launch\+Failure 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_exec_item_ab095e25ece8b9edba9afee4db705f68e}\label{class_c_h_i_p_exec_item_ab095e25ece8b9edba9afee4db705f68e}} 
\index{CHIPExecItem@{CHIPExecItem}!setArg@{setArg}}
\index{setArg@{setArg}!CHIPExecItem@{CHIPExecItem}}
\doxysubsubsection{\texorpdfstring{setArg()}{setArg()}}
{\footnotesize\ttfamily void CHIPExec\+Item\+::set\+Arg (\begin{DoxyParamCaption}\item[{const void $\ast$}]{arg,  }\item[{size\+\_\+t}]{size,  }\item[{size\+\_\+t}]{offset }\end{DoxyParamCaption})}



Setup a single argument. gets called by hip\+Setup\+Argument calls to which are emitted by hip-\/clang. 


\begin{DoxyParams}{Parameters}
{\em arg} & \\
\hline
{\em size} & \\
\hline
{\em offset} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_c_h_i_p_exec_item_a662d2529f1b5aa74a9b530d1dc88edb5}\label{class_c_h_i_p_exec_item_a662d2529f1b5aa74a9b530d1dc88edb5}} 
\index{CHIPExecItem@{CHIPExecItem}!setArgPointer@{setArgPointer}}
\index{setArgPointer@{setArgPointer}!CHIPExecItem@{CHIPExecItem}}
\doxysubsubsection{\texorpdfstring{setArgPointer()}{setArgPointer()}}
{\footnotesize\ttfamily void CHIPExec\+Item\+::set\+Arg\+Pointer (\begin{DoxyParamCaption}\item[{void $\ast$$\ast$}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Set the Arg Pointer object for launching kernels via new HIP API. 


\begin{DoxyParams}{Parameters}
{\em args} & args pointer \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/\+Users/pvelesko/local/\+CHIP-\/\+SPV/src/\mbox{\hyperlink{_c_h_i_p_backend_8hh}{CHIPBackend.\+hh}}\item 
/\+Users/pvelesko/local/\+CHIP-\/\+SPV/src/backend/\+Level0/Level0\+Backend.\+cc\item 
/\+Users/pvelesko/local/\+CHIP-\/\+SPV/src/CHIPBackend.\+cc\end{DoxyCompactItemize}
