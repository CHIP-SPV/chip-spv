In addition to providing a portable C++ programming environment for GPUs, HIP is designed to ease the porting of existing CUDA code into the HIP environment. This section describes the available tools and provides practical suggestions on how to port CUDA code and work through common issues.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md715}{}\doxysection{Table of Contents}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md715}

\begin{DoxyItemize}
\item \href{\#porting-a-new-cuda-project}{\texttt{ Porting a New CUDA Project}}
\begin{DoxyItemize}
\item \href{\#general-tips}{\texttt{ General Tips}}
\item \href{\#scanning-existing-cuda-code-to-scope-the-porting-effort}{\texttt{ Scanning existing CUDA code to scope the porting effort}}
\item \href{\#converting-a-project-in-place}{\texttt{ Converting a project \char`\"{}in-\/place\char`\"{}}}
\item \href{\#library-equivalents}{\texttt{ CUDA to HIP Math Library Equivalents}}
\end{DoxyItemize}
\item \href{\#distinguishing-compiler-modes}{\texttt{ Distinguishing Compiler Modes}}
\begin{DoxyItemize}
\item \href{\#identifying-hip-target-platform}{\texttt{ Identifying HIP Target Platform}}
\item \href{\#identifying-the-compiler-hip-clang-or-nvcc}{\texttt{ Identifying the Compiler\+: hip-\/clang, or nvcc}}
\item \href{\#identifying-current-compilation-pass-host-or-device}{\texttt{ Identifying Current Compilation Pass\+: Host or Device}}
\item \href{\#compiler-defines-summary}{\texttt{ Compiler Defines\+: Summary}}
\end{DoxyItemize}
\item \href{\#identifying-architecture-features}{\texttt{ Identifying Architecture Features}}
\begin{DoxyItemize}
\item \href{\#hip_arch-defines}{\texttt{ HIP\+\_\+\+ARCH Defines}}
\item \href{\#device-architecture-properties}{\texttt{ Device-\/\+Architecture Properties}}
\item \href{\#table-of-architecture-properties}{\texttt{ Table of Architecture Properties}}
\end{DoxyItemize}
\item \href{\#finding-hip}{\texttt{ Finding HIP}}
\item \href{\#identifying-hip-runtime}{\texttt{ Identifying HIP Runtime}}
\item \href{\#hiplaunchkernel}{\texttt{ hip\+Launch\+Kernel}}
\item \href{\#compiler-options}{\texttt{ Compiler Options}}
\item \href{\#linking-issues}{\texttt{ Linking Issues}}
\begin{DoxyItemize}
\item \href{\#linking-with-hipcc}{\texttt{ Linking With hipcc}}
\item \href{\#-lm-option}{\texttt{ -\/lm Option}}
\end{DoxyItemize}
\item \href{\#linking-code-with-other-compilers}{\texttt{ Linking Code With Other Compilers}}
\begin{DoxyItemize}
\item \href{\#libc-and-libstdc}{\texttt{ libc++ and libstdc++}}
\item \href{\#hip-headers-hip_runtimeh-hip_runtime_apih}{\texttt{ HIP Headers (hip\+\_\+runtime.\+h, hip\+\_\+runtime\+\_\+api.\+h)}}
\item \href{\#using-a-standard-c-compiler}{\texttt{ Using a Standard C++ Compiler}}
\begin{DoxyItemize}
\item \href{\#cudah}{\texttt{ cuda.\+h}}
\end{DoxyItemize}
\item \href{\#choosing-hip-file-extensions}{\texttt{ Choosing HIP File Extensions}}
\end{DoxyItemize}
\item \href{\#workarounds}{\texttt{ Workarounds}}
\begin{DoxyItemize}
\item \href{\#warpsize}{\texttt{ warp\+Size}}
\item \href{\#kernel-launch-with-group-size--256}{\texttt{ Kernel launch with group size \texorpdfstring{$>$}{>} 256}}
\end{DoxyItemize}
\item \href{\#memcpytosymbol}{\texttt{ memcpy\+To\+Symbol}}
\item \href{\#threadfence_system}{\texttt{ threadfence\+\_\+system}}
\begin{DoxyItemize}
\item \href{\#textures-and-cache-control}{\texttt{ Textures and Cache Control}}
\end{DoxyItemize}
\item \href{\#more-tips}{\texttt{ More Tips}}
\begin{DoxyItemize}
\item \href{\#hip-logging}{\texttt{ HIP Logging}}
\item \href{\#debugging-hipcc}{\texttt{ Debugging hipcc}}
\item \href{\#what-does-this-error-mean}{\texttt{ What Does This Error Mean?}}
\begin{DoxyItemize}
\item \href{\#usrincludecv1memory517215-error-call-to-implicitly-deleted-default-constructor-of-std__1bad_weak_ptr-throw-bad_weak_ptr}{\texttt{ /usr/include/c++/v1/memory\+:5172\+:15\+: error\+: call to implicitly deleted default constructor of \textquotesingle{}std\+::\+\_\+\+\_\+1\+::bad\+\_\+weak\+\_\+ptr\textquotesingle{} throw bad\+\_\+weak\+\_\+ptr();}}
\end{DoxyItemize}
\item \href{\#editor-highlighting}{\texttt{ Editor Highlighting}}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md716}{}\doxysection{Porting a New CUDA Project}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md716}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md717}{}\doxysubsection{General Tips}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md717}

\begin{DoxyItemize}
\item Starting the port on a CUDA machine is often the easiest approach, since you can incrementally port pieces of the code to HIP while leaving the rest in CUDA. (Recall that on CUDA machines HIP is just a thin layer over CUDA, so the two code types can interoperate on nvcc platforms.) Also, the HIP port can be compared with the original CUDA code for function and performance.
\item Once the CUDA code is ported to HIP and is running on the CUDA machine, compile the HIP code using the HIP compiler on an AMD machine.
\item HIP ports can replace CUDA versions\+: HIP can deliver the same performance as a native CUDA implementation, with the benefit of portability to both Nvidia and AMD architectures as well as a path to future C++ standard support. You can handle platform-\/specific features through conditional compilation or by adding them to the open-\/source HIP infrastructure.
\item Use {\bfseries{\href{https://github.com/ROCm-Developer-Tools/HIP/blob/master/bin/hipconvertinplace-perl.sh}{\texttt{ bin/hipconvertinplace-\/perl.\+sh}}}} to hipify all code files in the CUDA source directory.
\end{DoxyItemize}\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md718}{}\doxysubsection{Scanning existing CUDA code to scope the porting effort}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md718}
The hipexamine-\/perl.\+sh tool will scan a source directory to determine which files contain CUDA code and how much of that code can be automatically hipified. 
\begin{DoxyCode}{0}
\DoxyCodeLine{> cd examples/rodinia\_3.0/cuda/kmeans}
\DoxyCodeLine{> \$HIP\_DIR/bin/hipexamine-\/perl.sh.}
\DoxyCodeLine{info: hipify ./kmeans.h =====>}
\DoxyCodeLine{info: hipify ./unistd.h =====>}
\DoxyCodeLine{info: hipify ./kmeans.c =====>}
\DoxyCodeLine{info: hipify ./kmeans\_cuda\_kernel.cu =====>}
\DoxyCodeLine{  info: converted 40 CUDA-\/>HIP refs( dev:0 mem:0 kern:0 builtin:37 math:0 stream:0 event:0 err:0 def:0 tex:3 other:0 ) warn:0 LOC:185}
\DoxyCodeLine{info: hipify ./getopt.h =====>}
\DoxyCodeLine{info: hipify ./kmeans\_cuda.cu =====>}
\DoxyCodeLine{  info: converted 49 CUDA-\/>HIP refs( dev:3 mem:32 kern:2 builtin:0 math:0 stream:0 event:0 err:0 def:0 tex:12 other:0 ) warn:0 LOC:311}
\DoxyCodeLine{info: hipify ./rmse.c =====>}
\DoxyCodeLine{info: hipify ./cluster.c =====>}
\DoxyCodeLine{info: hipify ./getopt.c =====>}
\DoxyCodeLine{info: hipify ./kmeans\_clustering.c =====>}
\DoxyCodeLine{info: TOTAL-\/converted 89 CUDA-\/>HIP refs( dev:3 mem:32 kern:2 builtin:37 math:0 stream:0 event:0 err:0 def:0 tex:15 other:0 ) warn:0 LOC:3607}
\DoxyCodeLine{  kernels (1 total) :   kmeansPoint(1)}

\end{DoxyCode}


hipexamine-\/perl scans each code file (cpp, c, h, hpp, etc.) found in the specified directory\+:


\begin{DoxyItemize}
\item Files with no CUDA code (ie kmeans.\+h) print one line summary just listing the source file name.
\item Files with CUDA code print a summary of what was found -\/ for example the kmeans\+\_\+cuda\+\_\+kernel.\+cu file\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{info: hipify ./kmeans\_cuda\_kernel.cu =====>}
\DoxyCodeLine{  info: converted 40 CUDA-\/>HIP refs( dev:0 mem:0 kern:0 builtin:37 math:0 stream:0 event:0}

\end{DoxyCode}

\end{DoxyItemize}

Interesting information in kmeans\+\_\+cuda\+\_\+kernel.\+cu \+:
\begin{DoxyItemize}
\item How many CUDA calls were converted to HIP (40)
\item Breakdown of the CUDA functionality used (dev\+:0 mem\+:0 etc). This file uses many CUDA builtins (37) and texture functions (3).
\begin{DoxyItemize}
\item Warning for code that looks like CUDA API but was not converted (0 in this file).
\item Count Lines-\/of-\/\+Code (LOC) -\/ 185 for this file.
\end{DoxyItemize}
\end{DoxyItemize}

hipexamine-\/perl also presents a summary at the end of the process for the statistics collected across all files. This has similar format to the per-\/file reporting, and also includes a list of all kernels which have been called. An example from above\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{info: TOTAL-\/converted 89 CUDA-\/>HIP refs( dev:3 mem:32 kern:2 builtin:37 math:0 stream:0 event:0 err:0 def:0 tex:15 other:0 ) warn:0 LOC:3607}
\DoxyCodeLine{  kernels (1 total) :   kmeansPoint(1)}

\end{DoxyCode}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md719}{}\doxysubsection{Converting a project \char`\"{}in-\/place\char`\"{}}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md719}

\begin{DoxyCode}{0}
\DoxyCodeLine{> hipify-\/perl -\/-\/inplace}

\end{DoxyCode}


For each input file FILE, this script will\+:
\begin{DoxyItemize}
\item If \char`\"{}\+FILE.\+prehip file does not exist, copy the original code to a new file with extension \char`\"{}.prehip\char`\"{}. Then hipify the code file.   -\/ If \char`\"{}FILE.\+prehip\char`\"{} file exists, hipify FILE.\+prehip and save to FILE.  \+This is useful for testing improvements to the hipify toolset.   \+The $<$a href=\char`\"{}\href{https://github.com/ROCm-Developer-Tools/HIP/blob/master/bin/hipconvertinplace-perl.sh}{\texttt{ https\+://github.\+com/\+ROCm-\/\+Developer-\/\+Tools/\+HIP/blob/master/bin/hipconvertinplace-\/perl.\+sh}}\char`\"{} $>$hipconvertinplace-\/perl.\+sh$<$/a$>$ script will perform inplace conversion for all code files in the specified directory. \+This can be quite handy when dealing with an existing CUDA code base since the script preserves the existing directory structure and filenames -\/ and includes work.  After converting in-\/place, you can review the code to add additional parameters to directory names.   @code\{shell\}  $>$ hipconvertinplace-\/perl.\+sh MY\+\_\+\+SRC\+\_\+\+DIR @endcode  @subsection autotoc\+\_\+md720 Library Equivalents  $<$table class=\char`\"{}markdown\+Table\char`\"{}$>$   $<$tr class=\char`\"{}markdown\+Table\+Head\char`\"{}$>$    $<$th class=\char`\"{}markdown\+Table\+Head\+None"{}\texorpdfstring{$>$}{>} CUDA Library   
\end{DoxyItemize}

ROCm Library   

Comment    

cu\+BLAS   

roc\+BLAS   

Basic Linear Algebra Subroutines    

cu\+FFT   

roc\+FFT   

Fast Fourier Transfer Library    

cu\+SPARSE   

roc\+SPARSE   

Sparse BLAS + SPMV    

cu\+Solver   

roc\+SOLVER   

Lapack library    

AMG-\/X   

roc\+ALUTION   

Sparse iterative solvers and preconditioners with Geometric and Algebraic Multi\+Grid    

Thrust   

roc\+Thrust   

C++ parallel algorithms library    

CUB   

roc\+PRIM   

Low Level Optimized Parallel Primitives    

cu\+DNN   

MIOpen   

Deep learning Solver Library    

cu\+RAND   

roc\+RAND   

Random Number Generator Library    

EIGEN   

EIGEN – HIP port   

C++ template library for linear algebra\+: matrices, vectors, numerical solvers,    

NCCL   

RCCL   

Communications Primitives Library based on the MPI equivalents   \hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md721}{}\doxysection{Distinguishing Compiler Modes}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md721}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md722}{}\doxysubsection{Identifying HIP Target Platform}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md722}
All HIP projects target either AMD or NVIDIA platform. The platform affects which headers are included and which libraries are used for linking.


\begin{DoxyItemize}
\item {\ttfamily HIP\+\_\+\+PLATFORM\+\_\+\+AMD} is defined if the HIP platform targets AMD. Note, {\ttfamily HIP\+\_\+\+PLATFORM\+\_\+\+HCC} was previously defined if the HIP platform targeted AMD, it is deprecated.
\item {\ttfamily HIP\+\_\+\+PLATFORM\+\_\+\+NVDIA} is defined if the HIP platform targets NVIDIA. Note, {\ttfamily HIP\+\_\+\+PLATFORM\+\_\+\+NVCC} was previously defined if the HIP platform targeted NVIDIA, it is deprecated.
\end{DoxyItemize}\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md723}{}\doxysubsection{Identifying the Compiler\+: hip-\/clang or nvcc}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md723}
Often, it\textquotesingle{}s useful to know whether the underlying compiler is HIP-\/\+Clang or nvcc. This knowledge can guard platform-\/specific code or aid in platform-\/specific performance tuning.


\begin{DoxyCode}{0}
\DoxyCodeLine{\#ifdef \_\_HIP\_PLATFORM\_AMD\_\_}
\DoxyCodeLine{// Compiled with HIP-\/Clang}
\DoxyCodeLine{\#endif}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\#ifdef \_\_HIP\_PLATFORM\_NVIDIA\_\_}
\DoxyCodeLine{// Compiled with nvcc}
\DoxyCodeLine{//  Could be compiling with CUDA language extensions enabled (for example, a "{}.cu file)}
\DoxyCodeLine{//  Could be in pass-\/through mode to an underlying host compile OR (for example, a .cpp file)}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\#ifdef \_\_CUDACC\_\_}
\DoxyCodeLine{// Compiled with nvcc (CUDA language extensions enabled)}

\end{DoxyCode}


Compiler directly generates the host code (using the Clang x86 target) and passes the code to another host compiler. Thus, they have no equivalent of the \+\_\+\+\_\+\+CUDA\+\_\+\+ACC define.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md724}{}\doxysubsection{Identifying Current Compilation Pass\+: Host or Device}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md724}
nvcc makes two passes over the code\+: one for host code and one for device code. HIP-\/\+Clang will have multiple passes over the code\+: one for the host code, and one for each architecture on the device code. {\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+DEVICE\+\_\+\+COMPILE\+\_\+\+\_\+} is set to a nonzero value when the compiler (HIP-\/\+Clang or nvcc) is compiling code for a device inside a {\ttfamily \+\_\+\+\_\+global\+\_\+\+\_\+} kernel or for a device function. {\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+DEVICE\+\_\+\+COMPILE\+\_\+\+\_\+} can replace \#ifdef checks on the {\ttfamily \+\_\+\+\_\+\+CUDA\+\_\+\+ARCH\+\_\+\+\_\+} define.


\begin{DoxyCode}{0}
\DoxyCodeLine{// \#ifdef \_\_CUDA\_ARCH\_\_}
\DoxyCodeLine{\#if \_\_HIP\_DEVICE\_COMPILE\_\_}

\end{DoxyCode}


Unlike {\ttfamily \+\_\+\+\_\+\+CUDA\+\_\+\+ARCH\+\_\+\+\_\+}, the {\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+DEVICE\+\_\+\+COMPILE\+\_\+\+\_\+} value is 1 or undefined, and it doesn\textquotesingle{}t represent the feature capability of the target device.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md725}{}\doxysubsection{Compiler Defines\+: Summary}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md725}
$\vert$\+Define $\vert$ HIP-\/\+Clang $\vert$ nvcc $\vert$ Other (GCC, ICC, Clang, etc.) $\vert$--- $\vert$ --- $\vert$ --- $\vert$---$\vert$ $\vert$\+HIP-\/related defines\+:$\vert$ $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+PLATFORM\+\_\+\+AMD\+\_\+\+\_\+}$\vert$ Defined $\vert$ Undefined $\vert$ Defined if targeting AMD platform; undefined otherwise $\vert$ $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+PLATFORM\+\_\+\+NVIDIA\+\_\+\+\_\+}$\vert$ Undefined $\vert$ Defined $\vert$ Defined if targeting NVIDIA platform; undefined otherwise $\vert$ $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+DEVICE\+\_\+\+COMPILE\+\_\+\+\_\+} $\vert$ 1 if compiling for device; undefined if compiling for host $\vert$1 if compiling for device; undefined if compiling for host $\vert$ Undefined $\vert${\ttfamily \+\_\+\+\_\+\+HIPCC\+\_\+\+\_\+} $\vert$ Defined $\vert$ Defined $\vert$ Undefined $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+$\ast$} $\vert$0 or 1 depending on feature support (see below) $\vert$ 0 or 1 depending on feature support (see below) $\vert$ 0 $\vert$nvcc-\/related defines\+:$\vert$ $\vert${\ttfamily \+\_\+\+\_\+\+CUDACC\+\_\+\+\_\+} $\vert$ Defined if source code is compiled by nvcc; undefined otherwise $\vert$ Undefined $\vert${\ttfamily \+\_\+\+\_\+\+NVCC\+\_\+\+\_\+} $\vert$ Undefined $\vert$ Defined $\vert$ Undefined $\vert${\ttfamily \+\_\+\+\_\+\+CUDA\+\_\+\+ARCH\+\_\+\+\_\+} $\vert$ Undefined $\vert$ Unsigned representing compute capability (e.\+g., \char`\"{}130\char`\"{}) if in device code; 0 if in host code $\vert$ Undefined $\vert$hip-\/clang-\/related defines\+:$\vert$ $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+\_\+} $\vert$ Defined $\vert$ Undefined $\vert$ Undefined $\vert$\+HIP-\/\+Clang common defines\+:$\vert$ $\vert${\ttfamily \+\_\+\+\_\+clang\+\_\+\+\_\+} $\vert$ Defined $\vert$ Defined $\vert$ Undefined $\vert$ Defined if using Clang; otherwise undefined\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md726}{}\doxysection{Identifying Architecture Features}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md726}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md727}{}\doxysubsection{HIP\+\_\+\+ARCH Defines}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md727}
Some CUDA code tests {\ttfamily \+\_\+\+\_\+\+CUDA\+\_\+\+ARCH\+\_\+\+\_\+} for a specific value to determine whether the machine supports a certain architectural feature. For instance,


\begin{DoxyCode}{0}
\DoxyCodeLine{\#if (\_\_CUDA\_ARCH\_\_ >= 130)}
\DoxyCodeLine{// doubles are supported}

\end{DoxyCode}
 This type of code requires special attention, since AMD and CUDA devices have different architectural capabilities. Moreover, you can\textquotesingle{}t determine the presence of a feature using a simple comparison against an architecture\textquotesingle{}s version number. HIP provides a set of defines and device properties to query whether a specific architectural feature is supported.

The {\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+$\ast$} defines can replace comparisons of {\ttfamily \+\_\+\+\_\+\+CUDA\+\_\+\+ARCH\+\_\+\+\_\+} values\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{//\#if (\_\_CUDA\_ARCH\_\_ >= 130)   // non-\/portable}
\DoxyCodeLine{if \_\_HIP\_ARCH\_HAS\_DOUBLES\_\_ \{  // portable HIP feature query}
\DoxyCodeLine{   // doubles are supported}
\DoxyCodeLine{\}}

\end{DoxyCode}


For host code, the {\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+\_\+$\ast$} defines are set to 0. You should only use the {\bfseries{HIP\+\_\+\+ARCH}} fields in device code.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md728}{}\doxysubsection{Device-\/\+Architecture Properties}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md728}
Host code should query the architecture feature flags in the device properties that hip\+Get\+Device\+Properties returns, rather than testing the \char`\"{}major\char`\"{} and \char`\"{}minor\char`\"{} fields directly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{hipGetDeviceProperties(\&deviceProp, device);}
\DoxyCodeLine{//if ((deviceProp.major == 1 \&\& deviceProp.minor < 2))  // non-\/portable}
\DoxyCodeLine{if (deviceProp.arch.hasSharedInt32Atomics) \{            // portable HIP feature query}
\DoxyCodeLine{    // has shared int32 atomic operations ...}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md729}{}\doxysubsection{Table of Architecture Properties}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md729}
The table below shows the full set of architectural properties that HIP supports.

$\vert$\+Define (use only in device code) $\vert$ Device Property (run-\/time query) $\vert$ Comment $\vert$ $\vert$-\/-\/-\/-\/--- $\vert$ -\/-\/-\/-\/-\/-\/--- $\vert$ -\/-\/--- $\vert$ $\vert$32-\/bit atomics\+:$\vert$$\vert$ $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+GLOBAL\+\_\+\+INT32\+\_\+\+ATOMICS\+\_\+\+\_\+} $\vert$ has\+Global\+Int32\+Atomics $\vert$32-\/bit integer atomics for global memory $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+GLOBAL\+\_\+\+FLOAT\+\_\+\+ATOMIC\+\_\+\+EXCH\+\_\+\+\_\+} $\vert$ has\+Global\+Float\+Atomic\+Exch $\vert$32-\/bit float atomic exchange for global memory $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+SHARED\+\_\+\+INT32\+\_\+\+ATOMICS\+\_\+\+\_\+} $\vert$ has\+Shared\+Int32\+Atomics $\vert$32-\/bit integer atomics for shared memory $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+SHARED\+\_\+\+FLOAT\+\_\+\+ATOMIC\+\_\+\+EXCH\+\_\+\+\_\+} $\vert$ has\+Shared\+Float\+Atomic\+Exch $\vert$32-\/bit float atomic exchange for shared memory $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+FLOAT\+\_\+\+ATOMIC\+\_\+\+ADD\+\_\+\+\_\+} $\vert$ has\+Float\+Atomic\+Add $\vert$32-\/bit float atomic add in global and shared memory $\vert$64-\/bit atomics\+: $\vert$ $\vert$ $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+GLOBAL\+\_\+\+INT64\+\_\+\+ATOMICS\+\_\+\+\_\+} $\vert$ has\+Global\+Int64\+Atomics $\vert$64-\/bit integer atomics for global memory $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+SHARED\+\_\+\+INT64\+\_\+\+ATOMICS\+\_\+\+\_\+} $\vert$ has\+Shared\+Int64\+Atomics $\vert$64-\/bit integer atomics for shared memory $\vert$\+Doubles\+: $\vert$ $\vert$ $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+DOUBLES\+\_\+\+\_\+} $\vert$ has\+Doubles $\vert$\+Double-\/precision floating point $\vert$\+Warp cross-\/lane operations\+: $\vert$ $\vert$ $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+WARP\+\_\+\+VOTE\+\_\+\+\_\+} $\vert$ has\+Warp\+Vote $\vert$\+Warp vote instructions (any, all) $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+WARP\+\_\+\+BALLOT\+\_\+\+\_\+} $\vert$ has\+Warp\+Ballot $\vert$\+Warp ballot instructions $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+WARP\+\_\+\+SHUFFLE\+\_\+\+\_\+} $\vert$ has\+Warp\+Shuffle $\vert$\+Warp shuffle operations (shfl\+\_\+$\ast$) $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+WARP\+\_\+\+FUNNEL\+\_\+\+SHIFT\+\_\+\+\_\+} $\vert$ has\+Funnel\+Shift $\vert$\+Funnel shift two input words into one $\vert$\+Sync\+: $\vert$ $\vert$ $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+THREAD\+\_\+\+FENCE\+\_\+\+SYSTEM\+\_\+\+\_\+} $\vert$ has\+Thread\+Fence\+System $\vert$threadfence\+\_\+system $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+SYNC\+\_\+\+THREAD\+\_\+\+EXT\+\_\+\+\_\+} $\vert$ has\+Sync\+Threads\+Ext $\vert$syncthreads\+\_\+count, syncthreads\+\_\+and, syncthreads\+\_\+or $\vert$\+Miscellaneous\+: $\vert$ $\vert$ $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+SURFACE\+\_\+\+FUNCS\+\_\+\+\_\+} $\vert$ has\+Surface\+Funcs $\vert$ $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+3\+DGRID\+\_\+\+\_\+} $\vert$ has3d\+Grid $\vert$ Grids and groups are 3D $\vert${\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+ARCH\+\_\+\+HAS\+\_\+\+DYNAMIC\+\_\+\+PARALLEL\+\_\+\+\_\+} $\vert$ has\+Dynamic\+Parallelism $\vert$\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md730}{}\doxysection{Finding HIP}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md730}
Makefiles can use the following syntax to conditionally provide a default HIP\+\_\+\+PATH if one does not exist\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{HIP\_PATH ?= \$(shell hipconfig -\/-\/path)}

\end{DoxyCode}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md731}{}\doxysection{Identifying HIP Runtime}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md731}
HIP can depend on rocclr, or cuda as runtime


\begin{DoxyItemize}
\item AMD platform On AMD platform, HIP uses Radeon Open Compute Common Language Runtime, called ROCclr. ROCclr is a virtual device interface that HIP runtimes interact with different backends which allows runtimes to work on Linux , as well as Windows without much efforts.
\item NVIDIA platform On Nvidia platform, HIP is just a thin layer on top of CUDA. On non-\/\+AMD platform, HIP runtime determines if cuda is available and can be used. If available, HIP\+\_\+\+PLATFORM is set to nvidia and underneath CUDA path is used.
\end{DoxyItemize}\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md732}{}\doxysection{hip\+Launch\+Kernel}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md732}
hip\+Launch\+Kernel is a variadic macro which accepts as parameters the launch configurations (grid dims, group dims, stream, dynamic shared size) followed by a variable number of kernel arguments. This sequence is then expanded into the appropriate kernel launch syntax depending on the platform. While this can be a convenient single-\/line kernel launch syntax, the macro implementation can cause issues when nested inside other macros. For example, consider the following\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{// Will cause compile error:}
\DoxyCodeLine{\#define MY\_LAUNCH(command, doTrace) \(\backslash\)}
\DoxyCodeLine{\{\(\backslash\)}
\DoxyCodeLine{    if (doTrace) printf ("{}TRACE: \%s\(\backslash\)n"{}, \#command); \(\backslash\)}
\DoxyCodeLine{    (command);   /* The nested ( ) will cause compile error */\(\backslash\)}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{MY\_LAUNCH (hipLaunchKernel(vAdd, dim3(1024), dim3(1), 0, 0, Ad), true, "{}firstCall"{});}

\end{DoxyCode}


Avoid nesting macro parameters inside parenthesis -\/ here\textquotesingle{}s an alternative that will work\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\#define MY\_LAUNCH(command, doTrace) \(\backslash\)}
\DoxyCodeLine{\{\(\backslash\)}
\DoxyCodeLine{    if (doTrace) printf ("{}TRACE: \%s\(\backslash\)n"{}, \#command); \(\backslash\)}
\DoxyCodeLine{    command;\(\backslash\) }
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{MY\_LAUNCH (hipLaunchKernel(vAdd, dim3(1024), dim3(1), 0, 0, Ad), true, "{}firstCall"{});}

\end{DoxyCode}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md733}{}\doxysection{Compiler Options}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md733}
hipcc is a portable compiler driver that will call nvcc or HIP-\/\+Clang (depending on the target system) and attach all required include and library options. It passes options through to the target compiler. Tools that call hipcc must ensure the compiler options are appropriate for the target compiler. The {\ttfamily hipconfig} script may helpful in identifying the target platform, compiler and runtime. It can also help set options appropriately.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md734}{}\doxysubsection{Compiler options supported on AMD platforms}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md734}
Here are the main compiler options supported on AMD platforms by HIP-\/\+Clang.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endhead
--amdgpu-\/target=$<$gpu\+\_\+arch$>$   &\mbox{[}DEPRECATED\mbox{]} This option is being replaced by {\ttfamily -\/-\/offload-\/arch=\texorpdfstring{$<$}{<}target\texorpdfstring{$>$}{>}}. Generate code for the given GPU target. Supported targets are gfx701, gfx801, gfx802, gfx803, gfx900, gfx906, gfx908, gfx1010, gfx1011, gfx1012, gfx1030, gfx1031. This option could appear multiple times on the same command line to generate a fat binary for multiple targets.    \\\cline{1-2}
--fgpu-\/rdc   &Generate relocatable device code, which allows kernels or device functions calling device functions in different translation units.    \\\cline{1-2}
-\/ggdb   &Equivalent to {\ttfamily -\/g} plus tuning for GDB. This is recommended when using ROCm\textquotesingle{}s GDB to debug GPU code.    \\\cline{1-2}
--gpu-\/max-\/threads-\/per-\/block=$<$num$>$   &Generate code to support up to the specified number of threads per block.    \\\cline{1-2}
-\/O$<$n$>$   &Specify the optimization level.    \\\cline{1-2}
-\/offload-\/arch=$<$target$>$   &Specify the AMD GPU \href{https://clang.llvm.org/docs/ClangOffloadBundlerFileFormat.html\#target-id}{\texttt{ target ID}}.    \\\cline{1-2}
-\/save-\/temps   &Save the compiler generated intermediate files.    \\\cline{1-2}
-\/v   &Show the compilation steps.   \\\cline{1-2}
\end{longtabu}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md735}{}\doxysection{Linking Issues}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md735}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md736}{}\doxysubsection{Linking With hipcc}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md736}
hipcc adds the necessary libraries for HIP as well as for the accelerator compiler (nvcc or AMD compiler). We recommend linking with hipcc since it automatically links the binary to the necessary HIP runtime libraries. It also has knowledge on how to link and to manage the GPU objects.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md737}{}\doxysubsection{-\/lm Option}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md737}
hipcc adds -\/lm by default to the link command.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md738}{}\doxysection{Linking Code With Other Compilers}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md738}
CUDA code often uses nvcc for accelerator code (defining and launching kernels, typically defined in .cu or .cuh files). It also uses a standard compiler (g++) for the rest of the application. nvcc is a preprocessor that employs a standard host compiler (gcc) to generate the host code. Code compiled using this tool can employ only the intersection of language features supported by both nvcc and the host compiler. In some cases, you must take care to ensure the data types and alignment of the host compiler are identical to those of the device compiler. Only some host compilers are supported---for example, recent nvcc versions lack Clang host-\/compiler capability.

HIP-\/\+Clang generates both device and host code using the same Clang-\/based compiler. The code uses the same API as gcc, which allows code generated by different gcc-\/compatible compilers to be linked together. For example, code compiled using HIP-\/\+Clang can link with code compiled using \char`\"{}standard\char`\"{} compilers (such as gcc, ICC and Clang). Take care to ensure all compilers use the same standard C++ header and library formats.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md739}{}\doxysubsection{libc++ and libstdc++}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md739}
hipcc links to libstdc++ by default. This provides better compatibility between g++ and HIP.

If you pass \char`\"{}-\/-\/stdlib=libc++\char`\"{} to hipcc, hipcc will use the libc++ library. Generally, libc++ provides a broader set of C++ features while libstdc++ is the standard for more compilers (notably including g++).

When cross-\/linking C++ code, any C++ functions that use types from the C++ standard library (including std\+::string, std\+::vector and other containers) must use the same standard-\/library implementation. They include the following\+:


\begin{DoxyItemize}
\item Functions or kernels defined in HIP-\/\+Clang that are called from a standard compiler
\item Functions defined in a standard compiler that are called from HIP-\/\+Clanng.
\end{DoxyItemize}

Applications with these interfaces should use the default libstdc++ linking.

Applications which are compiled entirely with hipcc, and which benefit from advanced C++ features not supported in libstdc++, and which do not require portability to nvcc, may choose to use libc++.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md740}{}\doxysubsection{HIP Headers (hip\+\_\+runtime.\+h, hip\+\_\+runtime\+\_\+api.\+h)}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md740}
The \mbox{\hyperlink{hip__runtime_8h_source}{hip\+\_\+runtime.\+h}} and \mbox{\hyperlink{hip__runtime__api_8h}{hip\+\_\+runtime\+\_\+api.\+h}} files define the types, functions and enumerations needed to compile a HIP program\+:


\begin{DoxyItemize}
\item \mbox{\hyperlink{hip__runtime__api_8h}{hip\+\_\+runtime\+\_\+api.\+h}}\+: defines all the HIP runtime APIs (e.\+g., hip\+Malloc) and the types required to call them. \mbox{\hyperlink{class_a}{A}} source file that is only calling HIP APIs but neither defines nor launches any kernels can include \mbox{\hyperlink{hip__runtime__api_8h}{hip\+\_\+runtime\+\_\+api.\+h}}. \mbox{\hyperlink{hip__runtime__api_8h}{hip\+\_\+runtime\+\_\+api.\+h}} uses no custom hc language features and can be compiled using a standard C++ compiler.
\item \mbox{\hyperlink{hip__runtime_8h_source}{hip\+\_\+runtime.\+h}}\+: included in \mbox{\hyperlink{hip__runtime__api_8h}{hip\+\_\+runtime\+\_\+api.\+h}}. It additionally provides the types and defines required to create and launch kernels. \mbox{\hyperlink{hip__runtime_8h_source}{hip\+\_\+runtime.\+h}} can be compiled using a standard C++ compiler but will expose a subset of the available functions.
\end{DoxyItemize}

CUDA has slightly different contents for these two files. In some cases you may need to convert hipified code to include the richer \mbox{\hyperlink{hip__runtime_8h_source}{hip\+\_\+runtime.\+h}} instead of \mbox{\hyperlink{hip__runtime__api_8h}{hip\+\_\+runtime\+\_\+api.\+h}}.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md741}{}\doxysubsection{Using a Standard C++ Compiler}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md741}
You can compile \mbox{\hyperlink{hip__runtime__api_8h}{hip\+\_\+runtime\+\_\+api.\+h}} using a standard C or C++ compiler (e.\+g., gcc or ICC). The HIP include paths and defines ({\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+PLATFORM\+\_\+\+AMD\+\_\+\+\_\+} or {\ttfamily \+\_\+\+\_\+\+HIP\+\_\+\+PLATFORM\+\_\+\+NVIDIA\+\_\+\+\_\+}) must pass to the standard compiler; hipconfig then returns the necessary options\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{> hipconfig -\/-\/cxx\_config}
\DoxyCodeLine{ -\/D\_\_HIP\_PLATFORM\_AMD\_\_ -\/I/home/user1/hip/include}

\end{DoxyCode}


You can capture the hipconfig output and passed it to the standard compiler; below is a sample makefile syntax\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{CPPFLAGS += \$(shell \$(HIP\_PATH)/bin/hipconfig -\/-\/cpp\_config)}

\end{DoxyCode}


nvcc includes some headers by default. However, HIP does not include default headers, and instead all required files must be explicitly included. Specifically, files that call HIP run-\/time APIs or define HIP kernels must explicitly include the appropriate HIP headers. If the compilation process reports that it cannot find necessary APIs (for example, \char`\"{}error\+: identifier hip\+Set\+Device is undefined\char`\"{}), ensure that the file includes \mbox{\hyperlink{hip__runtime_8h_source}{hip\+\_\+runtime.\+h}} (or \mbox{\hyperlink{hip__runtime__api_8h}{hip\+\_\+runtime\+\_\+api.\+h}}, if appropriate). The hipify-\/perl script automatically converts \char`\"{}cuda\+\_\+runtime.\+h\char`\"{} to \char`\"{}hip\+\_\+runtime.\+h,\char`\"{} and it converts \char`\"{}cuda\+\_\+runtime\+\_\+api.\+h\char`\"{} to \char`\"{}hip\+\_\+runtime\+\_\+api.\+h\char`\"{}, but it may miss nested headers or macros.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md742}{}\doxysubsubsection{cuda.\+h}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md742}
The HIP-\/\+Clang path provides an empty cuda.\+h file. Some existing CUDA programs include this file but don\textquotesingle{}t require any of the functions.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md743}{}\doxysubsection{Choosing HIP File Extensions}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md743}
Many existing CUDA projects use the \char`\"{}.\+cu\char`\"{} and \char`\"{}.\+cuh\char`\"{} file extensions to indicate code that should be run through the nvcc compiler. For quick HIP ports, leaving these file extensions unchanged is often easier, as it minimizes the work required to change file names in the directory and \#include statements in the files.

For new projects or ports which can be re-\/factored, we recommend the use of the extension \char`\"{}.\+hip.\+cpp\char`\"{} for source files, and \char`\"{}.\+hip.\+h\char`\"{} or \char`\"{}.\+hip.\+hpp\char`\"{} for header files. This indicates that the code is standard C++ code, but also provides a unique indication for make tools to run hipcc when appropriate.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md744}{}\doxysection{Workarounds}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md744}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md745}{}\doxysubsection{warp\+Size}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md745}
Code should not assume a warp size of 32 or 64. See \href{hip_kernel_language.md\#warp-cross-lane-functions}{\texttt{ Warp Cross-\/\+Lane Functions}} for information on how to write portable wave-\/aware code.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md746}{}\doxysubsection{Kernel launch with group size $>$ 256}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md746}
Kernel code should use {\ttfamily \+\_\+\+\_\+attribute\+\_\+\+\_\+((amdgpu\+\_\+flat\+\_\+work\+\_\+group\+\_\+size(\texorpdfstring{$<$}{<}min\texorpdfstring{$>$}{>},\texorpdfstring{$<$}{<}max\texorpdfstring{$>$}{>})))}.

For example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\_\_global\_\_ void dot(double *a,double *b,const int n) \_\_attribute\_\_((amdgpu\_flat\_work\_group\_size(1, 512)))}

\end{DoxyCode}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md747}{}\doxysection{memcpy\+To\+Symbol}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md747}
HIP support for hip\+Memcpy\+To\+Symbol is complete. This feature allows a kernel to define a device-\/side data symbol which can be accessed on the host side. The symbol can be in \+\_\+\+\_\+constant or device space.

Note that the symbol name needs to be encased in the HIP\+\_\+\+SYMBOL macro, as shown in the code example below. This also applies to hip\+Memcpy\+From\+Symbol, hip\+Get\+Symbol\+Address, and hip\+Get\+Symbol\+Size.

For example\+:

Device Code\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\#include<hip/hip\_runtime.h>}
\DoxyCodeLine{\#include<hip/hip\_runtime\_api.h>}
\DoxyCodeLine{\#include<iostream>}
\DoxyCodeLine{}
\DoxyCodeLine{\#define HIP\_ASSERT(status) \(\backslash\)}
\DoxyCodeLine{    assert(status == hipSuccess)}
\DoxyCodeLine{}
\DoxyCodeLine{\#define LEN 512}
\DoxyCodeLine{\#define SIZE 2048}
\DoxyCodeLine{}
\DoxyCodeLine{\_\_constant\_\_ int Value[LEN];}
\DoxyCodeLine{}
\DoxyCodeLine{\_\_global\_\_ void Get(hipLaunchParm lp, int *Ad)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    int tid = threadIdx.x + blockIdx.x * blockDim.x;}
\DoxyCodeLine{    Ad[tid] = Value[tid];}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{int main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{    int *A, *B, *Ad;}
\DoxyCodeLine{    A = new int[LEN];}
\DoxyCodeLine{    B = new int[LEN];}
\DoxyCodeLine{    for(unsigned i=0;i<LEN;i++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        A[i] = -\/1*i;}
\DoxyCodeLine{        B[i] = 0;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    HIP\_ASSERT(hipMalloc((void**)\&Ad, SIZE));}
\DoxyCodeLine{}
\DoxyCodeLine{    HIP\_ASSERT(hipMemcpyToSymbol(HIP\_SYMBOL(Value), A, SIZE, 0, hipMemcpyHostToDevice));}
\DoxyCodeLine{    hipLaunchKernel(Get, dim3(1,1,1), dim3(LEN,1,1), 0, 0, Ad);}
\DoxyCodeLine{    HIP\_ASSERT(hipMemcpy(B, Ad, SIZE, hipMemcpyDeviceToHost));}
\DoxyCodeLine{}
\DoxyCodeLine{    for(unsigned i=0;i<LEN;i++)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        assert(A[i] == B[i]);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    std::cout<<"{}Passed"{}<<std::endl;}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md748}{}\doxysection{CU\+\_\+\+POINTER\+\_\+\+ATTRIBUTE\+\_\+\+MEMORY\+\_\+\+TYPE}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md748}
To get pointer\textquotesingle{}s memory type in HIP/\+HIP-\/\+Clang one should use hip\+Pointer\+Get\+Attributes API. First parameter of the API is \mbox{\hyperlink{structhip_pointer_attribute__t}{hip\+Pointer\+Attribute\+\_\+t}} which has \textquotesingle{}memory\+Type\textquotesingle{} as member variable. \textquotesingle{}memory\+Type\textquotesingle{} indicates input pointer is allocated on device or host.

For example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{double * ptr;}
\DoxyCodeLine{hipMalloc(reinterpret\_cast<void**>(\&ptr), sizeof(double));}
\DoxyCodeLine{hipPointerAttribute\_t attr;}
\DoxyCodeLine{hipPointerGetAttributes(\&attr, ptr); /*attr.memoryType will have value as hipMemoryTypeDevice*/}
\DoxyCodeLine{}
\DoxyCodeLine{double* ptrHost;}
\DoxyCodeLine{hipHostMalloc(\&ptrHost, sizeof(double));}
\DoxyCodeLine{hipPointerAttribute\_t attr;}
\DoxyCodeLine{hipPointerGetAttributes(\&attr, ptrHost); /*attr.memoryType will have value as hipMemoryTypeHost*/}

\end{DoxyCode}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md749}{}\doxysection{threadfence\+\_\+system}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md749}
Threadfence\+\_\+system makes all device memory writes, all writes to mapped host memory, and all writes to peer memory visible to CPU and other GPU devices. Some implementations can provide this behavior by flushing the GPU L2 cache. HIP/\+HIP-\/\+Clang does not provide this functionality. As a workaround, users can set the environment variable {\ttfamily HSA\+\_\+\+DISABLE\+\_\+\+CACHE=1} to disable the GPU L2 cache. This will affect all accesses and for all kernels and so may have a performance impact.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md750}{}\doxysubsection{Textures and Cache Control}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md750}
Compute programs sometimes use textures either to access dedicated texture caches or to use the texture-\/sampling hardware for interpolation and clamping. The former approach uses simple point samplers with linear interpolation, essentially only reading a single point. The latter approach uses the sampler hardware to interpolate and combine multiple samples. AMD hardware, as well as recent competing hardware, has a unified texture/\+L1 cache, so it no longer has a dedicated texture cache. But the nvcc path often caches global loads in the L2 cache, and some programs may benefit from explicit control of the L1 cache contents. We recommend the \+\_\+\+\_\+ldg instruction for this purpose.

AMD compilers currently load all data into both the L1 and L2 caches, so \+\_\+\+\_\+ldg is treated as a no-\/op.

We recommend the following for functional portability\+:


\begin{DoxyItemize}
\item For programs that use textures only to benefit from improved caching, use the \+\_\+\+\_\+ldg instruction
\item Programs that use texture object and reference APIs, work well on HIP
\end{DoxyItemize}\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md751}{}\doxysection{More Tips}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md751}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md752}{}\doxysubsection{HIP Logging}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md752}
On an AMD platform, set the AMD\+\_\+\+LOG\+\_\+\+LEVEL environment variable to log HIP application execution information.

The value of the setting controls different logging level,


\begin{DoxyCode}{0}
\DoxyCodeLine{enum LogLevel \{}
\DoxyCodeLine{LOG\_NONE = 0,}
\DoxyCodeLine{LOG\_ERROR = 1,}
\DoxyCodeLine{LOG\_WARNING = 2,}
\DoxyCodeLine{LOG\_INFO = 3,}
\DoxyCodeLine{LOG\_DEBUG = 4}
\DoxyCodeLine{\};}

\end{DoxyCode}


Logging mask is used to print types of functionalities during the execution of HIP application. It can be set as one of the following values,


\begin{DoxyCode}{0}
\DoxyCodeLine{enum LogMask \{}
\DoxyCodeLine{  LOG\_API       = 0x00000001, //!< API call}
\DoxyCodeLine{  LOG\_CMD       = 0x00000002, //!< Kernel and Copy Commands and Barriers}
\DoxyCodeLine{  LOG\_WAIT      = 0x00000004, //!< Synchronization and waiting for commands to finish}
\DoxyCodeLine{  LOG\_AQL       = 0x00000008, //!< Decode and display AQL packets}
\DoxyCodeLine{  LOG\_QUEUE     = 0x00000010, //!< Queue commands and queue contents}
\DoxyCodeLine{  LOG\_SIG       = 0x00000020, //!< Signal creation, allocation, pool}
\DoxyCodeLine{  LOG\_LOCK      = 0x00000040, //!< Locks and thread-\/safety code.}
\DoxyCodeLine{  LOG\_KERN      = 0x00000080, //!< kernel creations and arguments, etc.}
\DoxyCodeLine{  LOG\_COPY      = 0x00000100, //!< Copy debug}
\DoxyCodeLine{  LOG\_COPY2     = 0x00000200, //!< Detailed copy debug}
\DoxyCodeLine{  LOG\_RESOURCE  = 0x00000400, //!< Resource allocation, performance-\/impacting events.}
\DoxyCodeLine{  LOG\_INIT      = 0x00000800, //!< Initialization and shutdown}
\DoxyCodeLine{  LOG\_MISC      = 0x00001000, //!< misc debug, not yet classified}
\DoxyCodeLine{  LOG\_AQL2      = 0x00002000, //!< Show raw bytes of AQL packet}
\DoxyCodeLine{  LOG\_CODE      = 0x00004000, //!< Show code creation debug}
\DoxyCodeLine{  LOG\_CMD2      = 0x00008000, //!< More detailed command info, including barrier commands}
\DoxyCodeLine{  LOG\_LOCATION  = 0x00010000, //!< Log message location}
\DoxyCodeLine{  LOG\_ALWAYS    = 0xFFFFFFFF, //!< Log always even mask flag is zero}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md753}{}\doxysubsection{Debugging hipcc}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md753}
To see the detailed commands that hipcc issues, set the environment variable HIPCC\+\_\+\+VERBOSE to 1. Doing so will print to stderr the HIP-\/clang (or nvcc) commands that hipcc generates.


\begin{DoxyCode}{0}
\DoxyCodeLine{export HIPCC\_VERBOSE=1}
\DoxyCodeLine{make}
\DoxyCodeLine{...}
\DoxyCodeLine{hipcc-\/cmd: /opt/hcc/bin/hcc  -\/hc -\/I/opt/hcc/include -\/stdlib=libc++ -\/I../../../../hc/include -\/I../../../../include/amd\_detail/cuda -\/I../../../../include -\/x c++ -\/I../../common -\/O3 -\/c backprop\_cuda.cu}

\end{DoxyCode}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md754}{}\doxysubsection{What Does This Error Mean?}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md754}
\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md755}{}\doxysubsubsection{/usr/include/c++/v1/memory\+:5172\+:15\+: error\+: call to implicitly deleted default constructor of \textquotesingle{}std\+::\+\_\+\+\_\+1\+::bad\+\_\+weak\+\_\+ptr\textquotesingle{} throw bad\+\_\+weak\+\_\+ptr();}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md755}
If you pass a \char`\"{}.\+cu\char`\"{} file, hcc will attempt to compile it as a CUDA language file. You must tell hcc that it\textquotesingle{}s in fact a C++ file\+: use the \char`\"{}-\/x c++\char`\"{} option.\hypertarget{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md756}{}\doxysubsection{Editor Highlighting}\label{md___users_pvelesko_local__c_h_i_p__s_p_v__h_i_p_docs_markdown_hip_porting_guide_autotoc_md756}
See the utils/vim or utils/gedit directories to add handy highlighting to hip files. 