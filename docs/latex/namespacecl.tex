\hypertarget{namespacecl}{}\doxysection{cl Namespace Reference}
\label{namespacecl}\index{cl@{cl}}


The Open\+CL C++ bindings are defined within this namespace.  


\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}}
\begin{DoxyCompactList}\small\item\em Class interface for \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \mbox{\hyperlink{classcl_1_1_memory}{Memory}} Objects. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_buffer_g_l}{Buffer\+GL}}
\begin{DoxyCompactList}\small\item\em Class interface for GL \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \mbox{\hyperlink{classcl_1_1_memory}{Memory}} Objects. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_buffer_render_g_l}{Buffer\+Render\+GL}}
\begin{DoxyCompactList}\small\item\em Class interface for GL Render \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \mbox{\hyperlink{classcl_1_1_memory}{Memory}} Objects. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_c_l___e_x_t___s_u_f_f_i_x_____v_e_r_s_i_o_n__1__1___d_e_p_r_e_c_a_t_e_d}{CL\+\_\+\+EXT\+\_\+\+SUFFIX\+\_\+\+\_\+\+VERSION\+\_\+1\+\_\+1\+\_\+\+DEPRECATED}}
\begin{DoxyCompactList}\small\item\em Class interface for GL 2D \mbox{\hyperlink{classcl_1_1_image}{Image}} \mbox{\hyperlink{classcl_1_1_memory}{Memory}} objects. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_command_queue}{Command\+Queue}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classcl_1_1_command_queue}{Command\+Queue}} interface for cl\+\_\+command\+\_\+queue. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_context}{Context}}
\begin{DoxyCompactList}\small\item\em Class interface for cl\+\_\+context. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_device}{Device}}
\begin{DoxyCompactList}\small\item\em Class interface for cl\+\_\+device\+\_\+id. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_device_command_queue}{Device\+Command\+Queue}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classcl_1_1_device_command_queue}{Device\+Command\+Queue}} interface for device cl\+\_\+command\+\_\+queues. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{structcl_1_1_enqueue_args}{Enqueue\+Args}}
\item 
class \mbox{\hyperlink{classcl_1_1_event}{Event}}
\begin{DoxyCompactList}\small\item\em Class interface for cl\+\_\+event. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_image}{Image}}
\begin{DoxyCompactList}\small\item\em C++ base class for \mbox{\hyperlink{classcl_1_1_image}{Image}} \mbox{\hyperlink{classcl_1_1_memory}{Memory}} objects. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_image1_d}{Image1D}}
\begin{DoxyCompactList}\small\item\em Class interface for 1D \mbox{\hyperlink{classcl_1_1_image}{Image}} \mbox{\hyperlink{classcl_1_1_memory}{Memory}} objects. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_image1_d_array}{Image1\+DArray}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classcl_1_1_image}{Image}} interface for arrays of 1D images. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_image1_d_buffer}{Image1\+DBuffer}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classcl_1_1_image}{Image}} interface for 1D buffer images. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_image2_d}{Image2D}}
\begin{DoxyCompactList}\small\item\em Class interface for 2D \mbox{\hyperlink{classcl_1_1_image}{Image}} \mbox{\hyperlink{classcl_1_1_memory}{Memory}} objects. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_image2_d_array}{Image2\+DArray}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classcl_1_1_image}{Image}} interface for arrays of 2D images. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_image3_d}{Image3D}}
\begin{DoxyCompactList}\small\item\em Class interface for 3D \mbox{\hyperlink{classcl_1_1_image}{Image}} \mbox{\hyperlink{classcl_1_1_memory}{Memory}} objects. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_image3_d_g_l}{Image3\+DGL}}
\begin{DoxyCompactList}\small\item\em Class interface for GL 3D \mbox{\hyperlink{classcl_1_1_image}{Image}} \mbox{\hyperlink{classcl_1_1_memory}{Memory}} objects. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structcl_1_1_image_format}{Image\+Format}}
\begin{DoxyCompactList}\small\item\em Adds constructors and member functions for cl\+\_\+image\+\_\+format. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_image_g_l}{Image\+GL}}
\begin{DoxyCompactList}\small\item\em general image interface for GL interop. We abstract the 2D and 3D GL images into a single instance here that wraps all GL sourced images on the grounds that setup information was performed by Open\+CL anyway. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_kernel}{Kernel}}
\begin{DoxyCompactList}\small\item\em Class interface for cl\+\_\+kernel. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_kernel_functor}{Kernel\+Functor}}
\item 
struct \mbox{\hyperlink{structcl_1_1_local_space_arg}{Local\+Space\+Arg}}
\begin{DoxyCompactList}\small\item\em Local address wrapper for use with Kernel\+::set\+Arg. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structcl_1_1make__kernel}{make\+\_\+kernel}}
\item 
class \mbox{\hyperlink{classcl_1_1_memory}{Memory}}
\begin{DoxyCompactList}\small\item\em Class interface for cl\+\_\+mem. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_n_d_range}{NDRange}}
\begin{DoxyCompactList}\small\item\em Class interface for specifying \mbox{\hyperlink{classcl_1_1_n_d_range}{NDRange}} values. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_pipe}{Pipe}}
\begin{DoxyCompactList}\small\item\em Class interface for \mbox{\hyperlink{classcl_1_1_pipe}{Pipe}} \mbox{\hyperlink{classcl_1_1_memory}{Memory}} Objects. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_platform}{Platform}}
\begin{DoxyCompactList}\small\item\em Class interface for cl\+\_\+platform\+\_\+id. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_program}{Program}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classcl_1_1_program}{Program}} interface that implements cl\+\_\+program. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_sampler}{Sampler}}
\begin{DoxyCompactList}\small\item\em Class interface for cl\+\_\+sampler. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}
\begin{DoxyCompactList}\small\item\em class used to interface between C++ and Open\+CL C calls that require arrays of \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} values, whose size is known statically. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcl_1_1_s_v_m_allocator}{SVMAllocator}}
\item 
class \mbox{\hyperlink{classcl_1_1_s_v_m_allocator_3_01void_00_01_s_v_m_trait_01_4}{SVMAllocator$<$ void, SVMTrait $>$}}
\item 
class \mbox{\hyperlink{classcl_1_1_s_v_m_trait_atomic}{SVMTrait\+Atomic}}
\item 
class \mbox{\hyperlink{classcl_1_1_s_v_m_trait_coarse}{SVMTrait\+Coarse}}
\item 
class \mbox{\hyperlink{classcl_1_1_s_v_m_trait_fine}{SVMTrait\+Fine}}
\item 
class \mbox{\hyperlink{classcl_1_1_s_v_m_trait_read_only}{SVMTrait\+Read\+Only}}
\item 
class \mbox{\hyperlink{classcl_1_1_s_v_m_trait_read_write}{SVMTrait\+Read\+Write}}
\item 
class \mbox{\hyperlink{classcl_1_1_s_v_m_trait_write_only}{SVMTrait\+Write\+Only}}
\item 
class \mbox{\hyperlink{classcl_1_1_user_event}{User\+Event}}
\begin{DoxyCompactList}\small\item\em Class interface for user events (a subset of cl\+\_\+event\textquotesingle{}s). \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef std\+::string \mbox{\hyperlink{namespacecl_ad3ff55c5fe80ec84842876af323559c7}{STRING\+\_\+\+CLASS}}
\item 
\mbox{\Hypertarget{namespacecl_a35ea2a6f4cc42e6b4082daab0e4dc449}\label{namespacecl_a35ea2a6f4cc42e6b4082daab0e4dc449}} 
using {\bfseries size\+\_\+type} = \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}
\item 
\mbox{\Hypertarget{namespacecl_a01a0973ddf4c1799772079a09d7156cb}\label{namespacecl_a01a0973ddf4c1799772079a09d7156cb}} 
{\footnotesize template$<$class T , class Alloc  = std\+::allocator$<$\+T$>$$>$ }\\using {\bfseries vector} = std\+::vector$<$ T, Alloc $>$
\item 
\mbox{\Hypertarget{namespacecl_abff80bfb254d646f6afeb6638df41686}\label{namespacecl_abff80bfb254d646f6afeb6638df41686}} 
using {\bfseries string} = std\+::string
\item 
\mbox{\Hypertarget{namespacecl_ae65ac4732da5652cb62af5002ea568c1}\label{namespacecl_ae65ac4732da5652cb62af5002ea568c1}} 
{\footnotesize template$<$class T , class D $>$ }\\using {\bfseries pointer} = std\+::unique\+\_\+ptr$<$ T, D $>$
\item 
\mbox{\Hypertarget{namespacecl_a8856ce875094624efdce0a49496d695e}\label{namespacecl_a8856ce875094624efdce0a49496d695e}} 
{\footnotesize template$<$class T , \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} N$>$ }\\using {\bfseries array} = std\+::array$<$ T, N $>$
\item 
\mbox{\Hypertarget{namespacecl_a0982464a83dd2f129b737d17d9ff9b19}\label{namespacecl_a0982464a83dd2f129b737d17d9ff9b19}} 
using {\bfseries Build\+Log\+Type} = vector$<$ std\+::pair$<$ \mbox{\hyperlink{classcl_1_1_device}{cl\+::\+Device}}, typename \mbox{\hyperlink{structcl_1_1detail_1_1param__traits}{detail\+::param\+\_\+traits}}$<$ detail\+::cl\+\_\+program\+\_\+build\+\_\+info, CL\+\_\+\+PROGRAM\+\_\+\+BUILD\+\_\+\+LOG $>$\+::param\+\_\+type $>$ $>$
\item 
\mbox{\Hypertarget{namespacecl_abd957be3ad58ee2932a99ed8bc6cc049}\label{namespacecl_abd957be3ad58ee2932a99ed8bc6cc049}} 
{\footnotesize template$<$class T $>$ }\\using {\bfseries coarse\+\_\+svm\+\_\+vector} = vector$<$ T, \mbox{\hyperlink{classcl_1_1_s_v_m_allocator}{cl\+::\+SVMAllocator}}$<$ int, \mbox{\hyperlink{classcl_1_1_s_v_m_trait_coarse}{cl\+::\+SVMTrait\+Coarse}}$<$$>$ $>$ $>$
\begin{DoxyCompactList}\small\item\em Vector alias to simplify contruction of coarse-\/grained SVM containers. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacecl_a048aa194c540d1a3178054256db082b9}\label{namespacecl_a048aa194c540d1a3178054256db082b9}} 
{\footnotesize template$<$class T $>$ }\\using {\bfseries fine\+\_\+svm\+\_\+vector} = vector$<$ T, \mbox{\hyperlink{classcl_1_1_s_v_m_allocator}{cl\+::\+SVMAllocator}}$<$ int, \mbox{\hyperlink{classcl_1_1_s_v_m_trait_fine}{cl\+::\+SVMTrait\+Fine}}$<$$>$ $>$ $>$
\begin{DoxyCompactList}\small\item\em Vector alias to simplify contruction of fine-\/grained SVM containers. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacecl_aebc48a598e41f0cb98397460ca04ffb6}\label{namespacecl_aebc48a598e41f0cb98397460ca04ffb6}} 
{\footnotesize template$<$class T $>$ }\\using {\bfseries atomic\+\_\+svm\+\_\+vector} = vector$<$ T, \mbox{\hyperlink{classcl_1_1_s_v_m_allocator}{cl\+::\+SVMAllocator}}$<$ int, \mbox{\hyperlink{classcl_1_1_s_v_m_trait_atomic}{cl\+::\+SVMTrait\+Atomic}}$<$$>$ $>$ $>$
\begin{DoxyCompactList}\small\item\em Vector alias to simplify contruction of fine-\/grained SVM containers that support platform atomics. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespacecl_a6b1e69bec24f2a7f89eb17c265060e0d}\label{namespacecl_a6b1e69bec24f2a7f89eb17c265060e0d}} 
enum class {\bfseries Queue\+Properties} \+: cl\+\_\+command\+\_\+queue\+\_\+properties \{ {\bfseries None} = 0
, {\bfseries Profiling} = CL\+\_\+\+QUEUE\+\_\+\+PROFILING\+\_\+\+ENABLE
, {\bfseries Out\+Of\+Order} = CL\+\_\+\+QUEUE\+\_\+\+OUT\+\_\+\+OF\+\_\+\+ORDER\+\_\+\+EXEC\+\_\+\+MODE\+\_\+\+ENABLE
 \}
\item 
\mbox{\Hypertarget{namespacecl_a000ce6769841b11cf56253f7a0344277}\label{namespacecl_a000ce6769841b11cf56253f7a0344277}} 
enum class {\bfseries Device\+Queue\+Properties} \+: cl\+\_\+command\+\_\+queue\+\_\+properties \{ {\bfseries None} = 0
, {\bfseries Profiling} = CL\+\_\+\+QUEUE\+\_\+\+PROFILING\+\_\+\+ENABLE
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Iterator\+Type $>$ }\\cl\+\_\+int \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{copy}} (Iterator\+Type start\+Iterator, Iterator\+Type end\+Iterator, \mbox{\hyperlink{classcl_1_1_buffer}{cl\+::\+Buffer}} \&buffer)
\item 
{\footnotesize template$<$typename Iterator\+Type $>$ }\\cl\+\_\+int \mbox{\hyperlink{namespacecl_a05791e9d5da23b21abd6e319fb262c9f}{copy}} (const \mbox{\hyperlink{classcl_1_1_buffer}{cl\+::\+Buffer}} \&buffer, Iterator\+Type start\+Iterator, Iterator\+Type end\+Iterator)
\item 
{\footnotesize template$<$typename Iterator\+Type $>$ }\\cl\+\_\+int \mbox{\hyperlink{namespacecl_a2f71ed9a316daf59c03c0f3ba62f1bd3}{copy}} (const \mbox{\hyperlink{classcl_1_1_command_queue}{Command\+Queue}} \&queue, Iterator\+Type start\+Iterator, Iterator\+Type end\+Iterator, \mbox{\hyperlink{classcl_1_1_buffer}{cl\+::\+Buffer}} \&buffer)
\item 
{\footnotesize template$<$typename Iterator\+Type $>$ }\\cl\+\_\+int \mbox{\hyperlink{namespacecl_a02c4368c6ce7a1a99132eafd5dc96fa9}{copy}} (const \mbox{\hyperlink{classcl_1_1_command_queue}{Command\+Queue}} \&queue, const \mbox{\hyperlink{classcl_1_1_buffer}{cl\+::\+Buffer}} \&buffer, Iterator\+Type start\+Iterator, Iterator\+Type end\+Iterator)
\item 
CL\+\_\+\+EXT\+\_\+\+PREFIX\+\_\+\+\_\+\+VERSION\+\_\+1\+\_\+1\+\_\+\+DEPRECATED \mbox{\hyperlink{structcl_1_1_local_space_arg}{Local\+Space\+Arg}} \mbox{\hyperlink{namespacecl_a8c0bd8b2f6874ca5a62e2f25e5116c64}{\+\_\+\+\_\+local}} (\+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} size) \mbox{\hyperlink{classcl_1_1_c_l___e_x_t___s_u_f_f_i_x_____v_e_r_s_i_o_n__1__1___d_e_p_r_e_c_a_t_e_d}{CL\+\_\+\+EXT\+\_\+\+SUFFIX\+\_\+\+\_\+\+VERSION\+\_\+1\+\_\+1\+\_\+\+DEPRECATED}}
\begin{DoxyCompactList}\small\item\em Helper function for generating \mbox{\hyperlink{structcl_1_1_local_space_arg}{Local\+Space\+Arg}} objects. Deprecated. Replaced with Local. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structcl_1_1_local_space_arg}{Local\+Space\+Arg}} \mbox{\hyperlink{namespacecl_a861d36f255ea512d3aba2c40ce952e44}{Local}} (\+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} size)
\begin{DoxyCompactList}\small\item\em Helper function for generating \mbox{\hyperlink{structcl_1_1_local_space_arg}{Local\+Space\+Arg}} objects. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacecl_a5610ad7d382b6ab02d9063cfa413ae3c}\label{namespacecl_a5610ad7d382b6ab02d9063cfa413ae3c}} 
cl\+\_\+int {\bfseries enqueue\+Read\+Buffer} (const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&buffer, cl\+\_\+bool blocking, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} offset, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} size, void $\ast$ptr, const VECTOR\+\_\+\+CLASS$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_a1c4a6c7dda08ae8c2aa18366f5fe5981}\label{namespacecl_a1c4a6c7dda08ae8c2aa18366f5fe5981}} 
cl\+\_\+int {\bfseries enqueue\+Write\+Buffer} (const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&buffer, cl\+\_\+bool blocking, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} offset, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} size, const void $\ast$ptr, const VECTOR\+\_\+\+CLASS$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_a8f9e888c5887260997de0e3c6f49618b}\label{namespacecl_a8f9e888c5887260997de0e3c6f49618b}} 
void $\ast$ {\bfseries enqueue\+Map\+Buffer} (const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&buffer, cl\+\_\+bool blocking, cl\+\_\+map\+\_\+flags flags, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} offset, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} size, const VECTOR\+\_\+\+CLASS$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL, cl\+\_\+int $\ast$err=NULL)
\item 
\mbox{\Hypertarget{namespacecl_abb9786b5faa37a5124a9a8205e0703df}\label{namespacecl_abb9786b5faa37a5124a9a8205e0703df}} 
cl\+\_\+int {\bfseries enqueue\+Unmap\+Mem\+Object} (const \mbox{\hyperlink{classcl_1_1_memory}{Memory}} \&memory, void $\ast$mapped\+\_\+ptr, const VECTOR\+\_\+\+CLASS$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_ab4d3257868ecd7d2387cbb4166a76f95}\label{namespacecl_ab4d3257868ecd7d2387cbb4166a76f95}} 
cl\+\_\+int {\bfseries enqueue\+Copy\+Buffer} (const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&src, const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&dst, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} src\+\_\+offset, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} dst\+\_\+offset, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} size, const VECTOR\+\_\+\+CLASS$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_a168ceb56f757f62477945d72baa5a26b}\label{namespacecl_a168ceb56f757f62477945d72baa5a26b}} 
cl\+\_\+int {\bfseries enqueue\+Read\+Image} (const \mbox{\hyperlink{classcl_1_1_image}{Image}} \&image, cl\+\_\+bool blocking, const \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}$<$ 3 $>$ \&origin, const \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}$<$ 3 $>$ \&region, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} row\+\_\+pitch, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} slice\+\_\+pitch, void $\ast$ptr, const VECTOR\+\_\+\+CLASS$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_a08c67720079e3d5b1f9a0a2d4a57fc66}\label{namespacecl_a08c67720079e3d5b1f9a0a2d4a57fc66}} 
cl\+\_\+int {\bfseries enqueue\+Write\+Image} (const \mbox{\hyperlink{classcl_1_1_image}{Image}} \&image, cl\+\_\+bool blocking, const \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}$<$ 3 $>$ \&origin, const \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}$<$ 3 $>$ \&region, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} row\+\_\+pitch, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} slice\+\_\+pitch, const void $\ast$ptr, const VECTOR\+\_\+\+CLASS$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_a26f3b361603d543c0eee11ebd6c4d344}\label{namespacecl_a26f3b361603d543c0eee11ebd6c4d344}} 
cl\+\_\+int {\bfseries enqueue\+Copy\+Image} (const \mbox{\hyperlink{classcl_1_1_image}{Image}} \&src, const \mbox{\hyperlink{classcl_1_1_image}{Image}} \&dst, const \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}$<$ 3 $>$ \&src\+\_\+origin, const \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}$<$ 3 $>$ \&dst\+\_\+origin, const \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}$<$ 3 $>$ \&region, const VECTOR\+\_\+\+CLASS$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_a824ccdd6e63275c821b0f0447398e2bb}\label{namespacecl_a824ccdd6e63275c821b0f0447398e2bb}} 
cl\+\_\+int {\bfseries enqueue\+Copy\+Image\+To\+Buffer} (const \mbox{\hyperlink{classcl_1_1_image}{Image}} \&src, const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&dst, const \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}$<$ 3 $>$ \&src\+\_\+origin, const \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}$<$ 3 $>$ \&region, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} dst\+\_\+offset, const VECTOR\+\_\+\+CLASS$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_a6d6df68bd2845b894702c2d21efd90a6}\label{namespacecl_a6d6df68bd2845b894702c2d21efd90a6}} 
cl\+\_\+int {\bfseries enqueue\+Copy\+Buffer\+To\+Image} (const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&src, const \mbox{\hyperlink{classcl_1_1_image}{Image}} \&dst, \+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}} src\+\_\+offset, const \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}$<$ 3 $>$ \&dst\+\_\+origin, const \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}$<$ 3 $>$ \&region, const VECTOR\+\_\+\+CLASS$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_aec3275453ec57a74dfa7a34653cfa194}\label{namespacecl_aec3275453ec57a74dfa7a34653cfa194}} 
cl\+\_\+int {\bfseries flush} (void)
\item 
\mbox{\Hypertarget{namespacecl_a10f66d5f5f17570f71d7cbf467c0930f}\label{namespacecl_a10f66d5f5f17570f71d7cbf467c0930f}} 
cl\+\_\+int {\bfseries finish} (void)
\item 
{\footnotesize template$<$typename T $>$ }\\cl\+\_\+int \mbox{\hyperlink{namespacecl_abb2c4e45814ea569a27c39d37471b2a4}{enqueue\+Map\+SVM}} (T $\ast$ptr, cl\+\_\+bool blocking, cl\+\_\+map\+\_\+flags flags, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} size, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
{\footnotesize template$<$class T , class Alloc , class... Args$>$ }\\cl\+::pointer$<$ T, \mbox{\hyperlink{classcl_1_1detail_1_1_deleter}{detail\+::\+Deleter}}$<$ Alloc $>$ $>$ \mbox{\hyperlink{namespacecl_a8e1fce10cd1b8118f51aa91ce0a589e5}{allocate\+\_\+pointer}} (const Alloc \&alloc\+\_\+, Args \&\&... args)
\item 
\mbox{\Hypertarget{namespacecl_a463d82a565cebe025e902361a13af520}\label{namespacecl_a463d82a565cebe025e902361a13af520}} 
{\footnotesize template$<$class T , class SVMTrait , class... Args$>$ }\\cl\+::pointer$<$ T, \mbox{\hyperlink{classcl_1_1detail_1_1_deleter}{detail\+::\+Deleter}}$<$ \mbox{\hyperlink{classcl_1_1_s_v_m_allocator}{SVMAllocator}}$<$ T, SVMTrait $>$ $>$ $>$ {\bfseries allocate\+\_\+svm} (Args... args)
\item 
\mbox{\Hypertarget{namespacecl_ac0e80b24a5f43f2cbad2428f17e195d0}\label{namespacecl_ac0e80b24a5f43f2cbad2428f17e195d0}} 
{\footnotesize template$<$class T , class SVMTrait , class... Args$>$ }\\cl\+::pointer$<$ T, \mbox{\hyperlink{classcl_1_1detail_1_1_deleter}{detail\+::\+Deleter}}$<$ \mbox{\hyperlink{classcl_1_1_s_v_m_allocator}{SVMAllocator}}$<$ T, SVMTrait $>$ $>$ $>$ {\bfseries allocate\+\_\+svm} (const \mbox{\hyperlink{classcl_1_1_context}{cl\+::\+Context}} \&c, Args... args)
\item 
\mbox{\hyperlink{structcl_1_1_local_space_arg}{Local\+Space\+Arg}} \mbox{\hyperlink{namespacecl_a2f9d06d8196d7a2f4cf196d5bb7e5dd0}{Local}} (\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} size)
\begin{DoxyCompactList}\small\item\em Helper function for generating \mbox{\hyperlink{structcl_1_1_local_space_arg}{Local\+Space\+Arg}} objects. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacecl_afe680d09fa4ee6c58f6829179cf4dfd7}\label{namespacecl_afe680d09fa4ee6c58f6829179cf4dfd7}} 
\mbox{\hyperlink{classcl_1_1_program}{Program}} {\bfseries link\+Program} (\mbox{\hyperlink{classcl_1_1_program}{Program}} input1, \mbox{\hyperlink{classcl_1_1_program}{Program}} input2, const char $\ast$options=NULL, void(CL\+\_\+\+CALLBACK $\ast$notify\+Fptr)(cl\+\_\+program, void $\ast$)=NULL, void $\ast$data=NULL, cl\+\_\+int $\ast$err=NULL)
\item 
\mbox{\Hypertarget{namespacecl_a9e9c0fe106eba01e2955aca99ca9ef74}\label{namespacecl_a9e9c0fe106eba01e2955aca99ca9ef74}} 
\mbox{\hyperlink{classcl_1_1_program}{Program}} {\bfseries link\+Program} (vector$<$ \mbox{\hyperlink{classcl_1_1_program}{Program}} $>$ input\+Programs, const char $\ast$options=NULL, void(CL\+\_\+\+CALLBACK $\ast$notify\+Fptr)(cl\+\_\+program, void $\ast$)=NULL, void $\ast$data=NULL, cl\+\_\+int $\ast$err=NULL)
\item 
\mbox{\Hypertarget{namespacecl_a8cf7512fbd326bde84ecfaf1aa9500d0}\label{namespacecl_a8cf7512fbd326bde84ecfaf1aa9500d0}} 
Queue\+Properties {\bfseries operator$\vert$} (Queue\+Properties lhs, Queue\+Properties rhs)
\item 
\mbox{\Hypertarget{namespacecl_a26fae57f73cf3e22afddc2d00eaffbef}\label{namespacecl_a26fae57f73cf3e22afddc2d00eaffbef}} 
Device\+Queue\+Properties {\bfseries operator$\vert$} (Device\+Queue\+Properties lhs, Device\+Queue\+Properties rhs)
\item 
\mbox{\Hypertarget{namespacecl_a2f62d7a5c92ad30e9343983a77915a8f}\label{namespacecl_a2f62d7a5c92ad30e9343983a77915a8f}} 
cl\+\_\+int {\bfseries enqueue\+Read\+Buffer} (const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&buffer, cl\+\_\+bool blocking, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} offset, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} size, void $\ast$ptr, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_af6744ad8849f9e3a26d85fdd7dde5b4a}\label{namespacecl_af6744ad8849f9e3a26d85fdd7dde5b4a}} 
cl\+\_\+int {\bfseries enqueue\+Write\+Buffer} (const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&buffer, cl\+\_\+bool blocking, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} offset, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} size, const void $\ast$ptr, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_aec6eb2d8dcca208fc9e730e2ae2eea07}\label{namespacecl_aec6eb2d8dcca208fc9e730e2ae2eea07}} 
void $\ast$ {\bfseries enqueue\+Map\+Buffer} (const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&buffer, cl\+\_\+bool blocking, cl\+\_\+map\+\_\+flags flags, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} offset, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} size, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL, cl\+\_\+int $\ast$err=NULL)
\item 
{\footnotesize template$<$typename T , class D $>$ }\\cl\+\_\+int \mbox{\hyperlink{namespacecl_a7aa80934f265ff5c97b715419aa38566}{enqueue\+Map\+SVM}} (cl\+::pointer$<$ T, D $>$ ptr, cl\+\_\+bool blocking, cl\+\_\+map\+\_\+flags flags, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} size, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
{\footnotesize template$<$typename T , class Alloc $>$ }\\cl\+\_\+int \mbox{\hyperlink{namespacecl_a8037dc6274012b061edabe1550a2c0ee}{enqueue\+Map\+SVM}} (cl\+::vector$<$ T, Alloc $>$ container, cl\+\_\+bool blocking, cl\+\_\+map\+\_\+flags flags, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_ac71dfebe7bdaba6a9dfc76b57e48804f}\label{namespacecl_ac71dfebe7bdaba6a9dfc76b57e48804f}} 
cl\+\_\+int {\bfseries enqueue\+Unmap\+Mem\+Object} (const \mbox{\hyperlink{classcl_1_1_memory}{Memory}} \&memory, void $\ast$mapped\+\_\+ptr, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
{\footnotesize template$<$typename T $>$ }\\cl\+\_\+int \mbox{\hyperlink{namespacecl_a45d896e5d437b505648b399dbe1c3cac}{enqueue\+Unmap\+SVM}} (T $\ast$ptr, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
{\footnotesize template$<$typename T , class D $>$ }\\cl\+\_\+int \mbox{\hyperlink{namespacecl_aa1c4d75a33c1d658ca4abae23376f733}{enqueue\+Unmap\+SVM}} (cl\+::pointer$<$ T, D $>$ \&ptr, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
{\footnotesize template$<$typename T , class Alloc $>$ }\\cl\+\_\+int \mbox{\hyperlink{namespacecl_a5c0670097b79b7f6fd2762bae83328f4}{enqueue\+Unmap\+SVM}} (cl\+::vector$<$ T, Alloc $>$ \&container, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_adc1277d56ee9510bdc9e4552ccfd6c93}\label{namespacecl_adc1277d56ee9510bdc9e4552ccfd6c93}} 
cl\+\_\+int {\bfseries enqueue\+Copy\+Buffer} (const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&src, const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&dst, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} src\+\_\+offset, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} dst\+\_\+offset, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} size, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
{\footnotesize template$<$typename T , class Alloc $>$ }\\cl\+\_\+int \mbox{\hyperlink{namespacecl_ae97dc5bb86e2c3c3935280a86cda301c}{map\+SVM}} (cl\+::vector$<$ T, Alloc $>$ \&container)
\item 
{\footnotesize template$<$typename T , class Alloc $>$ }\\cl\+\_\+int \mbox{\hyperlink{namespacecl_af9f49b386b20c55c04a9e6cd21849fd5}{unmap\+SVM}} (cl\+::vector$<$ T, Alloc $>$ \&container)
\item 
\mbox{\Hypertarget{namespacecl_af05e92b70071d8b6869080ae02ac807d}\label{namespacecl_af05e92b70071d8b6869080ae02ac807d}} 
cl\+\_\+int {\bfseries enqueue\+Read\+Buffer\+Rect} (const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&buffer, cl\+\_\+bool blocking, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&buffer\+\_\+offset, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&host\+\_\+offset, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&region, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} buffer\+\_\+row\+\_\+pitch, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} buffer\+\_\+slice\+\_\+pitch, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} host\+\_\+row\+\_\+pitch, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} host\+\_\+slice\+\_\+pitch, void $\ast$ptr, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_aca10d37fe92b6ee56b9b277f18064db9}\label{namespacecl_aca10d37fe92b6ee56b9b277f18064db9}} 
cl\+\_\+int {\bfseries enqueue\+Write\+Buffer\+Rect} (const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&buffer, cl\+\_\+bool blocking, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&buffer\+\_\+offset, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&host\+\_\+offset, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&region, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} buffer\+\_\+row\+\_\+pitch, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} buffer\+\_\+slice\+\_\+pitch, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} host\+\_\+row\+\_\+pitch, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} host\+\_\+slice\+\_\+pitch, const void $\ast$ptr, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_aac389b8df07a4ed9809413eae7f7689e}\label{namespacecl_aac389b8df07a4ed9809413eae7f7689e}} 
cl\+\_\+int {\bfseries enqueue\+Copy\+Buffer\+Rect} (const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&src, const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&dst, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&src\+\_\+origin, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&dst\+\_\+origin, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&region, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} src\+\_\+row\+\_\+pitch, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} src\+\_\+slice\+\_\+pitch, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} dst\+\_\+row\+\_\+pitch, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} dst\+\_\+slice\+\_\+pitch, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_aca98dae2e67f001b26a37d60ccc8fd79}\label{namespacecl_aca98dae2e67f001b26a37d60ccc8fd79}} 
cl\+\_\+int {\bfseries enqueue\+Read\+Image} (const \mbox{\hyperlink{classcl_1_1_image}{Image}} \&image, cl\+\_\+bool blocking, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&origin, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&region, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} row\+\_\+pitch, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} slice\+\_\+pitch, void $\ast$ptr, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_ac7b430ef533bd2f3d89092172a39eb9a}\label{namespacecl_ac7b430ef533bd2f3d89092172a39eb9a}} 
cl\+\_\+int {\bfseries enqueue\+Write\+Image} (const \mbox{\hyperlink{classcl_1_1_image}{Image}} \&image, cl\+\_\+bool blocking, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&origin, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&region, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} row\+\_\+pitch, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} slice\+\_\+pitch, const void $\ast$ptr, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_a30c5c9c18b1773b185a8cdbca81955e0}\label{namespacecl_a30c5c9c18b1773b185a8cdbca81955e0}} 
cl\+\_\+int {\bfseries enqueue\+Copy\+Image} (const \mbox{\hyperlink{classcl_1_1_image}{Image}} \&src, const \mbox{\hyperlink{classcl_1_1_image}{Image}} \&dst, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&src\+\_\+origin, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&dst\+\_\+origin, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&region, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_af5bf3de7bf64abe6c5d0a05fadb121b1}\label{namespacecl_af5bf3de7bf64abe6c5d0a05fadb121b1}} 
cl\+\_\+int {\bfseries enqueue\+Copy\+Image\+To\+Buffer} (const \mbox{\hyperlink{classcl_1_1_image}{Image}} \&src, const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&dst, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&src\+\_\+origin, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&region, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} dst\+\_\+offset, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\item 
\mbox{\Hypertarget{namespacecl_a781572813b27377d2b72155d3b700160}\label{namespacecl_a781572813b27377d2b72155d3b700160}} 
cl\+\_\+int {\bfseries enqueue\+Copy\+Buffer\+To\+Image} (const \mbox{\hyperlink{classcl_1_1_buffer}{Buffer}} \&src, const \mbox{\hyperlink{classcl_1_1_image}{Image}} \&dst, \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}} src\+\_\+offset, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&dst\+\_\+origin, const array$<$ \mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}, 3 $>$ \&region, const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$events=NULL, \mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$event=NULL)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The Open\+CL C++ bindings are defined within this namespace. 

\doxysubsection{Typedef Documentation}
\mbox{\Hypertarget{namespacecl_ad3ff55c5fe80ec84842876af323559c7}\label{namespacecl_ad3ff55c5fe80ec84842876af323559c7}} 
\index{cl@{cl}!STRING\_CLASS@{STRING\_CLASS}}
\index{STRING\_CLASS@{STRING\_CLASS}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{STRING\_CLASS}{STRING\_CLASS}}
{\footnotesize\ttfamily typedef std\+::string \mbox{\hyperlink{namespacecl_ad3ff55c5fe80ec84842876af323559c7}{cl\+::\+STRING\+\_\+\+CLASS}}}

CL 1.\+2 marker and barrier commands 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacecl_a8c0bd8b2f6874ca5a62e2f25e5116c64}\label{namespacecl_a8c0bd8b2f6874ca5a62e2f25e5116c64}} 
\index{cl@{cl}!\_\_local@{\_\_local}}
\index{\_\_local@{\_\_local}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{\_\_local()}{\_\_local()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structcl_1_1_local_space_arg}{Local\+Space\+Arg}} cl\+::\+\_\+\+\_\+local (\begin{DoxyParamCaption}\item[{\+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Helper function for generating \mbox{\hyperlink{structcl_1_1_local_space_arg}{Local\+Space\+Arg}} objects. Deprecated. Replaced with Local. 

\+\_\+\+\_\+local \mbox{\Hypertarget{namespacecl_a8e1fce10cd1b8118f51aa91ce0a589e5}\label{namespacecl_a8e1fce10cd1b8118f51aa91ce0a589e5}} 
\index{cl@{cl}!allocate\_pointer@{allocate\_pointer}}
\index{allocate\_pointer@{allocate\_pointer}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{allocate\_pointer()}{allocate\_pointer()}}
{\footnotesize\ttfamily template$<$class T , class Alloc , class... Args$>$ \\
cl\+::pointer$<$ T, \mbox{\hyperlink{classcl_1_1detail_1_1_deleter}{detail\+::\+Deleter}}$<$ Alloc $>$ $>$ cl\+::allocate\+\_\+pointer (\begin{DoxyParamCaption}\item[{const Alloc \&}]{alloc\+\_\+,  }\item[{Args \&\&...}]{args }\end{DoxyParamCaption})}

Allocation operation compatible with std\+::allocate\+\_\+ptr. Creates a unique\+\_\+ptr$<$\+T$>$ by default. This requirement is to ensure that the control block is not allocated in memory inaccessible to the host. \mbox{\Hypertarget{namespacecl_a05791e9d5da23b21abd6e319fb262c9f}\label{namespacecl_a05791e9d5da23b21abd6e319fb262c9f}} 
\index{cl@{cl}!copy@{copy}}
\index{copy@{copy}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{copy()}{copy()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename Iterator\+Type $>$ \\
cl\+\_\+int cl\+::copy (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classcl_1_1_buffer}{cl\+::\+Buffer}} \&}]{buffer,  }\item[{Iterator\+Type}]{start\+Iterator,  }\item[{Iterator\+Type}]{end\+Iterator }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Blocking copy operation between iterators and a buffer. \mbox{\hyperlink{classcl_1_1_device}{Device}} to Host. Uses default command queue. \mbox{\Hypertarget{namespacecl_a02c4368c6ce7a1a99132eafd5dc96fa9}\label{namespacecl_a02c4368c6ce7a1a99132eafd5dc96fa9}} 
\index{cl@{cl}!copy@{copy}}
\index{copy@{copy}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{copy()}{copy()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Iterator\+Type $>$ \\
cl\+\_\+int cl\+::copy (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classcl_1_1_command_queue}{Command\+Queue}} \&}]{queue,  }\item[{const \mbox{\hyperlink{classcl_1_1_buffer}{cl\+::\+Buffer}} \&}]{buffer,  }\item[{Iterator\+Type}]{start\+Iterator,  }\item[{Iterator\+Type}]{end\+Iterator }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Blocking copy operation between iterators and a buffer. \mbox{\hyperlink{classcl_1_1_device}{Device}} to Host. Uses specified queue. \mbox{\Hypertarget{namespacecl_a2f71ed9a316daf59c03c0f3ba62f1bd3}\label{namespacecl_a2f71ed9a316daf59c03c0f3ba62f1bd3}} 
\index{cl@{cl}!copy@{copy}}
\index{copy@{copy}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{copy()}{copy()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Iterator\+Type $>$ \\
cl\+\_\+int cl\+::copy (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classcl_1_1_command_queue}{Command\+Queue}} \&}]{queue,  }\item[{Iterator\+Type}]{start\+Iterator,  }\item[{Iterator\+Type}]{end\+Iterator,  }\item[{\mbox{\hyperlink{classcl_1_1_buffer}{cl\+::\+Buffer}} \&}]{buffer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Blocking copy operation between iterators and a buffer. Host to \mbox{\hyperlink{classcl_1_1_device}{Device}}. Uses specified queue. \mbox{\Hypertarget{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}\label{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}} 
\index{cl@{cl}!copy@{copy}}
\index{copy@{copy}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{copy()}{copy()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Iterator\+Type $>$ \\
cl\+\_\+int cl\+::copy (\begin{DoxyParamCaption}\item[{Iterator\+Type}]{start\+Iterator,  }\item[{Iterator\+Type}]{end\+Iterator,  }\item[{\mbox{\hyperlink{classcl_1_1_buffer}{cl\+::\+Buffer}} \&}]{buffer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Blocking copy operation between iterators and a buffer. Host to \mbox{\hyperlink{classcl_1_1_device}{Device}}. Uses default command queue. \mbox{\Hypertarget{namespacecl_a7aa80934f265ff5c97b715419aa38566}\label{namespacecl_a7aa80934f265ff5c97b715419aa38566}} 
\index{cl@{cl}!enqueueMapSVM@{enqueueMapSVM}}
\index{enqueueMapSVM@{enqueueMapSVM}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{enqueueMapSVM()}{enqueueMapSVM()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T , class D $>$ \\
cl\+\_\+int cl\+::enqueue\+Map\+SVM (\begin{DoxyParamCaption}\item[{cl\+::pointer$<$ T, D $>$}]{ptr,  }\item[{cl\+\_\+bool}]{blocking,  }\item[{cl\+\_\+map\+\_\+flags}]{flags,  }\item[{\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}}]{size,  }\item[{const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$}]{events = {\ttfamily NULL},  }\item[{\mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$}]{event = {\ttfamily NULL} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Enqueues to the default queue a command that will allow the host to update a region of a coarse-\/grained SVM buffer. This variant takes a cl\+::pointer instance. \mbox{\Hypertarget{namespacecl_a8037dc6274012b061edabe1550a2c0ee}\label{namespacecl_a8037dc6274012b061edabe1550a2c0ee}} 
\index{cl@{cl}!enqueueMapSVM@{enqueueMapSVM}}
\index{enqueueMapSVM@{enqueueMapSVM}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{enqueueMapSVM()}{enqueueMapSVM()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , class Alloc $>$ \\
cl\+\_\+int cl\+::enqueue\+Map\+SVM (\begin{DoxyParamCaption}\item[{cl\+::vector$<$ T, Alloc $>$}]{container,  }\item[{cl\+\_\+bool}]{blocking,  }\item[{cl\+\_\+map\+\_\+flags}]{flags,  }\item[{const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$}]{events = {\ttfamily NULL},  }\item[{\mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$}]{event = {\ttfamily NULL} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Enqueues to the default queue a command that will allow the host to update a region of a coarse-\/grained SVM buffer. This variant takes a cl\+::vector instance. \mbox{\Hypertarget{namespacecl_abb2c4e45814ea569a27c39d37471b2a4}\label{namespacecl_abb2c4e45814ea569a27c39d37471b2a4}} 
\index{cl@{cl}!enqueueMapSVM@{enqueueMapSVM}}
\index{enqueueMapSVM@{enqueueMapSVM}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{enqueueMapSVM()}{enqueueMapSVM()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
cl\+\_\+int cl\+::enqueue\+Map\+SVM (\begin{DoxyParamCaption}\item[{T $\ast$}]{ptr,  }\item[{cl\+\_\+bool}]{blocking,  }\item[{cl\+\_\+map\+\_\+flags}]{flags,  }\item[{\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}}]{size,  }\item[{const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$}]{events,  }\item[{\mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$}]{event }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Enqueues to the default queue a command that will allow the host to update a region of a coarse-\/grained SVM buffer. This variant takes a raw SVM pointer. \mbox{\Hypertarget{namespacecl_aa1c4d75a33c1d658ca4abae23376f733}\label{namespacecl_aa1c4d75a33c1d658ca4abae23376f733}} 
\index{cl@{cl}!enqueueUnmapSVM@{enqueueUnmapSVM}}
\index{enqueueUnmapSVM@{enqueueUnmapSVM}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{enqueueUnmapSVM()}{enqueueUnmapSVM()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T , class D $>$ \\
cl\+\_\+int cl\+::enqueue\+Unmap\+SVM (\begin{DoxyParamCaption}\item[{cl\+::pointer$<$ T, D $>$ \&}]{ptr,  }\item[{const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$}]{events = {\ttfamily NULL},  }\item[{\mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$}]{event = {\ttfamily NULL} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Enqueues to the default queue a command that will release a coarse-\/grained SVM buffer back to the Open\+CL runtime. This variant takes a cl\+::pointer instance. \mbox{\Hypertarget{namespacecl_a5c0670097b79b7f6fd2762bae83328f4}\label{namespacecl_a5c0670097b79b7f6fd2762bae83328f4}} 
\index{cl@{cl}!enqueueUnmapSVM@{enqueueUnmapSVM}}
\index{enqueueUnmapSVM@{enqueueUnmapSVM}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{enqueueUnmapSVM()}{enqueueUnmapSVM()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , class Alloc $>$ \\
cl\+\_\+int cl\+::enqueue\+Unmap\+SVM (\begin{DoxyParamCaption}\item[{cl\+::vector$<$ T, Alloc $>$ \&}]{container,  }\item[{const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$}]{events = {\ttfamily NULL},  }\item[{\mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$}]{event = {\ttfamily NULL} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Enqueues to the default queue a command that will release a coarse-\/grained SVM buffer back to the Open\+CL runtime. This variant takes a cl\+::vector instance. \mbox{\Hypertarget{namespacecl_a45d896e5d437b505648b399dbe1c3cac}\label{namespacecl_a45d896e5d437b505648b399dbe1c3cac}} 
\index{cl@{cl}!enqueueUnmapSVM@{enqueueUnmapSVM}}
\index{enqueueUnmapSVM@{enqueueUnmapSVM}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{enqueueUnmapSVM()}{enqueueUnmapSVM()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
cl\+\_\+int cl\+::enqueue\+Unmap\+SVM (\begin{DoxyParamCaption}\item[{T $\ast$}]{ptr,  }\item[{const vector$<$ \mbox{\hyperlink{classcl_1_1_event}{Event}} $>$ $\ast$}]{events = {\ttfamily NULL},  }\item[{\mbox{\hyperlink{classcl_1_1_event}{Event}} $\ast$}]{event = {\ttfamily NULL} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Enqueues to the default queue a command that will release a coarse-\/grained SVM buffer back to the Open\+CL runtime. This variant takes a raw SVM pointer. \mbox{\Hypertarget{namespacecl_a861d36f255ea512d3aba2c40ce952e44}\label{namespacecl_a861d36f255ea512d3aba2c40ce952e44}} 
\index{cl@{cl}!Local@{Local}}
\index{Local@{Local}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{Local()}{Local()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{structcl_1_1_local_space_arg}{Local\+Space\+Arg}} cl\+::\+Local (\begin{DoxyParamCaption}\item[{\+::\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+t}}}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Helper function for generating \mbox{\hyperlink{structcl_1_1_local_space_arg}{Local\+Space\+Arg}} objects. 

Local \mbox{\Hypertarget{namespacecl_a2f9d06d8196d7a2f4cf196d5bb7e5dd0}\label{namespacecl_a2f9d06d8196d7a2f4cf196d5bb7e5dd0}} 
\index{cl@{cl}!Local@{Local}}
\index{Local@{Local}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{Local()}{Local()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{structcl_1_1_local_space_arg}{Local\+Space\+Arg}} cl\+::\+Local (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcl_1_1size__t}{size\+\_\+type}}}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Helper function for generating \mbox{\hyperlink{structcl_1_1_local_space_arg}{Local\+Space\+Arg}} objects. 

Local \mbox{\Hypertarget{namespacecl_ae97dc5bb86e2c3c3935280a86cda301c}\label{namespacecl_ae97dc5bb86e2c3c3935280a86cda301c}} 
\index{cl@{cl}!mapSVM@{mapSVM}}
\index{mapSVM@{mapSVM}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{mapSVM()}{mapSVM()}}
{\footnotesize\ttfamily template$<$typename T , class Alloc $>$ \\
cl\+\_\+int cl\+::map\+SVM (\begin{DoxyParamCaption}\item[{cl\+::vector$<$ T, Alloc $>$ \&}]{container }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Blocking SVM map operation -\/ performs a blocking map underneath. \mbox{\Hypertarget{namespacecl_af9f49b386b20c55c04a9e6cd21849fd5}\label{namespacecl_af9f49b386b20c55c04a9e6cd21849fd5}} 
\index{cl@{cl}!unmapSVM@{unmapSVM}}
\index{unmapSVM@{unmapSVM}!cl@{cl}}
\doxysubsubsection{\texorpdfstring{unmapSVM()}{unmapSVM()}}
{\footnotesize\ttfamily template$<$typename T , class Alloc $>$ \\
cl\+\_\+int cl\+::unmap\+SVM (\begin{DoxyParamCaption}\item[{cl\+::vector$<$ T, Alloc $>$ \&}]{container }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Blocking SVM map operation -\/ performs a blocking map underneath. 