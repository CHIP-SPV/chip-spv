\hypertarget{printf_8h_source}{}\doxysection{printf.\+h}
\label{printf_8h_source}\index{/Users/pvelesko/local/CHIP-\/SPV/spdlog/fmt/bundled/printf.h@{/Users/pvelesko/local/CHIP-\/SPV/spdlog/fmt/bundled/printf.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Formatting library for C++}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{// Copyright (c) 2012 -\/ 2016, Victor Zverovich}}
\DoxyCodeLine{4 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// For the license information refer to format.h.}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 \textcolor{preprocessor}{\#ifndef FMT\_PRINTF\_H\_}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#define FMT\_PRINTF\_H\_}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <algorithm>}  \textcolor{comment}{// std::fill\_n}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <limits>}     \textcolor{comment}{// std::numeric\_limits}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include "{}ostream.h"{}}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{17 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 \textcolor{comment}{// Checks if a value fits in int -\/ used to avoid warnings about comparing}}
\DoxyCodeLine{20 \textcolor{comment}{// signed and unsigned integers.}}
\DoxyCodeLine{21 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} IsSigned>}
\DoxyCodeLine{22 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1int__checker}{int\_checker}} \{}
\DoxyCodeLine{23   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{24   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} fits\_in\_int(T \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{25     \textcolor{keywordtype}{unsigned} max = std::numeric\_limits<int>::max();}
\DoxyCodeLine{26     \textcolor{keywordflow}{return} \mbox{\hyperlink{classinternal_1_1value}{value}} <= max;}
\DoxyCodeLine{27   \}}
\DoxyCodeLine{28   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} fits\_in\_int(\textcolor{keywordtype}{bool}) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{29 \};}
\DoxyCodeLine{30 }
\DoxyCodeLine{31 \textcolor{keyword}{template} <>}
\DoxyCodeLine{32 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1int__checker}{int\_checker}}<true> \{}
\DoxyCodeLine{33   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{34   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} fits\_in\_int(T \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{35     \textcolor{keywordflow}{return} \mbox{\hyperlink{classinternal_1_1value}{value}} >= std::numeric\_limits<int>::min() \&\&}
\DoxyCodeLine{36            \mbox{\hyperlink{classinternal_1_1value}{value <= std::numeric\_limits<int>::max}}();}
\DoxyCodeLine{37   \}}
\DoxyCodeLine{38   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} fits\_in\_int(\textcolor{keywordtype}{int}) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{39 \};}
\DoxyCodeLine{40 }
\DoxyCodeLine{41 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1printf__precision__handler}{printf\_precision\_handler}}: \textcolor{keyword}{public} \mbox{\hyperlink{structinternal_1_1function}{function}}<int> \{}
\DoxyCodeLine{42  \textcolor{keyword}{public}:}
\DoxyCodeLine{43   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{44   \textcolor{keyword}{typename} std::enable\_if<std::is\_integral<T>::value, \textcolor{keywordtype}{int}>::type}
\DoxyCodeLine{45       operator()(T \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{46     \textcolor{keywordflow}{if} (!\mbox{\hyperlink{structinternal_1_1int__checker}{int\_checker}}<std::numeric\_limits<T>::is\_signed>::fits\_in\_int(\mbox{\hyperlink{classinternal_1_1value}{value}}))}
\DoxyCodeLine{47       FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}number is too big"{}}));}
\DoxyCodeLine{48     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{49   \}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{52   \textcolor{keyword}{typename} std::enable\_if<!std::is\_integral<T>::value, \textcolor{keywordtype}{int}>::type operator()(T) \{}
\DoxyCodeLine{53     FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}precision is not integer"{}}));}
\DoxyCodeLine{54     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{55   \}}
\DoxyCodeLine{56 \};}
\DoxyCodeLine{57 }
\DoxyCodeLine{58 \textcolor{comment}{// An argument visitor that returns true iff arg is a zero integer.}}
\DoxyCodeLine{59 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1is__zero__int}{is\_zero\_int}}: \textcolor{keyword}{public} \mbox{\hyperlink{structinternal_1_1function}{function}}<bool> \{}
\DoxyCodeLine{60  \textcolor{keyword}{public}:}
\DoxyCodeLine{61   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{62   \textcolor{keyword}{typename} std::enable\_if<std::is\_integral<T>::value, \textcolor{keywordtype}{bool}>::type}
\DoxyCodeLine{63       operator()(T \mbox{\hyperlink{classinternal_1_1value}{value}}) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classinternal_1_1value}{value}} == 0; \}}
\DoxyCodeLine{64 }
\DoxyCodeLine{65   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{66   \textcolor{keyword}{typename} std::enable\_if<!std::is\_integral<T>::value, \textcolor{keywordtype}{bool}>::type}
\DoxyCodeLine{67       operator()(T) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{68 \};}
\DoxyCodeLine{69 }
\DoxyCodeLine{70 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{71 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1make__unsigned__or__bool}{make\_unsigned\_or\_bool}} : std::make\_unsigned<T> \{\};}
\DoxyCodeLine{72 }
\DoxyCodeLine{73 \textcolor{keyword}{template} <>}
\DoxyCodeLine{74 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1make__unsigned__or__bool}{make\_unsigned\_or\_bool}}<bool> \{}
\DoxyCodeLine{75   \textcolor{keyword}{typedef} \textcolor{keywordtype}{bool} type;}
\DoxyCodeLine{76 \};}
\DoxyCodeLine{77 }
\DoxyCodeLine{78 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{79 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1arg__converter}{arg\_converter}}: \textcolor{keyword}{public} \mbox{\hyperlink{structinternal_1_1function}{function}}<void> \{}
\DoxyCodeLine{80  \textcolor{keyword}{private}:}
\DoxyCodeLine{81   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Context::char\_type Char;}
\DoxyCodeLine{82 }
\DoxyCodeLine{83   \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} \&arg\_;}
\DoxyCodeLine{84   \textcolor{keyword}{typename} Context::char\_type type\_;}
\DoxyCodeLine{85 }
\DoxyCodeLine{86  \textcolor{keyword}{public}:}
\DoxyCodeLine{87   \mbox{\hyperlink{classinternal_1_1arg__converter}{arg\_converter}}(\mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} \&arg, Char type)}
\DoxyCodeLine{88     : arg\_(arg), type\_(type) \{\}}
\DoxyCodeLine{89 }
\DoxyCodeLine{90   \textcolor{keywordtype}{void} operator()(\textcolor{keywordtype}{bool} \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{91     \textcolor{keywordflow}{if} (type\_ != \textcolor{charliteral}{'s'})}
\DoxyCodeLine{92       operator()<\textcolor{keywordtype}{bool}>(\mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{93   \}}
\DoxyCodeLine{94 }
\DoxyCodeLine{95   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{96   \textcolor{keyword}{typename} std::enable\_if<std::is\_integral<U>::value>::type}
\DoxyCodeLine{97       operator()(U \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{98     \textcolor{keywordtype}{bool} is\_signed = type\_ == \textcolor{charliteral}{'d'} || type\_ == \textcolor{charliteral}{'i'};}
\DoxyCodeLine{99     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::conditional<}
\DoxyCodeLine{100         std::is\_same<T, void>::value, U, T>::type TargetType;}
\DoxyCodeLine{101     \textcolor{keywordflow}{if} (const\_check(\textcolor{keyword}{sizeof}(TargetType) <= \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}))) \{}
\DoxyCodeLine{102       \textcolor{comment}{// Extra casts are used to silence warnings.}}
\DoxyCodeLine{103       \textcolor{keywordflow}{if} (is\_signed) \{}
\DoxyCodeLine{104         arg\_ = internal::make\_arg<Context>(}
\DoxyCodeLine{105           \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}TargetType\textcolor{keyword}{>}(\mbox{\hyperlink{classinternal_1_1value}{value}})));}
\DoxyCodeLine{106       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{107         \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structinternal_1_1make__unsigned__or__bool}{make\_unsigned\_or\_bool<TargetType>::type}} Unsigned;}
\DoxyCodeLine{108         arg\_ = internal::make\_arg<Context>(}
\DoxyCodeLine{109           \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}Unsigned\textcolor{keyword}{>}(\mbox{\hyperlink{classinternal_1_1value}{value}})));}
\DoxyCodeLine{110       \}}
\DoxyCodeLine{111     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{112       \textcolor{keywordflow}{if} (is\_signed) \{}
\DoxyCodeLine{113         \textcolor{comment}{// glibc's printf doesn't sign extend arguments of smaller types:}}
\DoxyCodeLine{114         \textcolor{comment}{//   std::printf("{}\%lld"{}, -\/42);  // prints "{}4294967254"{}}}
\DoxyCodeLine{115         \textcolor{comment}{// but we don't have to do the same because it's a UB.}}
\DoxyCodeLine{116         arg\_ = internal::make\_arg<Context>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(\mbox{\hyperlink{classinternal_1_1value}{value}}));}
\DoxyCodeLine{117       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{118         arg\_ = internal::make\_arg<Context>(}
\DoxyCodeLine{119           \textcolor{keyword}{static\_cast<}typename \mbox{\hyperlink{structinternal_1_1make__unsigned__or__bool}{make\_unsigned\_or\_bool<U>::type}}\textcolor{keyword}{>}(\mbox{\hyperlink{classinternal_1_1value}{value}}));}
\DoxyCodeLine{120       \}}
\DoxyCodeLine{121     \}}
\DoxyCodeLine{122   \}}
\DoxyCodeLine{123 }
\DoxyCodeLine{124   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{125   \textcolor{keyword}{typename} std::enable\_if<!std::is\_integral<U>::value>::type operator()(U) \{}
\DoxyCodeLine{126     \textcolor{comment}{// No coversion needed for non-\/integral types.}}
\DoxyCodeLine{127   \}}
\DoxyCodeLine{128 \};}
\DoxyCodeLine{129 }
\DoxyCodeLine{130 \textcolor{comment}{// Converts an integer argument to T for printf, if T is an integral type.}}
\DoxyCodeLine{131 \textcolor{comment}{// If T is void, the argument is converted to corresponding signed or unsigned}}
\DoxyCodeLine{132 \textcolor{comment}{// type depending on the type specifier: 'd' and 'i' -\/ signed, other -\/}}
\DoxyCodeLine{133 \textcolor{comment}{// unsigned).}}
\DoxyCodeLine{134 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{135 \textcolor{keywordtype}{void} convert\_arg(\mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} \&arg, Char type) \{}
\DoxyCodeLine{136   fmt::visit(\mbox{\hyperlink{classinternal_1_1arg__converter}{arg\_converter<T, Context>}}(arg, type), arg);}
\DoxyCodeLine{137 \}}
\DoxyCodeLine{138 }
\DoxyCodeLine{139 \textcolor{comment}{// Converts an integer argument to char for printf.}}
\DoxyCodeLine{140 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{141 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1char__converter}{char\_converter}}: \textcolor{keyword}{public} \mbox{\hyperlink{structinternal_1_1function}{function}}<void> \{}
\DoxyCodeLine{142  \textcolor{keyword}{private}:}
\DoxyCodeLine{143   \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} \&arg\_;}
\DoxyCodeLine{144 }
\DoxyCodeLine{145  \textcolor{keyword}{public}:}
\DoxyCodeLine{146   \textcolor{keyword}{explicit} \mbox{\hyperlink{classinternal_1_1char__converter}{char\_converter}}(\mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} \&arg) : arg\_(arg) \{\}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{149   \textcolor{keyword}{typename} std::enable\_if<std::is\_integral<T>::value>::type}
\DoxyCodeLine{150       operator()(T \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{151     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Context::char\_type Char;}
\DoxyCodeLine{152     arg\_ = internal::make\_arg<Context>(\textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\mbox{\hyperlink{classinternal_1_1value}{value}}));}
\DoxyCodeLine{153   \}}
\DoxyCodeLine{154 }
\DoxyCodeLine{155   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{156   \textcolor{keyword}{typename} std::enable\_if<!std::is\_integral<T>::value>::type operator()(T) \{}
\DoxyCodeLine{157     \textcolor{comment}{// No coversion needed for non-\/integral types.}}
\DoxyCodeLine{158   \}}
\DoxyCodeLine{159 \};}
\DoxyCodeLine{160 }
\DoxyCodeLine{161 \textcolor{comment}{// Checks if an argument is a valid printf width specifier and sets}}
\DoxyCodeLine{162 \textcolor{comment}{// left alignment if it is negative.}}
\DoxyCodeLine{163 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{164 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1printf__width__handler}{printf\_width\_handler}}: \textcolor{keyword}{public} \mbox{\hyperlink{structinternal_1_1function}{function}}<unsigned> \{}
\DoxyCodeLine{165  \textcolor{keyword}{private}:}
\DoxyCodeLine{166   \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__specs}{basic\_format\_specs<Char>}} \mbox{\hyperlink{classbasic__format__specs}{format\_specs}};}
\DoxyCodeLine{167 }
\DoxyCodeLine{168   \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&spec\_;}
\DoxyCodeLine{169 }
\DoxyCodeLine{170  \textcolor{keyword}{public}:}
\DoxyCodeLine{171   \textcolor{keyword}{explicit} \mbox{\hyperlink{classinternal_1_1printf__width__handler}{printf\_width\_handler}}(\mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&spec) : spec\_(spec) \{\}}
\DoxyCodeLine{172 }
\DoxyCodeLine{173   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{174   \textcolor{keyword}{typename} std::enable\_if<std::is\_integral<T>::value, \textcolor{keywordtype}{unsigned}>::type}
\DoxyCodeLine{175       operator()(T \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{176     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structinternal_1_1int__traits}{internal::int\_traits<T>::main\_type}} UnsignedType;}
\DoxyCodeLine{177     UnsignedType width = \textcolor{keyword}{static\_cast<}UnsignedType\textcolor{keyword}{>}(\mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{178     \textcolor{keywordflow}{if} (internal::is\_negative(\mbox{\hyperlink{classinternal_1_1value}{value}})) \{}
\DoxyCodeLine{179       spec\_.align\_ = ALIGN\_LEFT;}
\DoxyCodeLine{180       width = 0 -\/ width;}
\DoxyCodeLine{181     \}}
\DoxyCodeLine{182     \textcolor{keywordtype}{unsigned} int\_max = std::numeric\_limits<int>::max();}
\DoxyCodeLine{183     \textcolor{keywordflow}{if} (width > int\_max)}
\DoxyCodeLine{184       FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}number is too big"{}}));}
\DoxyCodeLine{185     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(width);}
\DoxyCodeLine{186   \}}
\DoxyCodeLine{187 }
\DoxyCodeLine{188   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{189   \textcolor{keyword}{typename} std::enable\_if<!std::is\_integral<T>::value, \textcolor{keywordtype}{unsigned}>::type}
\DoxyCodeLine{190       operator()(T) \{}
\DoxyCodeLine{191     FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}width is not integer"{}}));}
\DoxyCodeLine{192     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{193   \}}
\DoxyCodeLine{194 \};}
\DoxyCodeLine{195 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{196 }
\DoxyCodeLine{197 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{198 \textcolor{keyword}{class }\mbox{\hyperlink{classprintf__arg__formatter}{printf\_arg\_formatter}};}
\DoxyCodeLine{199 }
\DoxyCodeLine{200 \textcolor{keyword}{template} <}
\DoxyCodeLine{201     \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char,}
\DoxyCodeLine{202     \textcolor{keyword}{typename} ArgFormatter =}
\DoxyCodeLine{203       \mbox{\hyperlink{classprintf__arg__formatter}{printf\_arg\_formatter<back\_insert\_range<internal::basic\_buffer<Char>}}>>>}
\DoxyCodeLine{204 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context}};}
\DoxyCodeLine{205 }
\DoxyCodeLine{211 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{212 \textcolor{keyword}{class }\mbox{\hyperlink{classprintf__arg__formatter}{printf\_arg\_formatter}}:}
\DoxyCodeLine{213   \textcolor{keyword}{public} \mbox{\hyperlink{structinternal_1_1function}{internal::function}}<}
\DoxyCodeLine{214     typename internal::arg\_formatter\_base<Range>::iterator>,}
\DoxyCodeLine{215   \textcolor{keyword}{public} \mbox{\hyperlink{classinternal_1_1arg__formatter__base}{internal::arg\_formatter\_base}}<Range> \{}
\DoxyCodeLine{216  \textcolor{keyword}{private}:}
\DoxyCodeLine{217   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Range::value\_type char\_type;}
\DoxyCodeLine{218   \textcolor{keyword}{typedef} \textcolor{keyword}{decltype}(internal::declval<Range>().begin()) iterator;}
\DoxyCodeLine{219   \textcolor{keyword}{typedef} \mbox{\hyperlink{classinternal_1_1arg__formatter__base}{internal::arg\_formatter\_base<Range>}} \mbox{\hyperlink{classinternal_1_1arg__formatter__base}{base}};}
\DoxyCodeLine{220   \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context<iterator, char\_type>}} \mbox{\hyperlink{classbasic__printf__context}{context\_type}};}
\DoxyCodeLine{221 }
\DoxyCodeLine{222   \mbox{\hyperlink{classbasic__printf__context}{context\_type}} \&context\_;}
\DoxyCodeLine{223 }
\DoxyCodeLine{224   \textcolor{keywordtype}{void} write\_null\_pointer(\textcolor{keywordtype}{char}) \{}
\DoxyCodeLine{225     this-\/>spec()-\/>type\_ = 0;}
\DoxyCodeLine{226     this-\/>write(\textcolor{stringliteral}{"{}(nil)"{}});}
\DoxyCodeLine{227   \}}
\DoxyCodeLine{228 }
\DoxyCodeLine{229   \textcolor{keywordtype}{void} write\_null\_pointer(\textcolor{keywordtype}{wchar\_t}) \{}
\DoxyCodeLine{230     this-\/>spec()-\/>type\_ = 0;}
\DoxyCodeLine{231     this-\/>write(L\textcolor{stringliteral}{"{}(nil)"{}});}
\DoxyCodeLine{232   \}}
\DoxyCodeLine{233 }
\DoxyCodeLine{234  \textcolor{keyword}{public}:}
\DoxyCodeLine{235   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__specs}{base::format\_specs}} \mbox{\hyperlink{classbasic__format__specs}{format\_specs}};}
\DoxyCodeLine{236 }
\DoxyCodeLine{244   \mbox{\hyperlink{classprintf__arg__formatter_a776ca166c8295596e9636470e8522f66}{printf\_arg\_formatter}}(\mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::basic\_buffer<char\_type>}} \&buffer,}
\DoxyCodeLine{245                        \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&spec, \mbox{\hyperlink{classbasic__printf__context}{context\_type}} \&ctx)}
\DoxyCodeLine{246     : \mbox{\hyperlink{classinternal_1_1arg__formatter__base}{base}}(\mbox{\hyperlink{classback__insert__range}{back\_insert\_range}}<internal::basic\_buffer<char\_type>>(buffer), \&spec),}
\DoxyCodeLine{247       context\_(ctx) \{\}}
\DoxyCodeLine{248 }
\DoxyCodeLine{249   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{250   \textcolor{keyword}{typename} std::enable\_if<std::is\_integral<T>::value, iterator>::type}
\DoxyCodeLine{251       operator()(T value) \{}
\DoxyCodeLine{252     \textcolor{comment}{// MSVC2013 fails to compile separate overloads for bool and char\_type so}}
\DoxyCodeLine{253     \textcolor{comment}{// use std::is\_same instead.}}
\DoxyCodeLine{254     \textcolor{keywordflow}{if} (std::is\_same<T, bool>::value) \{}
\DoxyCodeLine{255       \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&fmt\_spec = *this-\/>spec();}
\DoxyCodeLine{256       \textcolor{keywordflow}{if} (fmt\_spec.type\_ != \textcolor{charliteral}{'s'})}
\DoxyCodeLine{257         \textcolor{keywordflow}{return} base::operator()(value ? 1 : 0);}
\DoxyCodeLine{258       fmt\_spec.type\_ = 0;}
\DoxyCodeLine{259       this-\/>write(value != 0);}
\DoxyCodeLine{260     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (std::is\_same<T, char\_type>::value) \{}
\DoxyCodeLine{261       \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&fmt\_spec = *this-\/>spec();}
\DoxyCodeLine{262       \textcolor{keywordflow}{if} (fmt\_spec.type\_ \&\& fmt\_spec.type\_ != \textcolor{charliteral}{'c'})}
\DoxyCodeLine{263         \textcolor{keywordflow}{return} (*\textcolor{keyword}{this})(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{264       fmt\_spec.flags\_ = 0;}
\DoxyCodeLine{265       fmt\_spec.align\_ = ALIGN\_RIGHT;}
\DoxyCodeLine{266       \textcolor{keywordflow}{return} base::operator()(value);}
\DoxyCodeLine{267     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{268       \textcolor{keywordflow}{return} base::operator()(value);}
\DoxyCodeLine{269     \}}
\DoxyCodeLine{270     \textcolor{keywordflow}{return} this-\/>out();}
\DoxyCodeLine{271   \}}
\DoxyCodeLine{272 }
\DoxyCodeLine{273   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{274   \textcolor{keyword}{typename} std::enable\_if<std::is\_floating\_point<T>::value, iterator>::type}
\DoxyCodeLine{275       operator()(T value) \{}
\DoxyCodeLine{276     \textcolor{keywordflow}{return} base::operator()(value);}
\DoxyCodeLine{277   \}}
\DoxyCodeLine{278 }
\DoxyCodeLine{280   iterator \mbox{\hyperlink{classprintf__arg__formatter_a4e462c5b70ceef75a41261472aa56313}{operator()}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *value) \{}
\DoxyCodeLine{281     \textcolor{keywordflow}{if} (value)}
\DoxyCodeLine{282       base::operator()(value);}
\DoxyCodeLine{283     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this-\/>spec()-\/>type\_ == \textcolor{charliteral}{'p'})}
\DoxyCodeLine{284       write\_null\_pointer(char\_type());}
\DoxyCodeLine{285     \textcolor{keywordflow}{else}}
\DoxyCodeLine{286       this-\/>write(\textcolor{stringliteral}{"{}(null)"{}});}
\DoxyCodeLine{287     \textcolor{keywordflow}{return} this-\/>out();}
\DoxyCodeLine{288   \}}
\DoxyCodeLine{289 }
\DoxyCodeLine{291   iterator \mbox{\hyperlink{classprintf__arg__formatter_a880170cd3e3ace7546cb01268586ac77}{operator()}}(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t} *value) \{}
\DoxyCodeLine{292     \textcolor{keywordflow}{if} (value)}
\DoxyCodeLine{293       base::operator()(value);}
\DoxyCodeLine{294     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this-\/>spec()-\/>type\_ == \textcolor{charliteral}{'p'})}
\DoxyCodeLine{295       write\_null\_pointer(char\_type());}
\DoxyCodeLine{296     \textcolor{keywordflow}{else}}
\DoxyCodeLine{297       this-\/>write(L\textcolor{stringliteral}{"{}(null)"{}});}
\DoxyCodeLine{298     \textcolor{keywordflow}{return} this-\/>out();}
\DoxyCodeLine{299   \}}
\DoxyCodeLine{300 }
\DoxyCodeLine{301   iterator operator()(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} value) \{}
\DoxyCodeLine{302     \textcolor{keywordflow}{return} base::operator()(value);}
\DoxyCodeLine{303   \}}
\DoxyCodeLine{304 }
\DoxyCodeLine{305   iterator operator()(\mbox{\hyperlink{structmonostate}{monostate}} value) \{}
\DoxyCodeLine{306     \textcolor{keywordflow}{return} base::operator()(value);}
\DoxyCodeLine{307   \}}
\DoxyCodeLine{308 }
\DoxyCodeLine{310   iterator \mbox{\hyperlink{classprintf__arg__formatter_a22c7d349112400ecf9a66005b1a0229e}{operator()}}(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *value) \{}
\DoxyCodeLine{311     \textcolor{keywordflow}{if} (value)}
\DoxyCodeLine{312       \textcolor{keywordflow}{return} base::operator()(value);}
\DoxyCodeLine{313     this-\/>spec()-\/>type\_ = 0;}
\DoxyCodeLine{314     write\_null\_pointer(char\_type());}
\DoxyCodeLine{315     \textcolor{keywordflow}{return} this-\/>out();}
\DoxyCodeLine{316   \}}
\DoxyCodeLine{317 }
\DoxyCodeLine{319   iterator \mbox{\hyperlink{classprintf__arg__formatter_a57ded50a248eab9775966e05330dfcb5}{operator()}}(\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__arg_1_1handle}{basic\_format\_arg<context\_type>::handle}} handle) \{}
\DoxyCodeLine{320     handle.format(context\_);}
\DoxyCodeLine{321     \textcolor{keywordflow}{return} this-\/>out();}
\DoxyCodeLine{322   \}}
\DoxyCodeLine{323 \};}
\DoxyCodeLine{324 }
\DoxyCodeLine{325 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{326 \textcolor{keyword}{struct }\mbox{\hyperlink{structprintf__formatter}{printf\_formatter}} \{}
\DoxyCodeLine{327   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{328   \textcolor{keyword}{auto} parse(ParseContext \&ctx) -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{ \textcolor{keywordflow}{return} ctx.begin(); \}}
\DoxyCodeLine{329 }
\DoxyCodeLine{330   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{331   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} T \&value, FormatContext \&ctx) -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{332     internal::format\_value(internal::get\_container(ctx.out()), value);}
\DoxyCodeLine{333     \textcolor{keywordflow}{return} ctx.out();}
\DoxyCodeLine{334   \}}
\DoxyCodeLine{335 \};}
\DoxyCodeLine{336 }
\DoxyCodeLine{338 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} ArgFormatter>}
\DoxyCodeLine{339 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context}} :}
\DoxyCodeLine{340   \textcolor{comment}{// Inherit publicly as a workaround for the icc bug}}
\DoxyCodeLine{341   \textcolor{comment}{// https://software.intel.com/en-\/us/forums/intel-\/c-\/compiler/topic/783476.}}
\DoxyCodeLine{342   \textcolor{keyword}{public} \mbox{\hyperlink{classinternal_1_1context__base}{internal::context\_base}}<}
\DoxyCodeLine{343     OutputIt, basic\_printf\_context<OutputIt, Char, ArgFormatter>, Char> \{}
\DoxyCodeLine{344  \textcolor{keyword}{public}:}
\DoxyCodeLine{346   \textcolor{keyword}{typedef} Char \mbox{\hyperlink{classbasic__printf__context_a7f19ba5dfbcd66a87281c4b05bcf324e}{char\_type}};}
\DoxyCodeLine{347 }
\DoxyCodeLine{348   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{349   \textcolor{keyword}{struct }\mbox{\hyperlink{structbasic__printf__context_1_1formatter__type}{formatter\_type}} \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structprintf__formatter}{printf\_formatter<T>}} \mbox{\hyperlink{structprintf__formatter}{type}}; \};}
\DoxyCodeLine{350 }
\DoxyCodeLine{351  \textcolor{keyword}{private}:}
\DoxyCodeLine{352   \textcolor{keyword}{typedef} \mbox{\hyperlink{classinternal_1_1context__base}{internal::context\_base<OutputIt, basic\_printf\_context, Char>}} \mbox{\hyperlink{classinternal_1_1context__base}{base}};}
\DoxyCodeLine{353   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__arg}{base::format\_arg}} \mbox{\hyperlink{classbasic__format__arg}{format\_arg}};}
\DoxyCodeLine{354   \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__specs}{basic\_format\_specs<char\_type>}} \mbox{\hyperlink{classbasic__format__specs}{format\_specs}};}
\DoxyCodeLine{355   \textcolor{keyword}{typedef} \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{internal::null\_terminating\_iterator<char\_type>}} \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{iterator}};}
\DoxyCodeLine{356 }
\DoxyCodeLine{357   \textcolor{keywordtype}{void} parse\_flags(\mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&spec, \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{iterator}} \&it);}
\DoxyCodeLine{358 }
\DoxyCodeLine{359   \textcolor{comment}{// Returns the argument with specified index or, if arg\_index is equal}}
\DoxyCodeLine{360   \textcolor{comment}{// to the maximum unsigned value, the next argument.}}
\DoxyCodeLine{361   \mbox{\hyperlink{classbasic__format__arg}{format\_arg}} get\_arg(}
\DoxyCodeLine{362       \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{iterator}} it,}
\DoxyCodeLine{363       \textcolor{keywordtype}{unsigned} arg\_index = (std::numeric\_limits<unsigned>::max)());}
\DoxyCodeLine{364 }
\DoxyCodeLine{365   \textcolor{comment}{// Parses argument index, flags and width and returns the argument index.}}
\DoxyCodeLine{366   \textcolor{keywordtype}{unsigned} parse\_header(\mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{iterator}} \&it, \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&spec);}
\DoxyCodeLine{367 }
\DoxyCodeLine{368  \textcolor{keyword}{public}:}
\DoxyCodeLine{376   \mbox{\hyperlink{classbasic__printf__context_ae71967bec500702473ba5b98d4e36aa2}{basic\_printf\_context}}(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} format\_str,}
\DoxyCodeLine{377                        \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<basic\_printf\_context>}} args)}
\DoxyCodeLine{378     : \mbox{\hyperlink{classinternal_1_1context__base}{base}}(out, format\_str, args) \{\}}
\DoxyCodeLine{379 }
\DoxyCodeLine{380   \textcolor{keyword}{using} base::parse\_context;}
\DoxyCodeLine{381   \textcolor{keyword}{using} base::out;}
\DoxyCodeLine{382   \textcolor{keyword}{using} base::advance\_to;}
\DoxyCodeLine{383 }
\DoxyCodeLine{385   \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__printf__context_a1740a3a0a6d2748e4f489fb9b4b9e82c}{format}}();}
\DoxyCodeLine{386 \};}
\DoxyCodeLine{387 }
\DoxyCodeLine{388 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} AF>}
\DoxyCodeLine{389 \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context<OutputIt, Char, AF>::parse\_flags}}(}
\DoxyCodeLine{390     \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&spec, iterator \&it) \{}
\DoxyCodeLine{391   \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{392     \textcolor{keywordflow}{switch} (*it++) \{}
\DoxyCodeLine{393       \textcolor{keywordflow}{case} \textcolor{charliteral}{'-\/'}:}
\DoxyCodeLine{394         spec.align\_ = ALIGN\_LEFT;}
\DoxyCodeLine{395         \textcolor{keywordflow}{break};}
\DoxyCodeLine{396       \textcolor{keywordflow}{case} \textcolor{charliteral}{'+'}:}
\DoxyCodeLine{397         spec.flags\_ |= SIGN\_FLAG | PLUS\_FLAG;}
\DoxyCodeLine{398         \textcolor{keywordflow}{break};}
\DoxyCodeLine{399       \textcolor{keywordflow}{case} \textcolor{charliteral}{'0'}:}
\DoxyCodeLine{400         spec.fill\_ = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{401         \textcolor{keywordflow}{break};}
\DoxyCodeLine{402       \textcolor{keywordflow}{case} \textcolor{charliteral}{' '}:}
\DoxyCodeLine{403         spec.flags\_ |= SIGN\_FLAG;}
\DoxyCodeLine{404         \textcolor{keywordflow}{break};}
\DoxyCodeLine{405       \textcolor{keywordflow}{case} \textcolor{charliteral}{'\#'}:}
\DoxyCodeLine{406         spec.flags\_ |= HASH\_FLAG;}
\DoxyCodeLine{407         \textcolor{keywordflow}{break};}
\DoxyCodeLine{408       \textcolor{keywordflow}{default}:}
\DoxyCodeLine{409         -\/-\/it;}
\DoxyCodeLine{410         \textcolor{keywordflow}{return};}
\DoxyCodeLine{411     \}}
\DoxyCodeLine{412   \}}
\DoxyCodeLine{413 \}}
\DoxyCodeLine{414 }
\DoxyCodeLine{415 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} AF>}
\DoxyCodeLine{416 \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__arg}{basic\_printf\_context<OutputIt, Char, AF>::format\_arg}}}
\DoxyCodeLine{417   \mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context<OutputIt, Char, AF>::get\_arg}}(}
\DoxyCodeLine{418     iterator it, \textcolor{keywordtype}{unsigned} arg\_index) \{}
\DoxyCodeLine{419   (void)it;}
\DoxyCodeLine{420   \textcolor{keywordflow}{if} (arg\_index == std::numeric\_limits<unsigned>::max())}
\DoxyCodeLine{421     \textcolor{keywordflow}{return} this-\/>do\_get\_arg(this-\/>\mbox{\hyperlink{classbasic__parse__context}{parse\_context}}().next\_arg\_id());}
\DoxyCodeLine{422   \textcolor{keywordflow}{return} base::get\_arg(arg\_index -\/ 1);}
\DoxyCodeLine{423 \}}
\DoxyCodeLine{424 }
\DoxyCodeLine{425 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} AF>}
\DoxyCodeLine{426 \textcolor{keywordtype}{unsigned} \mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context<OutputIt, Char, AF>::parse\_header}}(}
\DoxyCodeLine{427   iterator \&it, \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&spec) \{}
\DoxyCodeLine{428   \textcolor{keywordtype}{unsigned} arg\_index = std::numeric\_limits<unsigned>::max();}
\DoxyCodeLine{429   char\_type c = *it;}
\DoxyCodeLine{430   \textcolor{keywordflow}{if} (c >= \textcolor{charliteral}{'0'} \&\& c <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{431     \textcolor{comment}{// Parse an argument index (if followed by '\$') or a width possibly}}
\DoxyCodeLine{432     \textcolor{comment}{// preceded with '0' flag(s).}}
\DoxyCodeLine{433     \mbox{\hyperlink{structinternal_1_1error__handler}{internal::error\_handler}} eh;}
\DoxyCodeLine{434     \textcolor{keywordtype}{unsigned} value = parse\_nonnegative\_int(it, eh);}
\DoxyCodeLine{435     \textcolor{keywordflow}{if} (*it == \textcolor{charliteral}{'\$'}) \{  \textcolor{comment}{// value is an argument index}}
\DoxyCodeLine{436       ++it;}
\DoxyCodeLine{437       arg\_index = value;}
\DoxyCodeLine{438     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{439       \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'0'})}
\DoxyCodeLine{440         spec.fill\_ = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{441       \textcolor{keywordflow}{if} (value != 0) \{}
\DoxyCodeLine{442         \textcolor{comment}{// Nonzero value means that we parsed width and don't need to}}
\DoxyCodeLine{443         \textcolor{comment}{// parse it or flags again, so return now.}}
\DoxyCodeLine{444         spec.width\_ = value;}
\DoxyCodeLine{445         \textcolor{keywordflow}{return} arg\_index;}
\DoxyCodeLine{446       \}}
\DoxyCodeLine{447     \}}
\DoxyCodeLine{448   \}}
\DoxyCodeLine{449   parse\_flags(spec, it);}
\DoxyCodeLine{450   \textcolor{comment}{// Parse width.}}
\DoxyCodeLine{451   \textcolor{keywordflow}{if} (*it >= \textcolor{charliteral}{'0'} \&\& *it <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{452     \mbox{\hyperlink{structinternal_1_1error__handler}{internal::error\_handler}} eh;}
\DoxyCodeLine{453     spec.width\_ = parse\_nonnegative\_int(it, eh);}
\DoxyCodeLine{454   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*it == \textcolor{charliteral}{'*'}) \{}
\DoxyCodeLine{455     ++it;}
\DoxyCodeLine{456     spec.width\_ =}
\DoxyCodeLine{457         fmt::visit(\mbox{\hyperlink{classinternal_1_1printf__width__handler}{internal::printf\_width\_handler<char\_type>}}(spec), get\_arg(it));}
\DoxyCodeLine{458   \}}
\DoxyCodeLine{459   \textcolor{keywordflow}{return} arg\_index;}
\DoxyCodeLine{460 \}}
\DoxyCodeLine{461 }
\DoxyCodeLine{462 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} AF>}
\DoxyCodeLine{463 \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__printf__context_a1740a3a0a6d2748e4f489fb9b4b9e82c}{basic\_printf\_context<OutputIt, Char, AF>::format}}() \{}
\DoxyCodeLine{464   \textcolor{keyword}{auto} \&buffer = internal::get\_container(this-\/>out());}
\DoxyCodeLine{465   \textcolor{keyword}{auto} start = \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{iterator}}(this-\/>\mbox{\hyperlink{classbasic__parse__context}{parse\_context}}());}
\DoxyCodeLine{466   \textcolor{keyword}{auto} it = start;}
\DoxyCodeLine{467   \textcolor{keyword}{using} internal::pointer\_from;}
\DoxyCodeLine{468   \textcolor{keywordflow}{while} (*it) \{}
\DoxyCodeLine{469     \mbox{\hyperlink{classbasic__printf__context_a7f19ba5dfbcd66a87281c4b05bcf324e}{char\_type}} c = *it++;}
\DoxyCodeLine{470     \textcolor{keywordflow}{if} (c != \textcolor{charliteral}{'\%'}) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{471     \textcolor{keywordflow}{if} (*it == c) \{}
\DoxyCodeLine{472       buffer.append(pointer\_from(start), pointer\_from(it));}
\DoxyCodeLine{473       start = ++it;}
\DoxyCodeLine{474       \textcolor{keywordflow}{continue};}
\DoxyCodeLine{475     \}}
\DoxyCodeLine{476     buffer.append(pointer\_from(start), pointer\_from(it) -\/ 1);}
\DoxyCodeLine{477 }
\DoxyCodeLine{478     \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} spec;}
\DoxyCodeLine{479     spec.align\_ = ALIGN\_RIGHT;}
\DoxyCodeLine{480 }
\DoxyCodeLine{481     \textcolor{comment}{// Parse argument index, flags and width.}}
\DoxyCodeLine{482     \textcolor{keywordtype}{unsigned} arg\_index = parse\_header(it, spec);}
\DoxyCodeLine{483 }
\DoxyCodeLine{484     \textcolor{comment}{// Parse precision.}}
\DoxyCodeLine{485     \textcolor{keywordflow}{if} (*it == \textcolor{charliteral}{'.'}) \{}
\DoxyCodeLine{486       ++it;}
\DoxyCodeLine{487       \textcolor{keywordflow}{if} (\textcolor{charliteral}{'0'} <= *it \&\& *it <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{488         \mbox{\hyperlink{structinternal_1_1error__handler}{internal::error\_handler}} eh;}
\DoxyCodeLine{489         spec.precision\_ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(parse\_nonnegative\_int(it, eh));}
\DoxyCodeLine{490       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*it == \textcolor{charliteral}{'*'}) \{}
\DoxyCodeLine{491         ++it;}
\DoxyCodeLine{492         spec.precision\_ =}
\DoxyCodeLine{493             fmt::visit(\mbox{\hyperlink{classinternal_1_1printf__precision__handler}{internal::printf\_precision\_handler}}(), get\_arg(it));}
\DoxyCodeLine{494       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{495         spec.precision\_ = 0;}
\DoxyCodeLine{496       \}}
\DoxyCodeLine{497     \}}
\DoxyCodeLine{498 }
\DoxyCodeLine{499     \mbox{\hyperlink{classbasic__format__arg}{format\_arg}} arg = get\_arg(it, arg\_index);}
\DoxyCodeLine{500     \textcolor{keywordflow}{if} (spec.flag(HASH\_FLAG) \&\& fmt::visit(\mbox{\hyperlink{classinternal_1_1is__zero__int}{internal::is\_zero\_int}}(), arg))}
\DoxyCodeLine{501       spec.flags\_ \&= \string~internal::to\_unsigned<int>(HASH\_FLAG);}
\DoxyCodeLine{502     \textcolor{keywordflow}{if} (spec.fill\_ == \textcolor{charliteral}{'0'}) \{}
\DoxyCodeLine{503       \textcolor{keywordflow}{if} (arg.is\_arithmetic())}
\DoxyCodeLine{504         spec.align\_ = ALIGN\_NUMERIC;}
\DoxyCodeLine{505       \textcolor{keywordflow}{else}}
\DoxyCodeLine{506         spec.fill\_ = \textcolor{charliteral}{' '};  \textcolor{comment}{// Ignore '0' flag for non-\/numeric types.}}
\DoxyCodeLine{507     \}}
\DoxyCodeLine{508 }
\DoxyCodeLine{509     \textcolor{comment}{// Parse length and convert the argument to the required type.}}
\DoxyCodeLine{510     \textcolor{keyword}{using} internal::convert\_arg;}
\DoxyCodeLine{511     \textcolor{keywordflow}{switch} (*it++) \{}
\DoxyCodeLine{512     \textcolor{keywordflow}{case} \textcolor{charliteral}{'h'}:}
\DoxyCodeLine{513       \textcolor{keywordflow}{if} (*it == \textcolor{charliteral}{'h'})}
\DoxyCodeLine{514         convert\_arg<signed char>(arg, *++it);}
\DoxyCodeLine{515       \textcolor{keywordflow}{else}}
\DoxyCodeLine{516         convert\_arg<short>(arg, *it);}
\DoxyCodeLine{517       \textcolor{keywordflow}{break};}
\DoxyCodeLine{518     \textcolor{keywordflow}{case} \textcolor{charliteral}{'l'}:}
\DoxyCodeLine{519       \textcolor{keywordflow}{if} (*it == \textcolor{charliteral}{'l'})}
\DoxyCodeLine{520         convert\_arg<long long>(arg, *++it);}
\DoxyCodeLine{521       \textcolor{keywordflow}{else}}
\DoxyCodeLine{522         convert\_arg<long>(arg, *it);}
\DoxyCodeLine{523       \textcolor{keywordflow}{break};}
\DoxyCodeLine{524     \textcolor{keywordflow}{case} \textcolor{charliteral}{'j'}:}
\DoxyCodeLine{525       convert\_arg<intmax\_t>(arg, *it);}
\DoxyCodeLine{526       \textcolor{keywordflow}{break};}
\DoxyCodeLine{527     \textcolor{keywordflow}{case} \textcolor{charliteral}{'z'}:}
\DoxyCodeLine{528       convert\_arg<std::size\_t>(arg, *it);}
\DoxyCodeLine{529       \textcolor{keywordflow}{break};}
\DoxyCodeLine{530     \textcolor{keywordflow}{case} \textcolor{charliteral}{'t'}:}
\DoxyCodeLine{531       convert\_arg<std::ptrdiff\_t>(arg, *it);}
\DoxyCodeLine{532       \textcolor{keywordflow}{break};}
\DoxyCodeLine{533     \textcolor{keywordflow}{case} \textcolor{charliteral}{'L'}:}
\DoxyCodeLine{534       \textcolor{comment}{// printf produces garbage when 'L' is omitted for long double, no}}
\DoxyCodeLine{535       \textcolor{comment}{// need to do the same.}}
\DoxyCodeLine{536       \textcolor{keywordflow}{break};}
\DoxyCodeLine{537     \textcolor{keywordflow}{default}:}
\DoxyCodeLine{538       -\/-\/it;}
\DoxyCodeLine{539       convert\_arg<void>(arg, *it);}
\DoxyCodeLine{540     \}}
\DoxyCodeLine{541 }
\DoxyCodeLine{542     \textcolor{comment}{// Parse type.}}
\DoxyCodeLine{543     \textcolor{keywordflow}{if} (!*it)}
\DoxyCodeLine{544       FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}invalid format string"{}}));}
\DoxyCodeLine{545     spec.type\_ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(*it++);}
\DoxyCodeLine{546     \textcolor{keywordflow}{if} (arg.is\_integral()) \{}
\DoxyCodeLine{547       \textcolor{comment}{// Normalize type.}}
\DoxyCodeLine{548       \textcolor{keywordflow}{switch} (spec.type\_) \{}
\DoxyCodeLine{549       \textcolor{keywordflow}{case} \textcolor{charliteral}{'i'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'u'}:}
\DoxyCodeLine{550         spec.type\_ = \textcolor{charliteral}{'d'};}
\DoxyCodeLine{551         \textcolor{keywordflow}{break};}
\DoxyCodeLine{552       \textcolor{keywordflow}{case} \textcolor{charliteral}{'c'}:}
\DoxyCodeLine{553         \textcolor{comment}{// TODO: handle wchar\_t better?}}
\DoxyCodeLine{554         fmt::visit(\mbox{\hyperlink{classinternal_1_1char__converter}{internal::char\_converter<basic\_printf\_context>}}(arg), arg);}
\DoxyCodeLine{555         \textcolor{keywordflow}{break};}
\DoxyCodeLine{556       \}}
\DoxyCodeLine{557     \}}
\DoxyCodeLine{558 }
\DoxyCodeLine{559     start = it;}
\DoxyCodeLine{560 }
\DoxyCodeLine{561     \textcolor{comment}{// Format argument.}}
\DoxyCodeLine{562     fmt::visit(AF(buffer, spec, *\textcolor{keyword}{this}), arg);}
\DoxyCodeLine{563   \}}
\DoxyCodeLine{564   buffer.append(pointer\_from(start), pointer\_from(it));}
\DoxyCodeLine{565 \}}
\DoxyCodeLine{566 }
\DoxyCodeLine{567 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{568 \textcolor{keywordtype}{void} printf(\mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::basic\_buffer<Char>}} \&buf, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format,}
\DoxyCodeLine{569             \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<Context>}} args) \{}
\DoxyCodeLine{570   Context(std::back\_inserter(buf), format, args).format();}
\DoxyCodeLine{571 \}}
\DoxyCodeLine{572 }
\DoxyCodeLine{573 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Buffer>}
\DoxyCodeLine{574 \textcolor{keyword}{struct }\mbox{\hyperlink{structprintf__context}{printf\_context}} \{}
\DoxyCodeLine{575   \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__printf__context}{basic\_printf\_context}}<}
\DoxyCodeLine{576     std::back\_insert\_iterator<Buffer>, \textcolor{keyword}{typename} Buffer::value\_type> \mbox{\hyperlink{classbasic__printf__context}{type}};}
\DoxyCodeLine{577 \};}
\DoxyCodeLine{578 }
\DoxyCodeLine{579 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ...Args>}
\DoxyCodeLine{580 \textcolor{keyword}{inline} \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store<printf\_context<internal::buffer>::type}}, Args...>}
\DoxyCodeLine{581     make\_printf\_args(\textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{582   \textcolor{keywordflow}{return} \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store<printf\_context<internal::buffer>::type}}, Args...>(}
\DoxyCodeLine{583       args...);}
\DoxyCodeLine{584 \}}
\DoxyCodeLine{585 \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<printf\_context<internal::buffer>::type}}> \mbox{\hyperlink{classbasic__format__args}{printf\_args}};}
\DoxyCodeLine{586 \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<printf\_context<internal::wbuffer>::type}}> \mbox{\hyperlink{classbasic__format__args}{wprintf\_args}};}
\DoxyCodeLine{587 }
\DoxyCodeLine{588 \textcolor{keyword}{inline} std::string vsprintf(\mbox{\hyperlink{classbasic__string__view}{string\_view}} format, \mbox{\hyperlink{classbasic__format__args}{printf\_args}} args) \{}
\DoxyCodeLine{589   \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}} buffer;}
\DoxyCodeLine{590   printf(buffer, format, args);}
\DoxyCodeLine{591   \textcolor{keywordflow}{return} to\_string(buffer);}
\DoxyCodeLine{592 \}}
\DoxyCodeLine{593 }
\DoxyCodeLine{603 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{604 \textcolor{keyword}{inline} std::string sprintf(\mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{605   \textcolor{keywordflow}{return} vsprintf(format\_str,}
\DoxyCodeLine{606     make\_format\_args<\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__printf__context}{printf\_context<internal::buffer>::type}}>(args...));}
\DoxyCodeLine{607 \}}
\DoxyCodeLine{608 }
\DoxyCodeLine{609 \textcolor{keyword}{inline} std::wstring vsprintf(\mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format, \mbox{\hyperlink{classbasic__format__args}{wprintf\_args}} args) \{}
\DoxyCodeLine{610   \mbox{\hyperlink{classbasic__memory__buffer}{wmemory\_buffer}} buffer;}
\DoxyCodeLine{611   printf(buffer, format, args);}
\DoxyCodeLine{612   \textcolor{keywordflow}{return} to\_string(buffer);}
\DoxyCodeLine{613 \}}
\DoxyCodeLine{614 }
\DoxyCodeLine{615 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{616 \textcolor{keyword}{inline} std::wstring sprintf(\mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str, \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{617   \textcolor{keywordflow}{return} vsprintf(format\_str,}
\DoxyCodeLine{618     make\_format\_args<\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__printf__context}{printf\_context<internal::wbuffer>::type}}>(args...));}
\DoxyCodeLine{619 \}}
\DoxyCodeLine{620 }
\DoxyCodeLine{621 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{622 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} vfprintf(std::FILE *f, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format,}
\DoxyCodeLine{623                     \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<\textcolor{keyword}{typename} \mbox{\hyperlink{structprintf__context}{printf\_context}}<}
\DoxyCodeLine{624                       \mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::basic\_buffer<Char>}}>::type> args) \{}
\DoxyCodeLine{625   \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char>}} buffer;}
\DoxyCodeLine{626   printf(buffer, format, args);}
\DoxyCodeLine{627   std::size\_t size = buffer.size();}
\DoxyCodeLine{628   \textcolor{keywordflow}{return} std::fwrite(}
\DoxyCodeLine{629     buffer.data(), \textcolor{keyword}{sizeof}(Char), size, f) < size ? -\/1 : \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(size);}
\DoxyCodeLine{630 \}}
\DoxyCodeLine{631 }
\DoxyCodeLine{641 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{642 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} fprintf(std::FILE *f, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{643   \textcolor{keyword}{auto} vargs = make\_format\_args<}
\DoxyCodeLine{644     \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__printf__context}{printf\_context<internal::buffer>::type}}>(args...);}
\DoxyCodeLine{645   \textcolor{keywordflow}{return} vfprintf<char>(f, format\_str, vargs);}
\DoxyCodeLine{646 \}}
\DoxyCodeLine{647 }
\DoxyCodeLine{648 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{649 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} fprintf(std::FILE *f, \mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str,}
\DoxyCodeLine{650                    \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{651   \textcolor{keywordflow}{return} vfprintf(f, format\_str,}
\DoxyCodeLine{652     make\_format\_args<\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__printf__context}{printf\_context<internal::wbuffer>::type}}>(args...));}
\DoxyCodeLine{653 \}}
\DoxyCodeLine{654 }
\DoxyCodeLine{655 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} vprintf(\mbox{\hyperlink{classbasic__string__view}{string\_view}} format, \mbox{\hyperlink{classbasic__format__args}{printf\_args}} args) \{}
\DoxyCodeLine{656   \textcolor{keywordflow}{return} vfprintf(stdout, format, args);}
\DoxyCodeLine{657 \}}
\DoxyCodeLine{658 }
\DoxyCodeLine{659 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} vprintf(\mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format, \mbox{\hyperlink{classbasic__format__args}{wprintf\_args}} args) \{}
\DoxyCodeLine{660   \textcolor{keywordflow}{return} vfprintf(stdout, format, args);}
\DoxyCodeLine{661 \}}
\DoxyCodeLine{662 }
\DoxyCodeLine{672 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{673 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} printf(\mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{674   \textcolor{keywordflow}{return} vprintf(format\_str,}
\DoxyCodeLine{675     make\_format\_args<\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__printf__context}{printf\_context<internal::buffer>::type}}>(args...));}
\DoxyCodeLine{676 \}}
\DoxyCodeLine{677 }
\DoxyCodeLine{678 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{679 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} printf(\mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str, \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{680   \textcolor{keywordflow}{return} vprintf(format\_str,}
\DoxyCodeLine{681     make\_format\_args<\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__printf__context}{printf\_context<internal::wbuffer>::type}}>(args...));}
\DoxyCodeLine{682 \}}
\DoxyCodeLine{683 }
\DoxyCodeLine{684 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} vfprintf(std::ostream \&os, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str,}
\DoxyCodeLine{685                     \mbox{\hyperlink{classbasic__format__args}{printf\_args}} args) \{}
\DoxyCodeLine{686   \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}} buffer;}
\DoxyCodeLine{687   printf(buffer, format\_str, args);}
\DoxyCodeLine{688   internal::write(os, buffer);}
\DoxyCodeLine{689   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(buffer.size());}
\DoxyCodeLine{690 \}}
\DoxyCodeLine{691 }
\DoxyCodeLine{692 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} vfprintf(std::wostream \&os, \mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str,}
\DoxyCodeLine{693                     \mbox{\hyperlink{classbasic__format__args}{wprintf\_args}} args) \{}
\DoxyCodeLine{694   \mbox{\hyperlink{classbasic__memory__buffer}{wmemory\_buffer}} buffer;}
\DoxyCodeLine{695   printf(buffer, format\_str, args);}
\DoxyCodeLine{696   internal::write(os, buffer);}
\DoxyCodeLine{697   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(buffer.size());}
\DoxyCodeLine{698 \}}
\DoxyCodeLine{699 }
\DoxyCodeLine{709 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{710 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} fprintf(std::ostream \&os, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str,}
\DoxyCodeLine{711                    \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{712   \textcolor{keyword}{auto} vargs = make\_format\_args<}
\DoxyCodeLine{713     \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__printf__context}{printf\_context<internal::buffer>::type}}>(args...);}
\DoxyCodeLine{714   \textcolor{keywordflow}{return} vfprintf(os, format\_str, vargs);}
\DoxyCodeLine{715 \}}
\DoxyCodeLine{716 }
\DoxyCodeLine{717 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{718 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} fprintf(std::wostream \&os, \mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str,}
\DoxyCodeLine{719                    \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{720   \textcolor{keyword}{auto} vargs = make\_format\_args<}
\DoxyCodeLine{721     \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__printf__context}{printf\_context<internal::buffer>::type}}>(args...);}
\DoxyCodeLine{722   \textcolor{keywordflow}{return} vfprintf(os, format\_str, vargs);}
\DoxyCodeLine{723 \}}
\DoxyCodeLine{724 FMT\_END\_NAMESPACE}
\DoxyCodeLine{725 }
\DoxyCodeLine{726 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_PRINTF\_H\_}}

\end{DoxyCode}
