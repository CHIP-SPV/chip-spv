\hypertarget{catch_8hpp_source}{}\doxysection{catch.\+hpp}
\label{catch_8hpp_source}\index{/Users/pvelesko/local/CHIP-\/SPV/HIP/tests/catch/external/Catch2/catch.hpp@{/Users/pvelesko/local/CHIP-\/SPV/HIP/tests/catch/external/Catch2/catch.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{ *  Catch v2.13.4}}
\DoxyCodeLine{3 \textcolor{comment}{ *  Generated: 2020-\/12-\/29 14:48:00.116107}}
\DoxyCodeLine{4 \textcolor{comment}{ *  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{5 \textcolor{comment}{ *  This file has been merged from multiple headers. Please don't edit it directly}}
\DoxyCodeLine{6 \textcolor{comment}{ *  Copyright (c) 2020 Two Blue Cubes Ltd. All rights reserved.}}
\DoxyCodeLine{7 \textcolor{comment}{ *}}
\DoxyCodeLine{8 \textcolor{comment}{ *  Distributed under the Boost Software License, Version 1.0. (See accompanying}}
\DoxyCodeLine{9 \textcolor{comment}{ *  file LICENSE\_1\_0.txt or copy at http://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{10 \textcolor{comment}{ */}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#ifndef TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#define TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{13 \textcolor{comment}{// start catch.hpp}}
\DoxyCodeLine{14 }
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{preprocessor}{\#define CATCH\_VERSION\_MAJOR 2}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#define CATCH\_VERSION\_MINOR 13}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#define CATCH\_VERSION\_PATCH 4}}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#    pragma clang system\_header}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#    pragma GCC system\_header}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{comment}{// start catch\_suppress\_warnings.h}}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#   ifdef \_\_ICC }\textcolor{comment}{// icpc defines the \_\_clang\_\_ macro}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#       pragma warning(push)}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#       pragma warning(disable: 161 1682)}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#   else }\textcolor{comment}{// \_\_ICC}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#       pragma clang diagnostic push}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wswitch-\/enum"{}}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wcovered-\/switch-\/default"{}}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{39      \textcolor{comment}{// Because REQUIREs trigger GCC's -\/Wparentheses, and because still}}
\DoxyCodeLine{40      \textcolor{comment}{// supported version of g++ have only buggy support for \_Pragmas,}}
\DoxyCodeLine{41      \textcolor{comment}{// Wparentheses have to be suppressed globally.}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wparentheses"{}} \textcolor{comment}{// See \#674 for details}}
\DoxyCodeLine{43 }
\DoxyCodeLine{44 \textcolor{preprocessor}{\#    pragma GCC diagnostic push}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wunused-\/variable"{}}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{48 \textcolor{comment}{// end catch\_suppress\_warnings.h}}
\DoxyCodeLine{49 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_MAIN) || defined(CATCH\_CONFIG\_RUNNER)}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#  define CATCH\_IMPL}}
\DoxyCodeLine{51 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ALL\_PARTS}}
\DoxyCodeLine{52 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{53 }
\DoxyCodeLine{54 \textcolor{comment}{// In the impl file, we want to have access to all parts of the headers}}
\DoxyCodeLine{55 \textcolor{comment}{// Can also be used to sanely support PCHs}}
\DoxyCodeLine{56 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ALL\_PARTS)}}
\DoxyCodeLine{57 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_EXTERNAL\_INTERFACES}}
\DoxyCodeLine{58 \textcolor{preprocessor}{\#  if defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{59 \textcolor{preprocessor}{\#    undef CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{60 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{61 \textcolor{preprocessor}{\#  if !defined(CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER)}}
\DoxyCodeLine{62 \textcolor{preprocessor}{\#    define CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{64 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{65 }
\DoxyCodeLine{66 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_IMPL\_ONLY)}}
\DoxyCodeLine{67 \textcolor{comment}{// start catch\_platform.h}}
\DoxyCodeLine{68 }
\DoxyCodeLine{69 \textcolor{preprocessor}{\#ifdef \_\_APPLE\_\_}}
\DoxyCodeLine{70 \textcolor{preprocessor}{\# include <TargetConditionals.h>}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\# if TARGET\_OS\_OSX == 1}}
\DoxyCodeLine{72 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{73 \textcolor{preprocessor}{\# elif TARGET\_OS\_IPHONE == 1}}
\DoxyCodeLine{74 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_IPHONE}}
\DoxyCodeLine{75 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{76 }
\DoxyCodeLine{77 \textcolor{preprocessor}{\#elif defined(linux) || defined(\_\_linux) || defined(\_\_linux\_\_)}}
\DoxyCodeLine{78 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_LINUX}}
\DoxyCodeLine{79 }
\DoxyCodeLine{80 \textcolor{preprocessor}{\#elif defined(WIN32) || defined(\_\_WIN32\_\_) || defined(\_WIN32) || defined(\_MSC\_VER) || defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{81 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{82 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{83 }
\DoxyCodeLine{84 \textcolor{comment}{// end catch\_platform.h}}
\DoxyCodeLine{85 }
\DoxyCodeLine{86 \textcolor{preprocessor}{\#ifdef CATCH\_IMPL}}
\DoxyCodeLine{87 \textcolor{preprocessor}{\#  ifndef CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{88 \textcolor{preprocessor}{\#    define CLARA\_CONFIG\_MAIN\_NOT\_DEFINED}}
\DoxyCodeLine{89 \textcolor{preprocessor}{\#    define CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{90 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{91 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{92 }
\DoxyCodeLine{93 \textcolor{comment}{// start catch\_user\_interfaces.h}}
\DoxyCodeLine{94 }
\DoxyCodeLine{95 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{96     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed();}
\DoxyCodeLine{97 \}}
\DoxyCodeLine{98 }
\DoxyCodeLine{99 \textcolor{comment}{// end catch\_user\_interfaces.h}}
\DoxyCodeLine{100 \textcolor{comment}{// start catch\_tag\_alias\_autoregistrar.h}}
\DoxyCodeLine{101 }
\DoxyCodeLine{102 \textcolor{comment}{// start catch\_common.h}}
\DoxyCodeLine{103 }
\DoxyCodeLine{104 \textcolor{comment}{// start catch\_compiler\_capabilities.h}}
\DoxyCodeLine{105 }
\DoxyCodeLine{106 \textcolor{comment}{// Detect a number of compiler features -\/ by compiler}}
\DoxyCodeLine{107 \textcolor{comment}{// The following features are defined:}}
\DoxyCodeLine{108 \textcolor{comment}{//}}
\DoxyCodeLine{109 \textcolor{comment}{// CATCH\_CONFIG\_COUNTER : is the \_\_COUNTER\_\_ macro supported?}}
\DoxyCodeLine{110 \textcolor{comment}{// CATCH\_CONFIG\_WINDOWS\_SEH : is Windows SEH supported?}}
\DoxyCodeLine{111 \textcolor{comment}{// CATCH\_CONFIG\_POSIX\_SIGNALS : are POSIX signals supported?}}
\DoxyCodeLine{112 \textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_EXCEPTIONS : Are exceptions enabled?}}
\DoxyCodeLine{113 \textcolor{comment}{// ****************}}
\DoxyCodeLine{114 \textcolor{comment}{// Note to maintainers: if new toggles are added please document them}}
\DoxyCodeLine{115 \textcolor{comment}{// in configuration.md, too}}
\DoxyCodeLine{116 \textcolor{comment}{// ****************}}
\DoxyCodeLine{117 }
\DoxyCodeLine{118 \textcolor{comment}{// In general each macro has a \_NO\_<feature name> form}}
\DoxyCodeLine{119 \textcolor{comment}{// (e.g. CATCH\_CONFIG\_NO\_POSIX\_SIGNALS) which disables the feature.}}
\DoxyCodeLine{120 \textcolor{comment}{// Many features, at point of detection, define an \_INTERNAL\_ macro, so they}}
\DoxyCodeLine{121 \textcolor{comment}{// can be combined, en-\/mass, with the \_NO\_ forms later.}}
\DoxyCodeLine{122 }
\DoxyCodeLine{123 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{124 }
\DoxyCodeLine{125 \textcolor{preprocessor}{\#  if (\_\_cplusplus >= 201402L) || (defined(\_MSVC\_LANG) \&\& \_MSVC\_LANG >= 201402L)}}
\DoxyCodeLine{126 \textcolor{preprocessor}{\#    define CATCH\_CPP14\_OR\_GREATER}}
\DoxyCodeLine{127 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{128 }
\DoxyCodeLine{129 \textcolor{preprocessor}{\#  if (\_\_cplusplus >= 201703L) || (defined(\_MSVC\_LANG) \&\& \_MSVC\_LANG >= 201703L)}}
\DoxyCodeLine{130 \textcolor{preprocessor}{\#    define CATCH\_CPP17\_OR\_GREATER}}
\DoxyCodeLine{131 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{132 }
\DoxyCodeLine{133 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{134 }
\DoxyCodeLine{135 \textcolor{comment}{// We have to avoid both ICC and Clang, because they try to mask themselves}}
\DoxyCodeLine{136 \textcolor{comment}{// as gcc, and we want only GCC in this block}}
\DoxyCodeLine{137 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) \&\& !defined(\_\_clang\_\_) \&\& !defined(\_\_ICC) \&\& !defined(\_\_CUDACC\_\_)}}
\DoxyCodeLine{138 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \_Pragma( "{}GCC diagnostic push"{}} )}
\DoxyCodeLine{139 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION  \_Pragma( "{}GCC diagnostic pop"{}} )}
\DoxyCodeLine{140 }
\DoxyCodeLine{141 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_IGNORE\_BUT\_WARN(...) (void)\_\_builtin\_constant\_p(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{142 }
\DoxyCodeLine{143 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{144 }
\DoxyCodeLine{145 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{146 }
\DoxyCodeLine{147 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \_Pragma( "{}clang diagnostic push"{}} )}
\DoxyCodeLine{148 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION  \_Pragma( "{}clang diagnostic pop"{}} )}
\DoxyCodeLine{149 }
\DoxyCodeLine{150 \textcolor{comment}{// As of this writing, IBM XL's implementation of \_\_builtin\_constant\_p has a bug}}
\DoxyCodeLine{151 \textcolor{comment}{// which results in calls to destructors being emitted for each temporary,}}
\DoxyCodeLine{152 \textcolor{comment}{// without a matching initialization. In practice, this can result in something}}
\DoxyCodeLine{153 \textcolor{comment}{// like `std::string::\string~string` being called on an uninitialized value.}}
\DoxyCodeLine{154 \textcolor{comment}{//}}
\DoxyCodeLine{155 \textcolor{comment}{// For example, this code will likely segfault under IBM XL:}}
\DoxyCodeLine{156 \textcolor{comment}{// ```}}
\DoxyCodeLine{157 \textcolor{comment}{// REQUIRE(std::string("{}12"{}) + "{}34"{} == "{}1234"{})}}
\DoxyCodeLine{158 \textcolor{comment}{// ```}}
\DoxyCodeLine{159 \textcolor{comment}{//}}
\DoxyCodeLine{160 \textcolor{comment}{// Therefore, `CATCH\_INTERNAL\_IGNORE\_BUT\_WARN` is not implemented.}}
\DoxyCodeLine{161 \textcolor{preprocessor}{\#  if !defined(\_\_ibmxl\_\_) \&\& !defined(\_\_CUDACC\_\_)}}
\DoxyCodeLine{162 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_IGNORE\_BUT\_WARN(...) (void)\_\_builtin\_constant\_p(\_\_VA\_ARGS\_\_) }\textcolor{comment}{/* NOLINT(cppcoreguidelines-\/pro-\/type-\/vararg, hicpp-\/vararg) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{163 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{164 }
\DoxyCodeLine{165 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{166 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wexit-\/time-\/destructors\(\backslash\)"{}"{}} ) \(\backslash\)}
\DoxyCodeLine{167          \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wglobal-\/constructors\(\backslash\)"{}"{})}
\DoxyCodeLine{168 }
\DoxyCodeLine{169 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{170 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wparentheses\(\backslash\)"{}"{}} )}
\DoxyCodeLine{171 }
\DoxyCodeLine{172 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{173 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wunused-\/variable\(\backslash\)"{}"{}} )}
\DoxyCodeLine{174 }
\DoxyCodeLine{175 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{176 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wgnu-\/zero-\/variadic-\/macro-\/arguments\(\backslash\)"{}"{}} )}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{179 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wunused-\/template\(\backslash\)"{}"{}} )}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_clang\_\_}}
\DoxyCodeLine{182 }
\DoxyCodeLine{184 \textcolor{comment}{// Assume that non-\/Windows platforms support posix signals by default}}
\DoxyCodeLine{185 \textcolor{preprocessor}{\#if !defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{186 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{187 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{188 }
\DoxyCodeLine{190 \textcolor{comment}{// We know some environments not to support full POSIX signals}}
\DoxyCodeLine{191 \textcolor{preprocessor}{\#if defined(\_\_CYGWIN\_\_) || defined(\_\_QNX\_\_) || defined(\_\_EMSCRIPTEN\_\_) || defined(\_\_DJGPP\_\_)}}
\DoxyCodeLine{192 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS}}
\DoxyCodeLine{193 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{194 }
\DoxyCodeLine{195 \textcolor{preprocessor}{\#ifdef \_\_OS400\_\_}}
\DoxyCodeLine{196 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS}}
\DoxyCodeLine{197 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_NONE}}
\DoxyCodeLine{198 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{199 }
\DoxyCodeLine{201 \textcolor{comment}{// Android somehow still does not support std::to\_string}}
\DoxyCodeLine{202 \textcolor{preprocessor}{\#if defined(\_\_ANDROID\_\_)}}
\DoxyCodeLine{203 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_CPP11\_TO\_STRING}}
\DoxyCodeLine{204 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_ANDROID\_LOGWRITE}}
\DoxyCodeLine{205 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{206 }
\DoxyCodeLine{208 \textcolor{comment}{// Not all Windows environments support SEH properly}}
\DoxyCodeLine{209 \textcolor{preprocessor}{\#if defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{210 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_WINDOWS\_SEH}}
\DoxyCodeLine{211 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{212 }
\DoxyCodeLine{214 \textcolor{comment}{// PS4}}
\DoxyCodeLine{215 \textcolor{preprocessor}{\#if defined(\_\_ORBIS\_\_)}}
\DoxyCodeLine{216 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_NEW\_CAPTURE}}
\DoxyCodeLine{217 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{218 }
\DoxyCodeLine{220 \textcolor{comment}{// Cygwin}}
\DoxyCodeLine{221 \textcolor{preprocessor}{\#ifdef \_\_CYGWIN\_\_}}
\DoxyCodeLine{222 }
\DoxyCodeLine{223 \textcolor{comment}{// Required for some versions of Cygwin to declare gettimeofday}}
\DoxyCodeLine{224 \textcolor{comment}{// see: http://stackoverflow.com/questions/36901803/gettimeofday-\/not-\/declared-\/in-\/this-\/scope-\/cygwin}}
\DoxyCodeLine{225 \textcolor{preprocessor}{\#   define \_BSD\_SOURCE}}
\DoxyCodeLine{226 \textcolor{comment}{// some versions of cygwin (most) do not support std::to\_string. Use the libstd check.}}
\DoxyCodeLine{227 \textcolor{comment}{// https://gcc.gnu.org/onlinedocs/gcc-\/4.8.2/libstdc++/api/a01053\_source.html line 2812-\/2813}}
\DoxyCodeLine{228 \textcolor{preprocessor}{\# if !((\_\_cplusplus >= 201103L) \&\& defined(\_GLIBCXX\_USE\_C99) \(\backslash\)}}
\DoxyCodeLine{229 \textcolor{preprocessor}{           \&\& !defined(\_GLIBCXX\_HAVE\_BROKEN\_VSWPRINTF))}}
\DoxyCodeLine{230 }
\DoxyCodeLine{231 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_CPP11\_TO\_STRING}}
\DoxyCodeLine{232 }
\DoxyCodeLine{233 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{234 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_CYGWIN\_\_}}
\DoxyCodeLine{235 }
\DoxyCodeLine{237 \textcolor{comment}{// Visual C++}}
\DoxyCodeLine{238 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{239 }
\DoxyCodeLine{240 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \_\_pragma( warning(push) )}}
\DoxyCodeLine{241 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION  \_\_pragma( warning(pop) )}}
\DoxyCodeLine{242 }
\DoxyCodeLine{243 \textcolor{comment}{// Universal Windows platform does not support SEH}}
\DoxyCodeLine{244 \textcolor{comment}{// Or console colours (or console at all...)}}
\DoxyCodeLine{245 \textcolor{preprocessor}{\#  if defined(WINAPI\_FAMILY) \&\& (WINAPI\_FAMILY == WINAPI\_FAMILY\_APP)}}
\DoxyCodeLine{246 \textcolor{preprocessor}{\#    define CATCH\_CONFIG\_COLOUR\_NONE}}
\DoxyCodeLine{247 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{248 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_WINDOWS\_SEH}}
\DoxyCodeLine{249 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{250 }
\DoxyCodeLine{251 \textcolor{comment}{// MSVC traditional preprocessor needs some workaround for \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{252 \textcolor{comment}{// \_MSVC\_TRADITIONAL == 0 means new conformant preprocessor}}
\DoxyCodeLine{253 \textcolor{comment}{// \_MSVC\_TRADITIONAL == 1 means old traditional non-\/conformant preprocessor}}
\DoxyCodeLine{254 \textcolor{preprocessor}{\#  if !defined(\_\_clang\_\_) }\textcolor{comment}{// Handle Clang masquerading for msvc}}
\DoxyCodeLine{255 \textcolor{preprocessor}{\#    if !defined(\_MSVC\_TRADITIONAL) || (defined(\_MSVC\_TRADITIONAL) \&\& \_MSVC\_TRADITIONAL)}}
\DoxyCodeLine{256 \textcolor{preprocessor}{\#      define CATCH\_INTERNAL\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{257 \textcolor{preprocessor}{\#    endif }\textcolor{comment}{// MSVC\_TRADITIONAL}}
\DoxyCodeLine{258 \textcolor{preprocessor}{\#  endif }\textcolor{comment}{// \_\_clang\_\_}}
\DoxyCodeLine{259 }
\DoxyCodeLine{260 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_MSC\_VER}}
\DoxyCodeLine{261 }
\DoxyCodeLine{262 \textcolor{preprocessor}{\#if defined(\_REENTRANT) || defined(\_MSC\_VER)}}
\DoxyCodeLine{263 \textcolor{comment}{// Enable async processing, as -\/pthread is specified or no additional linking is required}}
\DoxyCodeLine{264 \textcolor{preprocessor}{\# define CATCH\_INTERNAL\_CONFIG\_USE\_ASYNC}}
\DoxyCodeLine{265 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_MSC\_VER}}
\DoxyCodeLine{266 }
\DoxyCodeLine{268 \textcolor{comment}{// Check if we are compiled with -\/fno-\/exceptions or equivalent}}
\DoxyCodeLine{269 \textcolor{preprocessor}{\#if defined(\_\_EXCEPTIONS) || defined(\_\_cpp\_exceptions) || defined(\_CPPUNWIND)}}
\DoxyCodeLine{270 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_EXCEPTIONS\_ENABLED}}
\DoxyCodeLine{271 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{272 }
\DoxyCodeLine{274 \textcolor{comment}{// DJGPP}}
\DoxyCodeLine{275 \textcolor{preprocessor}{\#ifdef \_\_DJGPP\_\_}}
\DoxyCodeLine{276 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_NO\_WCHAR}}
\DoxyCodeLine{277 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_DJGPP\_\_}}
\DoxyCodeLine{278 }
\DoxyCodeLine{280 \textcolor{comment}{// Embarcadero C++Build}}
\DoxyCodeLine{281 \textcolor{preprocessor}{\#if defined(\_\_BORLANDC\_\_)}}
\DoxyCodeLine{282 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_POLYFILL\_ISNAN}}
\DoxyCodeLine{283 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{284 }
\DoxyCodeLine{286 }
\DoxyCodeLine{287 \textcolor{comment}{// Use of \_\_COUNTER\_\_ is suppressed during code analysis in}}
\DoxyCodeLine{288 \textcolor{comment}{// CLion/AppCode 2017.2.x and former, because \_\_COUNTER\_\_ is not properly}}
\DoxyCodeLine{289 \textcolor{comment}{// handled by it.}}
\DoxyCodeLine{290 \textcolor{comment}{// Otherwise all supported compilers support COUNTER macro,}}
\DoxyCodeLine{291 \textcolor{comment}{// but user still might want to turn it off}}
\DoxyCodeLine{292 \textcolor{preprocessor}{\#if ( !defined(\_\_JETBRAINS\_IDE\_\_) || \_\_JETBRAINS\_IDE\_\_ >= 20170300L )}}
\DoxyCodeLine{293 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_COUNTER}}
\DoxyCodeLine{294 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{295 }
\DoxyCodeLine{297 }
\DoxyCodeLine{298 \textcolor{comment}{// RTX is a special version of Windows that is real time.}}
\DoxyCodeLine{299 \textcolor{comment}{// This means that it is detected as Windows, but does not provide}}
\DoxyCodeLine{300 \textcolor{comment}{// the same set of capabilities as real Windows does.}}
\DoxyCodeLine{301 \textcolor{preprocessor}{\#if defined(UNDER\_RTSS) || defined(RTX64\_BUILD)}}
\DoxyCodeLine{302 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_NO\_WINDOWS\_SEH}}
\DoxyCodeLine{303 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_NO\_ASYNC}}
\DoxyCodeLine{304 \textcolor{preprocessor}{    \#define CATCH\_CONFIG\_COLOUR\_NONE}}
\DoxyCodeLine{305 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{306 }
\DoxyCodeLine{307 \textcolor{preprocessor}{\#if !defined(\_GLIBCXX\_USE\_C99\_MATH\_TR1)}}
\DoxyCodeLine{308 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_CONFIG\_GLOBAL\_NEXTAFTER}}
\DoxyCodeLine{309 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{310 }
\DoxyCodeLine{311 \textcolor{comment}{// Various stdlib support checks that require \_\_has\_include}}
\DoxyCodeLine{312 \textcolor{preprocessor}{\#if defined(\_\_has\_include)}}
\DoxyCodeLine{313   \textcolor{comment}{// Check if string\_view is available and usable}}
\DoxyCodeLine{314 \textcolor{preprocessor}{  \#if \_\_has\_include(<string\_view>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{315 \textcolor{preprocessor}{  \#    define CATCH\_INTERNAL\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{316 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{317 }
\DoxyCodeLine{318   \textcolor{comment}{// Check if optional is available and usable}}
\DoxyCodeLine{319 \textcolor{preprocessor}{  \#  if \_\_has\_include(<optional>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{320 \textcolor{preprocessor}{  \#    define CATCH\_INTERNAL\_CONFIG\_CPP17\_OPTIONAL}}
\DoxyCodeLine{321 \textcolor{preprocessor}{  \#  endif }\textcolor{comment}{// \_\_has\_include(<optional>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{322 }
\DoxyCodeLine{323   \textcolor{comment}{// Check if byte is available and usable}}
\DoxyCodeLine{324 \textcolor{preprocessor}{  \#  if \_\_has\_include(<cstddef>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{325 \textcolor{preprocessor}{  \#    include <cstddef>}}
\DoxyCodeLine{326 \textcolor{preprocessor}{  \#    if \_\_cpp\_lib\_byte > 0}}
\DoxyCodeLine{327 \textcolor{preprocessor}{  \#      define CATCH\_INTERNAL\_CONFIG\_CPP17\_BYTE}}
\DoxyCodeLine{328 \textcolor{preprocessor}{  \#    endif}}
\DoxyCodeLine{329 \textcolor{preprocessor}{  \#  endif }\textcolor{comment}{// \_\_has\_include(<cstddef>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{330 }
\DoxyCodeLine{331   \textcolor{comment}{// Check if variant is available and usable}}
\DoxyCodeLine{332 \textcolor{preprocessor}{  \#  if \_\_has\_include(<variant>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{333 \textcolor{preprocessor}{  \#    if defined(\_\_clang\_\_) \&\& (\_\_clang\_major\_\_ < 8)}}
\DoxyCodeLine{334          \textcolor{comment}{// work around clang bug with libstdc++ https://bugs.llvm.org/show\_bug.cgi?id=31852}}
\DoxyCodeLine{335          \textcolor{comment}{// fix should be in clang 8, workaround in libstdc++ 8.2}}
\DoxyCodeLine{336 \textcolor{preprocessor}{  \#      include <ciso646>}}
\DoxyCodeLine{337 \textcolor{preprocessor}{  \#      if defined(\_\_GLIBCXX\_\_) \&\& defined(\_GLIBCXX\_RELEASE) \&\& (\_GLIBCXX\_RELEASE < 9)}}
\DoxyCodeLine{338 \textcolor{preprocessor}{  \#        define CATCH\_CONFIG\_NO\_CPP17\_VARIANT}}
\DoxyCodeLine{339 \textcolor{preprocessor}{  \#      else}}
\DoxyCodeLine{340 \textcolor{preprocessor}{  \#        define CATCH\_INTERNAL\_CONFIG\_CPP17\_VARIANT}}
\DoxyCodeLine{341 \textcolor{preprocessor}{  \#      endif }\textcolor{comment}{// defined(\_\_GLIBCXX\_\_) \&\& defined(\_GLIBCXX\_RELEASE) \&\& (\_GLIBCXX\_RELEASE < 9)}}
\DoxyCodeLine{342 \textcolor{preprocessor}{  \#    else}}
\DoxyCodeLine{343 \textcolor{preprocessor}{  \#      define CATCH\_INTERNAL\_CONFIG\_CPP17\_VARIANT}}
\DoxyCodeLine{344 \textcolor{preprocessor}{  \#    endif }\textcolor{comment}{// defined(\_\_clang\_\_) \&\& (\_\_clang\_major\_\_ < 8)}}
\DoxyCodeLine{345 \textcolor{preprocessor}{  \#  endif }\textcolor{comment}{// \_\_has\_include(<variant>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{346 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// defined(\_\_has\_include)}}
\DoxyCodeLine{347 }
\DoxyCodeLine{348 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_COUNTER) \&\& !defined(CATCH\_CONFIG\_NO\_COUNTER) \&\& !defined(CATCH\_CONFIG\_COUNTER)}}
\DoxyCodeLine{349 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_COUNTER}}
\DoxyCodeLine{350 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{351 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_WINDOWS\_SEH) \&\& !defined(CATCH\_CONFIG\_NO\_WINDOWS\_SEH) \&\& !defined(CATCH\_CONFIG\_WINDOWS\_SEH) \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_WINDOWS\_SEH)}}
\DoxyCodeLine{352 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_WINDOWS\_SEH}}
\DoxyCodeLine{353 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{354 \textcolor{comment}{// This is set by default, because we assume that unix compilers are posix-\/signal-\/compatible by default.}}
\DoxyCodeLine{355 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_POSIX\_SIGNALS) \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS) \&\& !defined(CATCH\_CONFIG\_NO\_POSIX\_SIGNALS) \&\& !defined(CATCH\_CONFIG\_POSIX\_SIGNALS)}}
\DoxyCodeLine{356 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{357 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{358 \textcolor{comment}{// This is set by default, because we assume that compilers with no wchar\_t support are just rare exceptions.}}
\DoxyCodeLine{359 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_CONFIG\_NO\_WCHAR) \&\& !defined(CATCH\_CONFIG\_NO\_WCHAR) \&\& !defined(CATCH\_CONFIG\_WCHAR)}}
\DoxyCodeLine{360 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_WCHAR}}
\DoxyCodeLine{361 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{362 }
\DoxyCodeLine{363 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_CONFIG\_NO\_CPP11\_TO\_STRING) \&\& !defined(CATCH\_CONFIG\_NO\_CPP11\_TO\_STRING) \&\& !defined(CATCH\_CONFIG\_CPP11\_TO\_STRING)}}
\DoxyCodeLine{364 \textcolor{preprocessor}{\#    define CATCH\_CONFIG\_CPP11\_TO\_STRING}}
\DoxyCodeLine{365 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{366 }
\DoxyCodeLine{367 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_OPTIONAL) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_OPTIONAL) \&\& !defined(CATCH\_CONFIG\_CPP17\_OPTIONAL)}}
\DoxyCodeLine{368 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_OPTIONAL}}
\DoxyCodeLine{369 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{370 }
\DoxyCodeLine{371 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_STRING\_VIEW) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_STRING\_VIEW) \&\& !defined(CATCH\_CONFIG\_CPP17\_STRING\_VIEW)}}
\DoxyCodeLine{372 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{373 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{374 }
\DoxyCodeLine{375 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_VARIANT) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_VARIANT) \&\& !defined(CATCH\_CONFIG\_CPP17\_VARIANT)}}
\DoxyCodeLine{376 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_VARIANT}}
\DoxyCodeLine{377 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{378 }
\DoxyCodeLine{379 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_BYTE) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_BYTE) \&\& !defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{380 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_BYTE}}
\DoxyCodeLine{381 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{382 }
\DoxyCodeLine{383 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_EXPERIMENTAL\_REDIRECT)}}
\DoxyCodeLine{384 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_NEW\_CAPTURE}}
\DoxyCodeLine{385 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{386 }
\DoxyCodeLine{387 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_NEW\_CAPTURE) \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_NEW\_CAPTURE) \&\& !defined(CATCH\_CONFIG\_NO\_NEW\_CAPTURE) \&\& !defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{388 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_NEW\_CAPTURE}}
\DoxyCodeLine{389 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{390 }
\DoxyCodeLine{391 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_CONFIG\_EXCEPTIONS\_ENABLED) \&\& !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{392 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_DISABLE\_EXCEPTIONS}}
\DoxyCodeLine{393 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{394 }
\DoxyCodeLine{395 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_POLYFILL\_ISNAN) \&\& !defined(CATCH\_CONFIG\_NO\_POLYFILL\_ISNAN) \&\& !defined(CATCH\_CONFIG\_POLYFILL\_ISNAN)}}
\DoxyCodeLine{396 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_POLYFILL\_ISNAN}}
\DoxyCodeLine{397 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{398 }
\DoxyCodeLine{399 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_USE\_ASYNC)  \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_ASYNC) \&\& !defined(CATCH\_CONFIG\_NO\_USE\_ASYNC) \&\& !defined(CATCH\_CONFIG\_USE\_ASYNC)}}
\DoxyCodeLine{400 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_USE\_ASYNC}}
\DoxyCodeLine{401 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{402 }
\DoxyCodeLine{403 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_ANDROID\_LOGWRITE) \&\& !defined(CATCH\_CONFIG\_NO\_ANDROID\_LOGWRITE) \&\& !defined(CATCH\_CONFIG\_ANDROID\_LOGWRITE)}}
\DoxyCodeLine{404 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ANDROID\_LOGWRITE}}
\DoxyCodeLine{405 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{406 }
\DoxyCodeLine{407 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_GLOBAL\_NEXTAFTER) \&\& !defined(CATCH\_CONFIG\_NO\_GLOBAL\_NEXTAFTER) \&\& !defined(CATCH\_CONFIG\_GLOBAL\_NEXTAFTER)}}
\DoxyCodeLine{408 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_GLOBAL\_NEXTAFTER}}
\DoxyCodeLine{409 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{410 }
\DoxyCodeLine{411 \textcolor{comment}{// Even if we do not think the compiler has that warning, we still have}}
\DoxyCodeLine{412 \textcolor{comment}{// to provide a macro that can be used by the code.}}
\DoxyCodeLine{413 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION)}}
\DoxyCodeLine{414 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{415 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{416 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION)}}
\DoxyCodeLine{417 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{418 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{419 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS)}}
\DoxyCodeLine{420 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS}}
\DoxyCodeLine{421 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{422 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS)}}
\DoxyCodeLine{423 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS}}
\DoxyCodeLine{424 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{425 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS)}}
\DoxyCodeLine{426 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS}}
\DoxyCodeLine{427 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{428 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS)}}
\DoxyCodeLine{429 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS}}
\DoxyCodeLine{430 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{431 }
\DoxyCodeLine{432 \textcolor{comment}{// The goal of this macro is to avoid evaluation of the arguments, but}}
\DoxyCodeLine{433 \textcolor{comment}{// still have the compiler warn on problems inside...}}
\DoxyCodeLine{434 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_IGNORE\_BUT\_WARN)}}
\DoxyCodeLine{435 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_IGNORE\_BUT\_WARN(...)}}
\DoxyCodeLine{436 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{437 }
\DoxyCodeLine{438 \textcolor{preprocessor}{\#if defined(\_\_APPLE\_\_) \&\& defined(\_\_apple\_build\_version\_\_) \&\& (\_\_clang\_major\_\_ < 10)}}
\DoxyCodeLine{439 \textcolor{preprocessor}{\#   undef CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS}}
\DoxyCodeLine{440 \textcolor{preprocessor}{\#elif defined(\_\_clang\_\_) \&\& (\_\_clang\_major\_\_ < 5)}}
\DoxyCodeLine{441 \textcolor{preprocessor}{\#   undef CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS}}
\DoxyCodeLine{442 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{443 }
\DoxyCodeLine{444 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS)}}
\DoxyCodeLine{445 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS}}
\DoxyCodeLine{446 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{447 }
\DoxyCodeLine{448 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{449 \textcolor{preprocessor}{\#define CATCH\_TRY if ((true))}}
\DoxyCodeLine{450 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ALL if ((false))}}
\DoxyCodeLine{451 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ANON(type) if ((false))}}
\DoxyCodeLine{452 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{453 \textcolor{preprocessor}{\#define CATCH\_TRY try}}
\DoxyCodeLine{454 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ALL catch (...)}}
\DoxyCodeLine{455 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ANON(type) catch (type)}}
\DoxyCodeLine{456 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{457 }
\DoxyCodeLine{458 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR) \&\& !defined(CATCH\_CONFIG\_NO\_TRADITIONAL\_MSVC\_PREPROCESSOR) \&\& !defined(CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR)}}
\DoxyCodeLine{459 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{460 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{461 }
\DoxyCodeLine{462 \textcolor{comment}{// end catch\_compiler\_capabilities.h}}
\DoxyCodeLine{463 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE2( name, line ) name\#\#line}}
\DoxyCodeLine{464 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, line ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE2( name, line )}}
\DoxyCodeLine{465 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_COUNTER}}
\DoxyCodeLine{466 \textcolor{preprocessor}{\#  define INTERNAL\_CATCH\_UNIQUE\_NAME( name ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, \_\_COUNTER\_\_ )}}
\DoxyCodeLine{467 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{468 \textcolor{preprocessor}{\#  define INTERNAL\_CATCH\_UNIQUE\_NAME( name ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, \_\_LINE\_\_ )}}
\DoxyCodeLine{469 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{470 }
\DoxyCodeLine{471 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{472 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{473 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{474 }
\DoxyCodeLine{475 \textcolor{comment}{// We need a dummy global operator<< so we can bring it into Catch namespace later}}
\DoxyCodeLine{476 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch__global__namespace__dummy}{Catch\_global\_namespace\_dummy}} \{\};}
\DoxyCodeLine{477 std::ostream\& operator<<(std::ostream\&, \mbox{\hyperlink{struct_catch__global__namespace__dummy}{Catch\_global\_namespace\_dummy}});}
\DoxyCodeLine{478 }
\DoxyCodeLine{479 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{480 }
\DoxyCodeLine{481     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_case_sensitive}{CaseSensitive}} \{ \textcolor{keyword}{enum} Choice \{}
\DoxyCodeLine{482         Yes,}
\DoxyCodeLine{483         No}
\DoxyCodeLine{484     \}; \};}
\DoxyCodeLine{485 }
\DoxyCodeLine{486     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \{}
\DoxyCodeLine{487         \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}}( \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \textcolor{keyword}{const}\& )              = \textcolor{keyword}{delete};}
\DoxyCodeLine{488         \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}}( \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \&\& )                  = \textcolor{keyword}{delete};}
\DoxyCodeLine{489         \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}}\& operator = ( \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{490         \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}}\& operator = ( \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \&\& )     = \textcolor{keyword}{delete};}
\DoxyCodeLine{491 }
\DoxyCodeLine{492     \textcolor{keyword}{protected}:}
\DoxyCodeLine{493         \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}}();}
\DoxyCodeLine{494         \textcolor{keyword}{virtual} \mbox{\hyperlink{class_catch_1_1_non_copyable}{\string~NonCopyable}}();}
\DoxyCodeLine{495     \};}
\DoxyCodeLine{496 }
\DoxyCodeLine{497     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \{}
\DoxyCodeLine{498 }
\DoxyCodeLine{499         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}() = \textcolor{keyword}{delete};}
\DoxyCodeLine{500         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \_file, std::size\_t \_line ) noexcept}
\DoxyCodeLine{501         :   \mbox{\hyperlink{classfile}{file}}( \_file ),}
\DoxyCodeLine{502             line( \_line )}
\DoxyCodeLine{503         \{\}}
\DoxyCodeLine{504 }
\DoxyCodeLine{505         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}( \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& other )            = \textcolor{keywordflow}{default};}
\DoxyCodeLine{506         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}\& operator = ( \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{507         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}( \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}\&\& )              \textcolor{keyword}{noexcept} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{508         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}\& operator = ( \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}\&\& ) \textcolor{keyword}{noexcept} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{509 }
\DoxyCodeLine{510         \textcolor{keywordtype}{bool} empty() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classfile}{file}}[0] == \textcolor{charliteral}{'\(\backslash\)0'}; \}}
\DoxyCodeLine{511         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept};}
\DoxyCodeLine{512         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept};}
\DoxyCodeLine{513 }
\DoxyCodeLine{514         \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \mbox{\hyperlink{classfile}{file}};}
\DoxyCodeLine{515         std::size\_t line;}
\DoxyCodeLine{516     \};}
\DoxyCodeLine{517 }
\DoxyCodeLine{518     std::ostream\& operator << ( std::ostream\& os, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& info );}
\DoxyCodeLine{519 }
\DoxyCodeLine{520     \textcolor{comment}{// Bring in operator<< from global namespace into Catch namespace}}
\DoxyCodeLine{521     \textcolor{comment}{// This is necessary because the overload of operator<< above makes}}
\DoxyCodeLine{522     \textcolor{comment}{// lookup stop at namespace Catch}}
\DoxyCodeLine{523     using ::operator<<;}
\DoxyCodeLine{524 }
\DoxyCodeLine{525     \textcolor{comment}{// Use this in variadic streaming macros to allow}}
\DoxyCodeLine{526     \textcolor{comment}{//    >> +StreamEndStop}}
\DoxyCodeLine{527     \textcolor{comment}{// as well as}}
\DoxyCodeLine{528     \textcolor{comment}{//    >> stuff +StreamEndStop}}
\DoxyCodeLine{529     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_stream_end_stop}{StreamEndStop}} \{}
\DoxyCodeLine{530         std::string operator+() \textcolor{keyword}{const};}
\DoxyCodeLine{531     \};}
\DoxyCodeLine{532     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{533     T \textcolor{keyword}{const}\& operator + ( T \textcolor{keyword}{const}\& value, \mbox{\hyperlink{struct_catch_1_1_stream_end_stop}{StreamEndStop}} ) \{}
\DoxyCodeLine{534         \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{535     \}}
\DoxyCodeLine{536 \}}
\DoxyCodeLine{537 }
\DoxyCodeLine{538 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_LINEINFO \(\backslash\)}}
\DoxyCodeLine{539 \textcolor{preprocessor}{    ::Catch::SourceLineInfo( \_\_FILE\_\_, static\_cast<std::size\_t>( \_\_LINE\_\_ ) )}}
\DoxyCodeLine{540 }
\DoxyCodeLine{541 \textcolor{comment}{// end catch\_common.h}}
\DoxyCodeLine{542 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{543 }
\DoxyCodeLine{544     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_registrar_for_tag_aliases}{RegistrarForTagAliases}} \{}
\DoxyCodeLine{545         \mbox{\hyperlink{struct_catch_1_1_registrar_for_tag_aliases}{RegistrarForTagAliases}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* alias, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* tag, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{546     \};}
\DoxyCodeLine{547 }
\DoxyCodeLine{548 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{549 }
\DoxyCodeLine{550 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_TAG\_ALIAS( alias, spec ) \(\backslash\)}}
\DoxyCodeLine{551 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{552 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{553 \textcolor{preprocessor}{    namespace\{ Catch::RegistrarForTagAliases INTERNAL\_CATCH\_UNIQUE\_NAME( AutoRegisterTagAlias )( alias, spec, CATCH\_INTERNAL\_LINEINFO ); \} \(\backslash\)}}
\DoxyCodeLine{554 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{555 }
\DoxyCodeLine{556 \textcolor{comment}{// end catch\_tag\_alias\_autoregistrar.h}}
\DoxyCodeLine{557 \textcolor{comment}{// start catch\_test\_registry.h}}
\DoxyCodeLine{558 }
\DoxyCodeLine{559 \textcolor{comment}{// start catch\_interfaces\_testcase.h}}
\DoxyCodeLine{560 }
\DoxyCodeLine{561 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{562 }
\DoxyCodeLine{563 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{564 }
\DoxyCodeLine{565     \textcolor{keyword}{class }TestSpec;}
\DoxyCodeLine{566 }
\DoxyCodeLine{567     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{ITestInvoker}} \{}
\DoxyCodeLine{568         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} invoke () \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{569         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{\string~ITestInvoker}}();}
\DoxyCodeLine{570     \};}
\DoxyCodeLine{571 }
\DoxyCodeLine{572     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}};}
\DoxyCodeLine{573     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_config}{IConfig}};}
\DoxyCodeLine{574 }
\DoxyCodeLine{575     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_test_case_registry}{ITestCaseRegistry}} \{}
\DoxyCodeLine{576         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_test_case_registry}{\string~ITestCaseRegistry}}();}
\DoxyCodeLine{577         \textcolor{keyword}{virtual} std::vector<TestCase> \textcolor{keyword}{const}\& getAllTests() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{578         \textcolor{keyword}{virtual} std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestsSorted( \mbox{\hyperlink{struct_catch_1_1_i_config}{IConfig}} \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{579     \};}
\DoxyCodeLine{580 }
\DoxyCodeLine{581     \textcolor{keywordtype}{bool} isThrowSafe( \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} \textcolor{keyword}{const}\& testCase, \mbox{\hyperlink{struct_catch_1_1_i_config}{IConfig}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{582     \textcolor{keywordtype}{bool} matchTest( \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} \textcolor{keyword}{const}\& testCase, TestSpec \textcolor{keyword}{const}\& testSpec, \mbox{\hyperlink{struct_catch_1_1_i_config}{IConfig}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{583     std::vector<TestCase> filterTests( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, TestSpec \textcolor{keyword}{const}\& testSpec, \mbox{\hyperlink{struct_catch_1_1_i_config}{IConfig}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{584     std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestCasesSorted( \mbox{\hyperlink{struct_catch_1_1_i_config}{IConfig}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{585 }
\DoxyCodeLine{586 \}}
\DoxyCodeLine{587 }
\DoxyCodeLine{588 \textcolor{comment}{// end catch\_interfaces\_testcase.h}}
\DoxyCodeLine{589 \textcolor{comment}{// start catch\_stringref.h}}
\DoxyCodeLine{590 }
\DoxyCodeLine{591 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{592 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{593 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{594 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{595 }
\DoxyCodeLine{596 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{597 }
\DoxyCodeLine{601     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \{}
\DoxyCodeLine{602     \textcolor{keyword}{public}:}
\DoxyCodeLine{603         \textcolor{keyword}{using} size\_type = std::size\_t;}
\DoxyCodeLine{604         \textcolor{keyword}{using} const\_iterator = \textcolor{keyword}{const} \textcolor{keywordtype}{char}*;}
\DoxyCodeLine{605 }
\DoxyCodeLine{606     \textcolor{keyword}{private}:}
\DoxyCodeLine{607         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \textcolor{keyword}{const} s\_empty = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{608 }
\DoxyCodeLine{609         \textcolor{keywordtype}{char} \textcolor{keyword}{const}* m\_start = s\_empty;}
\DoxyCodeLine{610         size\_type m\_size = 0;}
\DoxyCodeLine{611 }
\DoxyCodeLine{612     \textcolor{keyword}{public}: \textcolor{comment}{// construction}}
\DoxyCodeLine{613         \textcolor{keyword}{constexpr} \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}}() \textcolor{keyword}{noexcept} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{614 }
\DoxyCodeLine{615         \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{616 }
\DoxyCodeLine{617         \textcolor{keyword}{constexpr} \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars, size\_type size ) noexcept}
\DoxyCodeLine{618         :   m\_start( rawChars ),}
\DoxyCodeLine{619             m\_size( size )}
\DoxyCodeLine{620         \{\}}
\DoxyCodeLine{621 }
\DoxyCodeLine{622         \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}}( std::string \textcolor{keyword}{const}\& stdString ) noexcept}
\DoxyCodeLine{623         :   m\_start( stdString.c\_str() ),}
\DoxyCodeLine{624             m\_size( stdString.size() )}
\DoxyCodeLine{625         \{\}}
\DoxyCodeLine{626 }
\DoxyCodeLine{627         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} std::string()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{628             \textcolor{keywordflow}{return} std::string(m\_start, m\_size);}
\DoxyCodeLine{629         \}}
\DoxyCodeLine{630 }
\DoxyCodeLine{631     \textcolor{keyword}{public}: \textcolor{comment}{// operators}}
\DoxyCodeLine{632         \textcolor{keyword}{auto} operator == ( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> bool;}
\DoxyCodeLine{633         \textcolor{keyword}{auto} operator != (\mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{634             \textcolor{keywordflow}{return} !(*\textcolor{keyword}{this} == other);}
\DoxyCodeLine{635         \}}
\DoxyCodeLine{636 }
\DoxyCodeLine{637         \textcolor{keyword}{auto} operator[] ( size\_type index ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{char} \{}
\DoxyCodeLine{638             assert(index < m\_size);}
\DoxyCodeLine{639             \textcolor{keywordflow}{return} m\_start[index];}
\DoxyCodeLine{640         \}}
\DoxyCodeLine{641 }
\DoxyCodeLine{642     \textcolor{keyword}{public}: \textcolor{comment}{// named queries}}
\DoxyCodeLine{643         \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} empty() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{644             \textcolor{keywordflow}{return} m\_size == 0;}
\DoxyCodeLine{645         \}}
\DoxyCodeLine{646         \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} size() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> size\_type \{}
\DoxyCodeLine{647             \textcolor{keywordflow}{return} m\_size;}
\DoxyCodeLine{648         \}}
\DoxyCodeLine{649 }
\DoxyCodeLine{650         \textcolor{comment}{// Returns the current start pointer. If the StringRef is not}}
\DoxyCodeLine{651         \textcolor{comment}{// null-\/terminated, throws std::domain\_exception}}
\DoxyCodeLine{652         \textcolor{keyword}{auto} c\_str() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{char} \textcolor{keyword}{const}*;}
\DoxyCodeLine{653 }
\DoxyCodeLine{654     \textcolor{keyword}{public}: \textcolor{comment}{// substrings and searches}}
\DoxyCodeLine{655         \textcolor{comment}{// Returns a substring of [start, start + length).}}
\DoxyCodeLine{656         \textcolor{comment}{// If start + length > size(), then the substring is [start, size()).}}
\DoxyCodeLine{657         \textcolor{comment}{// If start > size(), then the substring is empty.}}
\DoxyCodeLine{658         \textcolor{keyword}{auto} substr( size\_type start, size\_type length ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}};}
\DoxyCodeLine{659 }
\DoxyCodeLine{660         \textcolor{comment}{// Returns the current start pointer. May not be null-\/terminated.}}
\DoxyCodeLine{661         \textcolor{keyword}{auto} data() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{char} \textcolor{keyword}{const}*;}
\DoxyCodeLine{662 }
\DoxyCodeLine{663         \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} isNullTerminated() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{664             \textcolor{keywordflow}{return} m\_start[m\_size] == \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{665         \}}
\DoxyCodeLine{666 }
\DoxyCodeLine{667     \textcolor{keyword}{public}: \textcolor{comment}{// iterators}}
\DoxyCodeLine{668         \textcolor{keyword}{constexpr} const\_iterator begin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_start; \}}
\DoxyCodeLine{669         \textcolor{keyword}{constexpr} const\_iterator end()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_start + m\_size; \}}
\DoxyCodeLine{670     \};}
\DoxyCodeLine{671 }
\DoxyCodeLine{672     \textcolor{keyword}{auto} operator += ( std::string\& lhs, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& sr ) -\/> std::string\&;}
\DoxyCodeLine{673     \textcolor{keyword}{auto} operator << ( std::ostream\& os, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& sr ) -\/> std::ostream\&;}
\DoxyCodeLine{674 }
\DoxyCodeLine{675     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_sr( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars, std::size\_t size ) \textcolor{keyword}{noexcept} -\/> \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \{}
\DoxyCodeLine{676         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}}( rawChars, size );}
\DoxyCodeLine{677     \}}
\DoxyCodeLine{678 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{679 }
\DoxyCodeLine{680 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_catch\_sr( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars, std::size\_t size ) \textcolor{keyword}{noexcept} -\/> \mbox{\hyperlink{class_catch_1_1_string_ref}{Catch::StringRef}} \{}
\DoxyCodeLine{681     \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_string_ref}{Catch::StringRef}}( rawChars, size );}
\DoxyCodeLine{682 \}}
\DoxyCodeLine{683 }
\DoxyCodeLine{684 \textcolor{comment}{// end catch\_stringref.h}}
\DoxyCodeLine{685 \textcolor{comment}{// start catch\_preprocessor.hpp}}
\DoxyCodeLine{686 }
\DoxyCodeLine{687 }
\DoxyCodeLine{688 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL0(...) \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{689 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL1(...) CATCH\_RECURSION\_LEVEL0(CATCH\_RECURSION\_LEVEL0(CATCH\_RECURSION\_LEVEL0(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{690 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL2(...) CATCH\_RECURSION\_LEVEL1(CATCH\_RECURSION\_LEVEL1(CATCH\_RECURSION\_LEVEL1(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{691 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL3(...) CATCH\_RECURSION\_LEVEL2(CATCH\_RECURSION\_LEVEL2(CATCH\_RECURSION\_LEVEL2(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{692 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL4(...) CATCH\_RECURSION\_LEVEL3(CATCH\_RECURSION\_LEVEL3(CATCH\_RECURSION\_LEVEL3(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{693 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL5(...) CATCH\_RECURSION\_LEVEL4(CATCH\_RECURSION\_LEVEL4(CATCH\_RECURSION\_LEVEL4(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{694 }
\DoxyCodeLine{695 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{696 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_EXPAND\_VARGS(...) \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{697 \textcolor{comment}{// MSVC needs more evaluations}}
\DoxyCodeLine{698 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL6(...) CATCH\_RECURSION\_LEVEL5(CATCH\_RECURSION\_LEVEL5(CATCH\_RECURSION\_LEVEL5(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{699 \textcolor{preprocessor}{\#define CATCH\_RECURSE(...)  CATCH\_RECURSION\_LEVEL6(CATCH\_RECURSION\_LEVEL6(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{700 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{701 \textcolor{preprocessor}{\#define CATCH\_RECURSE(...)  CATCH\_RECURSION\_LEVEL5(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{702 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{703 }
\DoxyCodeLine{704 \textcolor{preprocessor}{\#define CATCH\_REC\_END(...)}}
\DoxyCodeLine{705 \textcolor{preprocessor}{\#define CATCH\_REC\_OUT}}
\DoxyCodeLine{706 }
\DoxyCodeLine{707 \textcolor{preprocessor}{\#define CATCH\_EMPTY()}}
\DoxyCodeLine{708 \textcolor{preprocessor}{\#define CATCH\_DEFER(id) id CATCH\_EMPTY()}}
\DoxyCodeLine{709 }
\DoxyCodeLine{710 \textcolor{preprocessor}{\#define CATCH\_REC\_GET\_END2() 0, CATCH\_REC\_END}}
\DoxyCodeLine{711 \textcolor{preprocessor}{\#define CATCH\_REC\_GET\_END1(...) CATCH\_REC\_GET\_END2}}
\DoxyCodeLine{712 \textcolor{preprocessor}{\#define CATCH\_REC\_GET\_END(...) CATCH\_REC\_GET\_END1}}
\DoxyCodeLine{713 \textcolor{preprocessor}{\#define CATCH\_REC\_NEXT0(test, next, ...) next CATCH\_REC\_OUT}}
\DoxyCodeLine{714 \textcolor{preprocessor}{\#define CATCH\_REC\_NEXT1(test, next) CATCH\_DEFER ( CATCH\_REC\_NEXT0 ) ( test, next, 0)}}
\DoxyCodeLine{715 \textcolor{preprocessor}{\#define CATCH\_REC\_NEXT(test, next)  CATCH\_REC\_NEXT1(CATCH\_REC\_GET\_END test, next)}}
\DoxyCodeLine{716 }
\DoxyCodeLine{717 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST0(f, x, peek, ...) , f(x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1) ) ( f, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{718 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST1(f, x, peek, ...) , f(x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST0) ) ( f, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{719 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST2(f, x, peek, ...)   f(x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1) ) ( f, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{720 }
\DoxyCodeLine{721 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST0\_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1\_UD) ) ( f, userdata, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{722 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST1\_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST0\_UD) ) ( f, userdata, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{723 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST2\_UD(f, userdata, x, peek, ...)   f(userdata, x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1\_UD) ) ( f, userdata, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{724 }
\DoxyCodeLine{725 \textcolor{comment}{// Applies the function macro `f` to each of the remaining parameters, inserts commas between the results,}}
\DoxyCodeLine{726 \textcolor{comment}{// and passes userdata as the first parameter to each invocation,}}
\DoxyCodeLine{727 \textcolor{comment}{// e.g. CATCH\_REC\_LIST\_UD(f, x, a, b, c) evaluates to f(x, a), f(x, b), f(x, c)}}
\DoxyCodeLine{728 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST\_UD(f, userdata, ...) CATCH\_RECURSE(CATCH\_REC\_LIST2\_UD(f, userdata, \_\_VA\_ARGS\_\_, ()()(), ()()(), ()()(), 0))}}
\DoxyCodeLine{729 }
\DoxyCodeLine{730 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST(f, ...) CATCH\_RECURSE(CATCH\_REC\_LIST2(f, \_\_VA\_ARGS\_\_, ()()(), ()()(), ()()(), 0))}}
\DoxyCodeLine{731 }
\DoxyCodeLine{732 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_EXPAND1(param) INTERNAL\_CATCH\_EXPAND2(param)}}
\DoxyCodeLine{733 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_EXPAND2(...) INTERNAL\_CATCH\_NO\#\# \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{734 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEF(...) INTERNAL\_CATCH\_DEF \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{735 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NOINTERNAL\_CATCH\_DEF}}
\DoxyCodeLine{736 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE(...) INTERNAL\_CATCH\_STRINGIZE2(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{737 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{738 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE2(...) \#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{739 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS(param) INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_REMOVE\_PARENS(param))}}
\DoxyCodeLine{740 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{741 \textcolor{comment}{// MSVC is adding extra space and needs another indirection to expand INTERNAL\_CATCH\_NOINTERNAL\_CATCH\_DEF}}
\DoxyCodeLine{742 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE2(...) INTERNAL\_CATCH\_STRINGIZE3(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{743 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE3(...) \#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{744 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS(param) (INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_REMOVE\_PARENS(param)) + 1)}}
\DoxyCodeLine{745 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{746 }
\DoxyCodeLine{747 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_NAMESPACE2(...) ns\_\#\#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{748 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_NAMESPACE(name) INTERNAL\_CATCH\_MAKE\_NAMESPACE2(name)}}
\DoxyCodeLine{749 }
\DoxyCodeLine{750 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS(...) INTERNAL\_CATCH\_EXPAND1(INTERNAL\_CATCH\_DEF \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{751 }
\DoxyCodeLine{752 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{753 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LIST2(...) decltype(get\_wrapper<INTERNAL\_CATCH\_REMOVE\_PARENS\_GEN(\_\_VA\_ARGS\_\_)>())}}
\DoxyCodeLine{754 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LIST(...) INTERNAL\_CATCH\_MAKE\_TYPE\_LIST2(INTERNAL\_CATCH\_REMOVE\_PARENS(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{755 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{756 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LIST2(...) INTERNAL\_CATCH\_EXPAND\_VARGS(decltype(get\_wrapper<INTERNAL\_CATCH\_REMOVE\_PARENS\_GEN(\_\_VA\_ARGS\_\_)>()))}}
\DoxyCodeLine{757 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LIST(...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_MAKE\_TYPE\_LIST2(INTERNAL\_CATCH\_REMOVE\_PARENS(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{758 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{759 }
\DoxyCodeLine{760 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(...)\(\backslash\)}}
\DoxyCodeLine{761 \textcolor{preprocessor}{    CATCH\_REC\_LIST(INTERNAL\_CATCH\_MAKE\_TYPE\_LIST,\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{762 }
\DoxyCodeLine{763 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_1\_ARG(\_0) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0)}}
\DoxyCodeLine{764 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_2\_ARG(\_0, \_1) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_1\_ARG(\_1)}}
\DoxyCodeLine{765 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_3\_ARG(\_0, \_1, \_2) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_2\_ARG(\_1, \_2)}}
\DoxyCodeLine{766 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_4\_ARG(\_0, \_1, \_2, \_3) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_3\_ARG(\_1, \_2, \_3)}}
\DoxyCodeLine{767 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_5\_ARG(\_0, \_1, \_2, \_3, \_4) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_4\_ARG(\_1, \_2, \_3, \_4)}}
\DoxyCodeLine{768 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_6\_ARG(\_0, \_1, \_2, \_3, \_4, \_5) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_5\_ARG(\_1, \_2, \_3, \_4, \_5)}}
\DoxyCodeLine{769 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_7\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_6\_ARG(\_1, \_2, \_3, \_4, \_5, \_6)}}
\DoxyCodeLine{770 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_8\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_7\_ARG(\_1, \_2, \_3, \_4, \_5, \_6, \_7)}}
\DoxyCodeLine{771 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_9\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_8\_ARG(\_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8)}}
\DoxyCodeLine{772 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_10\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_9\_ARG(\_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9)}}
\DoxyCodeLine{773 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_11\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9, \_10) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_10\_ARG(\_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9, \_10)}}
\DoxyCodeLine{774 }
\DoxyCodeLine{775 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9, \_10, N, ...) N}}
\DoxyCodeLine{776 }
\DoxyCodeLine{777 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{778 \textcolor{preprocessor}{    template<typename...> struct TypeList \{\};\(\backslash\)}}
\DoxyCodeLine{779 \textcolor{preprocessor}{    template<typename...Ts>\(\backslash\)}}
\DoxyCodeLine{780 \textcolor{preprocessor}{    constexpr auto get\_wrapper() noexcept -\/> TypeList<Ts...> \{ return \{\}; \}\(\backslash\)}}
\DoxyCodeLine{781 \textcolor{preprocessor}{    template<template<typename...> class...> struct TemplateTypeList\{\};\(\backslash\)}}
\DoxyCodeLine{782 \textcolor{preprocessor}{    template<template<typename...> class...Cs>\(\backslash\)}}
\DoxyCodeLine{783 \textcolor{preprocessor}{    constexpr auto get\_wrapper() noexcept -\/> TemplateTypeList<Cs...> \{ return \{\}; \}\(\backslash\)}}
\DoxyCodeLine{784 \textcolor{preprocessor}{    template<typename...>\(\backslash\)}}
\DoxyCodeLine{785 \textcolor{preprocessor}{    struct append;\(\backslash\)}}
\DoxyCodeLine{786 \textcolor{preprocessor}{    template<typename...>\(\backslash\)}}
\DoxyCodeLine{787 \textcolor{preprocessor}{    struct rewrap;\(\backslash\)}}
\DoxyCodeLine{788 \textcolor{preprocessor}{    template<template<typename...> class, typename...>\(\backslash\)}}
\DoxyCodeLine{789 \textcolor{preprocessor}{    struct create;\(\backslash\)}}
\DoxyCodeLine{790 \textcolor{preprocessor}{    template<template<typename...> class, typename>\(\backslash\)}}
\DoxyCodeLine{791 \textcolor{preprocessor}{    struct convert;\(\backslash\)}}
\DoxyCodeLine{792 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{793 \textcolor{preprocessor}{    template<typename T> \(\backslash\)}}
\DoxyCodeLine{794 \textcolor{preprocessor}{    struct append<T> \{ using type = T; \};\(\backslash\)}}
\DoxyCodeLine{795 \textcolor{preprocessor}{    template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\(\backslash\)}}
\DoxyCodeLine{796 \textcolor{preprocessor}{    struct append<L1<E1...>, L2<E2...>, Rest...> \{ using type = typename append<L1<E1...,E2...>, Rest...>::type; \};\(\backslash\)}}
\DoxyCodeLine{797 \textcolor{preprocessor}{    template< template<typename...> class L1, typename...E1, typename...Rest>\(\backslash\)}}
\DoxyCodeLine{798 \textcolor{preprocessor}{    struct append<L1<E1...>, TypeList<mpl\_::na>, Rest...> \{ using type = L1<E1...>; \};\(\backslash\)}}
\DoxyCodeLine{799 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{800 \textcolor{preprocessor}{    template< template<typename...> class Container, template<typename...> class List, typename...elems>\(\backslash\)}}
\DoxyCodeLine{801 \textcolor{preprocessor}{    struct rewrap<TemplateTypeList<Container>, List<elems...>> \{ using type = TypeList<Container<elems...>>; \};\(\backslash\)}}
\DoxyCodeLine{802 \textcolor{preprocessor}{    template< template<typename...> class Container, template<typename...> class List, class...Elems, typename...Elements>\(\backslash\)}}
\DoxyCodeLine{803 \textcolor{preprocessor}{    struct rewrap<TemplateTypeList<Container>, List<Elems...>, Elements...> \{ using type = typename append<TypeList<Container<Elems...>>, typename rewrap<TemplateTypeList<Container>, Elements...>::type>::type; \};\(\backslash\)}}
\DoxyCodeLine{804 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{805 \textcolor{preprocessor}{    template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\(\backslash\)}}
\DoxyCodeLine{806 \textcolor{preprocessor}{    struct create<Final, TemplateTypeList<Containers...>, TypeList<Types...>> \{ using type = typename append<Final<>, typename rewrap<TemplateTypeList<Containers>, Types...>::type...>::type; \};\(\backslash\)}}
\DoxyCodeLine{807 \textcolor{preprocessor}{    template<template <typename...> class Final, template <typename...> class List, typename...Ts>\(\backslash\)}}
\DoxyCodeLine{808 \textcolor{preprocessor}{    struct convert<Final, List<Ts...>> \{ using type = typename append<Final<>,TypeList<Ts>...>::type; \};}}
\DoxyCodeLine{809 }
\DoxyCodeLine{810 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_1(signature, ...)\(\backslash\)}}
\DoxyCodeLine{811 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> struct Nttp\{\};\(\backslash\)}}
\DoxyCodeLine{812 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{813 \textcolor{preprocessor}{    constexpr auto get\_wrapper() noexcept -\/> Nttp<\_\_VA\_ARGS\_\_> \{ return \{\}; \} \(\backslash\)}}
\DoxyCodeLine{814 \textcolor{preprocessor}{    template<template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class...> struct NttpTemplateTypeList\{\};\(\backslash\)}}
\DoxyCodeLine{815 \textcolor{preprocessor}{    template<template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class...Cs>\(\backslash\)}}
\DoxyCodeLine{816 \textcolor{preprocessor}{    constexpr auto get\_wrapper() noexcept -\/> NttpTemplateTypeList<Cs...> \{ return \{\}; \} \(\backslash\)}}
\DoxyCodeLine{817 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{818 \textcolor{preprocessor}{    template< template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class Container, template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class List, INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{819 \textcolor{preprocessor}{    struct rewrap<NttpTemplateTypeList<Container>, List<\_\_VA\_ARGS\_\_>> \{ using type = TypeList<Container<\_\_VA\_ARGS\_\_>>; \};\(\backslash\)}}
\DoxyCodeLine{820 \textcolor{preprocessor}{    template< template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class Container, template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class List, INTERNAL\_CATCH\_REMOVE\_PARENS(signature), typename...Elements>\(\backslash\)}}
\DoxyCodeLine{821 \textcolor{preprocessor}{    struct rewrap<NttpTemplateTypeList<Container>, List<\_\_VA\_ARGS\_\_>, Elements...> \{ using type = typename append<TypeList<Container<\_\_VA\_ARGS\_\_>>, typename rewrap<NttpTemplateTypeList<Container>, Elements...>::type>::type; \};\(\backslash\)}}
\DoxyCodeLine{822 \textcolor{preprocessor}{    template<template <typename...> class Final, template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class...Containers, typename...Types>\(\backslash\)}}
\DoxyCodeLine{823 \textcolor{preprocessor}{    struct create<Final, NttpTemplateTypeList<Containers...>, TypeList<Types...>> \{ using type = typename append<Final<>, typename rewrap<NttpTemplateTypeList<Containers>, Types...>::type...>::type; \};}}
\DoxyCodeLine{824 }
\DoxyCodeLine{825 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST0(TestName)}}
\DoxyCodeLine{826 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST1(TestName, signature)\(\backslash\)}}
\DoxyCodeLine{827 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{828 \textcolor{preprocessor}{    static void TestName()}}
\DoxyCodeLine{829 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X(TestName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{830 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{831 \textcolor{preprocessor}{    static void TestName()}}
\DoxyCodeLine{832 }
\DoxyCodeLine{833 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST0(TestName)}}
\DoxyCodeLine{834 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST1(TestName, signature)\(\backslash\)}}
\DoxyCodeLine{835 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{836 \textcolor{preprocessor}{    static void TestName()}}
\DoxyCodeLine{837 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X(TestName, signature,...)\(\backslash\)}}
\DoxyCodeLine{838 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{839 \textcolor{preprocessor}{    static void TestName()}}
\DoxyCodeLine{840 }
\DoxyCodeLine{841 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REGISTER0(TestFunc, signature)\(\backslash\)}}
\DoxyCodeLine{842 \textcolor{preprocessor}{    template<typename Type>\(\backslash\)}}
\DoxyCodeLine{843 \textcolor{preprocessor}{    void reg\_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\(\backslash\)}}
\DoxyCodeLine{844 \textcolor{preprocessor}{    \{\(\backslash\)}}
\DoxyCodeLine{845 \textcolor{preprocessor}{        Catch::AutoReg( Catch::makeTestInvoker(\&TestFunc<Type>), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), nameAndTags);\(\backslash\)}}
\DoxyCodeLine{846 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{847 }
\DoxyCodeLine{848 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REGISTER(TestFunc, signature, ...)\(\backslash\)}}
\DoxyCodeLine{849 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{850 \textcolor{preprocessor}{    void reg\_test(Nttp<\_\_VA\_ARGS\_\_>, Catch::NameAndTags nameAndTags)\(\backslash\)}}
\DoxyCodeLine{851 \textcolor{preprocessor}{    \{\(\backslash\)}}
\DoxyCodeLine{852 \textcolor{preprocessor}{        Catch::AutoReg( Catch::makeTestInvoker(\&TestFunc<\_\_VA\_ARGS\_\_>), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), nameAndTags);\(\backslash\)}}
\DoxyCodeLine{853 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{854 }
\DoxyCodeLine{855 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0(TestName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{856 \textcolor{preprocessor}{    template<typename Type>\(\backslash\)}}
\DoxyCodeLine{857 \textcolor{preprocessor}{    void reg\_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\(\backslash\)}}
\DoxyCodeLine{858 \textcolor{preprocessor}{    \{\(\backslash\)}}
\DoxyCodeLine{859 \textcolor{preprocessor}{        Catch::AutoReg( Catch::makeTestInvoker(\&TestName<Type>::test), CATCH\_INTERNAL\_LINEINFO, className, nameAndTags);\(\backslash\)}}
\DoxyCodeLine{860 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{861 }
\DoxyCodeLine{862 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD(TestName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{863 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{864 \textcolor{preprocessor}{    void reg\_test(Nttp<\_\_VA\_ARGS\_\_>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\(\backslash\)}}
\DoxyCodeLine{865 \textcolor{preprocessor}{    \{\(\backslash\)}}
\DoxyCodeLine{866 \textcolor{preprocessor}{        Catch::AutoReg( Catch::makeTestInvoker(\&TestName<\_\_VA\_ARGS\_\_>::test), CATCH\_INTERNAL\_LINEINFO, className, nameAndTags);\(\backslash\)}}
\DoxyCodeLine{867 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{868 }
\DoxyCodeLine{869 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD0(TestName, ClassName)}}
\DoxyCodeLine{870 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD1(TestName, ClassName, signature)\(\backslash\)}}
\DoxyCodeLine{871 \textcolor{preprocessor}{    template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{872 \textcolor{preprocessor}{    struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName)<TestType> \{ \(\backslash\)}}
\DoxyCodeLine{873 \textcolor{preprocessor}{        void test();\(\backslash\)}}
\DoxyCodeLine{874 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{875 }
\DoxyCodeLine{876 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X(TestName, ClassName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{877 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> \(\backslash\)}}
\DoxyCodeLine{878 \textcolor{preprocessor}{    struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName)<\_\_VA\_ARGS\_\_> \{ \(\backslash\)}}
\DoxyCodeLine{879 \textcolor{preprocessor}{        void test();\(\backslash\)}}
\DoxyCodeLine{880 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{881 }
\DoxyCodeLine{882 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD0(TestName)}}
\DoxyCodeLine{883 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD1(TestName, signature)\(\backslash\)}}
\DoxyCodeLine{884 \textcolor{preprocessor}{    template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{885 \textcolor{preprocessor}{    void INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)::TestName<TestType>::test()}}
\DoxyCodeLine{886 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X(TestName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{887 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> \(\backslash\)}}
\DoxyCodeLine{888 \textcolor{preprocessor}{    void INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)::TestName<\_\_VA\_ARGS\_\_>::test()}}
\DoxyCodeLine{889 }
\DoxyCodeLine{890 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{891 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_0}}
\DoxyCodeLine{892 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_GEN(...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_),INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_0)}}
\DoxyCodeLine{893 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD(TestName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD1, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD0)(TestName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{894 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD(TestName, ClassName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD1, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD0)(TestName, ClassName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{895 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REG\_METHOD\_GEN(TestName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0)(TestName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{896 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REG\_GEN(TestFunc, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER0, INTERNAL\_CATCH\_NTTP\_REGISTER0)(TestFunc, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{897 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST(TestName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST1, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST0)(TestName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{898 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST(TestName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST1, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST0)(TestName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{899 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_GEN(...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_REMOVE\_PARENS\_11\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_10\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_9\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_8\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_7\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_6\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_5\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_4\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_3\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_2\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_1\_ARG)(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{900 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{901 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_0(signature)}}
\DoxyCodeLine{902 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_GEN(...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1,INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_0)( \_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{903 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD(TestName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD1, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD0)(TestName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{904 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD(TestName, ClassName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD1, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD0)(TestName, ClassName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{905 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REG\_METHOD\_GEN(TestName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0)(TestName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{906 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REG\_GEN(TestFunc, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER0, INTERNAL\_CATCH\_NTTP\_REGISTER0)(TestFunc, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{907 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST(TestName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST1, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST0)(TestName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{908 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST(TestName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST1, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST0)(TestName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{909 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_GEN(...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_REMOVE\_PARENS\_11\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_10\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_9\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_8\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_7\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_6\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_5\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_4\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_3\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_2\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_1\_ARG)(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{910 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{911 }
\DoxyCodeLine{912 \textcolor{comment}{// end catch\_preprocessor.hpp}}
\DoxyCodeLine{913 \textcolor{comment}{// start catch\_meta.hpp}}
\DoxyCodeLine{914 }
\DoxyCodeLine{915 }
\DoxyCodeLine{916 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{917 }
\DoxyCodeLine{918 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{919     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{920     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false}} : std::false\_type \{\};}
\DoxyCodeLine{921 }
\DoxyCodeLine{922     \textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1true__given}{true\_given}} : std::true\_type \{\};}
\DoxyCodeLine{923     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1is__callable__tester}{is\_callable\_tester}} \{}
\DoxyCodeLine{924         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{925         \mbox{\hyperlink{struct_catch_1_1true__given}{true\_given<decltype(std::declval<Fun>}}()(std::declval<Args>()...))> \textcolor{keyword}{static} test(\textcolor{keywordtype}{int});}
\DoxyCodeLine{926         \textcolor{keyword}{template} <\textcolor{keyword}{typename}...>}
\DoxyCodeLine{927         std::false\_type \textcolor{keyword}{static} test(...);}
\DoxyCodeLine{928     \};}
\DoxyCodeLine{929 }
\DoxyCodeLine{930     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{931     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1is__callable}{is\_callable}};}
\DoxyCodeLine{932 }
\DoxyCodeLine{933     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{934     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1is__callable}{is\_callable}}<Fun(Args...)> : decltype(is\_callable\_tester::test<Fun, Args...>(0)) \{\};}
\DoxyCodeLine{935 }
\DoxyCodeLine{936 \textcolor{preprocessor}{\#if defined(\_\_cpp\_lib\_is\_invocable) \&\& \_\_cpp\_lib\_is\_invocable >= 201703}}
\DoxyCodeLine{937     \textcolor{comment}{// std::result\_of is deprecated in C++17 and removed in C++20. Hence, it is}}
\DoxyCodeLine{938     \textcolor{comment}{// replaced with std::invoke\_result here.}}
\DoxyCodeLine{939     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename}... U>}
\DoxyCodeLine{940     \textcolor{keyword}{using} FunctionReturnType = std::remove\_reference\_t<std::remove\_cv\_t<std::invoke\_result\_t<Func, U...>>>;}
\DoxyCodeLine{941 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{942     \textcolor{comment}{// Keep ::type here because we still support C++11}}
\DoxyCodeLine{943     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename}... U>}
\DoxyCodeLine{944     \textcolor{keyword}{using} FunctionReturnType = \textcolor{keyword}{typename} std::remove\_reference<\textcolor{keyword}{typename} std::remove\_cv<\textcolor{keyword}{typename} std::result\_of<Func(U...)>::type>::type>::type;}
\DoxyCodeLine{945 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{946 }
\DoxyCodeLine{947 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{948 }
\DoxyCodeLine{949 \textcolor{keyword}{namespace }mpl\_\{}
\DoxyCodeLine{950     \textcolor{keyword}{struct }na;}
\DoxyCodeLine{951 \}}
\DoxyCodeLine{952 }
\DoxyCodeLine{953 \textcolor{comment}{// end catch\_meta.hpp}}
\DoxyCodeLine{954 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{955 }
\DoxyCodeLine{956 \textcolor{keyword}{template}<\textcolor{keyword}{typename} C>}
\DoxyCodeLine{957 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_test_invoker_as_method}{TestInvokerAsMethod}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{ITestInvoker}} \{}
\DoxyCodeLine{958     void (C::*m\_testAsMethod)();}
\DoxyCodeLine{959 \textcolor{keyword}{public}:}
\DoxyCodeLine{960     \mbox{\hyperlink{class_catch_1_1_test_invoker_as_method}{TestInvokerAsMethod}}( \textcolor{keywordtype}{void} (C::*testAsMethod)() ) noexcept : m\_testAsMethod( testAsMethod ) \{\}}
\DoxyCodeLine{961 }
\DoxyCodeLine{962     \textcolor{keywordtype}{void} invoke()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{963         C obj;}
\DoxyCodeLine{964         (obj.*m\_testAsMethod)();}
\DoxyCodeLine{965     \}}
\DoxyCodeLine{966 \};}
\DoxyCodeLine{967 }
\DoxyCodeLine{968 \textcolor{keyword}{auto} makeTestInvoker( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept -\/> \mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{ITestInvoker}}*;}
\DoxyCodeLine{969 }
\DoxyCodeLine{970 template<typename C>}
\DoxyCodeLine{971 auto makeTestInvoker( \textcolor{keywordtype}{void} (C::*testAsMethod)() ) noexcept -\/> \mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{ITestInvoker}}* \{}
\DoxyCodeLine{972     \textcolor{keywordflow}{return} \textcolor{keyword}{new}(std::nothrow) \mbox{\hyperlink{class_catch_1_1_test_invoker_as_method}{TestInvokerAsMethod<C>}}( testAsMethod );}
\DoxyCodeLine{973 \}}
\DoxyCodeLine{974 }
\DoxyCodeLine{975 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_name_and_tags}{NameAndTags}} \{}
\DoxyCodeLine{976     \mbox{\hyperlink{struct_catch_1_1_name_and_tags}{NameAndTags}}( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& name\_ = \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}}(), \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& tags\_ = \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}}() ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{977     \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} name;}
\DoxyCodeLine{978     \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} tags;}
\DoxyCodeLine{979 \};}
\DoxyCodeLine{980 }
\DoxyCodeLine{981 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_auto_reg}{AutoReg}} : \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \{}
\DoxyCodeLine{982     \mbox{\hyperlink{struct_catch_1_1_auto_reg}{AutoReg}}( \mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{ITestInvoker}}* invoker, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& classOrMethod, \mbox{\hyperlink{struct_catch_1_1_name_and_tags}{NameAndTags}} \textcolor{keyword}{const}\& nameAndTags ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{983     \mbox{\hyperlink{struct_catch_1_1_auto_reg}{\string~AutoReg}}();}
\DoxyCodeLine{984 \};}
\DoxyCodeLine{985 }
\DoxyCodeLine{986 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{987 }
\DoxyCodeLine{988 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{989 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION( TestName, ... ) \(\backslash\)}}
\DoxyCodeLine{990 \textcolor{preprocessor}{        static void TestName()}}
\DoxyCodeLine{991 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE\_METHOD\_NO\_REGISTRATION( TestName, ClassName, ... ) \(\backslash\)}}
\DoxyCodeLine{992 \textcolor{preprocessor}{        namespace\{                        \(\backslash\)}}
\DoxyCodeLine{993 \textcolor{preprocessor}{            struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName) \{ \(\backslash\)}}
\DoxyCodeLine{994 \textcolor{preprocessor}{                void test();              \(\backslash\)}}
\DoxyCodeLine{995 \textcolor{preprocessor}{            \};                            \(\backslash\)}}
\DoxyCodeLine{996 \textcolor{preprocessor}{        \}                                 \(\backslash\)}}
\DoxyCodeLine{997 \textcolor{preprocessor}{        void TestName::test()}}
\DoxyCodeLine{998 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( TestName, TestFunc, Name, Tags, Signature, ... )  \(\backslash\)}}
\DoxyCodeLine{999 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DEFINE\_SIG\_TEST(TestFunc, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))}}
\DoxyCodeLine{1000 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \(\backslash\)}}
\DoxyCodeLine{1001 \textcolor{preprocessor}{        namespace\{                                                                                  \(\backslash\)}}
\DoxyCodeLine{1002 \textcolor{preprocessor}{            namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName) \{                                      \(\backslash\)}}
\DoxyCodeLine{1003 \textcolor{preprocessor}{            INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD(TestName, ClassName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature));\(\backslash\)}}
\DoxyCodeLine{1004 \textcolor{preprocessor}{        \}                                                                                           \(\backslash\)}}
\DoxyCodeLine{1005 \textcolor{preprocessor}{        \}                                                                                           \(\backslash\)}}
\DoxyCodeLine{1006 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD(TestName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))}}
\DoxyCodeLine{1007 }
\DoxyCodeLine{1008 \textcolor{preprocessor}{    \#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1009 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(Name, Tags, ...) \(\backslash\)}}
\DoxyCodeLine{1010 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, typename TestType, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1011 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1012 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(Name, Tags, ...) \(\backslash\)}}
\DoxyCodeLine{1013 \textcolor{preprocessor}{            INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, typename TestType, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1014 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1015 }
\DoxyCodeLine{1016 \textcolor{preprocessor}{    \#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1017 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(Name, Tags, Signature, ...) \(\backslash\)}}
\DoxyCodeLine{1018 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1019 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1020 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(Name, Tags, Signature, ...) \(\backslash\)}}
\DoxyCodeLine{1021 \textcolor{preprocessor}{            INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1022 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1023 }
\DoxyCodeLine{1024 \textcolor{preprocessor}{    \#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1025 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION( ClassName, Name, Tags,... ) \(\backslash\)}}
\DoxyCodeLine{1026 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1027 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1028 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION( ClassName, Name, Tags,... ) \(\backslash\)}}
\DoxyCodeLine{1029 \textcolor{preprocessor}{            INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1030 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1031 }
\DoxyCodeLine{1032 \textcolor{preprocessor}{    \#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1033 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1034 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1035 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1036 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1037 \textcolor{preprocessor}{            INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1038 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1039 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1040 }
\DoxyCodeLine{1042 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE2( TestName, ... ) \(\backslash\)}}
\DoxyCodeLine{1043 \textcolor{preprocessor}{        static void TestName(); \(\backslash\)}}
\DoxyCodeLine{1044 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1045 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1046 \textcolor{preprocessor}{        namespace\{ Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( Catch::makeTestInvoker( \&TestName ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); \} }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1047 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1048 \textcolor{preprocessor}{        static void TestName()}}
\DoxyCodeLine{1049 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE( ... ) \(\backslash\)}}
\DoxyCodeLine{1050 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TESTCASE2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1051 }
\DoxyCodeLine{1053 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( QualifiedMethod, ... ) \(\backslash\)}}
\DoxyCodeLine{1054 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1055 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1056 \textcolor{preprocessor}{        namespace\{ Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( Catch::makeTestInvoker( \&QualifiedMethod ), CATCH\_INTERNAL\_LINEINFO, "{}\&"{}} \#QualifiedMethod, Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); \} \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1057 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{1058 }
\DoxyCodeLine{1060 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEST\_CASE\_METHOD2( TestName, ClassName, ... )\(\backslash\)}}
\DoxyCodeLine{1061 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1062 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1063 \textcolor{preprocessor}{        namespace\{ \(\backslash\)}}
\DoxyCodeLine{1064 \textcolor{preprocessor}{            struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName) \{ \(\backslash\)}}
\DoxyCodeLine{1065 \textcolor{preprocessor}{                void test(); \(\backslash\)}}
\DoxyCodeLine{1066 \textcolor{preprocessor}{            \}; \(\backslash\)}}
\DoxyCodeLine{1067 \textcolor{preprocessor}{            Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar ) ( Catch::makeTestInvoker( \&TestName::test ), CATCH\_INTERNAL\_LINEINFO, \#ClassName, Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1068 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{1069 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1070 \textcolor{preprocessor}{        void TestName::test()}}
\DoxyCodeLine{1071 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEST\_CASE\_METHOD( ClassName, ... ) \(\backslash\)}}
\DoxyCodeLine{1072 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEST\_CASE\_METHOD2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), ClassName, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1073 }
\DoxyCodeLine{1075 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, ... ) \(\backslash\)}}
\DoxyCodeLine{1076 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1077 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1078 \textcolor{preprocessor}{        Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1079 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{1080 }
\DoxyCodeLine{1082 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2(TestName, TestFunc, Name, Tags, Signature, ... )\(\backslash\)}}
\DoxyCodeLine{1083 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1084 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1085 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1086 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1087 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DECLARE\_SIG\_TEST(TestFunc, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature));\(\backslash\)}}
\DoxyCodeLine{1088 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1089 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)\{\(\backslash\)}}
\DoxyCodeLine{1090 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{1091 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_GEN(INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1092 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_REG\_GEN(TestFunc,INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1093 \textcolor{preprocessor}{            template<typename...Types> \(\backslash\)}}
\DoxyCodeLine{1094 \textcolor{preprocessor}{            struct TestName\{\(\backslash\)}}
\DoxyCodeLine{1095 \textcolor{preprocessor}{                TestName()\{\(\backslash\)}}
\DoxyCodeLine{1096 \textcolor{preprocessor}{                    int index = 0;                                    \(\backslash\)}}
\DoxyCodeLine{1097 \textcolor{preprocessor}{                    constexpr char const* tmpl\_types[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, \_\_VA\_ARGS\_\_)\};\(\backslash\)}}
\DoxyCodeLine{1098 \textcolor{preprocessor}{                    using expander = int[];\(\backslash\)}}
\DoxyCodeLine{1099 \textcolor{preprocessor}{                    (void)expander\{(reg\_test(Types\{\}, Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(tmpl\_types[index]), Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1100 \textcolor{preprocessor}{                \}\(\backslash\)}}
\DoxyCodeLine{1101 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1102 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{\(\backslash\)}}
\DoxyCodeLine{1103 \textcolor{preprocessor}{            TestName<INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(\_\_VA\_ARGS\_\_)>();\(\backslash\)}}
\DoxyCodeLine{1104 \textcolor{preprocessor}{            return 0;\(\backslash\)}}
\DoxyCodeLine{1105 \textcolor{preprocessor}{        \}();\(\backslash\)}}
\DoxyCodeLine{1106 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1107 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1108 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1109 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DEFINE\_SIG\_TEST(TestFunc,INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))}}
\DoxyCodeLine{1110 }
\DoxyCodeLine{1111 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1112 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE(Name, Tags, ...) \(\backslash\)}}
\DoxyCodeLine{1113 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, typename TestType, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1114 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1115 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE(Name, Tags, ...) \(\backslash\)}}
\DoxyCodeLine{1116 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, typename TestType, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1117 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1118 }
\DoxyCodeLine{1119 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1120 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG(Name, Tags, Signature, ...) \(\backslash\)}}
\DoxyCodeLine{1121 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1122 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1123 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG(Name, Tags, Signature, ...) \(\backslash\)}}
\DoxyCodeLine{1124 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1125 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1126 }
\DoxyCodeLine{1127 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \(\backslash\)}}
\DoxyCodeLine{1128 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION                      \(\backslash\)}}
\DoxyCodeLine{1129 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS                      \(\backslash\)}}
\DoxyCodeLine{1130 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS                \(\backslash\)}}
\DoxyCodeLine{1131 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS              \(\backslash\)}}
\DoxyCodeLine{1132 \textcolor{preprocessor}{        template<typename TestType> static void TestFuncName();       \(\backslash\)}}
\DoxyCodeLine{1133 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1134 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName) \{                                     \(\backslash\)}}
\DoxyCodeLine{1135 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN                                                  \(\backslash\)}}
\DoxyCodeLine{1136 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_GEN(INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))         \(\backslash\)}}
\DoxyCodeLine{1137 \textcolor{preprocessor}{            template<typename... Types>                               \(\backslash\)}}
\DoxyCodeLine{1138 \textcolor{preprocessor}{            struct TestName \{                                         \(\backslash\)}}
\DoxyCodeLine{1139 \textcolor{preprocessor}{                void reg\_tests() \{                                          \(\backslash\)}}
\DoxyCodeLine{1140 \textcolor{preprocessor}{                    int index = 0;                                    \(\backslash\)}}
\DoxyCodeLine{1141 \textcolor{preprocessor}{                    using expander = int[];                           \(\backslash\)}}
\DoxyCodeLine{1142 \textcolor{preprocessor}{                    constexpr char const* tmpl\_types[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, INTERNAL\_CATCH\_REMOVE\_PARENS(TmplTypes))\};\(\backslash\)}}
\DoxyCodeLine{1143 \textcolor{preprocessor}{                    constexpr char const* types\_list[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, INTERNAL\_CATCH\_REMOVE\_PARENS(TypesList))\};\(\backslash\)}}
\DoxyCodeLine{1144 \textcolor{preprocessor}{                    constexpr auto num\_types = sizeof(types\_list) / sizeof(types\_list[0]);\(\backslash\)}}
\DoxyCodeLine{1145 \textcolor{preprocessor}{                    (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( \&TestFuncName<Types> ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(tmpl\_types[index / num\_types]) + "{}<"{} + std::string(types\_list[index \% num\_types]) + "{}>"{}, Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{\(\backslash\)}}
\DoxyCodeLine{1146 \textcolor{preprocessor}{                \}                                                     \(\backslash\)}}
\DoxyCodeLine{1147 \textcolor{preprocessor}{            \};                                                        \(\backslash\)}}
\DoxyCodeLine{1148 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{ \(\backslash\)}}
\DoxyCodeLine{1149 \textcolor{preprocessor}{                using TestInit = typename create<TestName, decltype(get\_wrapper<INTERNAL\_CATCH\_REMOVE\_PARENS(TmplTypes)>()), TypeList<INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(INTERNAL\_CATCH\_REMOVE\_PARENS(TypesList))>>::type; \(\backslash\)}}
\DoxyCodeLine{1150 \textcolor{preprocessor}{                TestInit t;                                           \(\backslash\)}}
\DoxyCodeLine{1151 \textcolor{preprocessor}{                t.reg\_tests();                                        \(\backslash\)}}
\DoxyCodeLine{1152 \textcolor{preprocessor}{                return 0;                                             \(\backslash\)}}
\DoxyCodeLine{1153 \textcolor{preprocessor}{            \}();                                                      \(\backslash\)}}
\DoxyCodeLine{1154 \textcolor{preprocessor}{        \}                                                             \(\backslash\)}}
\DoxyCodeLine{1155 \textcolor{preprocessor}{        \}                                                             \(\backslash\)}}
\DoxyCodeLine{1156 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION                       \(\backslash\)}}
\DoxyCodeLine{1157 \textcolor{preprocessor}{        template<typename TestType>                                   \(\backslash\)}}
\DoxyCodeLine{1158 \textcolor{preprocessor}{        static void TestFuncName()}}
\DoxyCodeLine{1159 }
\DoxyCodeLine{1160 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1161 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE(Name, Tags, ...)\(\backslash\)}}
\DoxyCodeLine{1162 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, typename T,\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{1163 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1164 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE(Name, Tags, ...)\(\backslash\)}}
\DoxyCodeLine{1165 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, typename T, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1166 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1167 }
\DoxyCodeLine{1168 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1169 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG(Name, Tags, Signature, ...)\(\backslash\)}}
\DoxyCodeLine{1170 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{1171 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1172 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG(Name, Tags, Signature, ...)\(\backslash\)}}
\DoxyCodeLine{1173 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1174 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1175 }
\DoxyCodeLine{1176 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_2(TestName, TestFunc, Name, Tags, TmplList)\(\backslash\)}}
\DoxyCodeLine{1177 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1178 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1179 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1180 \textcolor{preprocessor}{        template<typename TestType> static void TestFunc();       \(\backslash\)}}
\DoxyCodeLine{1181 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1182 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)\{\(\backslash\)}}
\DoxyCodeLine{1183 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{1184 \textcolor{preprocessor}{        template<typename... Types>                               \(\backslash\)}}
\DoxyCodeLine{1185 \textcolor{preprocessor}{        struct TestName \{                                         \(\backslash\)}}
\DoxyCodeLine{1186 \textcolor{preprocessor}{            void reg\_tests() \{                                          \(\backslash\)}}
\DoxyCodeLine{1187 \textcolor{preprocessor}{                int index = 0;                                    \(\backslash\)}}
\DoxyCodeLine{1188 \textcolor{preprocessor}{                using expander = int[];                           \(\backslash\)}}
\DoxyCodeLine{1189 \textcolor{preprocessor}{                (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( \&TestFunc<Types> ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(INTERNAL\_CATCH\_STRINGIZE(TmplList)) + "{} -\/ "{} + std::to\_string(index), Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{\(\backslash\)}}
\DoxyCodeLine{1190 \textcolor{preprocessor}{            \}                                                     \(\backslash\)}}
\DoxyCodeLine{1191 \textcolor{preprocessor}{        \};\(\backslash\)}}
\DoxyCodeLine{1192 \textcolor{preprocessor}{        static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{ \(\backslash\)}}
\DoxyCodeLine{1193 \textcolor{preprocessor}{                using TestInit = typename convert<TestName, TmplList>::type; \(\backslash\)}}
\DoxyCodeLine{1194 \textcolor{preprocessor}{                TestInit t;                                           \(\backslash\)}}
\DoxyCodeLine{1195 \textcolor{preprocessor}{                t.reg\_tests();                                        \(\backslash\)}}
\DoxyCodeLine{1196 \textcolor{preprocessor}{                return 0;                                             \(\backslash\)}}
\DoxyCodeLine{1197 \textcolor{preprocessor}{            \}();                                                      \(\backslash\)}}
\DoxyCodeLine{1198 \textcolor{preprocessor}{        \}\}\(\backslash\)}}
\DoxyCodeLine{1199 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION                       \(\backslash\)}}
\DoxyCodeLine{1200 \textcolor{preprocessor}{        template<typename TestType>                                   \(\backslash\)}}
\DoxyCodeLine{1201 \textcolor{preprocessor}{        static void TestFunc()}}
\DoxyCodeLine{1202 }
\DoxyCodeLine{1203 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE(Name, Tags, TmplList) \(\backslash\)}}
\DoxyCodeLine{1204 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, TmplList )}}
\DoxyCodeLine{1205 }
\DoxyCodeLine{1206 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1207 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1208 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1209 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1210 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1211 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1212 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)\{ \(\backslash\)}}
\DoxyCodeLine{1213 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{1214 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_GEN(INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1215 \textcolor{preprocessor}{            INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD(TestName, ClassName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature));\(\backslash\)}}
\DoxyCodeLine{1216 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_REG\_METHOD\_GEN(TestName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1217 \textcolor{preprocessor}{            template<typename...Types> \(\backslash\)}}
\DoxyCodeLine{1218 \textcolor{preprocessor}{            struct TestNameClass\{\(\backslash\)}}
\DoxyCodeLine{1219 \textcolor{preprocessor}{                TestNameClass()\{\(\backslash\)}}
\DoxyCodeLine{1220 \textcolor{preprocessor}{                    int index = 0;                                    \(\backslash\)}}
\DoxyCodeLine{1221 \textcolor{preprocessor}{                    constexpr char const* tmpl\_types[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, \_\_VA\_ARGS\_\_)\};\(\backslash\)}}
\DoxyCodeLine{1222 \textcolor{preprocessor}{                    using expander = int[];\(\backslash\)}}
\DoxyCodeLine{1223 \textcolor{preprocessor}{                    (void)expander\{(reg\_test(Types\{\}, \#ClassName, Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(tmpl\_types[index]), Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1224 \textcolor{preprocessor}{                \}\(\backslash\)}}
\DoxyCodeLine{1225 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1226 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{\(\backslash\)}}
\DoxyCodeLine{1227 \textcolor{preprocessor}{                TestNameClass<INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(\_\_VA\_ARGS\_\_)>();\(\backslash\)}}
\DoxyCodeLine{1228 \textcolor{preprocessor}{                return 0;\(\backslash\)}}
\DoxyCodeLine{1229 \textcolor{preprocessor}{        \}();\(\backslash\)}}
\DoxyCodeLine{1230 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1231 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1232 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1233 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD(TestName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))}}
\DoxyCodeLine{1234 }
\DoxyCodeLine{1235 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1236 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( ClassName, Name, Tags,... ) \(\backslash\)}}
\DoxyCodeLine{1237 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1238 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1239 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( ClassName, Name, Tags,... ) \(\backslash\)}}
\DoxyCodeLine{1240 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1241 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1242 }
\DoxyCodeLine{1243 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1244 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1245 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1246 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1247 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1248 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1249 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1250 }
\DoxyCodeLine{1251 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\(\backslash\)}}
\DoxyCodeLine{1252 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1253 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1254 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1255 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1256 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{1257 \textcolor{preprocessor}{            struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName <TestType>) \{ \(\backslash\)}}
\DoxyCodeLine{1258 \textcolor{preprocessor}{                void test();\(\backslash\)}}
\DoxyCodeLine{1259 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1260 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1261 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestNameClass) \{\(\backslash\)}}
\DoxyCodeLine{1262 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN                  \(\backslash\)}}
\DoxyCodeLine{1263 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_GEN(INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1264 \textcolor{preprocessor}{            template<typename...Types>\(\backslash\)}}
\DoxyCodeLine{1265 \textcolor{preprocessor}{            struct TestNameClass\{\(\backslash\)}}
\DoxyCodeLine{1266 \textcolor{preprocessor}{                void reg\_tests()\{\(\backslash\)}}
\DoxyCodeLine{1267 \textcolor{preprocessor}{                    int index = 0;\(\backslash\)}}
\DoxyCodeLine{1268 \textcolor{preprocessor}{                    using expander = int[];\(\backslash\)}}
\DoxyCodeLine{1269 \textcolor{preprocessor}{                    constexpr char const* tmpl\_types[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, INTERNAL\_CATCH\_REMOVE\_PARENS(TmplTypes))\};\(\backslash\)}}
\DoxyCodeLine{1270 \textcolor{preprocessor}{                    constexpr char const* types\_list[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, INTERNAL\_CATCH\_REMOVE\_PARENS(TypesList))\};\(\backslash\)}}
\DoxyCodeLine{1271 \textcolor{preprocessor}{                    constexpr auto num\_types = sizeof(types\_list) / sizeof(types\_list[0]);\(\backslash\)}}
\DoxyCodeLine{1272 \textcolor{preprocessor}{                    (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( \&TestName<Types>::test ), CATCH\_INTERNAL\_LINEINFO, \#ClassName, Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(tmpl\_types[index / num\_types]) + "{}<"{} + std::string(types\_list[index \% num\_types]) + "{}>"{}, Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1273 \textcolor{preprocessor}{                \}\(\backslash\)}}
\DoxyCodeLine{1274 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1275 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{\(\backslash\)}}
\DoxyCodeLine{1276 \textcolor{preprocessor}{                using TestInit = typename create<TestNameClass, decltype(get\_wrapper<INTERNAL\_CATCH\_REMOVE\_PARENS(TmplTypes)>()), TypeList<INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(INTERNAL\_CATCH\_REMOVE\_PARENS(TypesList))>>::type;\(\backslash\)}}
\DoxyCodeLine{1277 \textcolor{preprocessor}{                TestInit t;\(\backslash\)}}
\DoxyCodeLine{1278 \textcolor{preprocessor}{                t.reg\_tests();\(\backslash\)}}
\DoxyCodeLine{1279 \textcolor{preprocessor}{                return 0;\(\backslash\)}}
\DoxyCodeLine{1280 \textcolor{preprocessor}{            \}(); \(\backslash\)}}
\DoxyCodeLine{1281 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1282 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1283 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1284 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{1285 \textcolor{preprocessor}{        void TestName<TestType>::test()}}
\DoxyCodeLine{1286 }
\DoxyCodeLine{1287 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1288 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( ClassName, Name, Tags, ... )\(\backslash\)}}
\DoxyCodeLine{1289 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1290 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1291 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( ClassName, Name, Tags, ... )\(\backslash\)}}
\DoxyCodeLine{1292 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), ClassName, Name, Tags, typename T,\_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1293 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1294 }
\DoxyCodeLine{1295 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1296 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( ClassName, Name, Tags, Signature, ... )\(\backslash\)}}
\DoxyCodeLine{1297 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1298 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1299 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( ClassName, Name, Tags, Signature, ... )\(\backslash\)}}
\DoxyCodeLine{1300 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), ClassName, Name, Tags, Signature,\_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1301 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1302 }
\DoxyCodeLine{1303 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD\_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \(\backslash\)}}
\DoxyCodeLine{1304 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1305 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1306 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1307 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{1308 \textcolor{preprocessor}{        struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName <TestType>) \{ \(\backslash\)}}
\DoxyCodeLine{1309 \textcolor{preprocessor}{            void test();\(\backslash\)}}
\DoxyCodeLine{1310 \textcolor{preprocessor}{        \};\(\backslash\)}}
\DoxyCodeLine{1311 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1312 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)\{ \(\backslash\)}}
\DoxyCodeLine{1313 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{1314 \textcolor{preprocessor}{            template<typename...Types>\(\backslash\)}}
\DoxyCodeLine{1315 \textcolor{preprocessor}{            struct TestNameClass\{\(\backslash\)}}
\DoxyCodeLine{1316 \textcolor{preprocessor}{                void reg\_tests()\{\(\backslash\)}}
\DoxyCodeLine{1317 \textcolor{preprocessor}{                    int index = 0;\(\backslash\)}}
\DoxyCodeLine{1318 \textcolor{preprocessor}{                    using expander = int[];\(\backslash\)}}
\DoxyCodeLine{1319 \textcolor{preprocessor}{                    (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( \&TestName<Types>::test ), CATCH\_INTERNAL\_LINEINFO, \#ClassName, Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(INTERNAL\_CATCH\_STRINGIZE(TmplList)) + "{} -\/ "{} + std::to\_string(index), Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1320 \textcolor{preprocessor}{                \}\(\backslash\)}}
\DoxyCodeLine{1321 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1322 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{\(\backslash\)}}
\DoxyCodeLine{1323 \textcolor{preprocessor}{                using TestInit = typename convert<TestNameClass, TmplList>::type;\(\backslash\)}}
\DoxyCodeLine{1324 \textcolor{preprocessor}{                TestInit t;\(\backslash\)}}
\DoxyCodeLine{1325 \textcolor{preprocessor}{                t.reg\_tests();\(\backslash\)}}
\DoxyCodeLine{1326 \textcolor{preprocessor}{                return 0;\(\backslash\)}}
\DoxyCodeLine{1327 \textcolor{preprocessor}{            \}(); \(\backslash\)}}
\DoxyCodeLine{1328 \textcolor{preprocessor}{        \}\}\(\backslash\)}}
\DoxyCodeLine{1329 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1330 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{1331 \textcolor{preprocessor}{        void TestName<TestType>::test()}}
\DoxyCodeLine{1332 }
\DoxyCodeLine{1333 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD(ClassName, Name, Tags, TmplList) \(\backslash\)}}
\DoxyCodeLine{1334 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), ClassName, Name, Tags, TmplList )}}
\DoxyCodeLine{1335 }
\DoxyCodeLine{1336 \textcolor{comment}{// end catch\_test\_registry.h}}
\DoxyCodeLine{1337 \textcolor{comment}{// start catch\_capture.hpp}}
\DoxyCodeLine{1338 }
\DoxyCodeLine{1339 \textcolor{comment}{// start catch\_assertionhandler.h}}
\DoxyCodeLine{1340 }
\DoxyCodeLine{1341 \textcolor{comment}{// start catch\_assertioninfo.h}}
\DoxyCodeLine{1342 }
\DoxyCodeLine{1343 \textcolor{comment}{// start catch\_result\_type.h}}
\DoxyCodeLine{1344 }
\DoxyCodeLine{1345 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1346 }
\DoxyCodeLine{1347     \textcolor{comment}{// ResultWas::OfType enum}}
\DoxyCodeLine{1348     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_result_was}{ResultWas}} \{ \textcolor{keyword}{enum} OfType \{}
\DoxyCodeLine{1349         Unknown = -\/1,}
\DoxyCodeLine{1350         Ok = 0,}
\DoxyCodeLine{1351         Info = 1,}
\DoxyCodeLine{1352         Warning = 2,}
\DoxyCodeLine{1353 }
\DoxyCodeLine{1354         FailureBit = 0x10,}
\DoxyCodeLine{1355 }
\DoxyCodeLine{1356         ExpressionFailed = FailureBit | 1,}
\DoxyCodeLine{1357         ExplicitFailure = FailureBit | 2,}
\DoxyCodeLine{1358 }
\DoxyCodeLine{1359         Exception = 0x100 | FailureBit,}
\DoxyCodeLine{1360 }
\DoxyCodeLine{1361         ThrewException = Exception | 1,}
\DoxyCodeLine{1362         DidntThrowException = Exception | 2,}
\DoxyCodeLine{1363 }
\DoxyCodeLine{1364         FatalErrorCondition = 0x200 | FailureBit}
\DoxyCodeLine{1365 }
\DoxyCodeLine{1366     \}; \};}
\DoxyCodeLine{1367 }
\DoxyCodeLine{1368     \textcolor{keywordtype}{bool} isOk( ResultWas::OfType resultType );}
\DoxyCodeLine{1369     \textcolor{keywordtype}{bool} isJustInfo( \textcolor{keywordtype}{int} flags );}
\DoxyCodeLine{1370 }
\DoxyCodeLine{1371     \textcolor{comment}{// ResultDisposition::Flags enum}}
\DoxyCodeLine{1372     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_result_disposition}{ResultDisposition}} \{ \textcolor{keyword}{enum} Flags \{}
\DoxyCodeLine{1373         Normal = 0x01,}
\DoxyCodeLine{1374 }
\DoxyCodeLine{1375         ContinueOnFailure = 0x02,   \textcolor{comment}{// Failures fail test, but execution continues}}
\DoxyCodeLine{1376         FalseTest = 0x04,           \textcolor{comment}{// Prefix expression with !}}
\DoxyCodeLine{1377         SuppressFail = 0x08         \textcolor{comment}{// Failures are reported but do not fail the test}}
\DoxyCodeLine{1378     \}; \};}
\DoxyCodeLine{1379 }
\DoxyCodeLine{1380     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );}
\DoxyCodeLine{1381 }
\DoxyCodeLine{1382     \textcolor{keywordtype}{bool} shouldContinueOnFailure( \textcolor{keywordtype}{int} flags );}
\DoxyCodeLine{1383     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} isFalseTest( \textcolor{keywordtype}{int} flags ) \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::FalseTest ) != 0; \}}
\DoxyCodeLine{1384     \textcolor{keywordtype}{bool} shouldSuppressFailure( \textcolor{keywordtype}{int} flags );}
\DoxyCodeLine{1385 }
\DoxyCodeLine{1386 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{1387 }
\DoxyCodeLine{1388 \textcolor{comment}{// end catch\_result\_type.h}}
\DoxyCodeLine{1389 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1390 }
\DoxyCodeLine{1391     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}}}
\DoxyCodeLine{1392     \{}
\DoxyCodeLine{1393         \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} macroName;}
\DoxyCodeLine{1394         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{1395         \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} capturedExpression;}
\DoxyCodeLine{1396         ResultDisposition::Flags resultDisposition;}
\DoxyCodeLine{1397 }
\DoxyCodeLine{1398         \textcolor{comment}{// We want to delete this constructor but a compiler bug in 4.8 means}}
\DoxyCodeLine{1399         \textcolor{comment}{// the struct is then treated as non-\/aggregate}}
\DoxyCodeLine{1400         \textcolor{comment}{//AssertionInfo() = delete;}}
\DoxyCodeLine{1401     \};}
\DoxyCodeLine{1402 }
\DoxyCodeLine{1403 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{1404 }
\DoxyCodeLine{1405 \textcolor{comment}{// end catch\_assertioninfo.h}}
\DoxyCodeLine{1406 \textcolor{comment}{// start catch\_decomposer.h}}
\DoxyCodeLine{1407 }
\DoxyCodeLine{1408 \textcolor{comment}{// start catch\_tostring.h}}
\DoxyCodeLine{1409 }
\DoxyCodeLine{1410 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{1411 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{1412 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{1413 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{1414 \textcolor{comment}{// start catch\_stream.h}}
\DoxyCodeLine{1415 }
\DoxyCodeLine{1416 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{1417 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{1418 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{1419 }
\DoxyCodeLine{1420 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1421 }
\DoxyCodeLine{1422     std::ostream\& cout();}
\DoxyCodeLine{1423     std::ostream\& cerr();}
\DoxyCodeLine{1424     std::ostream\& clog();}
\DoxyCodeLine{1425 }
\DoxyCodeLine{1426     \textcolor{keyword}{class }StringRef;}
\DoxyCodeLine{1427 }
\DoxyCodeLine{1428     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_stream}{IStream}} \{}
\DoxyCodeLine{1429         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_stream}{\string~IStream}}();}
\DoxyCodeLine{1430         \textcolor{keyword}{virtual} std::ostream\& stream() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{1431     \};}
\DoxyCodeLine{1432 }
\DoxyCodeLine{1433     \textcolor{keyword}{auto} makeStream( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const} \&filename ) -\/> \mbox{\hyperlink{struct_catch_1_1_i_stream}{IStream}} \textcolor{keyword}{const}*;}
\DoxyCodeLine{1434 }
\DoxyCodeLine{1435     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{ReusableStringStream}} : \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \{}
\DoxyCodeLine{1436         std::size\_t m\_index;}
\DoxyCodeLine{1437         std::ostream* m\_oss;}
\DoxyCodeLine{1438     \textcolor{keyword}{public}:}
\DoxyCodeLine{1439         \mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{ReusableStringStream}}();}
\DoxyCodeLine{1440         \mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{\string~ReusableStringStream}}();}
\DoxyCodeLine{1441 }
\DoxyCodeLine{1442         \textcolor{keyword}{auto} str() \textcolor{keyword}{const} -\/> std::string;}
\DoxyCodeLine{1443 }
\DoxyCodeLine{1444         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1445         \textcolor{keyword}{auto} operator << ( T \textcolor{keyword}{const}\& value ) -\/> \mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{ReusableStringStream}}\& \{}
\DoxyCodeLine{1446             *m\_oss << value;}
\DoxyCodeLine{1447             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{1448         \}}
\DoxyCodeLine{1449         \textcolor{keyword}{auto} get() -\/> std::ostream\& \{ \textcolor{keywordflow}{return} *m\_oss; \}}
\DoxyCodeLine{1450     \};}
\DoxyCodeLine{1451 \}}
\DoxyCodeLine{1452 }
\DoxyCodeLine{1453 \textcolor{comment}{// end catch\_stream.h}}
\DoxyCodeLine{1454 \textcolor{comment}{// start catch\_interfaces\_enum\_values\_registry.h}}
\DoxyCodeLine{1455 }
\DoxyCodeLine{1456 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{1457 }
\DoxyCodeLine{1458 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1459 }
\DoxyCodeLine{1460     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1461         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_detail_1_1_enum_info}{EnumInfo}} \{}
\DoxyCodeLine{1462             \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} m\_name;}
\DoxyCodeLine{1463             std::vector<std::pair<int, StringRef>> m\_values;}
\DoxyCodeLine{1464 }
\DoxyCodeLine{1465             \mbox{\hyperlink{struct_catch_1_1_detail_1_1_enum_info}{\string~EnumInfo}}();}
\DoxyCodeLine{1466 }
\DoxyCodeLine{1467             \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} lookup( \textcolor{keywordtype}{int} value ) \textcolor{keyword}{const};}
\DoxyCodeLine{1468         \};}
\DoxyCodeLine{1469     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{1470 }
\DoxyCodeLine{1471     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_mutable_enum_values_registry}{IMutableEnumValuesRegistry}} \{}
\DoxyCodeLine{1472         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_mutable_enum_values_registry}{\string~IMutableEnumValuesRegistry}}();}
\DoxyCodeLine{1473 }
\DoxyCodeLine{1474         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_detail_1_1_enum_info}{Detail::EnumInfo}} \textcolor{keyword}{const}\& registerEnum( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} enumName, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} allEnums, std::vector<int> \textcolor{keyword}{const}\& values ) = 0;}
\DoxyCodeLine{1475 }
\DoxyCodeLine{1476         \textcolor{keyword}{template}<\textcolor{keyword}{typename} E>}
\DoxyCodeLine{1477         \mbox{\hyperlink{struct_catch_1_1_detail_1_1_enum_info}{Detail::EnumInfo}} \textcolor{keyword}{const}\& registerEnum( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} enumName, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} allEnums, std::initializer\_list<E> values ) \{}
\DoxyCodeLine{1478             \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(int) >= \textcolor{keyword}{sizeof}(E), \textcolor{stringliteral}{"{}Cannot serialize enum to int"{}});}
\DoxyCodeLine{1479             std::vector<int> intValues;}
\DoxyCodeLine{1480             intValues.reserve( values.size() );}
\DoxyCodeLine{1481             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} enumValue : values )}
\DoxyCodeLine{1482                 intValues.push\_back( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( enumValue ) );}
\DoxyCodeLine{1483             \textcolor{keywordflow}{return} registerEnum( enumName, allEnums, intValues );}
\DoxyCodeLine{1484         \}}
\DoxyCodeLine{1485     \};}
\DoxyCodeLine{1486 }
\DoxyCodeLine{1487 \} \textcolor{comment}{// Catch}}
\DoxyCodeLine{1488 }
\DoxyCodeLine{1489 \textcolor{comment}{// end catch\_interfaces\_enum\_values\_registry.h}}
\DoxyCodeLine{1490 }
\DoxyCodeLine{1491 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{1492 \textcolor{preprocessor}{\#include <string\_view>}}
\DoxyCodeLine{1493 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1494 }
\DoxyCodeLine{1495 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{1496 \textcolor{comment}{// start catch\_objc\_arc.hpp}}
\DoxyCodeLine{1497 }
\DoxyCodeLine{1498 \textcolor{preprocessor}{\#import <Foundation/Foundation.h>}}
\DoxyCodeLine{1499 }
\DoxyCodeLine{1500 \textcolor{preprocessor}{\#ifdef \_\_has\_feature}}
\DoxyCodeLine{1501 \textcolor{preprocessor}{\#define CATCH\_ARC\_ENABLED \_\_has\_feature(objc\_arc)}}
\DoxyCodeLine{1502 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1503 \textcolor{preprocessor}{\#define CATCH\_ARC\_ENABLED 0}}
\DoxyCodeLine{1504 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1505 }
\DoxyCodeLine{1506 \textcolor{keywordtype}{void} arcSafeRelease( NSObject* obj );}
\DoxyCodeLine{1507 \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel );}
\DoxyCodeLine{1508 }
\DoxyCodeLine{1509 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{1510 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} arcSafeRelease( NSObject* obj ) \{}
\DoxyCodeLine{1511     [obj release];}
\DoxyCodeLine{1512 \}}
\DoxyCodeLine{1513 \textcolor{keyword}{inline} \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel ) \{}
\DoxyCodeLine{1514     \textcolor{keywordflow}{if}( [obj respondsToSelector: sel] )}
\DoxyCodeLine{1515         \textcolor{keywordflow}{return} [obj performSelector: sel];}
\DoxyCodeLine{1516     \textcolor{keywordflow}{return} nil;}
\DoxyCodeLine{1517 \}}
\DoxyCodeLine{1518 \textcolor{preprocessor}{\#define CATCH\_UNSAFE\_UNRETAINED}}
\DoxyCodeLine{1519 \textcolor{preprocessor}{\#define CATCH\_ARC\_STRONG}}
\DoxyCodeLine{1520 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1521 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} arcSafeRelease( NSObject* )\{\}}
\DoxyCodeLine{1522 \textcolor{keyword}{inline} \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel ) \{}
\DoxyCodeLine{1523 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{1524 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{1525 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Warc-\/performSelector-\/leaks"{}}}
\DoxyCodeLine{1526 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1527     \textcolor{keywordflow}{if}( [obj respondsToSelector: sel] )}
\DoxyCodeLine{1528         \textcolor{keywordflow}{return} [obj performSelector: sel];}
\DoxyCodeLine{1529 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{1530 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{1531 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1532     \textcolor{keywordflow}{return} nil;}
\DoxyCodeLine{1533 \}}
\DoxyCodeLine{1534 \textcolor{preprocessor}{\#define CATCH\_UNSAFE\_UNRETAINED \_\_unsafe\_unretained}}
\DoxyCodeLine{1535 \textcolor{preprocessor}{\#define CATCH\_ARC\_STRONG \_\_strong}}
\DoxyCodeLine{1536 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1537 }
\DoxyCodeLine{1538 \textcolor{comment}{// end catch\_objc\_arc.hpp}}
\DoxyCodeLine{1539 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1540 }
\DoxyCodeLine{1541 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{1542 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{1543 \textcolor{preprocessor}{\#pragma warning(disable:4180) }\textcolor{comment}{// We attempt to stream a function (address) by const\&, which MSVC complains about but is harmless}}
\DoxyCodeLine{1544 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1545 }
\DoxyCodeLine{1546 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1547     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1548 }
\DoxyCodeLine{1549         \textcolor{keyword}{extern} \textcolor{keyword}{const} std::string unprintableString;}
\DoxyCodeLine{1550 }
\DoxyCodeLine{1551         std::string rawMemoryToString( \textcolor{keyword}{const} \textcolor{keywordtype}{void} *\textcolor{keywordtype}{object}, std::size\_t size );}
\DoxyCodeLine{1552 }
\DoxyCodeLine{1553         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1554         std::string rawMemoryToString( \textcolor{keyword}{const} T\& \textcolor{keywordtype}{object} ) \{}
\DoxyCodeLine{1555           \textcolor{keywordflow}{return} rawMemoryToString( \&\textcolor{keywordtype}{object}, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{object}) );}
\DoxyCodeLine{1556         \}}
\DoxyCodeLine{1557 }
\DoxyCodeLine{1558         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1559         \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_detail_1_1_is_stream_insertable}{IsStreamInsertable}} \{}
\DoxyCodeLine{1560             \textcolor{keyword}{template}<\textcolor{keyword}{typename} Stream, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{1561             \textcolor{keyword}{static} \textcolor{keyword}{auto} test(\textcolor{keywordtype}{int})}
\DoxyCodeLine{1562                 -\/> \textcolor{keyword}{decltype}(std::declval<Stream\&>() << std::declval<U>(), std::true\_type());}
\DoxyCodeLine{1563 }
\DoxyCodeLine{1564             \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}>}
\DoxyCodeLine{1565             \textcolor{keyword}{static} \textcolor{keyword}{auto} test(...)-\/>std::false\_type;}
\DoxyCodeLine{1566 }
\DoxyCodeLine{1567         \textcolor{keyword}{public}:}
\DoxyCodeLine{1568             \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{decltype}(test<std::ostream, const T\&>(0))::value;}
\DoxyCodeLine{1569         \};}
\DoxyCodeLine{1570 }
\DoxyCodeLine{1571         \textcolor{keyword}{template}<\textcolor{keyword}{typename} E>}
\DoxyCodeLine{1572         std::string convertUnknownEnumToString( E e );}
\DoxyCodeLine{1573 }
\DoxyCodeLine{1574         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1575         \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1576             !std::is\_enum<T>::value \&\& !std::is\_base\_of<std::exception, T>::value,}
\DoxyCodeLine{1577         std::string>::type convertUnstreamable( T \textcolor{keyword}{const}\& ) \{}
\DoxyCodeLine{1578             \textcolor{keywordflow}{return} Detail::unprintableString;}
\DoxyCodeLine{1579         \}}
\DoxyCodeLine{1580         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1581         \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1582             !std::is\_enum<T>::value \&\& std::is\_base\_of<std::exception, T>::value,}
\DoxyCodeLine{1583          std::string>::type convertUnstreamable(T \textcolor{keyword}{const}\& ex) \{}
\DoxyCodeLine{1584             \textcolor{keywordflow}{return} ex.what();}
\DoxyCodeLine{1585         \}}
\DoxyCodeLine{1586 }
\DoxyCodeLine{1587         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1588         \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1589             std::is\_enum<T>::value}
\DoxyCodeLine{1590         , std::string>::type convertUnstreamable( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{1591             \textcolor{keywordflow}{return} convertUnknownEnumToString( value );}
\DoxyCodeLine{1592         \}}
\DoxyCodeLine{1593 }
\DoxyCodeLine{1594 \textcolor{preprocessor}{\#if defined(\_MANAGED)}}
\DoxyCodeLine{1596         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1597         std::string clrReferenceToString( T\string^ ref ) \{}
\DoxyCodeLine{1598             \textcolor{keywordflow}{if} (ref == \textcolor{keyword}{nullptr})}
\DoxyCodeLine{1599                 \textcolor{keywordflow}{return} std::string(\textcolor{stringliteral}{"{}null"{}});}
\DoxyCodeLine{1600             \textcolor{keyword}{auto} bytes = System::Text::Encoding::UTF8-\/>GetBytes(ref-\/>ToString());}
\DoxyCodeLine{1601             cli::pin\_ptr<System::Byte> p = \&bytes[0];}
\DoxyCodeLine{1602             \textcolor{keywordflow}{return} std::string(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} \textcolor{keyword}{const }*\textcolor{keyword}{>}(p), bytes-\/>Length);}
\DoxyCodeLine{1603         \}}
\DoxyCodeLine{1604 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1605 }
\DoxyCodeLine{1606     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{1607 }
\DoxyCodeLine{1608     \textcolor{comment}{// If we decide for C++14, change these to enable\_if\_ts}}
\DoxyCodeLine{1609     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1610     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}} \{}
\DoxyCodeLine{1611         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fake = T>}
\DoxyCodeLine{1612         \textcolor{keyword}{static}}
\DoxyCodeLine{1613         \textcolor{keyword}{typename} std::enable\_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type}
\DoxyCodeLine{1614             convert(\textcolor{keyword}{const} Fake\& value) \{}
\DoxyCodeLine{1615                 \mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{ReusableStringStream}} rss;}
\DoxyCodeLine{1616                 \textcolor{comment}{// NB: call using the function-\/like syntax to avoid ambiguity with}}
\DoxyCodeLine{1617                 \textcolor{comment}{// user-\/defined templated operator<< under clang.}}
\DoxyCodeLine{1618                 rss.operator<<(value);}
\DoxyCodeLine{1619                 \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1620         \}}
\DoxyCodeLine{1621 }
\DoxyCodeLine{1622         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fake = T>}
\DoxyCodeLine{1623         \textcolor{keyword}{static}}
\DoxyCodeLine{1624         \textcolor{keyword}{typename} std::enable\_if<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type}
\DoxyCodeLine{1625             convert( \textcolor{keyword}{const} Fake\& value ) \{}
\DoxyCodeLine{1626 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_FALLBACK\_STRINGIFIER)}}
\DoxyCodeLine{1627             \textcolor{keywordflow}{return} Detail::convertUnstreamable(value);}
\DoxyCodeLine{1628 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1629             \textcolor{keywordflow}{return} CATCH\_CONFIG\_FALLBACK\_STRINGIFIER(value);}
\DoxyCodeLine{1630 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1631         \}}
\DoxyCodeLine{1632     \};}
\DoxyCodeLine{1633 }
\DoxyCodeLine{1634     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1635 }
\DoxyCodeLine{1636         \textcolor{comment}{// This function dispatches all stringification requests inside of Catch.}}
\DoxyCodeLine{1637         \textcolor{comment}{// Should be preferably called fully qualified, like ::Catch::Detail::stringify}}
\DoxyCodeLine{1638         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1639         std::string stringify(\textcolor{keyword}{const} T\& e) \{}
\DoxyCodeLine{1640             return ::Catch::StringMaker<typename std::remove\_cv<typename std::remove\_reference<T>::type>::type>::convert(e);}
\DoxyCodeLine{1641         \}}
\DoxyCodeLine{1642 }
\DoxyCodeLine{1643         \textcolor{keyword}{template}<\textcolor{keyword}{typename} E>}
\DoxyCodeLine{1644         std::string convertUnknownEnumToString( E e ) \{}
\DoxyCodeLine{1645             return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}typename std::underlying\_type<E>::type\textcolor{keyword}{>}(e));}
\DoxyCodeLine{1646         \}}
\DoxyCodeLine{1647 }
\DoxyCodeLine{1648 \textcolor{preprocessor}{\#if defined(\_MANAGED)}}
\DoxyCodeLine{1649         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1650         std::string stringify( T\string^ e ) \{}
\DoxyCodeLine{1651             return ::Catch::StringMaker<T\string^>::convert(e);}
\DoxyCodeLine{1652         \}}
\DoxyCodeLine{1653 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1654 }
\DoxyCodeLine{1655     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{1656 }
\DoxyCodeLine{1657     \textcolor{comment}{// Some predefined specializations}}
\DoxyCodeLine{1658 }
\DoxyCodeLine{1659     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1660     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<std::string> \{}
\DoxyCodeLine{1661         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::string\& str);}
\DoxyCodeLine{1662     \};}
\DoxyCodeLine{1663 }
\DoxyCodeLine{1664 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{1665     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1666     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<std::\mbox{\hyperlink{classbasic__string__view}{string\_view}}> \{}
\DoxyCodeLine{1667         \textcolor{keyword}{static} std::string convert(std::string\_view str);}
\DoxyCodeLine{1668     \};}
\DoxyCodeLine{1669 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1670 }
\DoxyCodeLine{1671     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1672     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<char const *> \{}
\DoxyCodeLine{1673         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} \textcolor{keyword}{const} * str);}
\DoxyCodeLine{1674     \};}
\DoxyCodeLine{1675     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1676     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<char *> \{}
\DoxyCodeLine{1677         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} * str);}
\DoxyCodeLine{1678     \};}
\DoxyCodeLine{1679 }
\DoxyCodeLine{1680 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_WCHAR}}
\DoxyCodeLine{1681     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1682     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<std::wstring> \{}
\DoxyCodeLine{1683         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::wstring\& wstr);}
\DoxyCodeLine{1684     \};}
\DoxyCodeLine{1685 }
\DoxyCodeLine{1686 \textcolor{preprocessor}{\# ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{1687     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1688     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<std::\mbox{\hyperlink{classbasic__string__view}{wstring\_view}}> \{}
\DoxyCodeLine{1689         \textcolor{keyword}{static} std::string convert(std::wstring\_view str);}
\DoxyCodeLine{1690     \};}
\DoxyCodeLine{1691 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{1692 }
\DoxyCodeLine{1693     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1694     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<wchar\_t const *> \{}
\DoxyCodeLine{1695         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * str);}
\DoxyCodeLine{1696     \};}
\DoxyCodeLine{1697     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1698     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<wchar\_t *> \{}
\DoxyCodeLine{1699         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{wchar\_t} * str);}
\DoxyCodeLine{1700     \};}
\DoxyCodeLine{1701 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1702 }
\DoxyCodeLine{1703     \textcolor{comment}{// TBD: Should we use `strnlen` to ensure that we don't go out of the buffer,}}
\DoxyCodeLine{1704     \textcolor{comment}{//      while keeping string semantics?}}
\DoxyCodeLine{1705     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{1706     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<char[SZ]> \{}
\DoxyCodeLine{1707         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{1708             return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{1709         \}}
\DoxyCodeLine{1710     \};}
\DoxyCodeLine{1711     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{1712     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<signed char[SZ]> \{}
\DoxyCodeLine{1713         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{1714             return ::Catch::Detail::stringify(std::string\{ \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} \textcolor{keyword}{const }*\textcolor{keyword}{>}(str) \});}
\DoxyCodeLine{1715         \}}
\DoxyCodeLine{1716     \};}
\DoxyCodeLine{1717     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{1718     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<unsigned char[SZ]> \{}
\DoxyCodeLine{1719         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{1720             return ::Catch::Detail::stringify(std::string\{ \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} \textcolor{keyword}{const }*\textcolor{keyword}{>}(str) \});}
\DoxyCodeLine{1721         \}}
\DoxyCodeLine{1722     \};}
\DoxyCodeLine{1723 }
\DoxyCodeLine{1724 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{1725     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1726     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<std::byte> \{}
\DoxyCodeLine{1727         \textcolor{keyword}{static} std::string convert(std::byte value);}
\DoxyCodeLine{1728     \};}
\DoxyCodeLine{1729 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{1730     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1731     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<int> \{}
\DoxyCodeLine{1732         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{int} value);}
\DoxyCodeLine{1733     \};}
\DoxyCodeLine{1734     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1735     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<long> \{}
\DoxyCodeLine{1736         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{long} value);}
\DoxyCodeLine{1737     \};}
\DoxyCodeLine{1738     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1739     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<long long> \{}
\DoxyCodeLine{1740         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value);}
\DoxyCodeLine{1741     \};}
\DoxyCodeLine{1742     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1743     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<unsigned int> \{}
\DoxyCodeLine{1744         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} value);}
\DoxyCodeLine{1745     \};}
\DoxyCodeLine{1746     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1747     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<unsigned long> \{}
\DoxyCodeLine{1748         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} value);}
\DoxyCodeLine{1749     \};}
\DoxyCodeLine{1750     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1751     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<unsigned long long> \{}
\DoxyCodeLine{1752         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value);}
\DoxyCodeLine{1753     \};}
\DoxyCodeLine{1754 }
\DoxyCodeLine{1755     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1756     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<bool> \{}
\DoxyCodeLine{1757         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{bool} b);}
\DoxyCodeLine{1758     \};}
\DoxyCodeLine{1759 }
\DoxyCodeLine{1760     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1761     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<char> \{}
\DoxyCodeLine{1762         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} c);}
\DoxyCodeLine{1763     \};}
\DoxyCodeLine{1764     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1765     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<signed char> \{}
\DoxyCodeLine{1766         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} c);}
\DoxyCodeLine{1767     \};}
\DoxyCodeLine{1768     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1769     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<unsigned char> \{}
\DoxyCodeLine{1770         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c);}
\DoxyCodeLine{1771     \};}
\DoxyCodeLine{1772 }
\DoxyCodeLine{1773     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1774     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<std::nullptr\_t> \{}
\DoxyCodeLine{1775         \textcolor{keyword}{static} std::string convert(std::nullptr\_t);}
\DoxyCodeLine{1776     \};}
\DoxyCodeLine{1777 }
\DoxyCodeLine{1778     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1779     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<float> \{}
\DoxyCodeLine{1780         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{float} value);}
\DoxyCodeLine{1781         \textcolor{keyword}{static} \textcolor{keywordtype}{int} precision;}
\DoxyCodeLine{1782     \};}
\DoxyCodeLine{1783 }
\DoxyCodeLine{1784     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1785     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<double> \{}
\DoxyCodeLine{1786         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{double} value);}
\DoxyCodeLine{1787         \textcolor{keyword}{static} \textcolor{keywordtype}{int} precision;}
\DoxyCodeLine{1788     \};}
\DoxyCodeLine{1789 }
\DoxyCodeLine{1790     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1791     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<T*> \{}
\DoxyCodeLine{1792         \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{1793         \textcolor{keyword}{static} std::string convert(U* p) \{}
\DoxyCodeLine{1794             \textcolor{keywordflow}{if} (p) \{}
\DoxyCodeLine{1795                 return ::Catch::Detail::rawMemoryToString(p);}
\DoxyCodeLine{1796             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1797                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nullptr"{}};}
\DoxyCodeLine{1798             \}}
\DoxyCodeLine{1799         \}}
\DoxyCodeLine{1800     \};}
\DoxyCodeLine{1801 }
\DoxyCodeLine{1802     \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename} C>}
\DoxyCodeLine{1803     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<R C::*> \{}
\DoxyCodeLine{1804         \textcolor{keyword}{static} std::string convert(R C::* p) \{}
\DoxyCodeLine{1805             \textcolor{keywordflow}{if} (p) \{}
\DoxyCodeLine{1806                 return ::Catch::Detail::rawMemoryToString(p);}
\DoxyCodeLine{1807             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1808                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nullptr"{}};}
\DoxyCodeLine{1809             \}}
\DoxyCodeLine{1810         \}}
\DoxyCodeLine{1811     \};}
\DoxyCodeLine{1812 }
\DoxyCodeLine{1813 \textcolor{preprocessor}{\#if defined(\_MANAGED)}}
\DoxyCodeLine{1814     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1815     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<T\string^> \{}
\DoxyCodeLine{1816         \textcolor{keyword}{static} std::string convert( T\string^ ref ) \{}
\DoxyCodeLine{1817             return ::Catch::Detail::clrReferenceToString(ref);}
\DoxyCodeLine{1818         \}}
\DoxyCodeLine{1819     \};}
\DoxyCodeLine{1820 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1821 }
\DoxyCodeLine{1822     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1823         \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIterator, \textcolor{keyword}{typename} Sentinel = InputIterator>}
\DoxyCodeLine{1824         std::string rangeToString(InputIterator first, Sentinel last) \{}
\DoxyCodeLine{1825             ReusableStringStream rss;}
\DoxyCodeLine{1826             rss << \textcolor{stringliteral}{"{}\{ "{}};}
\DoxyCodeLine{1827             \textcolor{keywordflow}{if} (first != last) \{}
\DoxyCodeLine{1828                 rss << ::Catch::Detail::stringify(*first);}
\DoxyCodeLine{1829                 \textcolor{keywordflow}{for} (++first; first != last; ++first)}
\DoxyCodeLine{1830                     rss << \textcolor{stringliteral}{"{}, "{}} << ::Catch::Detail::stringify(*first);}
\DoxyCodeLine{1831             \}}
\DoxyCodeLine{1832             rss << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{1833             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1834         \}}
\DoxyCodeLine{1835     \}}
\DoxyCodeLine{1836 }
\DoxyCodeLine{1837 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{1838     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1839     \textcolor{keyword}{struct }StringMaker<NSString*> \{}
\DoxyCodeLine{1840         \textcolor{keyword}{static} std::string convert(NSString * nsstring) \{}
\DoxyCodeLine{1841             \textcolor{keywordflow}{if} (!nsstring)}
\DoxyCodeLine{1842                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nil"{}};}
\DoxyCodeLine{1843             \textcolor{keywordflow}{return} std::string(\textcolor{stringliteral}{"{}@"{}}) + [nsstring UTF8String];}
\DoxyCodeLine{1844         \}}
\DoxyCodeLine{1845     \};}
\DoxyCodeLine{1846     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1847     \textcolor{keyword}{struct }StringMaker<NSObject*> \{}
\DoxyCodeLine{1848         \textcolor{keyword}{static} std::string convert(NSObject* nsObject) \{}
\DoxyCodeLine{1849             return ::Catch::Detail::stringify([nsObject description]);}
\DoxyCodeLine{1850         \}}
\DoxyCodeLine{1851 }
\DoxyCodeLine{1852     \};}
\DoxyCodeLine{1853     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1854         \textcolor{keyword}{inline} std::string stringify( NSString* nsstring ) \{}
\DoxyCodeLine{1855             \textcolor{keywordflow}{return} StringMaker<NSString*>::convert( nsstring );}
\DoxyCodeLine{1856         \}}
\DoxyCodeLine{1857 }
\DoxyCodeLine{1858     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{1859 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_OBJC\_\_}}
\DoxyCodeLine{1860 }
\DoxyCodeLine{1861 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{1862 }
\DoxyCodeLine{1864 \textcolor{comment}{// Separate std-\/lib types stringification, so it can be selectively enabled}}
\DoxyCodeLine{1865 \textcolor{comment}{// This means that we do not bring in}}
\DoxyCodeLine{1866 }
\DoxyCodeLine{1867 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_ALL\_STRINGMAKERS)}}
\DoxyCodeLine{1868 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_PAIR\_STRINGMAKER}}
\DoxyCodeLine{1869 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_TUPLE\_STRINGMAKER}}
\DoxyCodeLine{1870 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_VARIANT\_STRINGMAKER}}
\DoxyCodeLine{1871 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{1872 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_OPTIONAL\_STRINGMAKER}}
\DoxyCodeLine{1873 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1874 }
\DoxyCodeLine{1875 \textcolor{comment}{// Separate std::pair specialization}}
\DoxyCodeLine{1876 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_PAIR\_STRINGMAKER)}}
\DoxyCodeLine{1877 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{1878 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1879     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1880     \textcolor{keyword}{struct }StringMaker<std::pair<T1, T2> > \{}
\DoxyCodeLine{1881         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::pair<T1, T2>\& pair) \{}
\DoxyCodeLine{1882             ReusableStringStream rss;}
\DoxyCodeLine{1883             rss << \textcolor{stringliteral}{"{}\{ "{}}}
\DoxyCodeLine{1884                 << ::Catch::Detail::stringify(pair.first)}
\DoxyCodeLine{1885                 << \textcolor{stringliteral}{"{}, "{}}}
\DoxyCodeLine{1886                 << ::Catch::Detail::stringify(pair.second)}
\DoxyCodeLine{1887                 << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{1888             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1889         \}}
\DoxyCodeLine{1890     \};}
\DoxyCodeLine{1891 \}}
\DoxyCodeLine{1892 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_PAIR\_STRINGMAKER}}
\DoxyCodeLine{1893 }
\DoxyCodeLine{1894 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_OPTIONAL\_STRINGMAKER) \&\& defined(CATCH\_CONFIG\_CPP17\_OPTIONAL)}}
\DoxyCodeLine{1895 \textcolor{preprocessor}{\#include <optional>}}
\DoxyCodeLine{1896 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1897     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1898     \textcolor{keyword}{struct }StringMaker<std::optional<T> > \{}
\DoxyCodeLine{1899         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::optional<T>\& optional) \{}
\DoxyCodeLine{1900             ReusableStringStream rss;}
\DoxyCodeLine{1901             \textcolor{keywordflow}{if} (optional.has\_value()) \{}
\DoxyCodeLine{1902                 rss << ::Catch::Detail::stringify(*optional);}
\DoxyCodeLine{1903             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1904                 rss << \textcolor{stringliteral}{"{}\{ \}"{}};}
\DoxyCodeLine{1905             \}}
\DoxyCodeLine{1906             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1907         \}}
\DoxyCodeLine{1908     \};}
\DoxyCodeLine{1909 \}}
\DoxyCodeLine{1910 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_OPTIONAL\_STRINGMAKER}}
\DoxyCodeLine{1911 }
\DoxyCodeLine{1912 \textcolor{comment}{// Separate std::tuple specialization}}
\DoxyCodeLine{1913 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_TUPLE\_STRINGMAKER)}}
\DoxyCodeLine{1914 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{1915 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1916     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1917         \textcolor{keyword}{template}<}
\DoxyCodeLine{1918             \textcolor{keyword}{typename} Tuple,}
\DoxyCodeLine{1919             std::size\_t N = 0,}
\DoxyCodeLine{1920             \textcolor{keywordtype}{bool} = (N < std::tuple\_size<Tuple>::value)}
\DoxyCodeLine{1921             >}
\DoxyCodeLine{1922             \textcolor{keyword}{struct} TupleElementPrinter \{}
\DoxyCodeLine{1923             \textcolor{keyword}{static} \textcolor{keywordtype}{void} print(\textcolor{keyword}{const} Tuple\& tuple, std::ostream\& os) \{}
\DoxyCodeLine{1924                 os << (N ? \textcolor{stringliteral}{"{}, "{}} : \textcolor{stringliteral}{"{} "{}})}
\DoxyCodeLine{1925                     << ::Catch::Detail::stringify(std::get<N>(tuple));}
\DoxyCodeLine{1926                 TupleElementPrinter<Tuple, N + 1>::print(tuple, os);}
\DoxyCodeLine{1927             \}}
\DoxyCodeLine{1928         \};}
\DoxyCodeLine{1929 }
\DoxyCodeLine{1930         \textcolor{keyword}{template}<}
\DoxyCodeLine{1931             \textcolor{keyword}{typename} Tuple,}
\DoxyCodeLine{1932             std::size\_t N}
\DoxyCodeLine{1933         >}
\DoxyCodeLine{1934             \textcolor{keyword}{struct }TupleElementPrinter<Tuple, N, false> \{}
\DoxyCodeLine{1935             \textcolor{keyword}{static} \textcolor{keywordtype}{void} print(\textcolor{keyword}{const} Tuple\&, std::ostream\&) \{\}}
\DoxyCodeLine{1936         \};}
\DoxyCodeLine{1937 }
\DoxyCodeLine{1938     \}}
\DoxyCodeLine{1939 }
\DoxyCodeLine{1940     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...Types>}
\DoxyCodeLine{1941     \textcolor{keyword}{struct }StringMaker<std::tuple<Types...>> \{}
\DoxyCodeLine{1942         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::tuple<Types...>\& tuple) \{}
\DoxyCodeLine{1943             ReusableStringStream rss;}
\DoxyCodeLine{1944             rss << \textcolor{charliteral}{'\{'};}
\DoxyCodeLine{1945             Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());}
\DoxyCodeLine{1946             rss << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{1947             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1948         \}}
\DoxyCodeLine{1949     \};}
\DoxyCodeLine{1950 \}}
\DoxyCodeLine{1951 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_TUPLE\_STRINGMAKER}}
\DoxyCodeLine{1952 }
\DoxyCodeLine{1953 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_VARIANT\_STRINGMAKER) \&\& defined(CATCH\_CONFIG\_CPP17\_VARIANT)}}
\DoxyCodeLine{1954 \textcolor{preprocessor}{\#include <variant>}}
\DoxyCodeLine{1955 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1956     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1957     \textcolor{keyword}{struct }StringMaker<std::\mbox{\hyperlink{structmonostate}{monostate}}> \{}
\DoxyCodeLine{1958         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::monostate\&) \{}
\DoxyCodeLine{1959             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}\{ \}"{}};}
\DoxyCodeLine{1960         \}}
\DoxyCodeLine{1961     \};}
\DoxyCodeLine{1962 }
\DoxyCodeLine{1963     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Elements>}
\DoxyCodeLine{1964     \textcolor{keyword}{struct }StringMaker<std::variant<Elements...>> \{}
\DoxyCodeLine{1965         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::variant<Elements...>\& variant) \{}
\DoxyCodeLine{1966             \textcolor{keywordflow}{if} (variant.valueless\_by\_exception()) \{}
\DoxyCodeLine{1967                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}\{valueless variant\}"{}};}
\DoxyCodeLine{1968             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1969                 \textcolor{keywordflow}{return} std::visit(}
\DoxyCodeLine{1970                     [](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& value) \{}
\DoxyCodeLine{1971                         return ::Catch::Detail::stringify(value);}
\DoxyCodeLine{1972                     \},}
\DoxyCodeLine{1973                     variant}
\DoxyCodeLine{1974                 );}
\DoxyCodeLine{1975             \}}
\DoxyCodeLine{1976         \}}
\DoxyCodeLine{1977     \};}
\DoxyCodeLine{1978 \}}
\DoxyCodeLine{1979 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_VARIANT\_STRINGMAKER}}
\DoxyCodeLine{1980 }
\DoxyCodeLine{1981 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1982     \textcolor{comment}{// Import begin/ end from std here}}
\DoxyCodeLine{1983     \textcolor{keyword}{using} std::begin;}
\DoxyCodeLine{1984     \textcolor{keyword}{using} std::end;}
\DoxyCodeLine{1985 }
\DoxyCodeLine{1986     \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{1987         \textcolor{keyword}{template} <\textcolor{keyword}{typename}...>}
\DoxyCodeLine{1988         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1detail_1_1void__type}{void\_type}} \{}
\DoxyCodeLine{1989             \textcolor{keyword}{using} type = void;}
\DoxyCodeLine{1990         \};}
\DoxyCodeLine{1991 }
\DoxyCodeLine{1992         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1993         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1detail_1_1is__range__impl}{is\_range\_impl}} : std::false\_type \{}
\DoxyCodeLine{1994         \};}
\DoxyCodeLine{1995 }
\DoxyCodeLine{1996         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1997         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1detail_1_1is__range__impl}{is\_range\_impl<T, typename void\_type<decltype(begin(std::declval<T>}}()))>::type> : std::true\_type \{}
\DoxyCodeLine{1998         \};}
\DoxyCodeLine{1999     \} \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{2000 }
\DoxyCodeLine{2001     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2002     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1is__range}{is\_range}} : \mbox{\hyperlink{struct_catch_1_1detail_1_1is__range__impl}{detail::is\_range\_impl}}<T> \{}
\DoxyCodeLine{2003     \};}
\DoxyCodeLine{2004 }
\DoxyCodeLine{2005 \textcolor{preprocessor}{\#if defined(\_MANAGED) }\textcolor{comment}{// Managed types are never ranges}}
\DoxyCodeLine{2006     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2007     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1is__range}{is\_range}}<T\string^> \{}
\DoxyCodeLine{2008         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{false};}
\DoxyCodeLine{2009     \};}
\DoxyCodeLine{2010 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2011 }
\DoxyCodeLine{2012     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{2013     std::string rangeToString( Range \textcolor{keyword}{const}\& range ) \{}
\DoxyCodeLine{2014         return ::Catch::Detail::rangeToString( begin( range ), end( range ) );}
\DoxyCodeLine{2015     \}}
\DoxyCodeLine{2016 }
\DoxyCodeLine{2017     \textcolor{comment}{// Handle vector<bool> specially}}
\DoxyCodeLine{2018     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Allocator>}
\DoxyCodeLine{2019     std::string rangeToString( std::vector<bool, Allocator> \textcolor{keyword}{const}\& v ) \{}
\DoxyCodeLine{2020         ReusableStringStream rss;}
\DoxyCodeLine{2021         rss << \textcolor{stringliteral}{"{}\{ "{}};}
\DoxyCodeLine{2022         \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{2023         \textcolor{keywordflow}{for}( \textcolor{keywordtype}{bool} b : v ) \{}
\DoxyCodeLine{2024             \textcolor{keywordflow}{if}( first )}
\DoxyCodeLine{2025                 first = \textcolor{keyword}{false};}
\DoxyCodeLine{2026             \textcolor{keywordflow}{else}}
\DoxyCodeLine{2027                 rss << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{2028             rss << ::Catch::Detail::stringify( b );}
\DoxyCodeLine{2029         \}}
\DoxyCodeLine{2030         rss << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{2031         \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2032     \}}
\DoxyCodeLine{2033 }
\DoxyCodeLine{2034     \textcolor{keyword}{template}<\textcolor{keyword}{typename} R>}
\DoxyCodeLine{2035     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<R, typename std::enable\_if<is\_range<R>::value \&\& !::Catch::Detail::IsStreamInsertable<R>::value>::type> \{}
\DoxyCodeLine{2036         \textcolor{keyword}{static} std::string convert( R \textcolor{keyword}{const}\& range ) \{}
\DoxyCodeLine{2037             \textcolor{keywordflow}{return} rangeToString( range );}
\DoxyCodeLine{2038         \}}
\DoxyCodeLine{2039     \};}
\DoxyCodeLine{2040 }
\DoxyCodeLine{2041     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{2042     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<T[SZ]> \{}
\DoxyCodeLine{2043         \textcolor{keyword}{static} std::string convert(T \textcolor{keyword}{const}(\&arr)[SZ]) \{}
\DoxyCodeLine{2044             \textcolor{keywordflow}{return} rangeToString(arr);}
\DoxyCodeLine{2045         \}}
\DoxyCodeLine{2046     \};}
\DoxyCodeLine{2047 }
\DoxyCodeLine{2048 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{2049 }
\DoxyCodeLine{2050 \textcolor{comment}{// Separate std::chrono::duration specialization}}
\DoxyCodeLine{2051 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER)}}
\DoxyCodeLine{2052 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{2053 \textcolor{preprocessor}{\#include <ratio>}}
\DoxyCodeLine{2054 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{2055 }
\DoxyCodeLine{2056 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2057 }
\DoxyCodeLine{2058 \textcolor{keyword}{template} <\textcolor{keyword}{class} Ratio>}
\DoxyCodeLine{2059 \textcolor{keyword}{struct }ratio\_string \{}
\DoxyCodeLine{2060     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2061 \};}
\DoxyCodeLine{2062 }
\DoxyCodeLine{2063 \textcolor{keyword}{template} <\textcolor{keyword}{class} Ratio>}
\DoxyCodeLine{2064 std::string ratio\_string<Ratio>::symbol() \{}
\DoxyCodeLine{2065     \mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{Catch::ReusableStringStream}} rss;}
\DoxyCodeLine{2066     rss << \textcolor{charliteral}{'['} << Ratio::num << \textcolor{charliteral}{'/'}}
\DoxyCodeLine{2067         << Ratio::den << \textcolor{charliteral}{']'};}
\DoxyCodeLine{2068     \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2069 \}}
\DoxyCodeLine{2070 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2071 \textcolor{keyword}{struct }ratio\_string<std::atto> \{}
\DoxyCodeLine{2072     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2073 \};}
\DoxyCodeLine{2074 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2075 \textcolor{keyword}{struct }ratio\_string<std::femto> \{}
\DoxyCodeLine{2076     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2077 \};}
\DoxyCodeLine{2078 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2079 \textcolor{keyword}{struct }ratio\_string<std::pico> \{}
\DoxyCodeLine{2080     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2081 \};}
\DoxyCodeLine{2082 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2083 \textcolor{keyword}{struct }ratio\_string<std::nano> \{}
\DoxyCodeLine{2084     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2085 \};}
\DoxyCodeLine{2086 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2087 \textcolor{keyword}{struct }ratio\_string<std::micro> \{}
\DoxyCodeLine{2088     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2089 \};}
\DoxyCodeLine{2090 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2091 \textcolor{keyword}{struct }ratio\_string<std::milli> \{}
\DoxyCodeLine{2092     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2093 \};}
\DoxyCodeLine{2094 }
\DoxyCodeLine{2096     \textcolor{comment}{// std::chrono::duration specializations}}
\DoxyCodeLine{2097     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value, \textcolor{keyword}{typename} Ratio>}
\DoxyCodeLine{2098     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, Ratio>> \{}
\DoxyCodeLine{2099         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, Ratio> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{2100             ReusableStringStream rss;}
\DoxyCodeLine{2101             rss << duration.count() << \textcolor{charliteral}{' '} << ratio\_string<Ratio>::symbol() << \textcolor{charliteral}{'s'};}
\DoxyCodeLine{2102             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2103         \}}
\DoxyCodeLine{2104     \};}
\DoxyCodeLine{2105     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{2106     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, std::ratio<1>>> \{}
\DoxyCodeLine{2107         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, std::ratio<1>> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{2108             ReusableStringStream rss;}
\DoxyCodeLine{2109             rss << duration.count() << \textcolor{stringliteral}{"{} s"{}};}
\DoxyCodeLine{2110             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2111         \}}
\DoxyCodeLine{2112     \};}
\DoxyCodeLine{2113     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{2114     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, std::ratio<60>>> \{}
\DoxyCodeLine{2115         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, std::ratio<60>> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{2116             ReusableStringStream rss;}
\DoxyCodeLine{2117             rss << duration.count() << \textcolor{stringliteral}{"{} m"{}};}
\DoxyCodeLine{2118             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2119         \}}
\DoxyCodeLine{2120     \};}
\DoxyCodeLine{2121     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{2122     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, std::ratio<3600>>> \{}
\DoxyCodeLine{2123         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, std::ratio<3600>> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{2124             ReusableStringStream rss;}
\DoxyCodeLine{2125             rss << duration.count() << \textcolor{stringliteral}{"{} h"{}};}
\DoxyCodeLine{2126             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2127         \}}
\DoxyCodeLine{2128     \};}
\DoxyCodeLine{2129 }
\DoxyCodeLine{2131     \textcolor{comment}{// std::chrono::time\_point specialization}}
\DoxyCodeLine{2132     \textcolor{comment}{// Generic time\_point cannot be specialized, only std::chrono::time\_point<system\_clock>}}
\DoxyCodeLine{2133     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{2134     \textcolor{keyword}{struct }StringMaker<std::chrono::time\_point<Clock, Duration>> \{}
\DoxyCodeLine{2135         \textcolor{keyword}{static} std::string convert(std::chrono::time\_point<Clock, Duration> \textcolor{keyword}{const}\& time\_point) \{}
\DoxyCodeLine{2136             return ::Catch::Detail::stringify(time\_point.time\_since\_epoch()) + \textcolor{stringliteral}{"{} since epoch"{}};}
\DoxyCodeLine{2137         \}}
\DoxyCodeLine{2138     \};}
\DoxyCodeLine{2139     \textcolor{comment}{// std::chrono::time\_point<system\_clock> specialization}}
\DoxyCodeLine{2140     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{2141     \textcolor{keyword}{struct }StringMaker<std::chrono::time\_point<std::chrono::system\_clock, Duration>> \{}
\DoxyCodeLine{2142         \textcolor{keyword}{static} std::string convert(std::chrono::time\_point<std::chrono::system\_clock, Duration> \textcolor{keyword}{const}\& time\_point) \{}
\DoxyCodeLine{2143             \textcolor{keyword}{auto} converted = std::chrono::system\_clock::to\_time\_t(time\_point);}
\DoxyCodeLine{2144 }
\DoxyCodeLine{2145 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2146             std::tm timeInfo = \{\};}
\DoxyCodeLine{2147             gmtime\_s(\&timeInfo, \&converted);}
\DoxyCodeLine{2148 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2149             std::tm* timeInfo = std::gmtime(\&converted);}
\DoxyCodeLine{2150 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2151 }
\DoxyCodeLine{2152             \textcolor{keyword}{auto} \textcolor{keyword}{const} timeStampSize = \textcolor{keyword}{sizeof}(\textcolor{stringliteral}{"{}2017-\/01-\/16T17:06:45Z"{}});}
\DoxyCodeLine{2153             \textcolor{keywordtype}{char} timeStamp[timeStampSize];}
\DoxyCodeLine{2154             \textcolor{keyword}{const} \textcolor{keywordtype}{char} * \textcolor{keyword}{const} fmt = \textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%dT\%H:\%M:\%SZ"{}};}
\DoxyCodeLine{2155 }
\DoxyCodeLine{2156 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2157             std::strftime(timeStamp, timeStampSize, fmt, \&timeInfo);}
\DoxyCodeLine{2158 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2159             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);}
\DoxyCodeLine{2160 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2161             \textcolor{keywordflow}{return} std::string(timeStamp);}
\DoxyCodeLine{2162         \}}
\DoxyCodeLine{2163     \};}
\DoxyCodeLine{2164 \}}
\DoxyCodeLine{2165 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{2166 }
\DoxyCodeLine{2167 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REGISTER\_ENUM( enumName, ... ) \(\backslash\)}}
\DoxyCodeLine{2168 \textcolor{preprocessor}{namespace Catch \{ \(\backslash\)}}
\DoxyCodeLine{2169 \textcolor{preprocessor}{    template<> struct StringMaker<enumName> \{ \(\backslash\)}}
\DoxyCodeLine{2170 \textcolor{preprocessor}{        static std::string convert( enumName value ) \{ \(\backslash\)}}
\DoxyCodeLine{2171 \textcolor{preprocessor}{            static const auto\& enumInfo = ::Catch::getMutableRegistryHub().getMutableEnumValuesRegistry().registerEnum( \#enumName, \#\_\_VA\_ARGS\_\_, \{ \_\_VA\_ARGS\_\_ \} ); \(\backslash\)}}
\DoxyCodeLine{2172 \textcolor{preprocessor}{            return static\_cast<std::string>(enumInfo.lookup( static\_cast<int>( value ) )); \(\backslash\)}}
\DoxyCodeLine{2173 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2174 \textcolor{preprocessor}{    \}; \(\backslash\)}}
\DoxyCodeLine{2175 \textcolor{preprocessor}{\}}}
\DoxyCodeLine{2176 }
\DoxyCodeLine{2177 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_ENUM( enumName, ... ) INTERNAL\_CATCH\_REGISTER\_ENUM( enumName, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{2178 }
\DoxyCodeLine{2179 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2180 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{2181 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2182 }
\DoxyCodeLine{2183 \textcolor{comment}{// end catch\_tostring.h}}
\DoxyCodeLine{2184 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{2185 }
\DoxyCodeLine{2186 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2187 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{2188 \textcolor{preprocessor}{\#pragma warning(disable:4389) }\textcolor{comment}{// '==' : signed/unsigned mismatch}}
\DoxyCodeLine{2189 \textcolor{preprocessor}{\#pragma warning(disable:4018) }\textcolor{comment}{// more "{}signed/unsigned mismatch"{}}}
\DoxyCodeLine{2190 \textcolor{preprocessor}{\#pragma warning(disable:4312) }\textcolor{comment}{// Converting int to T* using reinterpret\_cast (issue on x64 platform)}}
\DoxyCodeLine{2191 \textcolor{preprocessor}{\#pragma warning(disable:4180) }\textcolor{comment}{// qualifier applied to function type has no meaning}}
\DoxyCodeLine{2192 \textcolor{preprocessor}{\#pragma warning(disable:4800) }\textcolor{comment}{// Forcing result to true or false}}
\DoxyCodeLine{2193 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2194 }
\DoxyCodeLine{2195 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2196 }
\DoxyCodeLine{2197     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \{}
\DoxyCodeLine{2198         \textcolor{keyword}{auto} isBinaryExpression() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} m\_isBinaryExpression; \}}
\DoxyCodeLine{2199         \textcolor{keyword}{auto} getResult() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} m\_result; \}}
\DoxyCodeLine{2200         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2201 }
\DoxyCodeLine{2202         \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}}( \textcolor{keywordtype}{bool} isBinaryExpression, \textcolor{keywordtype}{bool} result )}
\DoxyCodeLine{2203         :   m\_isBinaryExpression( isBinaryExpression ),}
\DoxyCodeLine{2204             m\_result( result )}
\DoxyCodeLine{2205         \{\}}
\DoxyCodeLine{2206 }
\DoxyCodeLine{2207         \textcolor{comment}{// We don't actually need a virtual destructor, but many static analysers}}
\DoxyCodeLine{2208         \textcolor{comment}{// complain if it's not here :-\/(}}
\DoxyCodeLine{2209         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{\string~ITransientExpression}}();}
\DoxyCodeLine{2210 }
\DoxyCodeLine{2211         \textcolor{keywordtype}{bool} m\_isBinaryExpression;}
\DoxyCodeLine{2212         \textcolor{keywordtype}{bool} m\_result;}
\DoxyCodeLine{2213 }
\DoxyCodeLine{2214     \};}
\DoxyCodeLine{2215 }
\DoxyCodeLine{2216     \textcolor{keywordtype}{void} formatReconstructedExpression( std::ostream \&os, std::string \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} op, std::string \textcolor{keyword}{const}\& rhs );}
\DoxyCodeLine{2217 }
\DoxyCodeLine{2218     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2219     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr}}  : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \{}
\DoxyCodeLine{2220         LhsT m\_lhs;}
\DoxyCodeLine{2221         \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} m\_op;}
\DoxyCodeLine{2222         RhsT m\_rhs;}
\DoxyCodeLine{2223 }
\DoxyCodeLine{2224         \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2225             formatReconstructedExpression}
\DoxyCodeLine{2226                     ( os, Catch::Detail::stringify( m\_lhs ), m\_op, Catch::Detail::stringify( m\_rhs ) );}
\DoxyCodeLine{2227         \}}
\DoxyCodeLine{2228 }
\DoxyCodeLine{2229     \textcolor{keyword}{public}:}
\DoxyCodeLine{2230         \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr}}( \textcolor{keywordtype}{bool} comparisonResult, LhsT lhs, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} op, RhsT rhs )}
\DoxyCodeLine{2231         :   \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}}\{ \textcolor{keyword}{true}, comparisonResult \},}
\DoxyCodeLine{2232             m\_lhs( lhs ),}
\DoxyCodeLine{2233             m\_op( op ),}
\DoxyCodeLine{2234             m\_rhs( rhs )}
\DoxyCodeLine{2235         \{\}}
\DoxyCodeLine{2236 }
\DoxyCodeLine{2237         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2238         \textcolor{keyword}{auto} operator \&\& ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2239             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2240             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2241             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2242         \}}
\DoxyCodeLine{2243 }
\DoxyCodeLine{2244         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2245         \textcolor{keyword}{auto} operator || ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2246             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2247             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2248             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2249         \}}
\DoxyCodeLine{2250 }
\DoxyCodeLine{2251         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2252         \textcolor{keyword}{auto} operator == ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2253             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2254             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2255             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2256         \}}
\DoxyCodeLine{2257 }
\DoxyCodeLine{2258         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2259         \textcolor{keyword}{auto} operator != ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2260             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2261             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2262             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2263         \}}
\DoxyCodeLine{2264 }
\DoxyCodeLine{2265         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2266         \textcolor{keyword}{auto} operator > ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2267             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2268             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2269             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2270         \}}
\DoxyCodeLine{2271 }
\DoxyCodeLine{2272         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2273         \textcolor{keyword}{auto} operator < ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2274             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2275             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2276             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2277         \}}
\DoxyCodeLine{2278 }
\DoxyCodeLine{2279         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2280         \textcolor{keyword}{auto} operator >= ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2281             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2282             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2283             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2284         \}}
\DoxyCodeLine{2285 }
\DoxyCodeLine{2286         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2287         \textcolor{keyword}{auto} operator <= ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2288             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2289             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2290             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2291         \}}
\DoxyCodeLine{2292     \};}
\DoxyCodeLine{2293 }
\DoxyCodeLine{2294     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT>}
\DoxyCodeLine{2295     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_unary_expr}{UnaryExpr}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \{}
\DoxyCodeLine{2296         LhsT m\_lhs;}
\DoxyCodeLine{2297 }
\DoxyCodeLine{2298         \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2299             os << Catch::Detail::stringify( m\_lhs );}
\DoxyCodeLine{2300         \}}
\DoxyCodeLine{2301 }
\DoxyCodeLine{2302     \textcolor{keyword}{public}:}
\DoxyCodeLine{2303         \textcolor{keyword}{explicit} \mbox{\hyperlink{class_catch_1_1_unary_expr}{UnaryExpr}}( LhsT lhs )}
\DoxyCodeLine{2304         :   \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}}\{ \textcolor{keyword}{false}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(lhs) \},}
\DoxyCodeLine{2305             m\_lhs( lhs )}
\DoxyCodeLine{2306         \{\}}
\DoxyCodeLine{2307     \};}
\DoxyCodeLine{2308 }
\DoxyCodeLine{2309     \textcolor{comment}{// Specialised comparison functions to handle equality comparisons between ints and pointers (NULL deduces as an int)}}
\DoxyCodeLine{2310     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2311     \textcolor{keyword}{auto} compareEqual( LhsT \textcolor{keyword}{const}\& lhs, RhsT \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(lhs == rhs); \}}
\DoxyCodeLine{2312     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2313     \textcolor{keyword}{auto} compareEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{int} rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs == \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( rhs ); \}}
\DoxyCodeLine{2314     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2315     \textcolor{keyword}{auto} compareEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{long} rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs == \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( rhs ); \}}
\DoxyCodeLine{2316     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2317     \textcolor{keyword}{auto} compareEqual( \textcolor{keywordtype}{int} lhs, T* \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( lhs ) == rhs; \}}
\DoxyCodeLine{2318     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2319     \textcolor{keyword}{auto} compareEqual( \textcolor{keywordtype}{long} lhs, T* \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( lhs ) == rhs; \}}
\DoxyCodeLine{2320 }
\DoxyCodeLine{2321     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2322     \textcolor{keyword}{auto} compareNotEqual( LhsT \textcolor{keyword}{const}\& lhs, RhsT\&\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(lhs != rhs); \}}
\DoxyCodeLine{2323     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2324     \textcolor{keyword}{auto} compareNotEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{int} rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs != \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( rhs ); \}}
\DoxyCodeLine{2325     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2326     \textcolor{keyword}{auto} compareNotEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{long} rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs != \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( rhs ); \}}
\DoxyCodeLine{2327     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2328     \textcolor{keyword}{auto} compareNotEqual( \textcolor{keywordtype}{int} lhs, T* \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( lhs ) != rhs; \}}
\DoxyCodeLine{2329     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2330     \textcolor{keyword}{auto} compareNotEqual( \textcolor{keywordtype}{long} lhs, T* \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( lhs ) != rhs; \}}
\DoxyCodeLine{2331 }
\DoxyCodeLine{2332     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT>}
\DoxyCodeLine{2333     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs}} \{}
\DoxyCodeLine{2334         LhsT m\_lhs;}
\DoxyCodeLine{2335     \textcolor{keyword}{public}:}
\DoxyCodeLine{2336         \textcolor{keyword}{explicit} \mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs}}( LhsT lhs ) : m\_lhs( lhs ) \{\}}
\DoxyCodeLine{2337 }
\DoxyCodeLine{2338         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2339         \textcolor{keyword}{auto} operator == ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2340             \textcolor{keywordflow}{return} \{ compareEqual( m\_lhs, rhs ), m\_lhs, \textcolor{stringliteral}{"{}=="{}}, rhs \};}
\DoxyCodeLine{2341         \}}
\DoxyCodeLine{2342         \textcolor{keyword}{auto} operator == ( \textcolor{keywordtype}{bool} rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, bool>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2343             \textcolor{keywordflow}{return} \{ m\_lhs == rhs, m\_lhs, \textcolor{stringliteral}{"{}=="{}}, rhs \};}
\DoxyCodeLine{2344         \}}
\DoxyCodeLine{2345 }
\DoxyCodeLine{2346         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2347         \textcolor{keyword}{auto} operator != ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2348             \textcolor{keywordflow}{return} \{ compareNotEqual( m\_lhs, rhs ), m\_lhs, \textcolor{stringliteral}{"{}!="{}}, rhs \};}
\DoxyCodeLine{2349         \}}
\DoxyCodeLine{2350         \textcolor{keyword}{auto} operator != ( \textcolor{keywordtype}{bool} rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, bool>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2351             \textcolor{keywordflow}{return} \{ m\_lhs != rhs, m\_lhs, \textcolor{stringliteral}{"{}!="{}}, rhs \};}
\DoxyCodeLine{2352         \}}
\DoxyCodeLine{2353 }
\DoxyCodeLine{2354         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2355         \textcolor{keyword}{auto} operator > ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2356             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs > rhs), m\_lhs, \textcolor{stringliteral}{"{}>"{}}, rhs \};}
\DoxyCodeLine{2357         \}}
\DoxyCodeLine{2358         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2359         \textcolor{keyword}{auto} operator < ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2360             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs < rhs), m\_lhs, \textcolor{stringliteral}{"{}<"{}}, rhs \};}
\DoxyCodeLine{2361         \}}
\DoxyCodeLine{2362         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2363         \textcolor{keyword}{auto} operator >= ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2364             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs >= rhs), m\_lhs, \textcolor{stringliteral}{"{}>="{}}, rhs \};}
\DoxyCodeLine{2365         \}}
\DoxyCodeLine{2366         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2367         \textcolor{keyword}{auto} operator <= ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2368             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs <= rhs), m\_lhs, \textcolor{stringliteral}{"{}<="{}}, rhs \};}
\DoxyCodeLine{2369         \}}
\DoxyCodeLine{2370         \textcolor{keyword}{template} <\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2371         \textcolor{keyword}{auto} operator | (RhsT \textcolor{keyword}{const}\& rhs) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2372             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs | rhs), m\_lhs, \textcolor{stringliteral}{"{}|"{}}, rhs \};}
\DoxyCodeLine{2373         \}}
\DoxyCodeLine{2374         \textcolor{keyword}{template} <\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2375         \textcolor{keyword}{auto} operator \& (RhsT \textcolor{keyword}{const}\& rhs) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2376             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs \& rhs), m\_lhs, \textcolor{stringliteral}{"{}\&"{}}, rhs \};}
\DoxyCodeLine{2377         \}}
\DoxyCodeLine{2378         \textcolor{keyword}{template} <\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2379         \textcolor{keyword}{auto} operator \string^ (RhsT \textcolor{keyword}{const}\& rhs) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2380             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs \string^ rhs), m\_lhs, \textcolor{stringliteral}{"{}\string^"{}}, rhs \};}
\DoxyCodeLine{2381         \}}
\DoxyCodeLine{2382 }
\DoxyCodeLine{2383         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2384         \textcolor{keyword}{auto} operator \&\& ( RhsT \textcolor{keyword}{const}\& ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2385             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<RhsT>::value}},}
\DoxyCodeLine{2386             \textcolor{stringliteral}{"{}operator\&\& is not supported inside assertions, "{}}}
\DoxyCodeLine{2387             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2388         \}}
\DoxyCodeLine{2389 }
\DoxyCodeLine{2390         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2391         \textcolor{keyword}{auto} operator || ( RhsT \textcolor{keyword}{const}\& ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2392             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<RhsT>::value}},}
\DoxyCodeLine{2393             \textcolor{stringliteral}{"{}operator|| is not supported inside assertions, "{}}}
\DoxyCodeLine{2394             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2395         \}}
\DoxyCodeLine{2396 }
\DoxyCodeLine{2397         \textcolor{keyword}{auto} makeUnaryExpr() \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_unary_expr}{UnaryExpr<LhsT>}} \{}
\DoxyCodeLine{2398             \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_unary_expr}{UnaryExpr<LhsT>}}\{ m\_lhs \};}
\DoxyCodeLine{2399         \}}
\DoxyCodeLine{2400     \};}
\DoxyCodeLine{2401 }
\DoxyCodeLine{2402     \textcolor{keywordtype}{void} handleExpression( \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \textcolor{keyword}{const}\& expr );}
\DoxyCodeLine{2403 }
\DoxyCodeLine{2404     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2405     \textcolor{keywordtype}{void} handleExpression( \mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs<T>}} \textcolor{keyword}{const}\& expr ) \{}
\DoxyCodeLine{2406         handleExpression( expr.makeUnaryExpr() );}
\DoxyCodeLine{2407     \}}
\DoxyCodeLine{2408 }
\DoxyCodeLine{2409     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_decomposer}{Decomposer}} \{}
\DoxyCodeLine{2410         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2411         \textcolor{keyword}{auto} operator <= ( T \textcolor{keyword}{const}\& lhs ) -\/> \mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs<T const\&>}} \{}
\DoxyCodeLine{2412             \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs<T const\&>}}\{ lhs \};}
\DoxyCodeLine{2413         \}}
\DoxyCodeLine{2414 }
\DoxyCodeLine{2415         \textcolor{keyword}{auto} operator <=( \textcolor{keywordtype}{bool} value ) -\/> \mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs<bool>}} \{}
\DoxyCodeLine{2416             \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs<bool>}}\{ value \};}
\DoxyCodeLine{2417         \}}
\DoxyCodeLine{2418     \};}
\DoxyCodeLine{2419 }
\DoxyCodeLine{2420 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2421 }
\DoxyCodeLine{2422 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2423 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{2424 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2425 }
\DoxyCodeLine{2426 \textcolor{comment}{// end catch\_decomposer.h}}
\DoxyCodeLine{2427 \textcolor{comment}{// start catch\_interfaces\_capture.h}}
\DoxyCodeLine{2428 }
\DoxyCodeLine{2429 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2430 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{2431 }
\DoxyCodeLine{2432 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2433 }
\DoxyCodeLine{2434     \textcolor{keyword}{class }AssertionResult;}
\DoxyCodeLine{2435     \textcolor{keyword}{struct }AssertionInfo;}
\DoxyCodeLine{2436     \textcolor{keyword}{struct }SectionInfo;}
\DoxyCodeLine{2437     \textcolor{keyword}{struct }SectionEndInfo;}
\DoxyCodeLine{2438     \textcolor{keyword}{struct }MessageInfo;}
\DoxyCodeLine{2439     \textcolor{keyword}{struct }MessageBuilder;}
\DoxyCodeLine{2440     \textcolor{keyword}{struct }Counts;}
\DoxyCodeLine{2441     \textcolor{keyword}{struct }AssertionReaction;}
\DoxyCodeLine{2442     \textcolor{keyword}{struct }SourceLineInfo;}
\DoxyCodeLine{2443 }
\DoxyCodeLine{2444     \textcolor{keyword}{struct }ITransientExpression;}
\DoxyCodeLine{2445     \textcolor{keyword}{struct }IGeneratorTracker;}
\DoxyCodeLine{2446 }
\DoxyCodeLine{2447 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{2448     \textcolor{keyword}{struct }BenchmarkInfo;}
\DoxyCodeLine{2449     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration = std::chrono::duration<\textcolor{keywordtype}{double}, std::nano>>}
\DoxyCodeLine{2450     \textcolor{keyword}{struct }BenchmarkStats;}
\DoxyCodeLine{2451 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{2452 }
\DoxyCodeLine{2453     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_result_capture}{IResultCapture}} \{}
\DoxyCodeLine{2454 }
\DoxyCodeLine{2455         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_result_capture}{\string~IResultCapture}}();}
\DoxyCodeLine{2456 }
\DoxyCodeLine{2457         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} sectionStarted(    \mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}} \textcolor{keyword}{const}\& sectionInfo,}
\DoxyCodeLine{2458                                         \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}}\& assertions ) = 0;}
\DoxyCodeLine{2459         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( \mbox{\hyperlink{struct_catch_1_1_section_end_info}{SectionEndInfo}} \textcolor{keyword}{const}\& endInfo ) = 0;}
\DoxyCodeLine{2460         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEndedEarly( \mbox{\hyperlink{struct_catch_1_1_section_end_info}{SectionEndInfo}} \textcolor{keyword}{const}\& endInfo ) = 0;}
\DoxyCodeLine{2461 }
\DoxyCodeLine{2462         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} acquireGeneratorTracker( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} generatorName, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo ) -\/> \mbox{\hyperlink{struct_catch_1_1_i_generator_tracker}{IGeneratorTracker}}\& = 0;}
\DoxyCodeLine{2463 }
\DoxyCodeLine{2464 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{2465         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkPreparing( std::string \textcolor{keyword}{const}\& name ) = 0;}
\DoxyCodeLine{2466         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& info ) = 0;}
\DoxyCodeLine{2467         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& stats ) = 0;}
\DoxyCodeLine{2468         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkFailed( std::string \textcolor{keyword}{const}\& error ) = 0;}
\DoxyCodeLine{2469 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{2470 }
\DoxyCodeLine{2471         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} pushScopedMessage( \mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}} \textcolor{keyword}{const}\& message ) = 0;}
\DoxyCodeLine{2472         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} popScopedMessage( \mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}} \textcolor{keyword}{const}\& message ) = 0;}
\DoxyCodeLine{2473 }
\DoxyCodeLine{2474         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} emplaceUnscopedMessage( \mbox{\hyperlink{struct_catch_1_1_message_builder}{MessageBuilder}} \textcolor{keyword}{const}\& builder ) = 0;}
\DoxyCodeLine{2475 }
\DoxyCodeLine{2476         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleFatalErrorCondition( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} message ) = 0;}
\DoxyCodeLine{2477 }
\DoxyCodeLine{2478         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleExpr}
\DoxyCodeLine{2479                 (   \mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{2480                     \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \textcolor{keyword}{const}\& expr,}
\DoxyCodeLine{2481                     \mbox{\hyperlink{struct_catch_1_1_assertion_reaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{2482         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleMessage}
\DoxyCodeLine{2483                 (   \mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{2484                     ResultWas::OfType resultType,}
\DoxyCodeLine{2485                     \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{2486                     \mbox{\hyperlink{struct_catch_1_1_assertion_reaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{2487         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleUnexpectedExceptionNotThrown}
\DoxyCodeLine{2488                 (   \mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{2489                     \mbox{\hyperlink{struct_catch_1_1_assertion_reaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{2490         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleUnexpectedInflightException}
\DoxyCodeLine{2491                 (   \mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{2492                     std::string \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{2493                     \mbox{\hyperlink{struct_catch_1_1_assertion_reaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{2494         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleIncomplete}
\DoxyCodeLine{2495                 (   \mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}} \textcolor{keyword}{const}\& info ) = 0;}
\DoxyCodeLine{2496         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleNonExpr}
\DoxyCodeLine{2497                 (   \mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}} \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{2498                     ResultWas::OfType resultType,}
\DoxyCodeLine{2499                     \mbox{\hyperlink{struct_catch_1_1_assertion_reaction}{AssertionReaction}} \&reaction ) = 0;}
\DoxyCodeLine{2500 }
\DoxyCodeLine{2501         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} lastAssertionPassed() = 0;}
\DoxyCodeLine{2502         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionPassed() = 0;}
\DoxyCodeLine{2503 }
\DoxyCodeLine{2504         \textcolor{comment}{// Deprecated, do not use:}}
\DoxyCodeLine{2505         \textcolor{keyword}{virtual} std::string getCurrentTestName() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2506         \textcolor{keyword}{virtual} \textcolor{keyword}{const} AssertionResult* getLastResult() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2507         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} exceptionEarlyReported() = 0;}
\DoxyCodeLine{2508     \};}
\DoxyCodeLine{2509 }
\DoxyCodeLine{2510     \mbox{\hyperlink{struct_catch_1_1_i_result_capture}{IResultCapture}}\& getResultCapture();}
\DoxyCodeLine{2511 \}}
\DoxyCodeLine{2512 }
\DoxyCodeLine{2513 \textcolor{comment}{// end catch\_interfaces\_capture.h}}
\DoxyCodeLine{2514 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2515 }
\DoxyCodeLine{2516     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_test_failure_exception}{TestFailureException}}\{\};}
\DoxyCodeLine{2517     \textcolor{keyword}{struct }AssertionResultData;}
\DoxyCodeLine{2518     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_result_capture}{IResultCapture}};}
\DoxyCodeLine{2519     \textcolor{keyword}{class }RunContext;}
\DoxyCodeLine{2520 }
\DoxyCodeLine{2521     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_lazy_expression}{LazyExpression}} \{}
\DoxyCodeLine{2522         \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_assertion_handler}{AssertionHandler}};}
\DoxyCodeLine{2523         \textcolor{keyword}{friend} \textcolor{keyword}{struct }AssertionStats;}
\DoxyCodeLine{2524         \textcolor{keyword}{friend} \textcolor{keyword}{class }RunContext;}
\DoxyCodeLine{2525 }
\DoxyCodeLine{2526         \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \textcolor{keyword}{const}* m\_transientExpression = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{2527         \textcolor{keywordtype}{bool} m\_isNegated;}
\DoxyCodeLine{2528     \textcolor{keyword}{public}:}
\DoxyCodeLine{2529         \mbox{\hyperlink{class_catch_1_1_lazy_expression}{LazyExpression}}( \textcolor{keywordtype}{bool} isNegated );}
\DoxyCodeLine{2530         \mbox{\hyperlink{class_catch_1_1_lazy_expression}{LazyExpression}}( \mbox{\hyperlink{class_catch_1_1_lazy_expression}{LazyExpression}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{2531         \mbox{\hyperlink{class_catch_1_1_lazy_expression}{LazyExpression}}\& operator = ( \mbox{\hyperlink{class_catch_1_1_lazy_expression}{LazyExpression}} \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{2532 }
\DoxyCodeLine{2533         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() \textcolor{keyword}{const};}
\DoxyCodeLine{2534 }
\DoxyCodeLine{2535         \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator << ( std::ostream\& os, \mbox{\hyperlink{class_catch_1_1_lazy_expression}{LazyExpression}} \textcolor{keyword}{const}\& lazyExpr ) -\/> std::ostream\&;}
\DoxyCodeLine{2536     \};}
\DoxyCodeLine{2537 }
\DoxyCodeLine{2538     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_assertion_reaction}{AssertionReaction}} \{}
\DoxyCodeLine{2539         \textcolor{keywordtype}{bool} shouldDebugBreak = \textcolor{keyword}{false};}
\DoxyCodeLine{2540         \textcolor{keywordtype}{bool} shouldThrow = \textcolor{keyword}{false};}
\DoxyCodeLine{2541     \};}
\DoxyCodeLine{2542 }
\DoxyCodeLine{2543     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_assertion_handler}{AssertionHandler}} \{}
\DoxyCodeLine{2544         \mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}} m\_assertionInfo;}
\DoxyCodeLine{2545         \mbox{\hyperlink{struct_catch_1_1_assertion_reaction}{AssertionReaction}} m\_reaction;}
\DoxyCodeLine{2546         \textcolor{keywordtype}{bool} m\_completed = \textcolor{keyword}{false};}
\DoxyCodeLine{2547         \mbox{\hyperlink{struct_catch_1_1_i_result_capture}{IResultCapture}}\& m\_resultCapture;}
\DoxyCodeLine{2548 }
\DoxyCodeLine{2549     \textcolor{keyword}{public}:}
\DoxyCodeLine{2550         \mbox{\hyperlink{class_catch_1_1_assertion_handler}{AssertionHandler}}}
\DoxyCodeLine{2551             (   \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{2552                 \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{2553                 \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} capturedExpression,}
\DoxyCodeLine{2554                 ResultDisposition::Flags resultDisposition );}
\DoxyCodeLine{2555         \mbox{\hyperlink{class_catch_1_1_assertion_handler}{\string~AssertionHandler}}() \{}
\DoxyCodeLine{2556             \textcolor{keywordflow}{if} ( !m\_completed ) \{}
\DoxyCodeLine{2557                 m\_resultCapture.handleIncomplete( m\_assertionInfo );}
\DoxyCodeLine{2558             \}}
\DoxyCodeLine{2559         \}}
\DoxyCodeLine{2560 }
\DoxyCodeLine{2561         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2562         \textcolor{keywordtype}{void} handleExpr( \mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs<T>}} \textcolor{keyword}{const}\& expr ) \{}
\DoxyCodeLine{2563             handleExpr( expr.makeUnaryExpr() );}
\DoxyCodeLine{2564         \}}
\DoxyCodeLine{2565         \textcolor{keywordtype}{void} handleExpr( \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \textcolor{keyword}{const}\& expr );}
\DoxyCodeLine{2566 }
\DoxyCodeLine{2567         \textcolor{keywordtype}{void} handleMessage(ResultWas::OfType resultType, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& message);}
\DoxyCodeLine{2568 }
\DoxyCodeLine{2569         \textcolor{keywordtype}{void} handleExceptionThrownAsExpected();}
\DoxyCodeLine{2570         \textcolor{keywordtype}{void} handleUnexpectedExceptionNotThrown();}
\DoxyCodeLine{2571         \textcolor{keywordtype}{void} handleExceptionNotThrownAsExpected();}
\DoxyCodeLine{2572         \textcolor{keywordtype}{void} handleThrowingCallSkipped();}
\DoxyCodeLine{2573         \textcolor{keywordtype}{void} handleUnexpectedInflightException();}
\DoxyCodeLine{2574 }
\DoxyCodeLine{2575         \textcolor{keywordtype}{void} complete();}
\DoxyCodeLine{2576         \textcolor{keywordtype}{void} setCompleted();}
\DoxyCodeLine{2577 }
\DoxyCodeLine{2578         \textcolor{comment}{// query}}
\DoxyCodeLine{2579         \textcolor{keyword}{auto} allowThrows() \textcolor{keyword}{const} -\/> bool;}
\DoxyCodeLine{2580     \};}
\DoxyCodeLine{2581 }
\DoxyCodeLine{2582     \textcolor{keywordtype}{void} handleExceptionMatchExpr( \mbox{\hyperlink{class_catch_1_1_assertion_handler}{AssertionHandler}}\& handler, std::string \textcolor{keyword}{const}\& str, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& matcherString );}
\DoxyCodeLine{2583 }
\DoxyCodeLine{2584 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{2585 }
\DoxyCodeLine{2586 \textcolor{comment}{// end catch\_assertionhandler.h}}
\DoxyCodeLine{2587 \textcolor{comment}{// start catch\_message.h}}
\DoxyCodeLine{2588 }
\DoxyCodeLine{2589 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2590 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{2591 }
\DoxyCodeLine{2592 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2593 }
\DoxyCodeLine{2594     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}} \{}
\DoxyCodeLine{2595         \mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}}(    \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& \_macroName,}
\DoxyCodeLine{2596                         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{2597                         ResultWas::OfType \_type );}
\DoxyCodeLine{2598 }
\DoxyCodeLine{2599         \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} macroName;}
\DoxyCodeLine{2600         std::string message;}
\DoxyCodeLine{2601         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{2602         ResultWas::OfType type;}
\DoxyCodeLine{2603         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sequence;}
\DoxyCodeLine{2604 }
\DoxyCodeLine{2605         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{2606         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{2607     \textcolor{keyword}{private}:}
\DoxyCodeLine{2608         \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} globalCount;}
\DoxyCodeLine{2609     \};}
\DoxyCodeLine{2610 }
\DoxyCodeLine{2611     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_message_stream}{MessageStream}} \{}
\DoxyCodeLine{2612 }
\DoxyCodeLine{2613         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2614         \mbox{\hyperlink{struct_catch_1_1_message_stream}{MessageStream}}\& operator << ( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{2615             m\_stream << value;}
\DoxyCodeLine{2616             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2617         \}}
\DoxyCodeLine{2618 }
\DoxyCodeLine{2619         \mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{ReusableStringStream}} m\_stream;}
\DoxyCodeLine{2620     \};}
\DoxyCodeLine{2621 }
\DoxyCodeLine{2622     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_message_builder}{MessageBuilder}} : \mbox{\hyperlink{struct_catch_1_1_message_stream}{MessageStream}} \{}
\DoxyCodeLine{2623         \mbox{\hyperlink{struct_catch_1_1_message_builder}{MessageBuilder}}( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{2624                         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{2625                         ResultWas::OfType type );}
\DoxyCodeLine{2626 }
\DoxyCodeLine{2627         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2628         \mbox{\hyperlink{struct_catch_1_1_message_builder}{MessageBuilder}}\& operator << ( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{2629             m\_stream << value;}
\DoxyCodeLine{2630             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2631         \}}
\DoxyCodeLine{2632 }
\DoxyCodeLine{2633         \mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}} m\_info;}
\DoxyCodeLine{2634     \};}
\DoxyCodeLine{2635 }
\DoxyCodeLine{2636     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_scoped_message}{ScopedMessage}} \{}
\DoxyCodeLine{2637     \textcolor{keyword}{public}:}
\DoxyCodeLine{2638         \textcolor{keyword}{explicit} \mbox{\hyperlink{class_catch_1_1_scoped_message}{ScopedMessage}}( \mbox{\hyperlink{struct_catch_1_1_message_builder}{MessageBuilder}} \textcolor{keyword}{const}\& builder );}
\DoxyCodeLine{2639         \mbox{\hyperlink{class_catch_1_1_scoped_message}{ScopedMessage}}( \mbox{\hyperlink{class_catch_1_1_scoped_message}{ScopedMessage}}\& duplicate ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{2640         \mbox{\hyperlink{class_catch_1_1_scoped_message}{ScopedMessage}}( \mbox{\hyperlink{class_catch_1_1_scoped_message}{ScopedMessage}}\&\& old );}
\DoxyCodeLine{2641         \mbox{\hyperlink{class_catch_1_1_scoped_message}{\string~ScopedMessage}}();}
\DoxyCodeLine{2642 }
\DoxyCodeLine{2643         \mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}} m\_info;}
\DoxyCodeLine{2644         \textcolor{keywordtype}{bool} m\_moved;}
\DoxyCodeLine{2645     \};}
\DoxyCodeLine{2646 }
\DoxyCodeLine{2647     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_capturer}{Capturer}} \{}
\DoxyCodeLine{2648         std::vector<MessageInfo> m\_messages;}
\DoxyCodeLine{2649         \mbox{\hyperlink{struct_catch_1_1_i_result_capture}{IResultCapture}}\& m\_resultCapture = getResultCapture();}
\DoxyCodeLine{2650         \textcolor{keywordtype}{size\_t} m\_captured = 0;}
\DoxyCodeLine{2651     \textcolor{keyword}{public}:}
\DoxyCodeLine{2652         \mbox{\hyperlink{class_catch_1_1_capturer}{Capturer}}( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} macroName, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo, ResultWas::OfType resultType, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} names );}
\DoxyCodeLine{2653         \mbox{\hyperlink{class_catch_1_1_capturer}{\string~Capturer}}();}
\DoxyCodeLine{2654 }
\DoxyCodeLine{2655         \textcolor{keywordtype}{void} captureValue( \textcolor{keywordtype}{size\_t} index, std::string \textcolor{keyword}{const}\& value );}
\DoxyCodeLine{2656 }
\DoxyCodeLine{2657         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2658         \textcolor{keywordtype}{void} captureValues( \textcolor{keywordtype}{size\_t} index, T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{2659             captureValue( index, Catch::Detail::stringify( value ) );}
\DoxyCodeLine{2660         \}}
\DoxyCodeLine{2661 }
\DoxyCodeLine{2662         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{2663         \textcolor{keywordtype}{void} captureValues( \textcolor{keywordtype}{size\_t} index, T \textcolor{keyword}{const}\& value, Ts \textcolor{keyword}{const}\&... values ) \{}
\DoxyCodeLine{2664             captureValue( index, Catch::Detail::stringify(value) );}
\DoxyCodeLine{2665             captureValues( index+1, values... );}
\DoxyCodeLine{2666         \}}
\DoxyCodeLine{2667     \};}
\DoxyCodeLine{2668 }
\DoxyCodeLine{2669 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2670 }
\DoxyCodeLine{2671 \textcolor{comment}{// end catch\_message.h}}
\DoxyCodeLine{2672 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{2673 }
\DoxyCodeLine{2674 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_STRINGIFICATION)}}
\DoxyCodeLine{2675 \textcolor{preprocessor}{  \#define CATCH\_INTERNAL\_STRINGIFY(...) \#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{2676 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2677 \textcolor{preprocessor}{  \#define CATCH\_INTERNAL\_STRINGIFY(...) "{}Disabled by CATCH\_CONFIG\_DISABLE\_STRINGIFICATION"{}}}
\DoxyCodeLine{2678 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2679 }
\DoxyCodeLine{2680 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_FAST\_COMPILE) || defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{2681 }
\DoxyCodeLine{2683 \textcolor{comment}{// Another way to speed-\/up compilation is to omit local try-\/catch for REQUIRE*}}
\DoxyCodeLine{2684 \textcolor{comment}{// macros.}}
\DoxyCodeLine{2685 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRY}}
\DoxyCodeLine{2686 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_CATCH( capturer )}}
\DoxyCodeLine{2687 }
\DoxyCodeLine{2688 \textcolor{preprocessor}{\#else }\textcolor{comment}{// CATCH\_CONFIG\_FAST\_COMPILE}}
\DoxyCodeLine{2689 }
\DoxyCodeLine{2690 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRY try}}
\DoxyCodeLine{2691 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_CATCH( handler ) catch(...) \{ handler.handleUnexpectedInflightException(); \}}}
\DoxyCodeLine{2692 }
\DoxyCodeLine{2693 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2694 }
\DoxyCodeLine{2695 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REACT( handler ) handler.complete();}}
\DoxyCodeLine{2696 }
\DoxyCodeLine{2698 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEST( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2699 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2700 \textcolor{preprocessor}{        CATCH\_INTERNAL\_IGNORE\_BUT\_WARN(\_\_VA\_ARGS\_\_); \(\backslash\)}}
\DoxyCodeLine{2701 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{2702 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TRY \{ \(\backslash\)}}
\DoxyCodeLine{2703 \textcolor{preprocessor}{            CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{2704 \textcolor{preprocessor}{            CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{2705 \textcolor{preprocessor}{            catchAssertionHandler.handleExpr( Catch::Decomposer() <= \_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{2706 \textcolor{preprocessor}{            CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{2707 \textcolor{preprocessor}{        \} INTERNAL\_CATCH\_CATCH( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2708 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2709 \textcolor{preprocessor}{    \} while( (void)0, (false) \&\& static\_cast<bool>( !!(\_\_VA\_ARGS\_\_) ) )}}
\DoxyCodeLine{2710 }
\DoxyCodeLine{2712 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_IF( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2713 \textcolor{preprocessor}{    INTERNAL\_CATCH\_TEST( macroName, resultDisposition, \_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{2714 \textcolor{preprocessor}{    if( Catch::getResultCapture().lastAssertionPassed() )}}
\DoxyCodeLine{2715 }
\DoxyCodeLine{2717 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_ELSE( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2718 \textcolor{preprocessor}{    INTERNAL\_CATCH\_TEST( macroName, resultDisposition, \_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{2719 \textcolor{preprocessor}{    if( !Catch::getResultCapture().lastAssertionPassed() )}}
\DoxyCodeLine{2720 }
\DoxyCodeLine{2722 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NO\_THROW( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2723 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2724 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{2725 \textcolor{preprocessor}{        try \{ \(\backslash\)}}
\DoxyCodeLine{2726 \textcolor{preprocessor}{            static\_cast<void>(\_\_VA\_ARGS\_\_); \(\backslash\)}}
\DoxyCodeLine{2727 \textcolor{preprocessor}{            catchAssertionHandler.handleExceptionNotThrownAsExpected(); \(\backslash\)}}
\DoxyCodeLine{2728 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2729 \textcolor{preprocessor}{        catch( ... ) \{ \(\backslash\)}}
\DoxyCodeLine{2730 \textcolor{preprocessor}{            catchAssertionHandler.handleUnexpectedInflightException(); \(\backslash\)}}
\DoxyCodeLine{2731 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2732 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2733 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{2734 }
\DoxyCodeLine{2736 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2737 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2738 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_), resultDisposition); \(\backslash\)}}
\DoxyCodeLine{2739 \textcolor{preprocessor}{        if( catchAssertionHandler.allowThrows() ) \(\backslash\)}}
\DoxyCodeLine{2740 \textcolor{preprocessor}{            try \{ \(\backslash\)}}
\DoxyCodeLine{2741 \textcolor{preprocessor}{                static\_cast<void>(\_\_VA\_ARGS\_\_); \(\backslash\)}}
\DoxyCodeLine{2742 \textcolor{preprocessor}{                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}}
\DoxyCodeLine{2743 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{2744 \textcolor{preprocessor}{            catch( ... ) \{ \(\backslash\)}}
\DoxyCodeLine{2745 \textcolor{preprocessor}{                catchAssertionHandler.handleExceptionThrownAsExpected(); \(\backslash\)}}
\DoxyCodeLine{2746 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{2747 \textcolor{preprocessor}{        else \(\backslash\)}}
\DoxyCodeLine{2748 \textcolor{preprocessor}{            catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}}
\DoxyCodeLine{2749 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2750 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{2751 }
\DoxyCodeLine{2753 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS\_AS( macroName, exceptionType, resultDisposition, expr ) \(\backslash\)}}
\DoxyCodeLine{2754 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2755 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(expr) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(exceptionType), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{2756         if( catchAssertionHandler.allowThrows() ) \(\backslash\)}
\DoxyCodeLine{2757             try \{ \(\backslash\)}
\DoxyCodeLine{2758                 static\_cast<void>(expr); \(\backslash\)}
\DoxyCodeLine{2759                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}
\DoxyCodeLine{2760             \} \(\backslash\)}
\DoxyCodeLine{2761             catch( exceptionType const\& ) \{ \(\backslash\)}
\DoxyCodeLine{2762                 catchAssertionHandler.handleExceptionThrownAsExpected(); \(\backslash\)}
\DoxyCodeLine{2763             \} \(\backslash\)}
\DoxyCodeLine{2764             catch( ... ) \{ \(\backslash\)}
\DoxyCodeLine{2765                 catchAssertionHandler.handleUnexpectedInflightException(); \(\backslash\)}
\DoxyCodeLine{2766             \} \(\backslash\)}
\DoxyCodeLine{2767         else \(\backslash\)}
\DoxyCodeLine{2768             catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}
\DoxyCodeLine{2769         INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{2770     \} while( false )}
\DoxyCodeLine{2771 }
\DoxyCodeLine{2773 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MSG( macroName, messageType, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2774 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2775 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{2776 \textcolor{preprocessor}{        catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << \_\_VA\_ARGS\_\_ + ::Catch::StreamEndStop() ).m\_stream.str() ); \(\backslash\)}}
\DoxyCodeLine{2777 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2778 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{2779 }
\DoxyCodeLine{2781 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_CAPTURE( varName, macroName, ... ) \(\backslash\)}}
\DoxyCodeLine{2782 \textcolor{preprocessor}{    auto varName = Catch::Capturer( macroName, CATCH\_INTERNAL\_LINEINFO, Catch::ResultWas::Info, \#\_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{2783 \textcolor{preprocessor}{    varName.captureValues( 0, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{2784 }
\DoxyCodeLine{2786 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_INFO( macroName, log ) \(\backslash\)}}
\DoxyCodeLine{2787 \textcolor{preprocessor}{    Catch::ScopedMessage INTERNAL\_CATCH\_UNIQUE\_NAME( scopedMessage )( Catch::MessageBuilder( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, Catch::ResultWas::Info ) << log );}}
\DoxyCodeLine{2788 }
\DoxyCodeLine{2790 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_UNSCOPED\_INFO( macroName, log ) \(\backslash\)}}
\DoxyCodeLine{2791 \textcolor{preprocessor}{    Catch::getResultCapture().emplaceUnscopedMessage( Catch::MessageBuilder( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, Catch::ResultWas::Info ) << log )}}
\DoxyCodeLine{2792 }
\DoxyCodeLine{2794 \textcolor{comment}{// Although this is matcher-\/based, it can be used with just a string}}
\DoxyCodeLine{2795 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( macroName, resultDisposition, matcher, ... ) \(\backslash\)}}
\DoxyCodeLine{2796 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2797 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(matcher), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{2798         if( catchAssertionHandler.allowThrows() ) \(\backslash\)}
\DoxyCodeLine{2799             try \{ \(\backslash\)}
\DoxyCodeLine{2800                 static\_cast<void>(\_\_VA\_ARGS\_\_); \(\backslash\)}
\DoxyCodeLine{2801                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}
\DoxyCodeLine{2802             \} \(\backslash\)}
\DoxyCodeLine{2803             catch( ... ) \{ \(\backslash\)}
\DoxyCodeLine{2804                 Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, \#matcher\#\#\_catch\_sr ); \(\backslash\)}
\DoxyCodeLine{2805             \} \(\backslash\)}
\DoxyCodeLine{2806         else \(\backslash\)}
\DoxyCodeLine{2807             catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}
\DoxyCodeLine{2808         INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{2809     \} while( false )}
\DoxyCodeLine{2810 }
\DoxyCodeLine{2811 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{2812 }
\DoxyCodeLine{2813 \textcolor{comment}{// end catch\_capture.hpp}}
\DoxyCodeLine{2814 \textcolor{comment}{// start catch\_section.h}}
\DoxyCodeLine{2815 }
\DoxyCodeLine{2816 \textcolor{comment}{// start catch\_section\_info.h}}
\DoxyCodeLine{2817 }
\DoxyCodeLine{2818 \textcolor{comment}{// start catch\_totals.h}}
\DoxyCodeLine{2819 }
\DoxyCodeLine{2820 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{2821 }
\DoxyCodeLine{2822 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2823 }
\DoxyCodeLine{2824     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} \{}
\DoxyCodeLine{2825         \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} operator -\/ ( \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{2826         \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}}\& operator += ( \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{2827 }
\DoxyCodeLine{2828         std::size\_t total() \textcolor{keyword}{const};}
\DoxyCodeLine{2829         \textcolor{keywordtype}{bool} allPassed() \textcolor{keyword}{const};}
\DoxyCodeLine{2830         \textcolor{keywordtype}{bool} allOk() \textcolor{keyword}{const};}
\DoxyCodeLine{2831 }
\DoxyCodeLine{2832         std::size\_t passed = 0;}
\DoxyCodeLine{2833         std::size\_t failed = 0;}
\DoxyCodeLine{2834         std::size\_t failedButOk = 0;}
\DoxyCodeLine{2835     \};}
\DoxyCodeLine{2836 }
\DoxyCodeLine{2837     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_totals}{Totals}} \{}
\DoxyCodeLine{2838 }
\DoxyCodeLine{2839         \mbox{\hyperlink{struct_catch_1_1_totals}{Totals}} operator -\/ ( \mbox{\hyperlink{struct_catch_1_1_totals}{Totals}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{2840         \mbox{\hyperlink{struct_catch_1_1_totals}{Totals}}\& operator += ( \mbox{\hyperlink{struct_catch_1_1_totals}{Totals}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{2841 }
\DoxyCodeLine{2842         \mbox{\hyperlink{struct_catch_1_1_totals}{Totals}} delta( \mbox{\hyperlink{struct_catch_1_1_totals}{Totals}} \textcolor{keyword}{const}\& prevTotals ) \textcolor{keyword}{const};}
\DoxyCodeLine{2843 }
\DoxyCodeLine{2844         \textcolor{keywordtype}{int} error = 0;}
\DoxyCodeLine{2845         \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} assertions;}
\DoxyCodeLine{2846         \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} testCases;}
\DoxyCodeLine{2847     \};}
\DoxyCodeLine{2848 \}}
\DoxyCodeLine{2849 }
\DoxyCodeLine{2850 \textcolor{comment}{// end catch\_totals.h}}
\DoxyCodeLine{2851 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2852 }
\DoxyCodeLine{2853 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2854 }
\DoxyCodeLine{2855     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}} \{}
\DoxyCodeLine{2856         \mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}}}
\DoxyCodeLine{2857             (   \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{2858                 std::string \textcolor{keyword}{const}\& \_name );}
\DoxyCodeLine{2859 }
\DoxyCodeLine{2860         \textcolor{comment}{// Deprecated}}
\DoxyCodeLine{2861         \mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}}}
\DoxyCodeLine{2862             (   \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{2863                 std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{2864                 std::string \textcolor{keyword}{const}\& ) : \mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}}( \_lineInfo, \_name ) \{\}}
\DoxyCodeLine{2865 }
\DoxyCodeLine{2866         std::string name;}
\DoxyCodeLine{2867         std::string description; \textcolor{comment}{// !Deprecated: this will always be empty}}
\DoxyCodeLine{2868         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{2869     \};}
\DoxyCodeLine{2870 }
\DoxyCodeLine{2871     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_section_end_info}{SectionEndInfo}} \{}
\DoxyCodeLine{2872         \mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}} sectionInfo;}
\DoxyCodeLine{2873         \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} prevAssertions;}
\DoxyCodeLine{2874         \textcolor{keywordtype}{double} durationInSeconds;}
\DoxyCodeLine{2875     \};}
\DoxyCodeLine{2876 }
\DoxyCodeLine{2877 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2878 }
\DoxyCodeLine{2879 \textcolor{comment}{// end catch\_section\_info.h}}
\DoxyCodeLine{2880 \textcolor{comment}{// start catch\_timer.h}}
\DoxyCodeLine{2881 }
\DoxyCodeLine{2882 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{2883 }
\DoxyCodeLine{2884 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2885 }
\DoxyCodeLine{2886     \textcolor{keyword}{auto} getCurrentNanosecondsSinceEpoch() -\/> uint64\_t;}
\DoxyCodeLine{2887     \textcolor{keyword}{auto} getEstimatedClockResolution() -\/> uint64\_t;}
\DoxyCodeLine{2888 }
\DoxyCodeLine{2889     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_timer}{Timer}} \{}
\DoxyCodeLine{2890         uint64\_t m\_nanoseconds = 0;}
\DoxyCodeLine{2891     \textcolor{keyword}{public}:}
\DoxyCodeLine{2892         \textcolor{keywordtype}{void} start();}
\DoxyCodeLine{2893         \textcolor{keyword}{auto} getElapsedNanoseconds() \textcolor{keyword}{const} -\/> uint64\_t;}
\DoxyCodeLine{2894         \textcolor{keyword}{auto} getElapsedMicroseconds() \textcolor{keyword}{const} -\/> uint64\_t;}
\DoxyCodeLine{2895         \textcolor{keyword}{auto} getElapsedMilliseconds() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{unsigned} int;}
\DoxyCodeLine{2896         \textcolor{keyword}{auto} getElapsedSeconds() \textcolor{keyword}{const} -\/> double;}
\DoxyCodeLine{2897     \};}
\DoxyCodeLine{2898 }
\DoxyCodeLine{2899 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{2900 }
\DoxyCodeLine{2901 \textcolor{comment}{// end catch\_timer.h}}
\DoxyCodeLine{2902 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2903 }
\DoxyCodeLine{2904 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2905 }
\DoxyCodeLine{2906     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_section}{Section}} : \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \{}
\DoxyCodeLine{2907     \textcolor{keyword}{public}:}
\DoxyCodeLine{2908         \mbox{\hyperlink{class_catch_1_1_section}{Section}}( \mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}} \textcolor{keyword}{const}\& info );}
\DoxyCodeLine{2909         \mbox{\hyperlink{class_catch_1_1_section}{\string~Section}}();}
\DoxyCodeLine{2910 }
\DoxyCodeLine{2911         \textcolor{comment}{// This indicates whether the section should be executed or not}}
\DoxyCodeLine{2912         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() \textcolor{keyword}{const};}
\DoxyCodeLine{2913 }
\DoxyCodeLine{2914     \textcolor{keyword}{private}:}
\DoxyCodeLine{2915         \mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}} m\_info;}
\DoxyCodeLine{2916 }
\DoxyCodeLine{2917         std::string m\_name;}
\DoxyCodeLine{2918         \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} m\_assertions;}
\DoxyCodeLine{2919         \textcolor{keywordtype}{bool} m\_sectionIncluded;}
\DoxyCodeLine{2920         \mbox{\hyperlink{class_catch_1_1_timer}{Timer}} m\_timer;}
\DoxyCodeLine{2921     \};}
\DoxyCodeLine{2922 }
\DoxyCodeLine{2923 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2924 }
\DoxyCodeLine{2925 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_SECTION( ... ) \(\backslash\)}}
\DoxyCodeLine{2926 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{2927 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{2928 \textcolor{preprocessor}{    if( Catch::Section const\& INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_Section ) = Catch::SectionInfo( CATCH\_INTERNAL\_LINEINFO, \_\_VA\_ARGS\_\_ ) ) \(\backslash\)}}
\DoxyCodeLine{2929 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{2930 }
\DoxyCodeLine{2931 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DYNAMIC\_SECTION( ... ) \(\backslash\)}}
\DoxyCodeLine{2932 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{2933 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{2934 \textcolor{preprocessor}{    if( Catch::Section const\& INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_Section ) = Catch::SectionInfo( CATCH\_INTERNAL\_LINEINFO, (Catch::ReusableStringStream() << \_\_VA\_ARGS\_\_).str() ) ) \(\backslash\)}}
\DoxyCodeLine{2935 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{2936 }
\DoxyCodeLine{2937 \textcolor{comment}{// end catch\_section.h}}
\DoxyCodeLine{2938 \textcolor{comment}{// start catch\_interfaces\_exception.h}}
\DoxyCodeLine{2939 }
\DoxyCodeLine{2940 \textcolor{comment}{// start catch\_interfaces\_registry\_hub.h}}
\DoxyCodeLine{2941 }
\DoxyCodeLine{2942 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2943 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{2944 }
\DoxyCodeLine{2945 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2946 }
\DoxyCodeLine{2947     \textcolor{keyword}{class }TestCase;}
\DoxyCodeLine{2948     \textcolor{keyword}{struct }ITestCaseRegistry;}
\DoxyCodeLine{2949     \textcolor{keyword}{struct }IExceptionTranslatorRegistry;}
\DoxyCodeLine{2950     \textcolor{keyword}{struct }IExceptionTranslator;}
\DoxyCodeLine{2951     \textcolor{keyword}{struct }IReporterRegistry;}
\DoxyCodeLine{2952     \textcolor{keyword}{struct }IReporterFactory;}
\DoxyCodeLine{2953     \textcolor{keyword}{struct }ITagAliasRegistry;}
\DoxyCodeLine{2954     \textcolor{keyword}{struct }IMutableEnumValuesRegistry;}
\DoxyCodeLine{2955 }
\DoxyCodeLine{2956     \textcolor{keyword}{class }StartupExceptionRegistry;}
\DoxyCodeLine{2957 }
\DoxyCodeLine{2958     \textcolor{keyword}{using} IReporterFactoryPtr = std::shared\_ptr<IReporterFactory>;}
\DoxyCodeLine{2959 }
\DoxyCodeLine{2960     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_registry_hub}{IRegistryHub}} \{}
\DoxyCodeLine{2961         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_registry_hub}{\string~IRegistryHub}}();}
\DoxyCodeLine{2962 }
\DoxyCodeLine{2963         \textcolor{keyword}{virtual} IReporterRegistry \textcolor{keyword}{const}\& getReporterRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2964         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_test_case_registry}{ITestCaseRegistry}} \textcolor{keyword}{const}\& getTestCaseRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2965         \textcolor{keyword}{virtual} ITagAliasRegistry \textcolor{keyword}{const}\& getTagAliasRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2966         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_exception_translator_registry}{IExceptionTranslatorRegistry}} \textcolor{keyword}{const}\& getExceptionTranslatorRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2967 }
\DoxyCodeLine{2968         \textcolor{keyword}{virtual} StartupExceptionRegistry \textcolor{keyword}{const}\& getStartupExceptionRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2969     \};}
\DoxyCodeLine{2970 }
\DoxyCodeLine{2971     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_mutable_registry_hub}{IMutableRegistryHub}} \{}
\DoxyCodeLine{2972         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_mutable_registry_hub}{\string~IMutableRegistryHub}}();}
\DoxyCodeLine{2973         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) = 0;}
\DoxyCodeLine{2974         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) = 0;}
\DoxyCodeLine{2975         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTest( \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{2976         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} \mbox{\hyperlink{struct_catch_1_1_i_exception_translator}{IExceptionTranslator}}* translator ) = 0;}
\DoxyCodeLine{2977         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTagAlias( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo ) = 0;}
\DoxyCodeLine{2978         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerStartupException() \textcolor{keyword}{noexcept} = 0;}
\DoxyCodeLine{2979         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_mutable_enum_values_registry}{IMutableEnumValuesRegistry}}\& getMutableEnumValuesRegistry() = 0;}
\DoxyCodeLine{2980     \};}
\DoxyCodeLine{2981 }
\DoxyCodeLine{2982     \mbox{\hyperlink{struct_catch_1_1_i_registry_hub}{IRegistryHub}} \textcolor{keyword}{const}\& getRegistryHub();}
\DoxyCodeLine{2983     \mbox{\hyperlink{struct_catch_1_1_i_mutable_registry_hub}{IMutableRegistryHub}}\& getMutableRegistryHub();}
\DoxyCodeLine{2984     \textcolor{keywordtype}{void} cleanUp();}
\DoxyCodeLine{2985     std::string translateActiveException();}
\DoxyCodeLine{2986 }
\DoxyCodeLine{2987 \}}
\DoxyCodeLine{2988 }
\DoxyCodeLine{2989 \textcolor{comment}{// end catch\_interfaces\_registry\_hub.h}}
\DoxyCodeLine{2990 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{2991 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION\_NO\_REG( translatorName, signature) \(\backslash\)}}
\DoxyCodeLine{2992 \textcolor{preprocessor}{        static std::string translatorName( signature )}}
\DoxyCodeLine{2993 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2994 }
\DoxyCodeLine{2995 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{2996 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2997 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{2998 }
\DoxyCodeLine{2999 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3000     \textcolor{keyword}{using} exceptionTranslateFunction = std::string(*)();}
\DoxyCodeLine{3001 }
\DoxyCodeLine{3002     \textcolor{keyword}{struct }IExceptionTranslator;}
\DoxyCodeLine{3003     \textcolor{keyword}{using} ExceptionTranslators = std::vector<std::unique\_ptr<IExceptionTranslator const>>;}
\DoxyCodeLine{3004 }
\DoxyCodeLine{3005     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_exception_translator}{IExceptionTranslator}} \{}
\DoxyCodeLine{3006         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_exception_translator}{\string~IExceptionTranslator}}();}
\DoxyCodeLine{3007         \textcolor{keyword}{virtual} std::string translate( ExceptionTranslators::const\_iterator it, ExceptionTranslators::const\_iterator itEnd ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3008     \};}
\DoxyCodeLine{3009 }
\DoxyCodeLine{3010     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_exception_translator_registry}{IExceptionTranslatorRegistry}} \{}
\DoxyCodeLine{3011         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_exception_translator_registry}{\string~IExceptionTranslatorRegistry}}();}
\DoxyCodeLine{3012 }
\DoxyCodeLine{3013         \textcolor{keyword}{virtual} std::string translateActiveException() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3014     \};}
\DoxyCodeLine{3015 }
\DoxyCodeLine{3016     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_exception_translator_registrar}{ExceptionTranslatorRegistrar}} \{}
\DoxyCodeLine{3017         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3018         \textcolor{keyword}{class }ExceptionTranslator : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_i_exception_translator}{IExceptionTranslator}} \{}
\DoxyCodeLine{3019         \textcolor{keyword}{public}:}
\DoxyCodeLine{3020 }
\DoxyCodeLine{3021             ExceptionTranslator( std::string(*translateFunction)( T\& ) )}
\DoxyCodeLine{3022             : m\_translateFunction( translateFunction )}
\DoxyCodeLine{3023             \{\}}
\DoxyCodeLine{3024 }
\DoxyCodeLine{3025             std::string translate( ExceptionTranslators::const\_iterator it, ExceptionTranslators::const\_iterator itEnd )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3026 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{3027                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{3028 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3029                 \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{3030                     \textcolor{keywordflow}{if}( it == itEnd )}
\DoxyCodeLine{3031                         std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{3032                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3033                         \textcolor{keywordflow}{return} (*it)-\/>translate( it+1, itEnd );}
\DoxyCodeLine{3034                 \}}
\DoxyCodeLine{3035                 \textcolor{keywordflow}{catch}( T\& ex ) \{}
\DoxyCodeLine{3036                     \textcolor{keywordflow}{return} m\_translateFunction( ex );}
\DoxyCodeLine{3037                 \}}
\DoxyCodeLine{3038 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3039             \}}
\DoxyCodeLine{3040 }
\DoxyCodeLine{3041         \textcolor{keyword}{protected}:}
\DoxyCodeLine{3042             std::string(*m\_translateFunction)( T\& );}
\DoxyCodeLine{3043         \};}
\DoxyCodeLine{3044 }
\DoxyCodeLine{3045     \textcolor{keyword}{public}:}
\DoxyCodeLine{3046         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3047         \mbox{\hyperlink{class_catch_1_1_exception_translator_registrar}{ExceptionTranslatorRegistrar}}( std::string(*translateFunction)( T\& ) ) \{}
\DoxyCodeLine{3048             getMutableRegistryHub().registerTranslator}
\DoxyCodeLine{3049                 ( \textcolor{keyword}{new} ExceptionTranslator<T>( translateFunction ) );}
\DoxyCodeLine{3050         \}}
\DoxyCodeLine{3051     \};}
\DoxyCodeLine{3052 \}}
\DoxyCodeLine{3053 }
\DoxyCodeLine{3055 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION2( translatorName, signature ) \(\backslash\)}}
\DoxyCodeLine{3056 \textcolor{preprocessor}{    static std::string translatorName( signature ); \(\backslash\)}}
\DoxyCodeLine{3057 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{3058 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{3059 \textcolor{preprocessor}{    namespace\{ Catch::ExceptionTranslatorRegistrar INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_ExceptionRegistrar )( \&translatorName ); \} \(\backslash\)}}
\DoxyCodeLine{3060 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{3061 \textcolor{preprocessor}{    static std::string translatorName( signature )}}
\DoxyCodeLine{3062 }
\DoxyCodeLine{3063 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION( signature ) INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION2( INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_ExceptionTranslator ), signature )}}
\DoxyCodeLine{3064 }
\DoxyCodeLine{3065 \textcolor{comment}{// end catch\_interfaces\_exception.h}}
\DoxyCodeLine{3066 \textcolor{comment}{// start catch\_approx.h}}
\DoxyCodeLine{3067 }
\DoxyCodeLine{3068 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{3069 }
\DoxyCodeLine{3070 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3071 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{3072 }
\DoxyCodeLine{3073     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \{}
\DoxyCodeLine{3074     \textcolor{keyword}{private}:}
\DoxyCodeLine{3075         \textcolor{keywordtype}{bool} equalityComparisonImpl(\textcolor{keywordtype}{double} other) \textcolor{keyword}{const};}
\DoxyCodeLine{3076         \textcolor{comment}{// Validates the new margin (margin >= 0)}}
\DoxyCodeLine{3077         \textcolor{comment}{// out-\/of-\/line to avoid including stdexcept in the header}}
\DoxyCodeLine{3078         \textcolor{keywordtype}{void} setMargin(\textcolor{keywordtype}{double} margin);}
\DoxyCodeLine{3079         \textcolor{comment}{// Validates the new epsilon (0 < epsilon < 1)}}
\DoxyCodeLine{3080         \textcolor{comment}{// out-\/of-\/line to avoid including stdexcept in the header}}
\DoxyCodeLine{3081         \textcolor{keywordtype}{void} setEpsilon(\textcolor{keywordtype}{double} epsilon);}
\DoxyCodeLine{3082 }
\DoxyCodeLine{3083     \textcolor{keyword}{public}:}
\DoxyCodeLine{3084         \textcolor{keyword}{explicit} \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} ( \textcolor{keywordtype}{double} value );}
\DoxyCodeLine{3085 }
\DoxyCodeLine{3086         \textcolor{keyword}{static} \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} custom();}
\DoxyCodeLine{3087 }
\DoxyCodeLine{3088         \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} operator-\/() \textcolor{keyword}{const};}
\DoxyCodeLine{3089 }
\DoxyCodeLine{3090         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3091         \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} operator()( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{3092             \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} approx( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value) );}
\DoxyCodeLine{3093             approx.m\_epsilon = m\_epsilon;}
\DoxyCodeLine{3094             approx.m\_margin = m\_margin;}
\DoxyCodeLine{3095             approx.m\_scale = m\_scale;}
\DoxyCodeLine{3096             \textcolor{keywordflow}{return} approx;}
\DoxyCodeLine{3097         \}}
\DoxyCodeLine{3098 }
\DoxyCodeLine{3099         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3100         \textcolor{keyword}{explicit} \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}}( T \textcolor{keyword}{const}\& value ): \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value))}
\DoxyCodeLine{3101         \{\}}
\DoxyCodeLine{3102 }
\DoxyCodeLine{3103         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3104         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator == ( \textcolor{keyword}{const} T\& lhs, \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3105             \textcolor{keyword}{auto} lhs\_v = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(lhs);}
\DoxyCodeLine{3106             \textcolor{keywordflow}{return} rhs.equalityComparisonImpl(lhs\_v);}
\DoxyCodeLine{3107         \}}
\DoxyCodeLine{3108 }
\DoxyCodeLine{3109         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3110         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& lhs, \textcolor{keyword}{const} T\& rhs ) \{}
\DoxyCodeLine{3111             \textcolor{keywordflow}{return} operator==( rhs, lhs );}
\DoxyCodeLine{3112         \}}
\DoxyCodeLine{3113 }
\DoxyCodeLine{3114         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3115         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator != ( T \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3116             \textcolor{keywordflow}{return} !operator==( lhs, rhs );}
\DoxyCodeLine{3117         \}}
\DoxyCodeLine{3118 }
\DoxyCodeLine{3119         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3120         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator != ( \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& lhs, T \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3121             \textcolor{keywordflow}{return} !operator==( rhs, lhs );}
\DoxyCodeLine{3122         \}}
\DoxyCodeLine{3123 }
\DoxyCodeLine{3124         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3125         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator <= ( T \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3126             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(lhs) < rhs.m\_value || lhs == rhs;}
\DoxyCodeLine{3127         \}}
\DoxyCodeLine{3128 }
\DoxyCodeLine{3129         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3130         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator <= ( \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& lhs, T \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3131             \textcolor{keywordflow}{return} lhs.m\_value < \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(rhs) || lhs == rhs;}
\DoxyCodeLine{3132         \}}
\DoxyCodeLine{3133 }
\DoxyCodeLine{3134         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3135         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator >= ( T \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3136             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(lhs) > rhs.m\_value || lhs == rhs;}
\DoxyCodeLine{3137         \}}
\DoxyCodeLine{3138 }
\DoxyCodeLine{3139         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3140         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator >= ( \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& lhs, T \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3141             \textcolor{keywordflow}{return} lhs.m\_value > \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(rhs) || lhs == rhs;}
\DoxyCodeLine{3142         \}}
\DoxyCodeLine{3143 }
\DoxyCodeLine{3144         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3145         \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}}\& epsilon( T \textcolor{keyword}{const}\& newEpsilon ) \{}
\DoxyCodeLine{3146             \textcolor{keywordtype}{double} epsilonAsDouble = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(newEpsilon);}
\DoxyCodeLine{3147             setEpsilon(epsilonAsDouble);}
\DoxyCodeLine{3148             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3149         \}}
\DoxyCodeLine{3150 }
\DoxyCodeLine{3151         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3152         \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}}\& margin( T \textcolor{keyword}{const}\& newMargin ) \{}
\DoxyCodeLine{3153             \textcolor{keywordtype}{double} marginAsDouble = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(newMargin);}
\DoxyCodeLine{3154             setMargin(marginAsDouble);}
\DoxyCodeLine{3155             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3156         \}}
\DoxyCodeLine{3157 }
\DoxyCodeLine{3158         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3159         \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}}\& scale( T \textcolor{keyword}{const}\& newScale ) \{}
\DoxyCodeLine{3160             m\_scale = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(newScale);}
\DoxyCodeLine{3161             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3162         \}}
\DoxyCodeLine{3163 }
\DoxyCodeLine{3164         std::string toString() \textcolor{keyword}{const};}
\DoxyCodeLine{3165 }
\DoxyCodeLine{3166     \textcolor{keyword}{private}:}
\DoxyCodeLine{3167         \textcolor{keywordtype}{double} m\_epsilon;}
\DoxyCodeLine{3168         \textcolor{keywordtype}{double} m\_margin;}
\DoxyCodeLine{3169         \textcolor{keywordtype}{double} m\_scale;}
\DoxyCodeLine{3170         \textcolor{keywordtype}{double} m\_value;}
\DoxyCodeLine{3171     \};}
\DoxyCodeLine{3172 \} \textcolor{comment}{// end namespace Detail}}
\DoxyCodeLine{3173 }
\DoxyCodeLine{3174 \textcolor{keyword}{namespace }literals \{}
\DoxyCodeLine{3175     \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Detail::Approx}} \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} val);}
\DoxyCodeLine{3176     \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Detail::Approx}} \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val);}
\DoxyCodeLine{3177 \} \textcolor{comment}{// end namespace literals}}
\DoxyCodeLine{3178 }
\DoxyCodeLine{3179 \textcolor{keyword}{template}<>}
\DoxyCodeLine{3180 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<Catch::\mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Detail::Approx}}> \{}
\DoxyCodeLine{3181     \textcolor{keyword}{static} std::string convert(\mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Catch::Detail::Approx}} \textcolor{keyword}{const}\& value);}
\DoxyCodeLine{3182 \};}
\DoxyCodeLine{3183 }
\DoxyCodeLine{3184 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{3185 }
\DoxyCodeLine{3186 \textcolor{comment}{// end catch\_approx.h}}
\DoxyCodeLine{3187 \textcolor{comment}{// start catch\_string\_manip.h}}
\DoxyCodeLine{3188 }
\DoxyCodeLine{3189 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3190 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{3191 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{3192 }
\DoxyCodeLine{3193 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3194 }
\DoxyCodeLine{3195     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& prefix );}
\DoxyCodeLine{3196     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} prefix );}
\DoxyCodeLine{3197     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& suffix );}
\DoxyCodeLine{3198     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} suffix );}
\DoxyCodeLine{3199     \textcolor{keywordtype}{bool} contains( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& infix );}
\DoxyCodeLine{3200     \textcolor{keywordtype}{void} toLowerInPlace( std::string\& s );}
\DoxyCodeLine{3201     std::string toLower( std::string \textcolor{keyword}{const}\& s );}
\DoxyCodeLine{3203     std::string trim( std::string \textcolor{keyword}{const}\& str );}
\DoxyCodeLine{3205     StringRef trim(StringRef ref);}
\DoxyCodeLine{3206 }
\DoxyCodeLine{3207     \textcolor{comment}{// !!! Be aware, returns refs into original string -\/ make sure original string outlives them}}
\DoxyCodeLine{3208     std::vector<StringRef> splitStringRef( StringRef str, \textcolor{keywordtype}{char} delimiter );}
\DoxyCodeLine{3209     \textcolor{keywordtype}{bool} replaceInPlace( std::string\& str, std::string \textcolor{keyword}{const}\& replaceThis, std::string \textcolor{keyword}{const}\& withThis );}
\DoxyCodeLine{3210 }
\DoxyCodeLine{3211     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1pluralise}{pluralise}} \{}
\DoxyCodeLine{3212         \mbox{\hyperlink{struct_catch_1_1pluralise}{pluralise}}( std::size\_t count, std::string \textcolor{keyword}{const}\& label );}
\DoxyCodeLine{3213 }
\DoxyCodeLine{3214         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, \mbox{\hyperlink{struct_catch_1_1pluralise}{pluralise}} \textcolor{keyword}{const}\& pluraliser );}
\DoxyCodeLine{3215 }
\DoxyCodeLine{3216         std::size\_t m\_count;}
\DoxyCodeLine{3217         std::string m\_label;}
\DoxyCodeLine{3218     \};}
\DoxyCodeLine{3219 \}}
\DoxyCodeLine{3220 }
\DoxyCodeLine{3221 \textcolor{comment}{// end catch\_string\_manip.h}}
\DoxyCodeLine{3222 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{3223 \textcolor{comment}{// start catch\_capture\_matchers.h}}
\DoxyCodeLine{3224 }
\DoxyCodeLine{3225 \textcolor{comment}{// start catch\_matchers.h}}
\DoxyCodeLine{3226 }
\DoxyCodeLine{3227 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3228 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{3229 }
\DoxyCodeLine{3230 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3231 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3232     \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{3233 }
\DoxyCodeLine{3234         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }MatchAllOf;}
\DoxyCodeLine{3235         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }MatchAnyOf;}
\DoxyCodeLine{3236         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }MatchNotOf;}
\DoxyCodeLine{3237 }
\DoxyCodeLine{3238         \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{MatcherUntypedBase}} \{}
\DoxyCodeLine{3239         \textcolor{keyword}{public}:}
\DoxyCodeLine{3240             \mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{MatcherUntypedBase}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{3241             \mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{MatcherUntypedBase}} ( \mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{MatcherUntypedBase}} \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{3242             \mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{MatcherUntypedBase}}\& operator = ( \mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{MatcherUntypedBase}} \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{3243             std::string toString() \textcolor{keyword}{const};}
\DoxyCodeLine{3244 }
\DoxyCodeLine{3245         \textcolor{keyword}{protected}:}
\DoxyCodeLine{3246             \textcolor{keyword}{virtual} \mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{\string~MatcherUntypedBase}}();}
\DoxyCodeLine{3247             \textcolor{keyword}{virtual} std::string describe() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3248             \textcolor{keyword}{mutable} std::string m\_cachedToString;}
\DoxyCodeLine{3249         \};}
\DoxyCodeLine{3250 }
\DoxyCodeLine{3251 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3252 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{3253 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wnon-\/virtual-\/dtor"{}}}
\DoxyCodeLine{3254 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3255 }
\DoxyCodeLine{3256         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ObjectT>}
\DoxyCodeLine{3257         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_method}{MatcherMethod}} \{}
\DoxyCodeLine{3258             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( ObjectT \textcolor{keyword}{const}\& arg ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3259         \};}
\DoxyCodeLine{3260 }
\DoxyCodeLine{3261 \textcolor{preprocessor}{\#if defined(\_\_OBJC\_\_)}}
\DoxyCodeLine{3262         \textcolor{comment}{// Hack to fix Catch GH issue \#1661. Could use id for generic Object support.}}
\DoxyCodeLine{3263         \textcolor{comment}{// use of const for Object pointers is very uncommon and under ARC it causes some kind of signature mismatch that breaks compilation}}
\DoxyCodeLine{3264         \textcolor{keyword}{template}<>}
\DoxyCodeLine{3265         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_method}{MatcherMethod}}<NSString*> \{}
\DoxyCodeLine{3266             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( NSString* arg ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3267         \};}
\DoxyCodeLine{3268 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3269 }
\DoxyCodeLine{3270 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3271 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{3272 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3273 }
\DoxyCodeLine{3274         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3275         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}} : \mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{MatcherUntypedBase}}, \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_method}{MatcherMethod}}<T> \{}
\DoxyCodeLine{3276 }
\DoxyCodeLine{3277             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_all_of}{MatchAllOf<T>}} operator \&\& ( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{3278             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_any_of}{MatchAnyOf<T>}} operator || ( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{3279             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_not_of}{MatchNotOf<T>}} operator ! () \textcolor{keyword}{const};}
\DoxyCodeLine{3280         \};}
\DoxyCodeLine{3281 }
\DoxyCodeLine{3282         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{3283         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_all_of}{MatchAllOf}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<ArgT> \{}
\DoxyCodeLine{3284             \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3285                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{3286                     \textcolor{keywordflow}{if} (!matcher-\/>match(arg))}
\DoxyCodeLine{3287                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3288                 \}}
\DoxyCodeLine{3289                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3290             \}}
\DoxyCodeLine{3291             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3292                 std::string description;}
\DoxyCodeLine{3293                 description.reserve( 4 + m\_matchers.size()*32 );}
\DoxyCodeLine{3294                 description += \textcolor{stringliteral}{"{}( "{}};}
\DoxyCodeLine{3295                 \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{3296                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{3297                     \textcolor{keywordflow}{if}( first )}
\DoxyCodeLine{3298                         first = \textcolor{keyword}{false};}
\DoxyCodeLine{3299                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3300                         description += \textcolor{stringliteral}{"{} and "{}};}
\DoxyCodeLine{3301                     description += matcher-\/>toString();}
\DoxyCodeLine{3302                 \}}
\DoxyCodeLine{3303                 description += \textcolor{stringliteral}{"{} )"{}};}
\DoxyCodeLine{3304                 \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{3305             \}}
\DoxyCodeLine{3306 }
\DoxyCodeLine{3307             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_all_of}{MatchAllOf<ArgT>}} operator \&\& ( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{3308                 \textcolor{keyword}{auto} \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{copy}}(*\textcolor{keyword}{this});}
\DoxyCodeLine{3309                 \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{copy}}.m\_matchers.push\_back( \&other );}
\DoxyCodeLine{3310                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{copy}};}
\DoxyCodeLine{3311             \}}
\DoxyCodeLine{3312 }
\DoxyCodeLine{3313             std::vector<MatcherBase<ArgT> \textcolor{keyword}{const}*> m\_matchers;}
\DoxyCodeLine{3314         \};}
\DoxyCodeLine{3315         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{3316         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_any_of}{MatchAnyOf}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<ArgT> \{}
\DoxyCodeLine{3317 }
\DoxyCodeLine{3318             \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3319                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{3320                     \textcolor{keywordflow}{if} (matcher-\/>match(arg))}
\DoxyCodeLine{3321                         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3322                 \}}
\DoxyCodeLine{3323                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3324             \}}
\DoxyCodeLine{3325             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3326                 std::string description;}
\DoxyCodeLine{3327                 description.reserve( 4 + m\_matchers.size()*32 );}
\DoxyCodeLine{3328                 description += \textcolor{stringliteral}{"{}( "{}};}
\DoxyCodeLine{3329                 \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{3330                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{3331                     \textcolor{keywordflow}{if}( first )}
\DoxyCodeLine{3332                         first = \textcolor{keyword}{false};}
\DoxyCodeLine{3333                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3334                         description += \textcolor{stringliteral}{"{} or "{}};}
\DoxyCodeLine{3335                     description += matcher-\/>toString();}
\DoxyCodeLine{3336                 \}}
\DoxyCodeLine{3337                 description += \textcolor{stringliteral}{"{} )"{}};}
\DoxyCodeLine{3338                 \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{3339             \}}
\DoxyCodeLine{3340 }
\DoxyCodeLine{3341             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_any_of}{MatchAnyOf<ArgT>}} operator || ( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{3342                 \textcolor{keyword}{auto} \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{copy}}(*\textcolor{keyword}{this});}
\DoxyCodeLine{3343                 \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{copy}}.m\_matchers.push\_back( \&other );}
\DoxyCodeLine{3344                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{copy}};}
\DoxyCodeLine{3345             \}}
\DoxyCodeLine{3346 }
\DoxyCodeLine{3347             std::vector<MatcherBase<ArgT> \textcolor{keyword}{const}*> m\_matchers;}
\DoxyCodeLine{3348         \};}
\DoxyCodeLine{3349 }
\DoxyCodeLine{3350         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{3351         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_not_of}{MatchNotOf}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<ArgT> \{}
\DoxyCodeLine{3352 }
\DoxyCodeLine{3353             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_not_of}{MatchNotOf}}( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& underlyingMatcher ) : m\_underlyingMatcher( underlyingMatcher ) \{\}}
\DoxyCodeLine{3354 }
\DoxyCodeLine{3355             \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3356                 \textcolor{keywordflow}{return} !m\_underlyingMatcher.match( arg );}
\DoxyCodeLine{3357             \}}
\DoxyCodeLine{3358 }
\DoxyCodeLine{3359             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3360                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}not "{}} + m\_underlyingMatcher.toString();}
\DoxyCodeLine{3361             \}}
\DoxyCodeLine{3362             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& m\_underlyingMatcher;}
\DoxyCodeLine{3363         \};}
\DoxyCodeLine{3364 }
\DoxyCodeLine{3365         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3366         \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_all_of}{MatchAllOf<T>}} \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase<T>::operator \&\& }}( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}} \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3367             \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_all_of}{MatchAllOf<T>}}() \&\& *\textcolor{keyword}{this} \&\& other;}
\DoxyCodeLine{3368         \}}
\DoxyCodeLine{3369         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3370         MatchAnyOf<T> \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase<T>::operator || }}( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}} \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3371             \textcolor{keywordflow}{return} MatchAnyOf<T>() || *\textcolor{keyword}{this} || other;}
\DoxyCodeLine{3372         \}}
\DoxyCodeLine{3373         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3374         MatchNotOf<T> \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase<T>::operator ! }}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3375             \textcolor{keywordflow}{return} MatchNotOf<T>( *\textcolor{keyword}{this} );}
\DoxyCodeLine{3376         \}}
\DoxyCodeLine{3377 }
\DoxyCodeLine{3378     \} \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{3379 }
\DoxyCodeLine{3380 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3381 }
\DoxyCodeLine{3382 \textcolor{keyword}{using namespace }Matchers;}
\DoxyCodeLine{3383 \textcolor{keyword}{using} Matchers::Impl::MatcherBase;}
\DoxyCodeLine{3384 }
\DoxyCodeLine{3385 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3386 }
\DoxyCodeLine{3387 \textcolor{comment}{// end catch\_matchers.h}}
\DoxyCodeLine{3388 \textcolor{comment}{// start catch\_matchers\_exception.hpp}}
\DoxyCodeLine{3389 }
\DoxyCodeLine{3390 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3391 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3392 \textcolor{keyword}{namespace }Exception \{}
\DoxyCodeLine{3393 }
\DoxyCodeLine{3394 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_matchers_1_1_exception_1_1_exception_message_matcher}{ExceptionMessageMatcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::exception> \{}
\DoxyCodeLine{3395     std::string m\_message;}
\DoxyCodeLine{3396 \textcolor{keyword}{public}:}
\DoxyCodeLine{3397 }
\DoxyCodeLine{3398     \mbox{\hyperlink{class_catch_1_1_matchers_1_1_exception_1_1_exception_message_matcher}{ExceptionMessageMatcher}}(std::string \textcolor{keyword}{const}\& message):}
\DoxyCodeLine{3399         m\_message(message)}
\DoxyCodeLine{3400     \{\}}
\DoxyCodeLine{3401 }
\DoxyCodeLine{3402     \textcolor{keywordtype}{bool} match(std::exception \textcolor{keyword}{const}\& ex) \textcolor{keyword}{const override};}
\DoxyCodeLine{3403 }
\DoxyCodeLine{3404     std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3405 \};}
\DoxyCodeLine{3406 }
\DoxyCodeLine{3407 \} \textcolor{comment}{// namespace Exception}}
\DoxyCodeLine{3408 }
\DoxyCodeLine{3409 \mbox{\hyperlink{class_catch_1_1_matchers_1_1_exception_1_1_exception_message_matcher}{Exception::ExceptionMessageMatcher}} Message(std::string \textcolor{keyword}{const}\& message);}
\DoxyCodeLine{3410 }
\DoxyCodeLine{3411 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3412 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3413 }
\DoxyCodeLine{3414 \textcolor{comment}{// end catch\_matchers\_exception.hpp}}
\DoxyCodeLine{3415 \textcolor{comment}{// start catch\_matchers\_floating.h}}
\DoxyCodeLine{3416 }
\DoxyCodeLine{3417 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3418 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3419 }
\DoxyCodeLine{3420     \textcolor{keyword}{namespace }Floating \{}
\DoxyCodeLine{3421 }
\DoxyCodeLine{3422         \textcolor{keyword}{enum class} FloatingPointKind : uint8\_t;}
\DoxyCodeLine{3423 }
\DoxyCodeLine{3424         struct \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_abs_matcher}{WithinAbsMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<double> \{}
\DoxyCodeLine{3425             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_abs_matcher}{WithinAbsMatcher}}(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} margin);}
\DoxyCodeLine{3426             \textcolor{keywordtype}{bool} match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee) \textcolor{keyword}{const override};}
\DoxyCodeLine{3427             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3428         \textcolor{keyword}{private}:}
\DoxyCodeLine{3429             \textcolor{keywordtype}{double} m\_target;}
\DoxyCodeLine{3430             \textcolor{keywordtype}{double} m\_margin;}
\DoxyCodeLine{3431         \};}
\DoxyCodeLine{3432 }
\DoxyCodeLine{3433         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_ulps_matcher}{WithinUlpsMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<double> \{}
\DoxyCodeLine{3434             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_ulps_matcher}{WithinUlpsMatcher}}(\textcolor{keywordtype}{double} target, uint64\_t ulps, FloatingPointKind baseType);}
\DoxyCodeLine{3435             \textcolor{keywordtype}{bool} match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee) \textcolor{keyword}{const override};}
\DoxyCodeLine{3436             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3437         \textcolor{keyword}{private}:}
\DoxyCodeLine{3438             \textcolor{keywordtype}{double} m\_target;}
\DoxyCodeLine{3439             uint64\_t m\_ulps;}
\DoxyCodeLine{3440             FloatingPointKind m\_type;}
\DoxyCodeLine{3441         \};}
\DoxyCodeLine{3442 }
\DoxyCodeLine{3443         \textcolor{comment}{// Given IEEE-\/754 format for floats and doubles, we can assume}}
\DoxyCodeLine{3444         \textcolor{comment}{// that float -\/> double promotion is lossless. Given this, we can}}
\DoxyCodeLine{3445         \textcolor{comment}{// assume that if we do the standard relative comparison of}}
\DoxyCodeLine{3446         \textcolor{comment}{// |lhs -\/ rhs| <= epsilon * max(fabs(lhs), fabs(rhs)), then we get}}
\DoxyCodeLine{3447         \textcolor{comment}{// the same result if we do this for floats, as if we do this for}}
\DoxyCodeLine{3448         \textcolor{comment}{// doubles that were promoted from floats.}}
\DoxyCodeLine{3449         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_rel_matcher}{WithinRelMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<double> \{}
\DoxyCodeLine{3450             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_rel_matcher}{WithinRelMatcher}}(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} epsilon);}
\DoxyCodeLine{3451             \textcolor{keywordtype}{bool} match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee) \textcolor{keyword}{const override};}
\DoxyCodeLine{3452             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3453         \textcolor{keyword}{private}:}
\DoxyCodeLine{3454             \textcolor{keywordtype}{double} m\_target;}
\DoxyCodeLine{3455             \textcolor{keywordtype}{double} m\_epsilon;}
\DoxyCodeLine{3456         \};}
\DoxyCodeLine{3457 }
\DoxyCodeLine{3458     \} \textcolor{comment}{// namespace Floating}}
\DoxyCodeLine{3459 }
\DoxyCodeLine{3460     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{3461     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{3462     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_ulps_matcher}{Floating::WithinUlpsMatcher}} WithinULP(\textcolor{keywordtype}{double} target, uint64\_t maxUlpDiff);}
\DoxyCodeLine{3463     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_ulps_matcher}{Floating::WithinUlpsMatcher}} WithinULP(\textcolor{keywordtype}{float} target, uint64\_t maxUlpDiff);}
\DoxyCodeLine{3464     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_abs_matcher}{Floating::WithinAbsMatcher}} WithinAbs(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} margin);}
\DoxyCodeLine{3465     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_rel_matcher}{Floating::WithinRelMatcher}} WithinRel(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} eps);}
\DoxyCodeLine{3466     \textcolor{comment}{// defaults epsilon to 100*numeric\_limits<double>::epsilon()}}
\DoxyCodeLine{3467     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_rel_matcher}{Floating::WithinRelMatcher}} WithinRel(\textcolor{keywordtype}{double} target);}
\DoxyCodeLine{3468     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_rel_matcher}{Floating::WithinRelMatcher}} WithinRel(\textcolor{keywordtype}{float} target, \textcolor{keywordtype}{float} eps);}
\DoxyCodeLine{3469     \textcolor{comment}{// defaults epsilon to 100*numeric\_limits<float>::epsilon()}}
\DoxyCodeLine{3470     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_rel_matcher}{Floating::WithinRelMatcher}} WithinRel(\textcolor{keywordtype}{float} target);}
\DoxyCodeLine{3471 }
\DoxyCodeLine{3472 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3473 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3474 }
\DoxyCodeLine{3475 \textcolor{comment}{// end catch\_matchers\_floating.h}}
\DoxyCodeLine{3476 \textcolor{comment}{// start catch\_matchers\_generic.hpp}}
\DoxyCodeLine{3477 }
\DoxyCodeLine{3478 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{3479 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3480 }
\DoxyCodeLine{3481 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3482 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3483 \textcolor{keyword}{namespace }Generic \{}
\DoxyCodeLine{3484 }
\DoxyCodeLine{3485 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{3486     std::string finalizeDescription(\textcolor{keyword}{const} std::string\& desc);}
\DoxyCodeLine{3487 \}}
\DoxyCodeLine{3488 }
\DoxyCodeLine{3489 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3490 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_matchers_1_1_generic_1_1_predicate_matcher}{PredicateMatcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<T> \{}
\DoxyCodeLine{3491     std::function<bool(T \textcolor{keyword}{const}\&)> m\_predicate;}
\DoxyCodeLine{3492     std::string m\_description;}
\DoxyCodeLine{3493 \textcolor{keyword}{public}:}
\DoxyCodeLine{3494 }
\DoxyCodeLine{3495     \mbox{\hyperlink{class_catch_1_1_matchers_1_1_generic_1_1_predicate_matcher}{PredicateMatcher}}(std::function<\textcolor{keywordtype}{bool}(T \textcolor{keyword}{const}\&)> \textcolor{keyword}{const}\& elem, std::string \textcolor{keyword}{const}\& descr)}
\DoxyCodeLine{3496         :m\_predicate(std::move(elem)),}
\DoxyCodeLine{3497         m\_description(Detail::finalizeDescription(descr))}
\DoxyCodeLine{3498     \{\}}
\DoxyCodeLine{3499 }
\DoxyCodeLine{3500     \textcolor{keywordtype}{bool} match( T \textcolor{keyword}{const}\& item )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3501         \textcolor{keywordflow}{return} m\_predicate(item);}
\DoxyCodeLine{3502     \}}
\DoxyCodeLine{3503 }
\DoxyCodeLine{3504     std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3505         \textcolor{keywordflow}{return} m\_description;}
\DoxyCodeLine{3506     \}}
\DoxyCodeLine{3507 \};}
\DoxyCodeLine{3508 }
\DoxyCodeLine{3509 \} \textcolor{comment}{// namespace Generic}}
\DoxyCodeLine{3510 }
\DoxyCodeLine{3511     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{3512     \textcolor{comment}{// The user has to explicitly specify type to the function, because}}
\DoxyCodeLine{3513     \textcolor{comment}{// inferring std::function<bool(T const\&)> is hard (but possible) and}}
\DoxyCodeLine{3514     \textcolor{comment}{// requires a lot of TMP.}}
\DoxyCodeLine{3515     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3516     \mbox{\hyperlink{class_catch_1_1_matchers_1_1_generic_1_1_predicate_matcher}{Generic::PredicateMatcher<T>}} Predicate(std::function<\textcolor{keywordtype}{bool}(T \textcolor{keyword}{const}\&)> \textcolor{keyword}{const}\& predicate, std::string \textcolor{keyword}{const}\& description = \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{3517         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_matchers_1_1_generic_1_1_predicate_matcher}{Generic::PredicateMatcher<T>}}(predicate, description);}
\DoxyCodeLine{3518     \}}
\DoxyCodeLine{3519 }
\DoxyCodeLine{3520 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3521 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3522 }
\DoxyCodeLine{3523 \textcolor{comment}{// end catch\_matchers\_generic.hpp}}
\DoxyCodeLine{3524 \textcolor{comment}{// start catch\_matchers\_string.h}}
\DoxyCodeLine{3525 }
\DoxyCodeLine{3526 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3527 }
\DoxyCodeLine{3528 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3529 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3530 }
\DoxyCodeLine{3531     \textcolor{keyword}{namespace }StdString \{}
\DoxyCodeLine{3532 }
\DoxyCodeLine{3533         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}}}
\DoxyCodeLine{3534         \{}
\DoxyCodeLine{3535             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}}( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity );}
\DoxyCodeLine{3536             std::string adjustString( std::string \textcolor{keyword}{const}\& str ) \textcolor{keyword}{const};}
\DoxyCodeLine{3537             std::string caseSensitivitySuffix() \textcolor{keyword}{const};}
\DoxyCodeLine{3538 }
\DoxyCodeLine{3539             CaseSensitive::Choice m\_caseSensitivity;}
\DoxyCodeLine{3540             std::string m\_str;}
\DoxyCodeLine{3541         \};}
\DoxyCodeLine{3542 }
\DoxyCodeLine{3543         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_string_matcher_base}{StringMatcherBase}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::string> \{}
\DoxyCodeLine{3544             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_string_matcher_base}{StringMatcherBase}}( std::string \textcolor{keyword}{const}\& operation, \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3545             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3546 }
\DoxyCodeLine{3547             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}} m\_comparator;}
\DoxyCodeLine{3548             std::string m\_operation;}
\DoxyCodeLine{3549         \};}
\DoxyCodeLine{3550 }
\DoxyCodeLine{3551         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_equals_matcher}{EqualsMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_string_matcher_base}{StringMatcherBase}} \{}
\DoxyCodeLine{3552             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_equals_matcher}{EqualsMatcher}}( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3553             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3554         \};}
\DoxyCodeLine{3555         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_contains_matcher}{ContainsMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_string_matcher_base}{StringMatcherBase}} \{}
\DoxyCodeLine{3556             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_contains_matcher}{ContainsMatcher}}( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3557             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3558         \};}
\DoxyCodeLine{3559         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_starts_with_matcher}{StartsWithMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_string_matcher_base}{StringMatcherBase}} \{}
\DoxyCodeLine{3560             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_starts_with_matcher}{StartsWithMatcher}}( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3561             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3562         \};}
\DoxyCodeLine{3563         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_ends_with_matcher}{EndsWithMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_string_matcher_base}{StringMatcherBase}} \{}
\DoxyCodeLine{3564             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_ends_with_matcher}{EndsWithMatcher}}( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3565             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3566         \};}
\DoxyCodeLine{3567 }
\DoxyCodeLine{3568         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_regex_matcher}{RegexMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::string> \{}
\DoxyCodeLine{3569             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_regex_matcher}{RegexMatcher}}( std::string regex, CaseSensitive::Choice caseSensitivity );}
\DoxyCodeLine{3570             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& matchee ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3571             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3572 }
\DoxyCodeLine{3573         \textcolor{keyword}{private}:}
\DoxyCodeLine{3574             std::string m\_regex;}
\DoxyCodeLine{3575             CaseSensitive::Choice m\_caseSensitivity;}
\DoxyCodeLine{3576         \};}
\DoxyCodeLine{3577 }
\DoxyCodeLine{3578     \} \textcolor{comment}{// namespace StdString}}
\DoxyCodeLine{3579 }
\DoxyCodeLine{3580     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{3581     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{3582 }
\DoxyCodeLine{3583     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_equals_matcher}{StdString::EqualsMatcher}} Equals( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3584     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_contains_matcher}{StdString::ContainsMatcher}} Contains( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3585     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_ends_with_matcher}{StdString::EndsWithMatcher}} EndsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3586     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_starts_with_matcher}{StdString::StartsWithMatcher}} StartsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3587     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_regex_matcher}{StdString::RegexMatcher}} Matches( std::string \textcolor{keyword}{const}\& regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3588 }
\DoxyCodeLine{3589 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3590 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3591 }
\DoxyCodeLine{3592 \textcolor{comment}{// end catch\_matchers\_string.h}}
\DoxyCodeLine{3593 \textcolor{comment}{// start catch\_matchers\_vector.h}}
\DoxyCodeLine{3594 }
\DoxyCodeLine{3595 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{3596 }
\DoxyCodeLine{3597 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3598 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3599 }
\DoxyCodeLine{3600     \textcolor{keyword}{namespace }Vector \{}
\DoxyCodeLine{3601         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Alloc>}
\DoxyCodeLine{3602         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_element_matcher}{ContainsElementMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::vector<T, Alloc>> \{}
\DoxyCodeLine{3603 }
\DoxyCodeLine{3604             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_element_matcher}{ContainsElementMatcher}}(T \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator) \{\}}
\DoxyCodeLine{3605 }
\DoxyCodeLine{3606             \textcolor{keywordtype}{bool} match(std::vector<T, Alloc> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3607                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& el : v) \{}
\DoxyCodeLine{3608                     \textcolor{keywordflow}{if} (el == m\_comparator) \{}
\DoxyCodeLine{3609                         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3610                     \}}
\DoxyCodeLine{3611                 \}}
\DoxyCodeLine{3612                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3613             \}}
\DoxyCodeLine{3614 }
\DoxyCodeLine{3615             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3616                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Contains: "{}} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{3617             \}}
\DoxyCodeLine{3618 }
\DoxyCodeLine{3619             T \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3620         \};}
\DoxyCodeLine{3621 }
\DoxyCodeLine{3622         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp, \textcolor{keyword}{typename} AllocMatch>}
\DoxyCodeLine{3623         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_matcher}{ContainsMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::vector<T, AllocMatch>> \{}
\DoxyCodeLine{3624 }
\DoxyCodeLine{3625             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_matcher}{ContainsMatcher}}(std::vector<T, AllocComp> \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator ) \{\}}
\DoxyCodeLine{3626 }
\DoxyCodeLine{3627             \textcolor{keywordtype}{bool} match(std::vector<T, AllocMatch> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3628                 \textcolor{comment}{// !TBD: see note in EqualsMatcher}}
\DoxyCodeLine{3629                 \textcolor{keywordflow}{if} (m\_comparator.size() > v.size())}
\DoxyCodeLine{3630                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3631                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& comparator : m\_comparator) \{}
\DoxyCodeLine{3632                     \textcolor{keyword}{auto} present = \textcolor{keyword}{false};}
\DoxyCodeLine{3633                     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : v) \{}
\DoxyCodeLine{3634                         \textcolor{keywordflow}{if} (el == comparator) \{}
\DoxyCodeLine{3635                             present = \textcolor{keyword}{true};}
\DoxyCodeLine{3636                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{3637                         \}}
\DoxyCodeLine{3638                     \}}
\DoxyCodeLine{3639                     \textcolor{keywordflow}{if} (!present) \{}
\DoxyCodeLine{3640                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3641                     \}}
\DoxyCodeLine{3642                 \}}
\DoxyCodeLine{3643                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3644             \}}
\DoxyCodeLine{3645             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3646                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Contains: "{}} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{3647             \}}
\DoxyCodeLine{3648 }
\DoxyCodeLine{3649             std::vector<T, AllocComp> \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3650         \};}
\DoxyCodeLine{3651 }
\DoxyCodeLine{3652         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp, \textcolor{keyword}{typename} AllocMatch>}
\DoxyCodeLine{3653         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_equals_matcher}{EqualsMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::vector<T, AllocMatch>> \{}
\DoxyCodeLine{3654 }
\DoxyCodeLine{3655             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_equals_matcher}{EqualsMatcher}}(std::vector<T, AllocComp> \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator ) \{\}}
\DoxyCodeLine{3656 }
\DoxyCodeLine{3657             \textcolor{keywordtype}{bool} match(std::vector<T, AllocMatch> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3658                 \textcolor{comment}{// !TBD: This currently works if all elements can be compared using !=}}
\DoxyCodeLine{3659                 \textcolor{comment}{// -\/ a more general approach would be via a compare template that defaults}}
\DoxyCodeLine{3660                 \textcolor{comment}{// to using !=. but could be specialised for, e.g. std::vector<T, Alloc> etc}}
\DoxyCodeLine{3661                 \textcolor{comment}{// -\/ then just call that directly}}
\DoxyCodeLine{3662                 \textcolor{keywordflow}{if} (m\_comparator.size() != v.size())}
\DoxyCodeLine{3663                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3664                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < v.size(); ++i)}
\DoxyCodeLine{3665                     \textcolor{keywordflow}{if} (m\_comparator[i] != v[i])}
\DoxyCodeLine{3666                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3667                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3668             \}}
\DoxyCodeLine{3669             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3670                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Equals: "{}} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{3671             \}}
\DoxyCodeLine{3672             std::vector<T, AllocComp> \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3673         \};}
\DoxyCodeLine{3674 }
\DoxyCodeLine{3675         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp, \textcolor{keyword}{typename} AllocMatch>}
\DoxyCodeLine{3676         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_approx_matcher}{ApproxMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::vector<T, AllocMatch>> \{}
\DoxyCodeLine{3677 }
\DoxyCodeLine{3678             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_approx_matcher}{ApproxMatcher}}(std::vector<T, AllocComp> \textcolor{keyword}{const}\& comparator) : m\_comparator( comparator ) \{\}}
\DoxyCodeLine{3679 }
\DoxyCodeLine{3680             \textcolor{keywordtype}{bool} match(std::vector<T, AllocMatch> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3681                 \textcolor{keywordflow}{if} (m\_comparator.size() != v.size())}
\DoxyCodeLine{3682                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3683                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < v.size(); ++i)}
\DoxyCodeLine{3684                     \textcolor{keywordflow}{if} (m\_comparator[i] != approx(v[i]))}
\DoxyCodeLine{3685                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3686                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3687             \}}
\DoxyCodeLine{3688             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3689                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is approx: "{}} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{3690             \}}
\DoxyCodeLine{3691             template <typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3692             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_approx_matcher}{ApproxMatcher}}\& epsilon( T \textcolor{keyword}{const}\& newEpsilon ) \{}
\DoxyCodeLine{3693                 approx.epsilon(newEpsilon);}
\DoxyCodeLine{3694                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3695             \}}
\DoxyCodeLine{3696             template <typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3697             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_approx_matcher}{ApproxMatcher}}\& margin( T \textcolor{keyword}{const}\& newMargin ) \{}
\DoxyCodeLine{3698                 approx.margin(newMargin);}
\DoxyCodeLine{3699                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3700             \}}
\DoxyCodeLine{3701             template <typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3702             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_approx_matcher}{ApproxMatcher}}\& scale( T \textcolor{keyword}{const}\& newScale ) \{}
\DoxyCodeLine{3703                 approx.scale(newScale);}
\DoxyCodeLine{3704                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3705             \}}
\DoxyCodeLine{3706 }
\DoxyCodeLine{3707             std::vector<T, AllocComp> \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3708             \textcolor{keyword}{mutable} \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Catch::Detail::Approx}} approx = Catch::Detail::Approx::custom();}
\DoxyCodeLine{3709         \};}
\DoxyCodeLine{3710 }
\DoxyCodeLine{3711         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp, \textcolor{keyword}{typename} AllocMatch>}
\DoxyCodeLine{3712         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_unordered_equals_matcher}{UnorderedEqualsMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::vector<T, AllocMatch>> \{}
\DoxyCodeLine{3713             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_unordered_equals_matcher}{UnorderedEqualsMatcher}}(std::vector<T, AllocComp> \textcolor{keyword}{const}\& target) : m\_target(target) \{\}}
\DoxyCodeLine{3714             \textcolor{keywordtype}{bool} match(std::vector<T, AllocMatch> \textcolor{keyword}{const}\& vec)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3715                 \textcolor{keywordflow}{if} (m\_target.size() != vec.size()) \{}
\DoxyCodeLine{3716                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3717                 \}}
\DoxyCodeLine{3718                 \textcolor{keywordflow}{return} std::is\_permutation(m\_target.begin(), m\_target.end(), vec.begin());}
\DoxyCodeLine{3719             \}}
\DoxyCodeLine{3720 }
\DoxyCodeLine{3721             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3722                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}UnorderedEquals: "{}} + ::Catch::Detail::stringify(m\_target);}
\DoxyCodeLine{3723             \}}
\DoxyCodeLine{3724         \textcolor{keyword}{private}:}
\DoxyCodeLine{3725             std::vector<T, AllocComp> \textcolor{keyword}{const}\& m\_target;}
\DoxyCodeLine{3726         \};}
\DoxyCodeLine{3727 }
\DoxyCodeLine{3728     \} \textcolor{comment}{// namespace Vector}}
\DoxyCodeLine{3729 }
\DoxyCodeLine{3730     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{3731     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{3732 }
\DoxyCodeLine{3733     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp = std::allocator<T>, \textcolor{keyword}{typename} AllocMatch = AllocComp>}
\DoxyCodeLine{3734     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_matcher}{Vector::ContainsMatcher<T, AllocComp, AllocMatch>}} Contains( std::vector<T, AllocComp> \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3735         \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_matcher}{Vector::ContainsMatcher<T, AllocComp, AllocMatch>}}( comparator );}
\DoxyCodeLine{3736     \}}
\DoxyCodeLine{3737 }
\DoxyCodeLine{3738     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Alloc = std::allocator<T>>}
\DoxyCodeLine{3739     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_element_matcher}{Vector::ContainsElementMatcher<T, Alloc>}} VectorContains( T \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3740         \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_element_matcher}{Vector::ContainsElementMatcher<T, Alloc>}}( comparator );}
\DoxyCodeLine{3741     \}}
\DoxyCodeLine{3742 }
\DoxyCodeLine{3743     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp = std::allocator<T>, \textcolor{keyword}{typename} AllocMatch = AllocComp>}
\DoxyCodeLine{3744     Vector::EqualsMatcher<T, AllocComp, AllocMatch> Equals( std::vector<T, AllocComp> \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3745         \textcolor{keywordflow}{return} Vector::EqualsMatcher<T, AllocComp, AllocMatch>( comparator );}
\DoxyCodeLine{3746     \}}
\DoxyCodeLine{3747 }
\DoxyCodeLine{3748     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp = std::allocator<T>, \textcolor{keyword}{typename} AllocMatch = AllocComp>}
\DoxyCodeLine{3749     Vector::ApproxMatcher<T, AllocComp, AllocMatch> \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}}( std::vector<T, AllocComp> \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3750         \textcolor{keywordflow}{return} Vector::ApproxMatcher<T, AllocComp, AllocMatch>( comparator );}
\DoxyCodeLine{3751     \}}
\DoxyCodeLine{3752 }
\DoxyCodeLine{3753     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp = std::allocator<T>, \textcolor{keyword}{typename} AllocMatch = AllocComp>}
\DoxyCodeLine{3754     Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch> UnorderedEquals(std::vector<T, AllocComp> \textcolor{keyword}{const}\& target) \{}
\DoxyCodeLine{3755         \textcolor{keywordflow}{return} Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch>( target );}
\DoxyCodeLine{3756     \}}
\DoxyCodeLine{3757 }
\DoxyCodeLine{3758 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3759 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3760 }
\DoxyCodeLine{3761 \textcolor{comment}{// end catch\_matchers\_vector.h}}
\DoxyCodeLine{3762 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3763 }
\DoxyCodeLine{3764     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT, \textcolor{keyword}{typename} MatcherT>}
\DoxyCodeLine{3765     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_match_expr}{MatchExpr}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \{}
\DoxyCodeLine{3766         ArgT \textcolor{keyword}{const}\& m\_arg;}
\DoxyCodeLine{3767         MatcherT m\_matcher;}
\DoxyCodeLine{3768         \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} m\_matcherString;}
\DoxyCodeLine{3769     \textcolor{keyword}{public}:}
\DoxyCodeLine{3770         \mbox{\hyperlink{class_catch_1_1_match_expr}{MatchExpr}}( ArgT \textcolor{keyword}{const}\& arg, MatcherT \textcolor{keyword}{const}\& matcher, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& matcherString )}
\DoxyCodeLine{3771         :   \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}}\{ \textcolor{keyword}{true}, matcher.match( arg ) \},}
\DoxyCodeLine{3772             m\_arg( arg ),}
\DoxyCodeLine{3773             m\_matcher( matcher ),}
\DoxyCodeLine{3774             m\_matcherString( matcherString )}
\DoxyCodeLine{3775         \{\}}
\DoxyCodeLine{3776 }
\DoxyCodeLine{3777         \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3778             \textcolor{keyword}{auto} matcherAsString = m\_matcher.toString();}
\DoxyCodeLine{3779             os << Catch::Detail::stringify( m\_arg ) << \textcolor{charliteral}{' '};}
\DoxyCodeLine{3780             \textcolor{keywordflow}{if}( matcherAsString == Detail::unprintableString )}
\DoxyCodeLine{3781                 os << m\_matcherString;}
\DoxyCodeLine{3782             \textcolor{keywordflow}{else}}
\DoxyCodeLine{3783                 os << matcherAsString;}
\DoxyCodeLine{3784         \}}
\DoxyCodeLine{3785     \};}
\DoxyCodeLine{3786 }
\DoxyCodeLine{3787     \textcolor{keyword}{using} \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{StringMatcher}} = \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{Matchers::Impl::MatcherBase<std::string>}};}
\DoxyCodeLine{3788 }
\DoxyCodeLine{3789     \textcolor{keywordtype}{void} handleExceptionMatchExpr( \mbox{\hyperlink{class_catch_1_1_assertion_handler}{AssertionHandler}}\& handler, \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{StringMatcher}} \textcolor{keyword}{const}\& matcher, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& matcherString  );}
\DoxyCodeLine{3790 }
\DoxyCodeLine{3791     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT, \textcolor{keyword}{typename} MatcherT>}
\DoxyCodeLine{3792     \textcolor{keyword}{auto} makeMatchExpr( ArgT \textcolor{keyword}{const}\& arg, MatcherT \textcolor{keyword}{const}\& matcher, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& matcherString  ) -\/> \mbox{\hyperlink{class_catch_1_1_match_expr}{MatchExpr<ArgT, MatcherT>}} \{}
\DoxyCodeLine{3793         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_match_expr}{MatchExpr<ArgT, MatcherT>}}( arg, matcher, matcherString );}
\DoxyCodeLine{3794     \}}
\DoxyCodeLine{3795 }
\DoxyCodeLine{3796 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3797 }
\DoxyCodeLine{3799 \textcolor{preprocessor}{\#define INTERNAL\_CHECK\_THAT( macroName, matcher, resultDisposition, arg ) \(\backslash\)}}
\DoxyCodeLine{3800 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{3801 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(arg) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(matcher), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{3802         INTERNAL\_CATCH\_TRY \{ \(\backslash\)}
\DoxyCodeLine{3803             catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, \#matcher\#\#\_catch\_sr ) ); \(\backslash\)}
\DoxyCodeLine{3804         \} INTERNAL\_CATCH\_CATCH( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{3805         INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{3806     \} while( false )}
\DoxyCodeLine{3807 }
\DoxyCodeLine{3809 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS\_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \(\backslash\)}}
\DoxyCodeLine{3810 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{3811 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(exceptionType) "{}, "{} CATCH\_INTERNAL\_STRINGIFY(matcher), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{3812         if( catchAssertionHandler.allowThrows() ) \(\backslash\)}
\DoxyCodeLine{3813             try \{ \(\backslash\)}
\DoxyCodeLine{3814                 static\_cast<void>(\_\_VA\_ARGS\_\_ ); \(\backslash\)}
\DoxyCodeLine{3815                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}
\DoxyCodeLine{3816             \} \(\backslash\)}
\DoxyCodeLine{3817             catch( exceptionType const\& ex ) \{ \(\backslash\)}
\DoxyCodeLine{3818                 catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, \#matcher\#\#\_catch\_sr ) ); \(\backslash\)}
\DoxyCodeLine{3819             \} \(\backslash\)}
\DoxyCodeLine{3820             catch( ... ) \{ \(\backslash\)}
\DoxyCodeLine{3821                 catchAssertionHandler.handleUnexpectedInflightException(); \(\backslash\)}
\DoxyCodeLine{3822             \} \(\backslash\)}
\DoxyCodeLine{3823         else \(\backslash\)}
\DoxyCodeLine{3824             catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}
\DoxyCodeLine{3825         INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{3826     \} while( false )}
\DoxyCodeLine{3827 }
\DoxyCodeLine{3828 \textcolor{comment}{// end catch\_capture\_matchers.h}}
\DoxyCodeLine{3829 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3830 \textcolor{comment}{// start catch\_generators.hpp}}
\DoxyCodeLine{3831 }
\DoxyCodeLine{3832 \textcolor{comment}{// start catch\_interfaces\_generatortracker.h}}
\DoxyCodeLine{3833 }
\DoxyCodeLine{3834 }
\DoxyCodeLine{3835 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{3836 }
\DoxyCodeLine{3837 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3838 }
\DoxyCodeLine{3839     \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{3840         \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_untyped_base}{GeneratorUntypedBase}} \{}
\DoxyCodeLine{3841         \textcolor{keyword}{public}:}
\DoxyCodeLine{3842             \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_untyped_base}{GeneratorUntypedBase}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{3843             \textcolor{keyword}{virtual} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_untyped_base}{\string~GeneratorUntypedBase}}();}
\DoxyCodeLine{3844             \textcolor{comment}{// Attempts to move the generator to the next element}}
\DoxyCodeLine{3845              \textcolor{comment}{//}}
\DoxyCodeLine{3846              \textcolor{comment}{// Returns true iff the move succeeded (and a valid element}}
\DoxyCodeLine{3847              \textcolor{comment}{// can be retrieved).}}
\DoxyCodeLine{3848             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} next() = 0;}
\DoxyCodeLine{3849         \};}
\DoxyCodeLine{3850         \textcolor{keyword}{using} GeneratorBasePtr = std::unique\_ptr<GeneratorUntypedBase>;}
\DoxyCodeLine{3851 }
\DoxyCodeLine{3852     \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{3853 }
\DoxyCodeLine{3854     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_generator_tracker}{IGeneratorTracker}} \{}
\DoxyCodeLine{3855         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_generator_tracker}{\string~IGeneratorTracker}}();}
\DoxyCodeLine{3856         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} hasGenerator() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} = 0;}
\DoxyCodeLine{3857         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} getGenerator() \textcolor{keyword}{const} -\/> Generators::GeneratorBasePtr \textcolor{keyword}{const}\& = 0;}
\DoxyCodeLine{3858         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setGenerator( Generators::GeneratorBasePtr\&\& generator ) = 0;}
\DoxyCodeLine{3859     \};}
\DoxyCodeLine{3860 }
\DoxyCodeLine{3861 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3862 }
\DoxyCodeLine{3863 \textcolor{comment}{// end catch\_interfaces\_generatortracker.h}}
\DoxyCodeLine{3864 \textcolor{comment}{// start catch\_enforce.h}}
\DoxyCodeLine{3865 }
\DoxyCodeLine{3866 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{3867 }
\DoxyCodeLine{3868 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3869 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{3870     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Ex>}
\DoxyCodeLine{3871     [[noreturn]]}
\DoxyCodeLine{3872     \textcolor{keywordtype}{void} throw\_exception(Ex \textcolor{keyword}{const}\& e) \{}
\DoxyCodeLine{3873         \textcolor{keywordflow}{throw} e;}
\DoxyCodeLine{3874     \}}
\DoxyCodeLine{3875 \textcolor{preprocessor}{\#else }\textcolor{comment}{// \string^\string^ Exceptions are enabled //  Exceptions are disabled vv}}
\DoxyCodeLine{3876     [[noreturn]]}
\DoxyCodeLine{3877     \textcolor{keywordtype}{void} throw\_exception(std::exception \textcolor{keyword}{const}\& e);}
\DoxyCodeLine{3878 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3879 }
\DoxyCodeLine{3880     [[noreturn]]}
\DoxyCodeLine{3881     \textcolor{keywordtype}{void} throw\_logic\_error(std::string \textcolor{keyword}{const}\& msg);}
\DoxyCodeLine{3882     [[noreturn]]}
\DoxyCodeLine{3883     \textcolor{keywordtype}{void} throw\_domain\_error(std::string \textcolor{keyword}{const}\& msg);}
\DoxyCodeLine{3884     [[noreturn]]}
\DoxyCodeLine{3885     \textcolor{keywordtype}{void} throw\_runtime\_error(std::string \textcolor{keyword}{const}\& msg);}
\DoxyCodeLine{3886 }
\DoxyCodeLine{3887 \} \textcolor{comment}{// namespace Catch;}}
\DoxyCodeLine{3888 }
\DoxyCodeLine{3889 \textcolor{preprocessor}{\#define CATCH\_MAKE\_MSG(...) \(\backslash\)}}
\DoxyCodeLine{3890 \textcolor{preprocessor}{    (Catch::ReusableStringStream() << \_\_VA\_ARGS\_\_).str()}}
\DoxyCodeLine{3891 }
\DoxyCodeLine{3892 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_ERROR(...) \(\backslash\)}}
\DoxyCodeLine{3893 \textcolor{preprocessor}{    Catch::throw\_logic\_error(CATCH\_MAKE\_MSG( CATCH\_INTERNAL\_LINEINFO << "{}: Internal Catch2 error: "{}} << \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{3894 }
\DoxyCodeLine{3895 \textcolor{preprocessor}{\#define CATCH\_ERROR(...) \(\backslash\)}}
\DoxyCodeLine{3896 \textcolor{preprocessor}{    Catch::throw\_domain\_error(CATCH\_MAKE\_MSG( \_\_VA\_ARGS\_\_ ))}}
\DoxyCodeLine{3897 }
\DoxyCodeLine{3898 \textcolor{preprocessor}{\#define CATCH\_RUNTIME\_ERROR(...) \(\backslash\)}}
\DoxyCodeLine{3899 \textcolor{preprocessor}{    Catch::throw\_runtime\_error(CATCH\_MAKE\_MSG( \_\_VA\_ARGS\_\_ ))}}
\DoxyCodeLine{3900 }
\DoxyCodeLine{3901 \textcolor{preprocessor}{\#define CATCH\_ENFORCE( condition, ... ) \(\backslash\)}}
\DoxyCodeLine{3902 \textcolor{preprocessor}{    do\{ if( !(condition) ) CATCH\_ERROR( \_\_VA\_ARGS\_\_ ); \} while(false)}}
\DoxyCodeLine{3903 }
\DoxyCodeLine{3904 \textcolor{comment}{// end catch\_enforce.h}}
\DoxyCodeLine{3905 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{3906 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{3907 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{3908 }
\DoxyCodeLine{3909 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{3910 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{3911 }
\DoxyCodeLine{3912 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3913 }
\DoxyCodeLine{3914 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generator_exception}{GeneratorException}} : \textcolor{keyword}{public} std::exception \{}
\DoxyCodeLine{3915     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \textcolor{keyword}{const} m\_msg = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{3916 }
\DoxyCodeLine{3917 \textcolor{keyword}{public}:}
\DoxyCodeLine{3918     \mbox{\hyperlink{class_catch_1_1_generator_exception}{GeneratorException}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* msg):}
\DoxyCodeLine{3919         m\_msg(msg)}
\DoxyCodeLine{3920     \{\}}
\DoxyCodeLine{3921 }
\DoxyCodeLine{3922     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* what() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \textcolor{keyword}{override} \textcolor{keyword}{final};}
\DoxyCodeLine{3923 \};}
\DoxyCodeLine{3924 }
\DoxyCodeLine{3925 \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{3926 }
\DoxyCodeLine{3927     \textcolor{comment}{// !TBD move this into its own location?}}
\DoxyCodeLine{3928     \textcolor{keyword}{namespace }pf\{}
\DoxyCodeLine{3929         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3930         std::unique\_ptr<T> make\_unique( Args\&\&... args ) \{}
\DoxyCodeLine{3931             \textcolor{keywordflow}{return} std::unique\_ptr<T>(\textcolor{keyword}{new} T(std::forward<Args>(args)...));}
\DoxyCodeLine{3932         \}}
\DoxyCodeLine{3933     \}}
\DoxyCodeLine{3934 }
\DoxyCodeLine{3935     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3936     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}} : \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_untyped_base}{GeneratorUntypedBase}} \{}
\DoxyCodeLine{3937         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{\string~IGenerator}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{3938 }
\DoxyCodeLine{3939         \textcolor{comment}{// Returns the current element of the generator}}
\DoxyCodeLine{3940         \textcolor{comment}{//}}
\DoxyCodeLine{3941         \textcolor{comment}{// \(\backslash\)Precondition The generator is either freshly constructed,}}
\DoxyCodeLine{3942         \textcolor{comment}{// or the last call to `next()` returned true}}
\DoxyCodeLine{3943         \textcolor{keyword}{virtual} T \textcolor{keyword}{const}\& get() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3944         \textcolor{keyword}{using} type = T;}
\DoxyCodeLine{3945     \};}
\DoxyCodeLine{3946 }
\DoxyCodeLine{3947     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3948     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_single_value_generator}{SingleValueGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{3949         T m\_value;}
\DoxyCodeLine{3950     \textcolor{keyword}{public}:}
\DoxyCodeLine{3951         \mbox{\hyperlink{class_catch_1_1_generators_1_1_single_value_generator}{SingleValueGenerator}}(T\&\& value) : m\_value(std::move(value)) \{\}}
\DoxyCodeLine{3952 }
\DoxyCodeLine{3953         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3954             \textcolor{keywordflow}{return} m\_value;}
\DoxyCodeLine{3955         \}}
\DoxyCodeLine{3956         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{3957             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3958         \}}
\DoxyCodeLine{3959     \};}
\DoxyCodeLine{3960 }
\DoxyCodeLine{3961     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3962     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_fixed_values_generator}{FixedValuesGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{3963         \textcolor{keyword}{static\_assert}(!std::is\_same<T, bool>::value,}
\DoxyCodeLine{3964             \textcolor{stringliteral}{"{}FixedValuesGenerator does not support bools because of std::vector<bool>"{}}}
\DoxyCodeLine{3965             \textcolor{stringliteral}{"{}specialization, use SingleValue Generator instead."{}});}
\DoxyCodeLine{3966         std::vector<T> m\_values;}
\DoxyCodeLine{3967         \textcolor{keywordtype}{size\_t} m\_idx = 0;}
\DoxyCodeLine{3968     \textcolor{keyword}{public}:}
\DoxyCodeLine{3969         \mbox{\hyperlink{class_catch_1_1_generators_1_1_fixed_values_generator}{FixedValuesGenerator}}( std::initializer\_list<T> values ) : m\_values( values ) \{\}}
\DoxyCodeLine{3970 }
\DoxyCodeLine{3971         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3972             \textcolor{keywordflow}{return} m\_values[m\_idx];}
\DoxyCodeLine{3973         \}}
\DoxyCodeLine{3974         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{3975             ++m\_idx;}
\DoxyCodeLine{3976             \textcolor{keywordflow}{return} m\_idx < m\_values.size();}
\DoxyCodeLine{3977         \}}
\DoxyCodeLine{3978     \};}
\DoxyCodeLine{3979 }
\DoxyCodeLine{3980     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3981     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper}} final \{}
\DoxyCodeLine{3982         std::unique\_ptr<IGenerator<T>> m\_generator;}
\DoxyCodeLine{3983     \textcolor{keyword}{public}:}
\DoxyCodeLine{3984         \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper}}(std::unique\_ptr<\mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator<T>}}> generator):}
\DoxyCodeLine{3985             m\_generator(std::move(generator))}
\DoxyCodeLine{3986         \{\}}
\DoxyCodeLine{3987         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3988             \textcolor{keywordflow}{return} m\_generator-\/>get();}
\DoxyCodeLine{3989         \}}
\DoxyCodeLine{3990         \textcolor{keywordtype}{bool} next() \{}
\DoxyCodeLine{3991             \textcolor{keywordflow}{return} m\_generator-\/>next();}
\DoxyCodeLine{3992         \}}
\DoxyCodeLine{3993     \};}
\DoxyCodeLine{3994 }
\DoxyCodeLine{3995     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3996     \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} value(T\&\& value) \{}
\DoxyCodeLine{3997         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}(pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_single_value_generator}{SingleValueGenerator<T>}}>(std::forward<T>(value)));}
\DoxyCodeLine{3998     \}}
\DoxyCodeLine{3999     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4000     GeneratorWrapper<T> values(std::initializer\_list<T> values) \{}
\DoxyCodeLine{4001         \textcolor{keywordflow}{return} GeneratorWrapper<T>(pf::make\_unique<FixedValuesGenerator<T>>(values));}
\DoxyCodeLine{4002     \}}
\DoxyCodeLine{4003 }
\DoxyCodeLine{4004     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4005     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_generators}{Generators}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{4006         std::vector<GeneratorWrapper<T>> m\_generators;}
\DoxyCodeLine{4007         \textcolor{keywordtype}{size\_t} m\_current = 0;}
\DoxyCodeLine{4008 }
\DoxyCodeLine{4009         \textcolor{keywordtype}{void} populate(\mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4010             m\_generators.emplace\_back(std::move(generator));}
\DoxyCodeLine{4011         \}}
\DoxyCodeLine{4012         \textcolor{keywordtype}{void} populate(T\&\& val) \{}
\DoxyCodeLine{4013             m\_generators.emplace\_back(value(std::forward<T>(val)));}
\DoxyCodeLine{4014         \}}
\DoxyCodeLine{4015         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{4016         \textcolor{keywordtype}{void} populate(U\&\& val) \{}
\DoxyCodeLine{4017             populate(T(std::forward<U>(val)));}
\DoxyCodeLine{4018         \}}
\DoxyCodeLine{4019         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4020         \textcolor{keywordtype}{void} populate(U\&\& valueOrGenerator, Gs \&\&... moreGenerators) \{}
\DoxyCodeLine{4021             populate(std::forward<U>(valueOrGenerator));}
\DoxyCodeLine{4022             populate(std::forward<Gs>(moreGenerators)...);}
\DoxyCodeLine{4023         \}}
\DoxyCodeLine{4024 }
\DoxyCodeLine{4025     \textcolor{keyword}{public}:}
\DoxyCodeLine{4026         \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4027         \mbox{\hyperlink{class_catch_1_1_generators_1_1_generators}{Generators}}(Gs \&\&... moreGenerators) \{}
\DoxyCodeLine{4028             m\_generators.reserve(\textcolor{keyword}{sizeof}...(Gs));}
\DoxyCodeLine{4029             populate(std::forward<Gs>(moreGenerators)...);}
\DoxyCodeLine{4030         \}}
\DoxyCodeLine{4031 }
\DoxyCodeLine{4032         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4033             \textcolor{keywordflow}{return} m\_generators[m\_current].get();}
\DoxyCodeLine{4034         \}}
\DoxyCodeLine{4035 }
\DoxyCodeLine{4036         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4037             \textcolor{keywordflow}{if} (m\_current >= m\_generators.size()) \{}
\DoxyCodeLine{4038                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4039             \}}
\DoxyCodeLine{4040             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} current\_status = m\_generators[m\_current].next();}
\DoxyCodeLine{4041             \textcolor{keywordflow}{if} (!current\_status) \{}
\DoxyCodeLine{4042                 ++m\_current;}
\DoxyCodeLine{4043             \}}
\DoxyCodeLine{4044             \textcolor{keywordflow}{return} m\_current < m\_generators.size();}
\DoxyCodeLine{4045         \}}
\DoxyCodeLine{4046     \};}
\DoxyCodeLine{4047 }
\DoxyCodeLine{4048     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{4049     \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper}}<std::tuple<Ts...>> table( std::initializer\_list<std::tuple<\textcolor{keyword}{typename} std::decay<Ts>::type...>> tuples ) \{}
\DoxyCodeLine{4050         \textcolor{keywordflow}{return} values<std::tuple<Ts...>>( tuples );}
\DoxyCodeLine{4051     \}}
\DoxyCodeLine{4052 }
\DoxyCodeLine{4053     \textcolor{comment}{// Tag type to signal that a generator sequence should convert arguments to a specific type}}
\DoxyCodeLine{4054     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4055     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_generators_1_1as}{as}} \{\};}
\DoxyCodeLine{4056 }
\DoxyCodeLine{4057     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4058     \textcolor{keyword}{auto} makeGenerators( \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator, Gs \&\&... moreGenerators ) -\/> \mbox{\hyperlink{class_catch_1_1_generators_1_1_generators}{Generators<T>}} \{}
\DoxyCodeLine{4059         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generators}{Generators<T>}}(std::move(generator), std::forward<Gs>(moreGenerators)...);}
\DoxyCodeLine{4060     \}}
\DoxyCodeLine{4061     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4062     \textcolor{keyword}{auto} makeGenerators( GeneratorWrapper<T>\&\& generator ) -\/> Generators<T> \{}
\DoxyCodeLine{4063         \textcolor{keywordflow}{return} Generators<T>(std::move(generator));}
\DoxyCodeLine{4064     \}}
\DoxyCodeLine{4065     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4066     \textcolor{keyword}{auto} makeGenerators( T\&\& val, Gs \&\&... moreGenerators ) -\/> Generators<T> \{}
\DoxyCodeLine{4067         \textcolor{keywordflow}{return} makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );}
\DoxyCodeLine{4068     \}}
\DoxyCodeLine{4069     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4070     \textcolor{keyword}{auto} makeGenerators( as<T>, U\&\& val, Gs \&\&... moreGenerators ) -\/> Generators<T> \{}
\DoxyCodeLine{4071         \textcolor{keywordflow}{return} makeGenerators( value( T( std::forward<U>( val ) ) ), std::forward<Gs>( moreGenerators )... );}
\DoxyCodeLine{4072     \}}
\DoxyCodeLine{4073 }
\DoxyCodeLine{4074     \textcolor{keyword}{auto} acquireGeneratorTracker( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -\/> IGeneratorTracker\&;}
\DoxyCodeLine{4075 }
\DoxyCodeLine{4076     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{4077     \textcolor{comment}{// Note: The type after -\/> is weird, because VS2015 cannot parse}}
\DoxyCodeLine{4078     \textcolor{comment}{//       the expression used in the typedef inside, when it is in}}
\DoxyCodeLine{4079     \textcolor{comment}{//       return type. Yeah.}}
\DoxyCodeLine{4080     \textcolor{keyword}{auto} generate( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo, L \textcolor{keyword}{const}\& generatorExpression ) -\/> \textcolor{keyword}{decltype}(std::declval<decltype(generatorExpression())>().get()) \{}
\DoxyCodeLine{4081         \textcolor{keyword}{using} UnderlyingType = \textcolor{keyword}{typename} \textcolor{keyword}{decltype}(generatorExpression())::type;}
\DoxyCodeLine{4082 }
\DoxyCodeLine{4083         IGeneratorTracker\& tracker = acquireGeneratorTracker( generatorName, lineInfo );}
\DoxyCodeLine{4084         \textcolor{keywordflow}{if} (!tracker.hasGenerator()) \{}
\DoxyCodeLine{4085             tracker.setGenerator(pf::make\_unique<Generators<UnderlyingType>>(generatorExpression()));}
\DoxyCodeLine{4086         \}}
\DoxyCodeLine{4087 }
\DoxyCodeLine{4088         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& generator = \textcolor{keyword}{static\_cast<}IGenerator<UnderlyingType> const\&\textcolor{keyword}{>}( *tracker.getGenerator() );}
\DoxyCodeLine{4089         \textcolor{keywordflow}{return} generator.get();}
\DoxyCodeLine{4090     \}}
\DoxyCodeLine{4091 }
\DoxyCodeLine{4092 \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{4093 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{4094 }
\DoxyCodeLine{4095 \textcolor{preprocessor}{\#define GENERATE( ... ) \(\backslash\)}}
\DoxyCodeLine{4096 \textcolor{preprocessor}{    Catch::Generators::generate( INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_UNIQUE\_NAME(generator)), \(\backslash\)}}
\DoxyCodeLine{4097 \textcolor{preprocessor}{                                 CATCH\_INTERNAL\_LINEINFO, \(\backslash\)}}
\DoxyCodeLine{4098 \textcolor{preprocessor}{                                 [ ]\{ using namespace Catch::Generators; return makeGenerators( \_\_VA\_ARGS\_\_ ); \} ) }\textcolor{comment}{//NOLINT(google-\/build-\/using-\/namespace)}}
\DoxyCodeLine{4099 \textcolor{preprocessor}{\#define GENERATE\_COPY( ... ) \(\backslash\)}}
\DoxyCodeLine{4100 \textcolor{preprocessor}{    Catch::Generators::generate( INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_UNIQUE\_NAME(generator)), \(\backslash\)}}
\DoxyCodeLine{4101 \textcolor{preprocessor}{                                 CATCH\_INTERNAL\_LINEINFO, \(\backslash\)}}
\DoxyCodeLine{4102 \textcolor{preprocessor}{                                 [=]\{ using namespace Catch::Generators; return makeGenerators( \_\_VA\_ARGS\_\_ ); \} ) }\textcolor{comment}{//NOLINT(google-\/build-\/using-\/namespace)}}
\DoxyCodeLine{4103 \textcolor{preprocessor}{\#define GENERATE\_REF( ... ) \(\backslash\)}}
\DoxyCodeLine{4104 \textcolor{preprocessor}{    Catch::Generators::generate( INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_UNIQUE\_NAME(generator)), \(\backslash\)}}
\DoxyCodeLine{4105 \textcolor{preprocessor}{                                 CATCH\_INTERNAL\_LINEINFO, \(\backslash\)}}
\DoxyCodeLine{4106 \textcolor{preprocessor}{                                 [\&]\{ using namespace Catch::Generators; return makeGenerators( \_\_VA\_ARGS\_\_ ); \} ) }\textcolor{comment}{//NOLINT(google-\/build-\/using-\/namespace)}}
\DoxyCodeLine{4107 }
\DoxyCodeLine{4108 \textcolor{comment}{// end catch\_generators.hpp}}
\DoxyCodeLine{4109 \textcolor{comment}{// start catch\_generators\_generic.hpp}}
\DoxyCodeLine{4110 }
\DoxyCodeLine{4111 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4112 \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{4113 }
\DoxyCodeLine{4114     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4115     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_take_generator}{TakeGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{4116         \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} m\_generator;}
\DoxyCodeLine{4117         \textcolor{keywordtype}{size\_t} m\_returned = 0;}
\DoxyCodeLine{4118         \textcolor{keywordtype}{size\_t} m\_target;}
\DoxyCodeLine{4119     \textcolor{keyword}{public}:}
\DoxyCodeLine{4120         \mbox{\hyperlink{class_catch_1_1_generators_1_1_take_generator}{TakeGenerator}}(\textcolor{keywordtype}{size\_t} target, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator):}
\DoxyCodeLine{4121             m\_generator(std::move(generator)),}
\DoxyCodeLine{4122             m\_target(target)}
\DoxyCodeLine{4123         \{}
\DoxyCodeLine{4124             assert(target != 0 \&\& \textcolor{stringliteral}{"{}Empty generators are not allowed"{}});}
\DoxyCodeLine{4125         \}}
\DoxyCodeLine{4126         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4127             \textcolor{keywordflow}{return} m\_generator.get();}
\DoxyCodeLine{4128         \}}
\DoxyCodeLine{4129         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4130             ++m\_returned;}
\DoxyCodeLine{4131             \textcolor{keywordflow}{if} (m\_returned >= m\_target) \{}
\DoxyCodeLine{4132                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4133             \}}
\DoxyCodeLine{4134 }
\DoxyCodeLine{4135             \textcolor{keyword}{const} \textcolor{keyword}{auto} success = m\_generator.next();}
\DoxyCodeLine{4136             \textcolor{comment}{// If the underlying generator does not contain enough values}}
\DoxyCodeLine{4137             \textcolor{comment}{// then we cut short as well}}
\DoxyCodeLine{4138             \textcolor{keywordflow}{if} (!success) \{}
\DoxyCodeLine{4139                 m\_returned = m\_target;}
\DoxyCodeLine{4140             \}}
\DoxyCodeLine{4141             \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{4142         \}}
\DoxyCodeLine{4143     \};}
\DoxyCodeLine{4144 }
\DoxyCodeLine{4145     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4146     \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} take(\textcolor{keywordtype}{size\_t} target, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4147         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}(pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_take_generator}{TakeGenerator<T>}}>(target, std::move(generator)));}
\DoxyCodeLine{4148     \}}
\DoxyCodeLine{4149 }
\DoxyCodeLine{4150     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Predicate>}
\DoxyCodeLine{4151     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_filter_generator}{FilterGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{4152         \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} m\_generator;}
\DoxyCodeLine{4153         Predicate m\_predicate;}
\DoxyCodeLine{4154     \textcolor{keyword}{public}:}
\DoxyCodeLine{4155         \textcolor{keyword}{template} <\textcolor{keyword}{typename} P = Predicate>}
\DoxyCodeLine{4156         \mbox{\hyperlink{class_catch_1_1_generators_1_1_filter_generator}{FilterGenerator}}(P\&\& pred, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator):}
\DoxyCodeLine{4157             m\_generator(std::move(generator)),}
\DoxyCodeLine{4158             m\_predicate(std::forward<P>(pred))}
\DoxyCodeLine{4159         \{}
\DoxyCodeLine{4160             \textcolor{keywordflow}{if} (!m\_predicate(m\_generator.get())) \{}
\DoxyCodeLine{4161                 \textcolor{comment}{// It might happen that there are no values that pass the}}
\DoxyCodeLine{4162                 \textcolor{comment}{// filter. In that case we throw an exception.}}
\DoxyCodeLine{4163                 \textcolor{keyword}{auto} has\_initial\_value = next();}
\DoxyCodeLine{4164                 \textcolor{keywordflow}{if} (!has\_initial\_value) \{}
\DoxyCodeLine{4165                     Catch::throw\_exception(\mbox{\hyperlink{class_catch_1_1_generator_exception}{GeneratorException}}(\textcolor{stringliteral}{"{}No valid value found in filtered generator"{}}));}
\DoxyCodeLine{4166                 \}}
\DoxyCodeLine{4167             \}}
\DoxyCodeLine{4168         \}}
\DoxyCodeLine{4169 }
\DoxyCodeLine{4170         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4171             \textcolor{keywordflow}{return} m\_generator.get();}
\DoxyCodeLine{4172         \}}
\DoxyCodeLine{4173 }
\DoxyCodeLine{4174         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4175             \textcolor{keywordtype}{bool} success = m\_generator.next();}
\DoxyCodeLine{4176             \textcolor{keywordflow}{if} (!success) \{}
\DoxyCodeLine{4177                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4178             \}}
\DoxyCodeLine{4179             \textcolor{keywordflow}{while} (!m\_predicate(m\_generator.get()) \&\& (success = m\_generator.next()) == \textcolor{keyword}{true});}
\DoxyCodeLine{4180             \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{4181         \}}
\DoxyCodeLine{4182     \};}
\DoxyCodeLine{4183 }
\DoxyCodeLine{4184     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Predicate>}
\DoxyCodeLine{4185     \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} filter(Predicate\&\& pred, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4186         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}(std::unique\_ptr<\mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator<T>}}>(pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_filter_generator}{FilterGenerator<T, Predicate>}}>(std::forward<Predicate>(pred), std::move(generator))));}
\DoxyCodeLine{4187     \}}
\DoxyCodeLine{4188 }
\DoxyCodeLine{4189     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4190     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_repeat_generator}{RepeatGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{4191         \textcolor{keyword}{static\_assert}(!std::is\_same<T, bool>::value,}
\DoxyCodeLine{4192             \textcolor{stringliteral}{"{}RepeatGenerator currently does not support bools"{}}}
\DoxyCodeLine{4193             \textcolor{stringliteral}{"{}because of std::vector<bool> specialization"{}});}
\DoxyCodeLine{4194         \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} m\_generator;}
\DoxyCodeLine{4195         \textcolor{keyword}{mutable} std::vector<T> m\_returned;}
\DoxyCodeLine{4196         \textcolor{keywordtype}{size\_t} m\_target\_repeats;}
\DoxyCodeLine{4197         \textcolor{keywordtype}{size\_t} m\_current\_repeat = 0;}
\DoxyCodeLine{4198         \textcolor{keywordtype}{size\_t} m\_repeat\_index = 0;}
\DoxyCodeLine{4199     \textcolor{keyword}{public}:}
\DoxyCodeLine{4200         \mbox{\hyperlink{class_catch_1_1_generators_1_1_repeat_generator}{RepeatGenerator}}(\textcolor{keywordtype}{size\_t} repeats, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator):}
\DoxyCodeLine{4201             m\_generator(std::move(generator)),}
\DoxyCodeLine{4202             m\_target\_repeats(repeats)}
\DoxyCodeLine{4203         \{}
\DoxyCodeLine{4204             assert(m\_target\_repeats > 0 \&\& \textcolor{stringliteral}{"{}Repeat generator must repeat at least once"{}});}
\DoxyCodeLine{4205         \}}
\DoxyCodeLine{4206 }
\DoxyCodeLine{4207         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4208             \textcolor{keywordflow}{if} (m\_current\_repeat == 0) \{}
\DoxyCodeLine{4209                 m\_returned.push\_back(m\_generator.get());}
\DoxyCodeLine{4210                 \textcolor{keywordflow}{return} m\_returned.back();}
\DoxyCodeLine{4211             \}}
\DoxyCodeLine{4212             \textcolor{keywordflow}{return} m\_returned[m\_repeat\_index];}
\DoxyCodeLine{4213         \}}
\DoxyCodeLine{4214 }
\DoxyCodeLine{4215         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4216             \textcolor{comment}{// There are 2 basic cases:}}
\DoxyCodeLine{4217             \textcolor{comment}{// 1) We are still reading the generator}}
\DoxyCodeLine{4218             \textcolor{comment}{// 2) We are reading our own cache}}
\DoxyCodeLine{4219 }
\DoxyCodeLine{4220             \textcolor{comment}{// In the first case, we need to poke the underlying generator.}}
\DoxyCodeLine{4221             \textcolor{comment}{// If it happily moves, we are left in that state, otherwise it is time to start reading from our cache}}
\DoxyCodeLine{4222             \textcolor{keywordflow}{if} (m\_current\_repeat == 0) \{}
\DoxyCodeLine{4223                 \textcolor{keyword}{const} \textcolor{keyword}{auto} success = m\_generator.next();}
\DoxyCodeLine{4224                 \textcolor{keywordflow}{if} (!success) \{}
\DoxyCodeLine{4225                     ++m\_current\_repeat;}
\DoxyCodeLine{4226                 \}}
\DoxyCodeLine{4227                 \textcolor{keywordflow}{return} m\_current\_repeat < m\_target\_repeats;}
\DoxyCodeLine{4228             \}}
\DoxyCodeLine{4229 }
\DoxyCodeLine{4230             \textcolor{comment}{// In the second case, we need to move indices forward and check that we haven't run up against the end}}
\DoxyCodeLine{4231             ++m\_repeat\_index;}
\DoxyCodeLine{4232             \textcolor{keywordflow}{if} (m\_repeat\_index == m\_returned.size()) \{}
\DoxyCodeLine{4233                 m\_repeat\_index = 0;}
\DoxyCodeLine{4234                 ++m\_current\_repeat;}
\DoxyCodeLine{4235             \}}
\DoxyCodeLine{4236             \textcolor{keywordflow}{return} m\_current\_repeat < m\_target\_repeats;}
\DoxyCodeLine{4237         \}}
\DoxyCodeLine{4238     \};}
\DoxyCodeLine{4239 }
\DoxyCodeLine{4240     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4241     \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} repeat(\textcolor{keywordtype}{size\_t} repeats, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4242         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}(pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_repeat_generator}{RepeatGenerator<T>}}>(repeats, std::move(generator)));}
\DoxyCodeLine{4243     \}}
\DoxyCodeLine{4244 }
\DoxyCodeLine{4245     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U, \textcolor{keyword}{typename} Func>}
\DoxyCodeLine{4246     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_map_generator}{MapGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{4247         \textcolor{comment}{// TBD: provide static assert for mapping function, for friendly error message}}
\DoxyCodeLine{4248         \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<U>}} m\_generator;}
\DoxyCodeLine{4249         Func m\_function;}
\DoxyCodeLine{4250         \textcolor{comment}{// To avoid returning dangling reference, we have to save the values}}
\DoxyCodeLine{4251         T m\_cache;}
\DoxyCodeLine{4252     \textcolor{keyword}{public}:}
\DoxyCodeLine{4253         \textcolor{keyword}{template} <\textcolor{keyword}{typename} F2 = Func>}
\DoxyCodeLine{4254         \mbox{\hyperlink{class_catch_1_1_generators_1_1_map_generator}{MapGenerator}}(F2\&\& \textcolor{keyword}{function}, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<U>}}\&\& generator) :}
\DoxyCodeLine{4255             m\_generator(std::move(generator)),}
\DoxyCodeLine{4256             m\_function(std::forward<F2>(\textcolor{keyword}{function})),}
\DoxyCodeLine{4257             m\_cache(m\_function(m\_generator.get()))}
\DoxyCodeLine{4258         \{\}}
\DoxyCodeLine{4259 }
\DoxyCodeLine{4260         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4261             \textcolor{keywordflow}{return} m\_cache;}
\DoxyCodeLine{4262         \}}
\DoxyCodeLine{4263         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4264             \textcolor{keyword}{const} \textcolor{keyword}{auto} success = m\_generator.next();}
\DoxyCodeLine{4265             \textcolor{keywordflow}{if} (success) \{}
\DoxyCodeLine{4266                 m\_cache = m\_function(m\_generator.get());}
\DoxyCodeLine{4267             \}}
\DoxyCodeLine{4268             \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{4269         \}}
\DoxyCodeLine{4270     \};}
\DoxyCodeLine{4271 }
\DoxyCodeLine{4272     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} U, \textcolor{keyword}{typename} T = FunctionReturnType<Func, U>>}
\DoxyCodeLine{4273     \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} map(Func\&\& \textcolor{keyword}{function}, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<U>}}\&\& generator) \{}
\DoxyCodeLine{4274         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}(}
\DoxyCodeLine{4275             pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_map_generator}{MapGenerator<T, U, Func>}}>(std::forward<Func>(\textcolor{keyword}{function}), std::move(generator))}
\DoxyCodeLine{4276         );}
\DoxyCodeLine{4277     \}}
\DoxyCodeLine{4278 }
\DoxyCodeLine{4279     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U, \textcolor{keyword}{typename} Func>}
\DoxyCodeLine{4280     GeneratorWrapper<T> map(Func\&\& \textcolor{keyword}{function}, GeneratorWrapper<U>\&\& generator) \{}
\DoxyCodeLine{4281         \textcolor{keywordflow}{return} GeneratorWrapper<T>(}
\DoxyCodeLine{4282             pf::make\_unique<MapGenerator<T, U, Func>>(std::forward<Func>(\textcolor{keyword}{function}), std::move(generator))}
\DoxyCodeLine{4283         );}
\DoxyCodeLine{4284     \}}
\DoxyCodeLine{4285 }
\DoxyCodeLine{4286     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4287     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_chunk_generator}{ChunkGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<std::vector<T>> \{}
\DoxyCodeLine{4288         std::vector<T> m\_chunk;}
\DoxyCodeLine{4289         \textcolor{keywordtype}{size\_t} m\_chunk\_size;}
\DoxyCodeLine{4290         \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} m\_generator;}
\DoxyCodeLine{4291         \textcolor{keywordtype}{bool} m\_used\_up = \textcolor{keyword}{false};}
\DoxyCodeLine{4292     \textcolor{keyword}{public}:}
\DoxyCodeLine{4293         \mbox{\hyperlink{class_catch_1_1_generators_1_1_chunk_generator}{ChunkGenerator}}(\textcolor{keywordtype}{size\_t} size, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} generator) :}
\DoxyCodeLine{4294             m\_chunk\_size(size), m\_generator(std::move(generator))}
\DoxyCodeLine{4295         \{}
\DoxyCodeLine{4296             m\_chunk.reserve(m\_chunk\_size);}
\DoxyCodeLine{4297             \textcolor{keywordflow}{if} (m\_chunk\_size != 0) \{}
\DoxyCodeLine{4298                 m\_chunk.push\_back(m\_generator.get());}
\DoxyCodeLine{4299                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 1; i < m\_chunk\_size; ++i) \{}
\DoxyCodeLine{4300                     \textcolor{keywordflow}{if} (!m\_generator.next()) \{}
\DoxyCodeLine{4301                         Catch::throw\_exception(\mbox{\hyperlink{class_catch_1_1_generator_exception}{GeneratorException}}(\textcolor{stringliteral}{"{}Not enough values to initialize the first chunk"{}}));}
\DoxyCodeLine{4302                     \}}
\DoxyCodeLine{4303                     m\_chunk.push\_back(m\_generator.get());}
\DoxyCodeLine{4304                 \}}
\DoxyCodeLine{4305             \}}
\DoxyCodeLine{4306         \}}
\DoxyCodeLine{4307         std::vector<T> \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4308             \textcolor{keywordflow}{return} m\_chunk;}
\DoxyCodeLine{4309         \}}
\DoxyCodeLine{4310         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4311             m\_chunk.clear();}
\DoxyCodeLine{4312             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} idx = 0; idx < m\_chunk\_size; ++idx) \{}
\DoxyCodeLine{4313                 \textcolor{keywordflow}{if} (!m\_generator.next()) \{}
\DoxyCodeLine{4314                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4315                 \}}
\DoxyCodeLine{4316                 m\_chunk.push\_back(m\_generator.get());}
\DoxyCodeLine{4317             \}}
\DoxyCodeLine{4318             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4319         \}}
\DoxyCodeLine{4320     \};}
\DoxyCodeLine{4321 }
\DoxyCodeLine{4322     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4323     \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<std::vector<T>}}> chunk(\textcolor{keywordtype}{size\_t} size, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4324         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<std::vector<T>}}>(}
\DoxyCodeLine{4325             pf::make\_unique<ChunkGenerator<T>>(size, std::move(generator))}
\DoxyCodeLine{4326         );}
\DoxyCodeLine{4327     \}}
\DoxyCodeLine{4328 }
\DoxyCodeLine{4329 \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{4330 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{4331 }
\DoxyCodeLine{4332 \textcolor{comment}{// end catch\_generators\_generic.hpp}}
\DoxyCodeLine{4333 \textcolor{comment}{// start catch\_generators\_specific.hpp}}
\DoxyCodeLine{4334 }
\DoxyCodeLine{4335 \textcolor{comment}{// start catch\_context.h}}
\DoxyCodeLine{4336 }
\DoxyCodeLine{4337 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{4338 }
\DoxyCodeLine{4339 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4340 }
\DoxyCodeLine{4341     \textcolor{keyword}{struct }IResultCapture;}
\DoxyCodeLine{4342     \textcolor{keyword}{struct }IRunner;}
\DoxyCodeLine{4343     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{4344     \textcolor{keyword}{struct }IMutableContext;}
\DoxyCodeLine{4345 }
\DoxyCodeLine{4346     \textcolor{keyword}{using} IConfigPtr = std::shared\_ptr<IConfig const>;}
\DoxyCodeLine{4347 }
\DoxyCodeLine{4348     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_context}{IContext}}}
\DoxyCodeLine{4349     \{}
\DoxyCodeLine{4350         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_context}{\string~IContext}}();}
\DoxyCodeLine{4351 }
\DoxyCodeLine{4352         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_result_capture}{IResultCapture}}* getResultCapture() = 0;}
\DoxyCodeLine{4353         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_runner}{IRunner}}* getRunner() = 0;}
\DoxyCodeLine{4354         \textcolor{keyword}{virtual} IConfigPtr \textcolor{keyword}{const}\& getConfig() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4355     \};}
\DoxyCodeLine{4356 }
\DoxyCodeLine{4357     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_mutable_context}{IMutableContext}} : \mbox{\hyperlink{struct_catch_1_1_i_context}{IContext}}}
\DoxyCodeLine{4358     \{}
\DoxyCodeLine{4359         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_mutable_context}{\string~IMutableContext}}();}
\DoxyCodeLine{4360         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setResultCapture( \mbox{\hyperlink{struct_catch_1_1_i_result_capture}{IResultCapture}}* resultCapture ) = 0;}
\DoxyCodeLine{4361         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setRunner( \mbox{\hyperlink{struct_catch_1_1_i_runner}{IRunner}}* runner ) = 0;}
\DoxyCodeLine{4362         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setConfig( IConfigPtr \textcolor{keyword}{const}\& config ) = 0;}
\DoxyCodeLine{4363 }
\DoxyCodeLine{4364     \textcolor{keyword}{private}:}
\DoxyCodeLine{4365         \textcolor{keyword}{static} \mbox{\hyperlink{struct_catch_1_1_i_mutable_context}{IMutableContext}} *currentContext;}
\DoxyCodeLine{4366         \textcolor{keyword}{friend} \mbox{\hyperlink{struct_catch_1_1_i_mutable_context}{IMutableContext}}\& getCurrentMutableContext();}
\DoxyCodeLine{4367         \textcolor{keyword}{friend} \textcolor{keywordtype}{void} cleanUpContext();}
\DoxyCodeLine{4368         \textcolor{keyword}{static} \textcolor{keywordtype}{void} createContext();}
\DoxyCodeLine{4369     \};}
\DoxyCodeLine{4370 }
\DoxyCodeLine{4371     \textcolor{keyword}{inline} \mbox{\hyperlink{struct_catch_1_1_i_mutable_context}{IMutableContext}}\& getCurrentMutableContext()}
\DoxyCodeLine{4372     \{}
\DoxyCodeLine{4373         \textcolor{keywordflow}{if}( !IMutableContext::currentContext )}
\DoxyCodeLine{4374             IMutableContext::createContext();}
\DoxyCodeLine{4375         \textcolor{comment}{// NOLINTNEXTLINE(clang-\/analyzer-\/core.uninitialized.UndefReturn)}}
\DoxyCodeLine{4376         \textcolor{keywordflow}{return} *IMutableContext::currentContext;}
\DoxyCodeLine{4377     \}}
\DoxyCodeLine{4378 }
\DoxyCodeLine{4379     \textcolor{keyword}{inline} IContext\& getCurrentContext()}
\DoxyCodeLine{4380     \{}
\DoxyCodeLine{4381         \textcolor{keywordflow}{return} getCurrentMutableContext();}
\DoxyCodeLine{4382     \}}
\DoxyCodeLine{4383 }
\DoxyCodeLine{4384     \textcolor{keywordtype}{void} cleanUpContext();}
\DoxyCodeLine{4385 }
\DoxyCodeLine{4386     \textcolor{keyword}{class }SimplePcg32;}
\DoxyCodeLine{4387     SimplePcg32\& rng();}
\DoxyCodeLine{4388 \}}
\DoxyCodeLine{4389 }
\DoxyCodeLine{4390 \textcolor{comment}{// end catch\_context.h}}
\DoxyCodeLine{4391 \textcolor{comment}{// start catch\_interfaces\_config.h}}
\DoxyCodeLine{4392 }
\DoxyCodeLine{4393 \textcolor{comment}{// start catch\_option.hpp}}
\DoxyCodeLine{4394 }
\DoxyCodeLine{4395 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4396 }
\DoxyCodeLine{4397     \textcolor{comment}{// An optional type}}
\DoxyCodeLine{4398     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4399     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_option}{Option}} \{}
\DoxyCodeLine{4400     \textcolor{keyword}{public}:}
\DoxyCodeLine{4401         \mbox{\hyperlink{class_catch_1_1_option}{Option}}() : nullableValue( \textcolor{keyword}{nullptr} ) \{\}}
\DoxyCodeLine{4402         \mbox{\hyperlink{class_catch_1_1_option}{Option}}( T \textcolor{keyword}{const}\& \_value )}
\DoxyCodeLine{4403         : nullableValue( \textcolor{keyword}{new}( storage ) T( \_value ) )}
\DoxyCodeLine{4404         \{\}}
\DoxyCodeLine{4405         \mbox{\hyperlink{class_catch_1_1_option}{Option}}( \mbox{\hyperlink{class_catch_1_1_option}{Option}} \textcolor{keyword}{const}\& \_other )}
\DoxyCodeLine{4406         : nullableValue( \_other ? \textcolor{keyword}{new}( storage ) T( *\_other ) : \textcolor{keyword}{nullptr} )}
\DoxyCodeLine{4407         \{\}}
\DoxyCodeLine{4408 }
\DoxyCodeLine{4409         \mbox{\hyperlink{class_catch_1_1_option}{\string~Option}}() \{}
\DoxyCodeLine{4410             reset();}
\DoxyCodeLine{4411         \}}
\DoxyCodeLine{4412 }
\DoxyCodeLine{4413         \mbox{\hyperlink{class_catch_1_1_option}{Option}}\& operator= ( \mbox{\hyperlink{class_catch_1_1_option}{Option}} \textcolor{keyword}{const}\& \_other ) \{}
\DoxyCodeLine{4414             \textcolor{keywordflow}{if}( \&\_other != \textcolor{keyword}{this} ) \{}
\DoxyCodeLine{4415                 reset();}
\DoxyCodeLine{4416                 \textcolor{keywordflow}{if}( \_other )}
\DoxyCodeLine{4417                     nullableValue = \textcolor{keyword}{new}( storage ) T( *\_other );}
\DoxyCodeLine{4418             \}}
\DoxyCodeLine{4419             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{4420         \}}
\DoxyCodeLine{4421         \mbox{\hyperlink{class_catch_1_1_option}{Option}}\& operator = ( T \textcolor{keyword}{const}\& \_value ) \{}
\DoxyCodeLine{4422             reset();}
\DoxyCodeLine{4423             nullableValue = \textcolor{keyword}{new}( storage ) T( \_value );}
\DoxyCodeLine{4424             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{4425         \}}
\DoxyCodeLine{4426 }
\DoxyCodeLine{4427         \textcolor{keywordtype}{void} reset() \{}
\DoxyCodeLine{4428             \textcolor{keywordflow}{if}( nullableValue )}
\DoxyCodeLine{4429                 nullableValue-\/>\string~T();}
\DoxyCodeLine{4430             nullableValue = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{4431         \}}
\DoxyCodeLine{4432 }
\DoxyCodeLine{4433         T\& operator*() \{ \textcolor{keywordflow}{return} *nullableValue; \}}
\DoxyCodeLine{4434         T \textcolor{keyword}{const}\& operator*()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *nullableValue; \}}
\DoxyCodeLine{4435         T* operator-\/>() \{ \textcolor{keywordflow}{return} nullableValue; \}}
\DoxyCodeLine{4436         \textcolor{keyword}{const} T* operator-\/>()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue; \}}
\DoxyCodeLine{4437 }
\DoxyCodeLine{4438         T valueOr( T \textcolor{keyword}{const}\& defaultValue )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4439             \textcolor{keywordflow}{return} nullableValue ? *nullableValue : defaultValue;}
\DoxyCodeLine{4440         \}}
\DoxyCodeLine{4441 }
\DoxyCodeLine{4442         \textcolor{keywordtype}{bool} some()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue != \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{4443         \textcolor{keywordtype}{bool} none()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue == \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{4444 }
\DoxyCodeLine{4445         \textcolor{keywordtype}{bool} operator !()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue == \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{4446         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4447             \textcolor{keywordflow}{return} some();}
\DoxyCodeLine{4448         \}}
\DoxyCodeLine{4449 }
\DoxyCodeLine{4450     \textcolor{keyword}{private}:}
\DoxyCodeLine{4451         T *nullableValue;}
\DoxyCodeLine{4452         \textcolor{keyword}{alignas}(\textcolor{keyword}{alignof}(T)) \textcolor{keywordtype}{char} storage[\textcolor{keyword}{sizeof}(T)];}
\DoxyCodeLine{4453     \};}
\DoxyCodeLine{4454 }
\DoxyCodeLine{4455 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{4456 }
\DoxyCodeLine{4457 \textcolor{comment}{// end catch\_option.hpp}}
\DoxyCodeLine{4458 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{4459 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{4460 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{4461 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{4462 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{4463 }
\DoxyCodeLine{4464 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4465 }
\DoxyCodeLine{4466     \textcolor{keyword}{enum class} Verbosity \{}
\DoxyCodeLine{4467         Quiet = 0,}
\DoxyCodeLine{4468         Normal,}
\DoxyCodeLine{4469         High}
\DoxyCodeLine{4470     \};}
\DoxyCodeLine{4471 }
\DoxyCodeLine{4472     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_warn_about}{WarnAbout}} \{ \textcolor{keyword}{enum} What \{}
\DoxyCodeLine{4473         Nothing = 0x00,}
\DoxyCodeLine{4474         NoAssertions = 0x01,}
\DoxyCodeLine{4475         NoTests = 0x02}
\DoxyCodeLine{4476     \}; \};}
\DoxyCodeLine{4477 }
\DoxyCodeLine{4478     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_show_durations}{ShowDurations}} \{ \textcolor{keyword}{enum} OrNot \{}
\DoxyCodeLine{4479         DefaultForReporter,}
\DoxyCodeLine{4480         Always,}
\DoxyCodeLine{4481         Never}
\DoxyCodeLine{4482     \}; \};}
\DoxyCodeLine{4483     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_run_tests}{RunTests}} \{ \textcolor{keyword}{enum} InWhatOrder \{}
\DoxyCodeLine{4484         InDeclarationOrder,}
\DoxyCodeLine{4485         InLexicographicalOrder,}
\DoxyCodeLine{4486         InRandomOrder}
\DoxyCodeLine{4487     \}; \};}
\DoxyCodeLine{4488     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_use_colour}{UseColour}} \{ \textcolor{keyword}{enum} YesOrNo \{}
\DoxyCodeLine{4489         Auto,}
\DoxyCodeLine{4490         Yes,}
\DoxyCodeLine{4491         No}
\DoxyCodeLine{4492     \}; \};}
\DoxyCodeLine{4493     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_wait_for_keypress}{WaitForKeypress}} \{ \textcolor{keyword}{enum} When \{}
\DoxyCodeLine{4494         Never,}
\DoxyCodeLine{4495         BeforeStart = 1,}
\DoxyCodeLine{4496         BeforeExit = 2,}
\DoxyCodeLine{4497         BeforeStartAndExit = BeforeStart | BeforeExit}
\DoxyCodeLine{4498     \}; \};}
\DoxyCodeLine{4499 }
\DoxyCodeLine{4500     \textcolor{keyword}{class }TestSpec;}
\DoxyCodeLine{4501 }
\DoxyCodeLine{4502     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_config}{IConfig}} : \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \{}
\DoxyCodeLine{4503 }
\DoxyCodeLine{4504         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_config}{\string~IConfig}}();}
\DoxyCodeLine{4505 }
\DoxyCodeLine{4506         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} allowThrows() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4507         \textcolor{keyword}{virtual} std::ostream\& stream() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4508         \textcolor{keyword}{virtual} std::string name() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4509         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} includeSuccessfulResults() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4510         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} shouldDebugBreak() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4511         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} warnAboutMissingAssertions() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4512         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} warnAboutNoTests() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4513         \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} abortAfter() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4514         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} showInvisibles() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4515         \textcolor{keyword}{virtual} ShowDurations::OrNot showDurations() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4516         \textcolor{keyword}{virtual} \textcolor{keywordtype}{double} minDuration() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4517         \textcolor{keyword}{virtual} TestSpec \textcolor{keyword}{const}\& testSpec() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4518         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} hasTestFilters() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4519         \textcolor{keyword}{virtual} std::vector<std::string> \textcolor{keyword}{const}\& getTestsOrTags() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4520         \textcolor{keyword}{virtual} RunTests::InWhatOrder runOrder() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4521         \textcolor{keyword}{virtual} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4522         \textcolor{keyword}{virtual} UseColour::YesOrNo useColour() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4523         \textcolor{keyword}{virtual} std::vector<std::string> \textcolor{keyword}{const}\& getSectionsToRun() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4524         \textcolor{keyword}{virtual} Verbosity verbosity() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4525 }
\DoxyCodeLine{4526         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} benchmarkNoAnalysis() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4527         \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} benchmarkSamples() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4528         \textcolor{keyword}{virtual} \textcolor{keywordtype}{double} benchmarkConfidenceInterval() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4529         \textcolor{keyword}{virtual} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} benchmarkResamples() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4530         \textcolor{keyword}{virtual} std::chrono::milliseconds benchmarkWarmupTime() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4531     \};}
\DoxyCodeLine{4532 }
\DoxyCodeLine{4533     \textcolor{keyword}{using} IConfigPtr = std::shared\_ptr<IConfig const>;}
\DoxyCodeLine{4534 \}}
\DoxyCodeLine{4535 }
\DoxyCodeLine{4536 \textcolor{comment}{// end catch\_interfaces\_config.h}}
\DoxyCodeLine{4537 \textcolor{comment}{// start catch\_random\_number\_generator.h}}
\DoxyCodeLine{4538 }
\DoxyCodeLine{4539 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{4540 }
\DoxyCodeLine{4541 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4542 }
\DoxyCodeLine{4543     \textcolor{comment}{// This is a simple implementation of C++11 Uniform Random Number}}
\DoxyCodeLine{4544     \textcolor{comment}{// Generator. It does not provide all operators, because Catch2}}
\DoxyCodeLine{4545     \textcolor{comment}{// does not use it, but it should behave as expected inside stdlib's}}
\DoxyCodeLine{4546     \textcolor{comment}{// distributions.}}
\DoxyCodeLine{4547     \textcolor{comment}{// The implementation is based on the PCG family (http://pcg-\/random.org)}}
\DoxyCodeLine{4548     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}} \{}
\DoxyCodeLine{4549         \textcolor{keyword}{using} state\_type = std::uint64\_t;}
\DoxyCodeLine{4550     \textcolor{keyword}{public}:}
\DoxyCodeLine{4551         \textcolor{keyword}{using} result\_type = std::uint32\_t;}
\DoxyCodeLine{4552         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} result\_type (min)() \{}
\DoxyCodeLine{4553             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4554         \}}
\DoxyCodeLine{4555         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} result\_type (max)() \{}
\DoxyCodeLine{4556             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}result\_type\textcolor{keyword}{>}(-\/1);}
\DoxyCodeLine{4557         \}}
\DoxyCodeLine{4558 }
\DoxyCodeLine{4559         \textcolor{comment}{// Provide some default initial state for the default constructor}}
\DoxyCodeLine{4560         \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}}():\mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}}(0xed743cc4U) \{\}}
\DoxyCodeLine{4561 }
\DoxyCodeLine{4562         \textcolor{keyword}{explicit} \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}}(result\_type seed\_);}
\DoxyCodeLine{4563 }
\DoxyCodeLine{4564         \textcolor{keywordtype}{void} seed(result\_type seed\_);}
\DoxyCodeLine{4565         \textcolor{keywordtype}{void} discard(uint64\_t skip);}
\DoxyCodeLine{4566 }
\DoxyCodeLine{4567         result\_type operator()();}
\DoxyCodeLine{4568 }
\DoxyCodeLine{4569     \textcolor{keyword}{private}:}
\DoxyCodeLine{4570         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator==(\mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}} \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}} \textcolor{keyword}{const}\& rhs);}
\DoxyCodeLine{4571         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator!=(\mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}} \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}} \textcolor{keyword}{const}\& rhs);}
\DoxyCodeLine{4572 }
\DoxyCodeLine{4573         \textcolor{comment}{// In theory we also need operator<< and operator>>}}
\DoxyCodeLine{4574         \textcolor{comment}{// In practice we do not use them, so we will skip them for now}}
\DoxyCodeLine{4575 }
\DoxyCodeLine{4576         std::uint64\_t m\_state;}
\DoxyCodeLine{4577         \textcolor{comment}{// This part of the state determines which "{}stream"{} of the numbers}}
\DoxyCodeLine{4578         \textcolor{comment}{// is chosen -\/-\/ we take it as a constant for Catch2, so we only}}
\DoxyCodeLine{4579         \textcolor{comment}{// need to deal with seeding the main state.}}
\DoxyCodeLine{4580         \textcolor{comment}{// Picked by reading 8 bytes from `/dev/random` :-\/)}}
\DoxyCodeLine{4581         \textcolor{keyword}{static} \textcolor{keyword}{const} std::uint64\_t s\_inc = (0x13ed0cc53f939476ULL << 1ULL) | 1ULL;}
\DoxyCodeLine{4582     \};}
\DoxyCodeLine{4583 }
\DoxyCodeLine{4584 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{4585 }
\DoxyCodeLine{4586 \textcolor{comment}{// end catch\_random\_number\_generator.h}}
\DoxyCodeLine{4587 \textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{4588 }
\DoxyCodeLine{4589 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4590 \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{4591 }
\DoxyCodeLine{4592 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float>}
\DoxyCodeLine{4593 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_random_floating_generator}{RandomFloatingGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<Float> \{}
\DoxyCodeLine{4594     \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{Catch::SimplePcg32}}\& m\_rng;}
\DoxyCodeLine{4595     std::uniform\_real\_distribution<Float> m\_dist;}
\DoxyCodeLine{4596     Float m\_current\_number;}
\DoxyCodeLine{4597 \textcolor{keyword}{public}:}
\DoxyCodeLine{4598 }
\DoxyCodeLine{4599     \mbox{\hyperlink{class_catch_1_1_generators_1_1_random_floating_generator}{RandomFloatingGenerator}}(Float a, Float b):}
\DoxyCodeLine{4600         m\_rng(rng()),}
\DoxyCodeLine{4601         m\_dist(a, b) \{}
\DoxyCodeLine{4602         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(next());}
\DoxyCodeLine{4603     \}}
\DoxyCodeLine{4604 }
\DoxyCodeLine{4605     Float \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4606         \textcolor{keywordflow}{return} m\_current\_number;}
\DoxyCodeLine{4607     \}}
\DoxyCodeLine{4608     \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4609         m\_current\_number = m\_dist(m\_rng);}
\DoxyCodeLine{4610         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4611     \}}
\DoxyCodeLine{4612 \};}
\DoxyCodeLine{4613 }
\DoxyCodeLine{4614 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Integer>}
\DoxyCodeLine{4615 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_random_integer_generator}{RandomIntegerGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<Integer> \{}
\DoxyCodeLine{4616     \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{Catch::SimplePcg32}}\& m\_rng;}
\DoxyCodeLine{4617     std::uniform\_int\_distribution<Integer> m\_dist;}
\DoxyCodeLine{4618     Integer m\_current\_number;}
\DoxyCodeLine{4619 \textcolor{keyword}{public}:}
\DoxyCodeLine{4620 }
\DoxyCodeLine{4621     \mbox{\hyperlink{class_catch_1_1_generators_1_1_random_integer_generator}{RandomIntegerGenerator}}(Integer a, Integer b):}
\DoxyCodeLine{4622         m\_rng(rng()),}
\DoxyCodeLine{4623         m\_dist(a, b) \{}
\DoxyCodeLine{4624         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(next());}
\DoxyCodeLine{4625     \}}
\DoxyCodeLine{4626 }
\DoxyCodeLine{4627     Integer \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4628         \textcolor{keywordflow}{return} m\_current\_number;}
\DoxyCodeLine{4629     \}}
\DoxyCodeLine{4630     \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4631         m\_current\_number = m\_dist(m\_rng);}
\DoxyCodeLine{4632         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4633     \}}
\DoxyCodeLine{4634 \};}
\DoxyCodeLine{4635 }
\DoxyCodeLine{4636 \textcolor{comment}{// TODO: Ideally this would be also constrained against the various char types,}}
\DoxyCodeLine{4637 \textcolor{comment}{//       but I don't expect users to run into that in practice.}}
\DoxyCodeLine{4638 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4639 \textcolor{keyword}{typename} std::enable\_if<std::is\_integral<T>::value \&\& !std::is\_same<T, bool>::value,}
\DoxyCodeLine{4640 \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}>::type}
\DoxyCodeLine{4641 random(T a, T b) \{}
\DoxyCodeLine{4642     \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}(}
\DoxyCodeLine{4643         pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_random_integer_generator}{RandomIntegerGenerator<T>}}>(a, b)}
\DoxyCodeLine{4644     );}
\DoxyCodeLine{4645 \}}
\DoxyCodeLine{4646 }
\DoxyCodeLine{4647 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4648 \textcolor{keyword}{typename} std::enable\_if<std::is\_floating\_point<T>::value,}
\DoxyCodeLine{4649 GeneratorWrapper<T>>::type}
\DoxyCodeLine{4650 random(T a, T b) \{}
\DoxyCodeLine{4651     \textcolor{keywordflow}{return} GeneratorWrapper<T>(}
\DoxyCodeLine{4652         pf::make\_unique<RandomFloatingGenerator<T>>(a, b)}
\DoxyCodeLine{4653     );}
\DoxyCodeLine{4654 \}}
\DoxyCodeLine{4655 }
\DoxyCodeLine{4656 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4657 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_range_generator}{RangeGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{4658     T m\_current;}
\DoxyCodeLine{4659     T m\_end;}
\DoxyCodeLine{4660     T m\_step;}
\DoxyCodeLine{4661     \textcolor{keywordtype}{bool} m\_positive;}
\DoxyCodeLine{4662 }
\DoxyCodeLine{4663 \textcolor{keyword}{public}:}
\DoxyCodeLine{4664     \mbox{\hyperlink{class_catch_1_1_generators_1_1_range_generator}{RangeGenerator}}(T \textcolor{keyword}{const}\& start, T \textcolor{keyword}{const}\& end, T \textcolor{keyword}{const}\& step):}
\DoxyCodeLine{4665         m\_current(start),}
\DoxyCodeLine{4666         m\_end(end),}
\DoxyCodeLine{4667         m\_step(step),}
\DoxyCodeLine{4668         m\_positive(m\_step > T(0))}
\DoxyCodeLine{4669     \{}
\DoxyCodeLine{4670         assert(m\_current != m\_end \&\& \textcolor{stringliteral}{"{}Range start and end cannot be equal"{}});}
\DoxyCodeLine{4671         assert(m\_step != T(0) \&\& \textcolor{stringliteral}{"{}Step size cannot be zero"{}});}
\DoxyCodeLine{4672         assert(((m\_positive \&\& m\_current <= m\_end) || (!m\_positive \&\& m\_current >= m\_end)) \&\& \textcolor{stringliteral}{"{}Step moves away from end"{}});}
\DoxyCodeLine{4673     \}}
\DoxyCodeLine{4674 }
\DoxyCodeLine{4675     \mbox{\hyperlink{class_catch_1_1_generators_1_1_range_generator}{RangeGenerator}}(T \textcolor{keyword}{const}\& start, T \textcolor{keyword}{const}\& end):}
\DoxyCodeLine{4676         \mbox{\hyperlink{class_catch_1_1_generators_1_1_range_generator}{RangeGenerator}}(start, end, (start < end) ? T(1) : T(-\/1))}
\DoxyCodeLine{4677     \{\}}
\DoxyCodeLine{4678 }
\DoxyCodeLine{4679     T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4680         \textcolor{keywordflow}{return} m\_current;}
\DoxyCodeLine{4681     \}}
\DoxyCodeLine{4682 }
\DoxyCodeLine{4683     \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4684         m\_current += m\_step;}
\DoxyCodeLine{4685         \textcolor{keywordflow}{return} (m\_positive) ? (m\_current < m\_end) : (m\_current > m\_end);}
\DoxyCodeLine{4686     \}}
\DoxyCodeLine{4687 \};}
\DoxyCodeLine{4688 }
\DoxyCodeLine{4689 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4690 \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} range(T \textcolor{keyword}{const}\& start, T \textcolor{keyword}{const}\& end, T \textcolor{keyword}{const}\& step) \{}
\DoxyCodeLine{4691     \textcolor{keyword}{static\_assert}(std::is\_arithmetic<T>::value \&\& !std::is\_same<T, bool>::value, \textcolor{stringliteral}{"{}Type must be numeric"{}});}
\DoxyCodeLine{4692     \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}(pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_range_generator}{RangeGenerator<T>}}>(start, end, step));}
\DoxyCodeLine{4693 \}}
\DoxyCodeLine{4694 }
\DoxyCodeLine{4695 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4696 GeneratorWrapper<T> range(T \textcolor{keyword}{const}\& start, T \textcolor{keyword}{const}\& end) \{}
\DoxyCodeLine{4697     \textcolor{keyword}{static\_assert}(std::is\_integral<T>::value \&\& !std::is\_same<T, bool>::value, \textcolor{stringliteral}{"{}Type must be an integer"{}});}
\DoxyCodeLine{4698     \textcolor{keywordflow}{return} GeneratorWrapper<T>(pf::make\_unique<RangeGenerator<T>>(start, end));}
\DoxyCodeLine{4699 \}}
\DoxyCodeLine{4700 }
\DoxyCodeLine{4701 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4702 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_iterator_generator}{IteratorGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{4703     \textcolor{keyword}{static\_assert}(!std::is\_same<T, bool>::value,}
\DoxyCodeLine{4704         \textcolor{stringliteral}{"{}IteratorGenerator currently does not support bools"{}}}
\DoxyCodeLine{4705         \textcolor{stringliteral}{"{}because of std::vector<bool> specialization"{}});}
\DoxyCodeLine{4706 }
\DoxyCodeLine{4707     std::vector<T> m\_elems;}
\DoxyCodeLine{4708     \textcolor{keywordtype}{size\_t} m\_current = 0;}
\DoxyCodeLine{4709 \textcolor{keyword}{public}:}
\DoxyCodeLine{4710     \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputIterator, \textcolor{keyword}{typename} InputSentinel>}
\DoxyCodeLine{4711     \mbox{\hyperlink{class_catch_1_1_generators_1_1_iterator_generator}{IteratorGenerator}}(InputIterator first, InputSentinel last):m\_elems(first, last) \{}
\DoxyCodeLine{4712         \textcolor{keywordflow}{if} (m\_elems.empty()) \{}
\DoxyCodeLine{4713             Catch::throw\_exception(\mbox{\hyperlink{class_catch_1_1_generator_exception}{GeneratorException}}(\textcolor{stringliteral}{"{}IteratorGenerator received no valid values"{}}));}
\DoxyCodeLine{4714         \}}
\DoxyCodeLine{4715     \}}
\DoxyCodeLine{4716 }
\DoxyCodeLine{4717     T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4718         \textcolor{keywordflow}{return} m\_elems[m\_current];}
\DoxyCodeLine{4719     \}}
\DoxyCodeLine{4720 }
\DoxyCodeLine{4721     \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4722         ++m\_current;}
\DoxyCodeLine{4723         \textcolor{keywordflow}{return} m\_current != m\_elems.size();}
\DoxyCodeLine{4724     \}}
\DoxyCodeLine{4725 \};}
\DoxyCodeLine{4726 }
\DoxyCodeLine{4727 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputIterator,}
\DoxyCodeLine{4728           \textcolor{keyword}{typename} InputSentinel,}
\DoxyCodeLine{4729           \textcolor{keyword}{typename} ResultType = \textcolor{keyword}{typename} std::iterator\_traits<InputIterator>::value\_type>}
\DoxyCodeLine{4730 \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<ResultType>}} from\_range(InputIterator from, InputSentinel to) \{}
\DoxyCodeLine{4731     \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<ResultType>}}(pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_iterator_generator}{IteratorGenerator<ResultType>}}>(from, to));}
\DoxyCodeLine{4732 \}}
\DoxyCodeLine{4733 }
\DoxyCodeLine{4734 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container,}
\DoxyCodeLine{4735           \textcolor{keyword}{typename} ResultType = \textcolor{keyword}{typename} Container::value\_type>}
\DoxyCodeLine{4736 GeneratorWrapper<ResultType> from\_range(Container \textcolor{keyword}{const}\& cnt) \{}
\DoxyCodeLine{4737     \textcolor{keywordflow}{return} GeneratorWrapper<ResultType>(pf::make\_unique<IteratorGenerator<ResultType>>(cnt.begin(), cnt.end()));}
\DoxyCodeLine{4738 \}}
\DoxyCodeLine{4739 }
\DoxyCodeLine{4740 \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{4741 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{4742 }
\DoxyCodeLine{4743 \textcolor{comment}{// end catch\_generators\_specific.hpp}}
\DoxyCodeLine{4744 }
\DoxyCodeLine{4745 \textcolor{comment}{// These files are included here so the single\_include script doesn't put them}}
\DoxyCodeLine{4746 \textcolor{comment}{// in the conditionally compiled sections}}
\DoxyCodeLine{4747 \textcolor{comment}{// start catch\_test\_case\_info.h}}
\DoxyCodeLine{4748 }
\DoxyCodeLine{4749 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{4750 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{4751 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{4752 }
\DoxyCodeLine{4753 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{4754 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{4755 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{4756 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4757 }
\DoxyCodeLine{4758 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4759 }
\DoxyCodeLine{4760     \textcolor{keyword}{struct }ITestInvoker;}
\DoxyCodeLine{4761 }
\DoxyCodeLine{4762     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_test_case_info}{TestCaseInfo}} \{}
\DoxyCodeLine{4763         \textcolor{keyword}{enum} SpecialProperties\{}
\DoxyCodeLine{4764             None = 0,}
\DoxyCodeLine{4765             IsHidden = 1 << 1,}
\DoxyCodeLine{4766             ShouldFail = 1 << 2,}
\DoxyCodeLine{4767             MayFail = 1 << 3,}
\DoxyCodeLine{4768             Throws = 1 << 4,}
\DoxyCodeLine{4769             NonPortable = 1 << 5,}
\DoxyCodeLine{4770             Benchmark = 1 << 6}
\DoxyCodeLine{4771         \};}
\DoxyCodeLine{4772 }
\DoxyCodeLine{4773         \mbox{\hyperlink{struct_catch_1_1_test_case_info}{TestCaseInfo}}(   std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{4774                         std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{4775                         std::string \textcolor{keyword}{const}\& \_description,}
\DoxyCodeLine{4776                         std::vector<std::string> \textcolor{keyword}{const}\& \_tags,}
\DoxyCodeLine{4777                         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo );}
\DoxyCodeLine{4778 }
\DoxyCodeLine{4779         \textcolor{keyword}{friend} \textcolor{keywordtype}{void} setTags( \mbox{\hyperlink{struct_catch_1_1_test_case_info}{TestCaseInfo}}\& testCaseInfo, std::vector<std::string> tags );}
\DoxyCodeLine{4780 }
\DoxyCodeLine{4781         \textcolor{keywordtype}{bool} isHidden() \textcolor{keyword}{const};}
\DoxyCodeLine{4782         \textcolor{keywordtype}{bool} \textcolor{keywordflow}{throws}() \textcolor{keyword}{const};}
\DoxyCodeLine{4783         \textcolor{keywordtype}{bool} okToFail() \textcolor{keyword}{const};}
\DoxyCodeLine{4784         \textcolor{keywordtype}{bool} expectedToFail() \textcolor{keyword}{const};}
\DoxyCodeLine{4785 }
\DoxyCodeLine{4786         std::string tagsAsString() \textcolor{keyword}{const};}
\DoxyCodeLine{4787 }
\DoxyCodeLine{4788         std::string name;}
\DoxyCodeLine{4789         std::string className;}
\DoxyCodeLine{4790         std::string description;}
\DoxyCodeLine{4791         std::vector<std::string> tags;}
\DoxyCodeLine{4792         std::vector<std::string> lcaseTags;}
\DoxyCodeLine{4793         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{4794         SpecialProperties properties;}
\DoxyCodeLine{4795     \};}
\DoxyCodeLine{4796 }
\DoxyCodeLine{4797     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_test_case_info}{TestCaseInfo}} \{}
\DoxyCodeLine{4798     \textcolor{keyword}{public}:}
\DoxyCodeLine{4799 }
\DoxyCodeLine{4800         \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}}( \mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{ITestInvoker}}* testCase, \mbox{\hyperlink{struct_catch_1_1_test_case_info}{TestCaseInfo}}\&\& info );}
\DoxyCodeLine{4801 }
\DoxyCodeLine{4802         \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} withName( std::string \textcolor{keyword}{const}\& \_newName ) \textcolor{keyword}{const};}
\DoxyCodeLine{4803 }
\DoxyCodeLine{4804         \textcolor{keywordtype}{void} invoke() \textcolor{keyword}{const};}
\DoxyCodeLine{4805 }
\DoxyCodeLine{4806         \mbox{\hyperlink{struct_catch_1_1_test_case_info}{TestCaseInfo}} \textcolor{keyword}{const}\& getTestCaseInfo() \textcolor{keyword}{const};}
\DoxyCodeLine{4807 }
\DoxyCodeLine{4808         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{4809         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{4810 }
\DoxyCodeLine{4811     \textcolor{keyword}{private}:}
\DoxyCodeLine{4812         std::shared\_ptr<ITestInvoker> test;}
\DoxyCodeLine{4813     \};}
\DoxyCodeLine{4814 }
\DoxyCodeLine{4815     \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} makeTestCase(  \mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{ITestInvoker}}* testCase,}
\DoxyCodeLine{4816                             std::string \textcolor{keyword}{const}\& className,}
\DoxyCodeLine{4817                             \mbox{\hyperlink{struct_catch_1_1_name_and_tags}{NameAndTags}} \textcolor{keyword}{const}\& nameAndTags,}
\DoxyCodeLine{4818                             \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{4819 \}}
\DoxyCodeLine{4820 }
\DoxyCodeLine{4821 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{4822 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{4823 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4824 }
\DoxyCodeLine{4825 \textcolor{comment}{// end catch\_test\_case\_info.h}}
\DoxyCodeLine{4826 \textcolor{comment}{// start catch\_interfaces\_runner.h}}
\DoxyCodeLine{4827 }
\DoxyCodeLine{4828 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4829 }
\DoxyCodeLine{4830     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_runner}{IRunner}} \{}
\DoxyCodeLine{4831         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_runner}{\string~IRunner}}();}
\DoxyCodeLine{4832         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} aborting() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4833     \};}
\DoxyCodeLine{4834 \}}
\DoxyCodeLine{4835 }
\DoxyCodeLine{4836 \textcolor{comment}{// end catch\_interfaces\_runner.h}}
\DoxyCodeLine{4837 }
\DoxyCodeLine{4838 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{4839 \textcolor{comment}{// start catch\_objc.hpp}}
\DoxyCodeLine{4840 }
\DoxyCodeLine{4841 \textcolor{preprocessor}{\#import <objc/runtime.h>}}
\DoxyCodeLine{4842 }
\DoxyCodeLine{4843 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{4844 }
\DoxyCodeLine{4845 \textcolor{comment}{// NB. Any general catch headers included here must be included}}
\DoxyCodeLine{4846 \textcolor{comment}{// in catch.hpp first to make sure they are included by the single}}
\DoxyCodeLine{4847 \textcolor{comment}{// header for non obj-\/usage}}
\DoxyCodeLine{4848 }
\DoxyCodeLine{4850 \textcolor{comment}{// This protocol is really only here for (self) documenting purposes, since}}
\DoxyCodeLine{4851 \textcolor{comment}{// all its methods are optional.}}
\DoxyCodeLine{4852 \textcolor{keyword}{@protocol }OcFixture}
\DoxyCodeLine{4853 }
\DoxyCodeLine{4854 \textcolor{keyword}{@optional}}
\DoxyCodeLine{4855 }
\DoxyCodeLine{4856 -\/(void) setUp;}
\DoxyCodeLine{4857 -\/(void) tearDown;}
\DoxyCodeLine{4858 }
\DoxyCodeLine{4859 \textcolor{keyword}{@end}}
\DoxyCodeLine{4860 }
\DoxyCodeLine{4861 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4862 }
\DoxyCodeLine{4863     \textcolor{keyword}{class }OcMethod : \textcolor{keyword}{public} ITestInvoker \{}
\DoxyCodeLine{4864 }
\DoxyCodeLine{4865     \textcolor{keyword}{public}:}
\DoxyCodeLine{4866         OcMethod( Class cls, \textcolor{keywordtype}{SEL} sel ) : m\_cls( cls ), m\_sel( sel ) \{\}}
\DoxyCodeLine{4867 }
\DoxyCodeLine{4868         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4869             \textcolor{keywordtype}{id} obj = [[m\_cls alloc] init];}
\DoxyCodeLine{4870 }
\DoxyCodeLine{4871             performOptionalSelector( obj, \textcolor{keyword}{@selector}(setUp)  );}
\DoxyCodeLine{4872             performOptionalSelector( obj, m\_sel );}
\DoxyCodeLine{4873             performOptionalSelector( obj, \textcolor{keyword}{@selector}(tearDown)  );}
\DoxyCodeLine{4874 }
\DoxyCodeLine{4875             arcSafeRelease( obj );}
\DoxyCodeLine{4876         \}}
\DoxyCodeLine{4877     \textcolor{keyword}{private}:}
\DoxyCodeLine{4878         \textcolor{keyword}{virtual} \string~OcMethod() \{\}}
\DoxyCodeLine{4879 }
\DoxyCodeLine{4880         Class m\_cls;}
\DoxyCodeLine{4881         \textcolor{keywordtype}{SEL} m\_sel;}
\DoxyCodeLine{4882     \};}
\DoxyCodeLine{4883 }
\DoxyCodeLine{4884     \textcolor{keyword}{namespace }Detail\{}
\DoxyCodeLine{4885 }
\DoxyCodeLine{4886         \textcolor{keyword}{inline} std::string getAnnotation(   Class cls,}
\DoxyCodeLine{4887                                             std::string \textcolor{keyword}{const}\& annotationName,}
\DoxyCodeLine{4888                                             std::string \textcolor{keyword}{const}\& testCaseName ) \{}
\DoxyCodeLine{4889             NSString* selStr = [[NSString alloc] initWithFormat:@"{}Catch\_\%s\_\%s"{}, annotationName.c\_str(), testCaseName.c\_str()];}
\DoxyCodeLine{4890             \textcolor{keywordtype}{SEL} sel = NSSelectorFromString( selStr );}
\DoxyCodeLine{4891             arcSafeRelease( selStr );}
\DoxyCodeLine{4892             \textcolor{keywordtype}{id} value = performOptionalSelector( cls, sel );}
\DoxyCodeLine{4893             \textcolor{keywordflow}{if}( value )}
\DoxyCodeLine{4894                 \textcolor{keywordflow}{return} [(NSString*)value UTF8String];}
\DoxyCodeLine{4895             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{4896         \}}
\DoxyCodeLine{4897     \}}
\DoxyCodeLine{4898 }
\DoxyCodeLine{4899     \textcolor{keyword}{inline} std::size\_t registerTestMethods() \{}
\DoxyCodeLine{4900         std::size\_t noTestMethods = 0;}
\DoxyCodeLine{4901         \textcolor{keywordtype}{int} noClasses = objc\_getClassList( \textcolor{keyword}{nullptr}, 0 );}
\DoxyCodeLine{4902 }
\DoxyCodeLine{4903         Class* classes = (CATCH\_UNSAFE\_UNRETAINED Class *)malloc( \textcolor{keyword}{sizeof}(Class) * noClasses);}
\DoxyCodeLine{4904         objc\_getClassList( classes, noClasses );}
\DoxyCodeLine{4905 }
\DoxyCodeLine{4906         \textcolor{keywordflow}{for}( \textcolor{keywordtype}{int} c = 0; c < noClasses; c++ ) \{}
\DoxyCodeLine{4907             Class cls = classes[c];}
\DoxyCodeLine{4908             \{}
\DoxyCodeLine{4909                 u\_int count;}
\DoxyCodeLine{4910                 Method* methods = class\_copyMethodList( cls, \&count );}
\DoxyCodeLine{4911                 \textcolor{keywordflow}{for}( u\_int m = 0; m < count ; m++ ) \{}
\DoxyCodeLine{4912                     \textcolor{keywordtype}{SEL} selector = method\_getName(methods[m]);}
\DoxyCodeLine{4913                     std::string methodName = sel\_getName(selector);}
\DoxyCodeLine{4914                     \textcolor{keywordflow}{if}( startsWith( methodName, \textcolor{stringliteral}{"{}Catch\_TestCase\_"{}} ) ) \{}
\DoxyCodeLine{4915                         std::string testCaseName = methodName.substr( 15 );}
\DoxyCodeLine{4916                         std::string name = Detail::getAnnotation( cls, \textcolor{stringliteral}{"{}Name"{}}, testCaseName );}
\DoxyCodeLine{4917                         std::string desc = Detail::getAnnotation( cls, \textcolor{stringliteral}{"{}Description"{}}, testCaseName );}
\DoxyCodeLine{4918                         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* className = class\_getName( cls );}
\DoxyCodeLine{4919 }
\DoxyCodeLine{4920                         getMutableRegistryHub().registerTest( makeTestCase( \textcolor{keyword}{new} OcMethod( cls, selector ), className, NameAndTags( name.c\_str(), desc.c\_str() ), SourceLineInfo(\textcolor{stringliteral}{"{}"{}},0) ) );}
\DoxyCodeLine{4921                         noTestMethods++;}
\DoxyCodeLine{4922                     \}}
\DoxyCodeLine{4923                 \}}
\DoxyCodeLine{4924                 free(methods);}
\DoxyCodeLine{4925             \}}
\DoxyCodeLine{4926         \}}
\DoxyCodeLine{4927         \textcolor{keywordflow}{return} noTestMethods;}
\DoxyCodeLine{4928     \}}
\DoxyCodeLine{4929 }
\DoxyCodeLine{4930 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{4931 }
\DoxyCodeLine{4932     \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{4933         \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{4934         \textcolor{keyword}{namespace }NSStringMatchers \{}
\DoxyCodeLine{4935 }
\DoxyCodeLine{4936             \textcolor{keyword}{struct }StringHolder : MatcherBase<NSString*>\{}
\DoxyCodeLine{4937                 StringHolder( NSString* substr ) : m\_substr( [substr \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{copy}}] )\{\}}
\DoxyCodeLine{4938                 StringHolder( StringHolder \textcolor{keyword}{const}\& other ) : m\_substr( [other.m\_substr \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{copy}}] )\{\}}
\DoxyCodeLine{4939                 StringHolder() \{}
\DoxyCodeLine{4940                     arcSafeRelease( m\_substr );}
\DoxyCodeLine{4941                 \}}
\DoxyCodeLine{4942 }
\DoxyCodeLine{4943                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4944                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4945                 \}}
\DoxyCodeLine{4946 }
\DoxyCodeLine{4947                 NSString* CATCH\_ARC\_STRONG m\_substr;}
\DoxyCodeLine{4948             \};}
\DoxyCodeLine{4949 }
\DoxyCodeLine{4950             \textcolor{keyword}{struct }Equals : StringHolder \{}
\DoxyCodeLine{4951                 Equals( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{4952 }
\DoxyCodeLine{4953                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4954                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{4955                             [str isEqualToString:m\_substr];}
\DoxyCodeLine{4956                 \}}
\DoxyCodeLine{4957 }
\DoxyCodeLine{4958                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4959                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}equals string: "{}} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{4960                 \}}
\DoxyCodeLine{4961             \};}
\DoxyCodeLine{4962 }
\DoxyCodeLine{4963             \textcolor{keyword}{struct }Contains : StringHolder \{}
\DoxyCodeLine{4964                 Contains( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{4965 }
\DoxyCodeLine{4966                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4967                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{4968                             [str rangeOfString:m\_substr].location != NSNotFound;}
\DoxyCodeLine{4969                 \}}
\DoxyCodeLine{4970 }
\DoxyCodeLine{4971                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4972                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}contains string: "{}} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{4973                 \}}
\DoxyCodeLine{4974             \};}
\DoxyCodeLine{4975 }
\DoxyCodeLine{4976             \textcolor{keyword}{struct }StartsWith : StringHolder \{}
\DoxyCodeLine{4977                 StartsWith( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{4978 }
\DoxyCodeLine{4979                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4980                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{4981                             [str rangeOfString:m\_substr].location == 0;}
\DoxyCodeLine{4982                 \}}
\DoxyCodeLine{4983 }
\DoxyCodeLine{4984                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4985                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}starts with: "{}} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{4986                 \}}
\DoxyCodeLine{4987             \};}
\DoxyCodeLine{4988             \textcolor{keyword}{struct }EndsWith : StringHolder \{}
\DoxyCodeLine{4989                 EndsWith( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{4990 }
\DoxyCodeLine{4991                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4992                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{4993                             [str rangeOfString:m\_substr].location == [str length] -\/ [m\_substr length];}
\DoxyCodeLine{4994                 \}}
\DoxyCodeLine{4995 }
\DoxyCodeLine{4996                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4997                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ends with: "{}} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{4998                 \}}
\DoxyCodeLine{4999             \};}
\DoxyCodeLine{5000 }
\DoxyCodeLine{5001         \} \textcolor{comment}{// namespace NSStringMatchers}}
\DoxyCodeLine{5002         \} \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{5003 }
\DoxyCodeLine{5004         \textcolor{keyword}{inline} Impl::NSStringMatchers::Equals}
\DoxyCodeLine{5005             Equals( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::Equals( substr ); \}}
\DoxyCodeLine{5006 }
\DoxyCodeLine{5007         \textcolor{keyword}{inline} Impl::NSStringMatchers::Contains}
\DoxyCodeLine{5008             Contains( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::Contains( substr ); \}}
\DoxyCodeLine{5009 }
\DoxyCodeLine{5010         \textcolor{keyword}{inline} Impl::NSStringMatchers::StartsWith}
\DoxyCodeLine{5011             StartsWith( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::StartsWith( substr ); \}}
\DoxyCodeLine{5012 }
\DoxyCodeLine{5013         \textcolor{keyword}{inline} Impl::NSStringMatchers::EndsWith}
\DoxyCodeLine{5014             EndsWith( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::EndsWith( substr ); \}}
\DoxyCodeLine{5015 }
\DoxyCodeLine{5016     \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{5017 }
\DoxyCodeLine{5018     \textcolor{keyword}{using namespace }Matchers;}
\DoxyCodeLine{5019 }
\DoxyCodeLine{5020 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{5021 }
\DoxyCodeLine{5022 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{5023 }
\DoxyCodeLine{5025 \textcolor{preprocessor}{\#define OC\_MAKE\_UNIQUE\_NAME( root, uniqueSuffix ) root\#\#uniqueSuffix}}
\DoxyCodeLine{5026 \textcolor{preprocessor}{\#define OC\_TEST\_CASE2( name, desc, uniqueSuffix ) \(\backslash\)}}
\DoxyCodeLine{5027 \textcolor{preprocessor}{+(NSString*) OC\_MAKE\_UNIQUE\_NAME( Catch\_Name\_test\_, uniqueSuffix ) \(\backslash\)}}
\DoxyCodeLine{5028 \textcolor{preprocessor}{\{ \(\backslash\)}}
\DoxyCodeLine{5029 \textcolor{preprocessor}{return @ name; \(\backslash\)}}
\DoxyCodeLine{5030 \textcolor{preprocessor}{\} \(\backslash\)}}
\DoxyCodeLine{5031 \textcolor{preprocessor}{+(NSString*) OC\_MAKE\_UNIQUE\_NAME( Catch\_Description\_test\_, uniqueSuffix ) \(\backslash\)}}
\DoxyCodeLine{5032 \textcolor{preprocessor}{\{ \(\backslash\)}}
\DoxyCodeLine{5033 \textcolor{preprocessor}{return @ desc; \(\backslash\)}}
\DoxyCodeLine{5034 \textcolor{preprocessor}{\} \(\backslash\)}}
\DoxyCodeLine{5035 \textcolor{preprocessor}{-\/(void) OC\_MAKE\_UNIQUE\_NAME( Catch\_TestCase\_test\_, uniqueSuffix )}}
\DoxyCodeLine{5036 }
\DoxyCodeLine{5037 \textcolor{preprocessor}{\#define OC\_TEST\_CASE( name, desc ) OC\_TEST\_CASE2( name, desc, \_\_LINE\_\_ )}}
\DoxyCodeLine{5038 }
\DoxyCodeLine{5039 \textcolor{comment}{// end catch\_objc.hpp}}
\DoxyCodeLine{5040 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5041 }
\DoxyCodeLine{5042 \textcolor{comment}{// Benchmarking needs the externally-\/facing parts of reporters to work}}
\DoxyCodeLine{5043 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_EXTERNAL\_INTERFACES) || defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{5044 \textcolor{comment}{// start catch\_external\_interfaces.h}}
\DoxyCodeLine{5045 }
\DoxyCodeLine{5046 \textcolor{comment}{// start catch\_reporter\_bases.hpp}}
\DoxyCodeLine{5047 }
\DoxyCodeLine{5048 \textcolor{comment}{// start catch\_interfaces\_reporter.h}}
\DoxyCodeLine{5049 }
\DoxyCodeLine{5050 \textcolor{comment}{// start catch\_config.hpp}}
\DoxyCodeLine{5051 }
\DoxyCodeLine{5052 \textcolor{comment}{// start catch\_test\_spec\_parser.h}}
\DoxyCodeLine{5053 }
\DoxyCodeLine{5054 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{5055 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{5056 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{5057 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5058 }
\DoxyCodeLine{5059 \textcolor{comment}{// start catch\_test\_spec.h}}
\DoxyCodeLine{5060 }
\DoxyCodeLine{5061 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{5062 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{5063 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{5064 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5065 }
\DoxyCodeLine{5066 \textcolor{comment}{// start catch\_wildcard\_pattern.h}}
\DoxyCodeLine{5067 }
\DoxyCodeLine{5068 \textcolor{keyword}{namespace }Catch}
\DoxyCodeLine{5069 \{}
\DoxyCodeLine{5070     \textcolor{keyword}{class }WildcardPattern \{}
\DoxyCodeLine{5071         \textcolor{keyword}{enum} WildcardPosition \{}
\DoxyCodeLine{5072             NoWildcard = 0,}
\DoxyCodeLine{5073             WildcardAtStart = 1,}
\DoxyCodeLine{5074             WildcardAtEnd = 2,}
\DoxyCodeLine{5075             WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd}
\DoxyCodeLine{5076         \};}
\DoxyCodeLine{5077 }
\DoxyCodeLine{5078     \textcolor{keyword}{public}:}
\DoxyCodeLine{5079 }
\DoxyCodeLine{5080         WildcardPattern( std::string \textcolor{keyword}{const}\& pattern, CaseSensitive::Choice caseSensitivity );}
\DoxyCodeLine{5081         \textcolor{keyword}{virtual} \string~WildcardPattern() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5082         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( std::string \textcolor{keyword}{const}\& str ) \textcolor{keyword}{const};}
\DoxyCodeLine{5083 }
\DoxyCodeLine{5084     \textcolor{keyword}{private}:}
\DoxyCodeLine{5085         std::string normaliseString( std::string \textcolor{keyword}{const}\& str ) \textcolor{keyword}{const};}
\DoxyCodeLine{5086         CaseSensitive::Choice m\_caseSensitivity;}
\DoxyCodeLine{5087         WildcardPosition m\_wildcard = NoWildcard;}
\DoxyCodeLine{5088         std::string m\_pattern;}
\DoxyCodeLine{5089     \};}
\DoxyCodeLine{5090 \}}
\DoxyCodeLine{5091 }
\DoxyCodeLine{5092 \textcolor{comment}{// end catch\_wildcard\_pattern.h}}
\DoxyCodeLine{5093 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5094 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{5095 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{5096 }
\DoxyCodeLine{5097 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5098 }
\DoxyCodeLine{5099     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{5100 }
\DoxyCodeLine{5101     \textcolor{keyword}{class }TestSpec \{}
\DoxyCodeLine{5102         \textcolor{keyword}{class }Pattern \{}
\DoxyCodeLine{5103         \textcolor{keyword}{public}:}
\DoxyCodeLine{5104             \textcolor{keyword}{explicit} Pattern( std::string \textcolor{keyword}{const}\& name );}
\DoxyCodeLine{5105             \textcolor{keyword}{virtual} \string~Pattern();}
\DoxyCodeLine{5106             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5107             std::string \textcolor{keyword}{const}\& name() \textcolor{keyword}{const};}
\DoxyCodeLine{5108         \textcolor{keyword}{private}:}
\DoxyCodeLine{5109             std::string \textcolor{keyword}{const} m\_name;}
\DoxyCodeLine{5110         \};}
\DoxyCodeLine{5111         \textcolor{keyword}{using} PatternPtr = std::shared\_ptr<Pattern>;}
\DoxyCodeLine{5112 }
\DoxyCodeLine{5113         \textcolor{keyword}{class }NamePattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{5114         \textcolor{keyword}{public}:}
\DoxyCodeLine{5115             \textcolor{keyword}{explicit} NamePattern( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& filterString );}
\DoxyCodeLine{5116             \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const override};}
\DoxyCodeLine{5117         \textcolor{keyword}{private}:}
\DoxyCodeLine{5118             WildcardPattern m\_wildcardPattern;}
\DoxyCodeLine{5119         \};}
\DoxyCodeLine{5120 }
\DoxyCodeLine{5121         \textcolor{keyword}{class }TagPattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{5122         \textcolor{keyword}{public}:}
\DoxyCodeLine{5123             \textcolor{keyword}{explicit} TagPattern( std::string \textcolor{keyword}{const}\& tag, std::string \textcolor{keyword}{const}\& filterString );}
\DoxyCodeLine{5124             \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const override};}
\DoxyCodeLine{5125         \textcolor{keyword}{private}:}
\DoxyCodeLine{5126             std::string m\_tag;}
\DoxyCodeLine{5127         \};}
\DoxyCodeLine{5128 }
\DoxyCodeLine{5129         \textcolor{keyword}{class }ExcludedPattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{5130         \textcolor{keyword}{public}:}
\DoxyCodeLine{5131             \textcolor{keyword}{explicit} ExcludedPattern( PatternPtr \textcolor{keyword}{const}\& underlyingPattern );}
\DoxyCodeLine{5132             \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const override};}
\DoxyCodeLine{5133         \textcolor{keyword}{private}:}
\DoxyCodeLine{5134             PatternPtr m\_underlyingPattern;}
\DoxyCodeLine{5135         \};}
\DoxyCodeLine{5136 }
\DoxyCodeLine{5137         \textcolor{keyword}{struct }Filter \{}
\DoxyCodeLine{5138             std::vector<PatternPtr> m\_patterns;}
\DoxyCodeLine{5139 }
\DoxyCodeLine{5140             \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const};}
\DoxyCodeLine{5141             std::string name() \textcolor{keyword}{const};}
\DoxyCodeLine{5142         \};}
\DoxyCodeLine{5143 }
\DoxyCodeLine{5144     \textcolor{keyword}{public}:}
\DoxyCodeLine{5145         \textcolor{keyword}{struct }FilterMatch \{}
\DoxyCodeLine{5146             std::string name;}
\DoxyCodeLine{5147             std::vector<TestCase const*> tests;}
\DoxyCodeLine{5148         \};}
\DoxyCodeLine{5149         \textcolor{keyword}{using} Matches = std::vector<FilterMatch>;}
\DoxyCodeLine{5150         \textcolor{keyword}{using} vectorStrings = std::vector<std::string>;}
\DoxyCodeLine{5151 }
\DoxyCodeLine{5152         \textcolor{keywordtype}{bool} hasFilters() \textcolor{keyword}{const};}
\DoxyCodeLine{5153         \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const};}
\DoxyCodeLine{5154         Matches matchesByFilter( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, IConfig \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const};}
\DoxyCodeLine{5155         \textcolor{keyword}{const} vectorStrings \& getInvalidArgs() \textcolor{keyword}{const};}
\DoxyCodeLine{5156 }
\DoxyCodeLine{5157     \textcolor{keyword}{private}:}
\DoxyCodeLine{5158         std::vector<Filter> m\_filters;}
\DoxyCodeLine{5159         std::vector<std::string> m\_invalidArgs;}
\DoxyCodeLine{5160         \textcolor{keyword}{friend} \textcolor{keyword}{class }TestSpecParser;}
\DoxyCodeLine{5161     \};}
\DoxyCodeLine{5162 \}}
\DoxyCodeLine{5163 }
\DoxyCodeLine{5164 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{5165 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{5166 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5167 }
\DoxyCodeLine{5168 \textcolor{comment}{// end catch\_test\_spec.h}}
\DoxyCodeLine{5169 \textcolor{comment}{// start catch\_interfaces\_tag\_alias\_registry.h}}
\DoxyCodeLine{5170 }
\DoxyCodeLine{5171 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5172 }
\DoxyCodeLine{5173 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5174 }
\DoxyCodeLine{5175     \textcolor{keyword}{struct }TagAlias;}
\DoxyCodeLine{5176 }
\DoxyCodeLine{5177     \textcolor{keyword}{struct }ITagAliasRegistry \{}
\DoxyCodeLine{5178         \textcolor{keyword}{virtual} \string~ITagAliasRegistry();}
\DoxyCodeLine{5179         \textcolor{comment}{// Nullptr if not present}}
\DoxyCodeLine{5180         \textcolor{keyword}{virtual} TagAlias \textcolor{keyword}{const}* find( std::string \textcolor{keyword}{const}\& alias ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5181         \textcolor{keyword}{virtual} std::string expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5182 }
\DoxyCodeLine{5183         \textcolor{keyword}{static} ITagAliasRegistry \textcolor{keyword}{const}\& get();}
\DoxyCodeLine{5184     \};}
\DoxyCodeLine{5185 }
\DoxyCodeLine{5186 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5187 }
\DoxyCodeLine{5188 \textcolor{comment}{// end catch\_interfaces\_tag\_alias\_registry.h}}
\DoxyCodeLine{5189 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5190 }
\DoxyCodeLine{5191     \textcolor{keyword}{class }TestSpecParser \{}
\DoxyCodeLine{5192         \textcolor{keyword}{enum} Mode\{ None, Name, QuotedName, Tag, EscapedName \};}
\DoxyCodeLine{5193         Mode m\_mode = None;}
\DoxyCodeLine{5194         Mode lastMode = None;}
\DoxyCodeLine{5195         \textcolor{keywordtype}{bool} m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{5196         std::size\_t m\_pos = 0;}
\DoxyCodeLine{5197         std::size\_t m\_realPatternPos = 0;}
\DoxyCodeLine{5198         std::string m\_arg;}
\DoxyCodeLine{5199         std::string m\_substring;}
\DoxyCodeLine{5200         std::string m\_patternName;}
\DoxyCodeLine{5201         std::vector<std::size\_t> m\_escapeChars;}
\DoxyCodeLine{5202         TestSpec::Filter m\_currentFilter;}
\DoxyCodeLine{5203         TestSpec m\_testSpec;}
\DoxyCodeLine{5204         ITagAliasRegistry \textcolor{keyword}{const}* m\_tagAliases = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{5205 }
\DoxyCodeLine{5206     \textcolor{keyword}{public}:}
\DoxyCodeLine{5207         TestSpecParser( ITagAliasRegistry \textcolor{keyword}{const}\& tagAliases );}
\DoxyCodeLine{5208 }
\DoxyCodeLine{5209         TestSpecParser\& parse( std::string \textcolor{keyword}{const}\& arg );}
\DoxyCodeLine{5210         TestSpec testSpec();}
\DoxyCodeLine{5211 }
\DoxyCodeLine{5212     \textcolor{keyword}{private}:}
\DoxyCodeLine{5213         \textcolor{keywordtype}{bool} visitChar( \textcolor{keywordtype}{char} c );}
\DoxyCodeLine{5214         \textcolor{keywordtype}{void} startNewMode( Mode mode );}
\DoxyCodeLine{5215         \textcolor{keywordtype}{bool} processNoneChar( \textcolor{keywordtype}{char} c );}
\DoxyCodeLine{5216         \textcolor{keywordtype}{void} processNameChar( \textcolor{keywordtype}{char} c );}
\DoxyCodeLine{5217         \textcolor{keywordtype}{bool} processOtherChar( \textcolor{keywordtype}{char} c );}
\DoxyCodeLine{5218         \textcolor{keywordtype}{void} endMode();}
\DoxyCodeLine{5219         \textcolor{keywordtype}{void} escape();}
\DoxyCodeLine{5220         \textcolor{keywordtype}{bool} isControlChar( \textcolor{keywordtype}{char} c ) \textcolor{keyword}{const};}
\DoxyCodeLine{5221         \textcolor{keywordtype}{void} saveLastMode();}
\DoxyCodeLine{5222         \textcolor{keywordtype}{void} revertBackToLastMode();}
\DoxyCodeLine{5223         \textcolor{keywordtype}{void} addFilter();}
\DoxyCodeLine{5224         \textcolor{keywordtype}{bool} separate();}
\DoxyCodeLine{5225 }
\DoxyCodeLine{5226         \textcolor{comment}{// Handles common preprocessing of the pattern for name/tag patterns}}
\DoxyCodeLine{5227         std::string preprocessPattern();}
\DoxyCodeLine{5228         \textcolor{comment}{// Adds the current pattern as a test name}}
\DoxyCodeLine{5229         \textcolor{keywordtype}{void} addNamePattern();}
\DoxyCodeLine{5230         \textcolor{comment}{// Adds the current pattern as a tag}}
\DoxyCodeLine{5231         \textcolor{keywordtype}{void} addTagPattern();}
\DoxyCodeLine{5232 }
\DoxyCodeLine{5233         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} addCharToPattern(\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{5234             m\_substring += c;}
\DoxyCodeLine{5235             m\_patternName += c;}
\DoxyCodeLine{5236             m\_realPatternPos++;}
\DoxyCodeLine{5237         \}}
\DoxyCodeLine{5238 }
\DoxyCodeLine{5239     \};}
\DoxyCodeLine{5240     TestSpec parseTestSpec( std::string \textcolor{keyword}{const}\& arg );}
\DoxyCodeLine{5241 }
\DoxyCodeLine{5242 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{5243 }
\DoxyCodeLine{5244 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{5245 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{5246 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5247 }
\DoxyCodeLine{5248 \textcolor{comment}{// end catch\_test\_spec\_parser.h}}
\DoxyCodeLine{5249 \textcolor{comment}{// Libstdc++ doesn't like incomplete classes for unique\_ptr}}
\DoxyCodeLine{5250 }
\DoxyCodeLine{5251 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{5252 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{5253 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5254 }
\DoxyCodeLine{5255 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{5256 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_CONSOLE\_WIDTH 80}}
\DoxyCodeLine{5257 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5258 }
\DoxyCodeLine{5259 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5260 }
\DoxyCodeLine{5261     \textcolor{keyword}{struct }IStream;}
\DoxyCodeLine{5262 }
\DoxyCodeLine{5263     \textcolor{keyword}{struct }ConfigData \{}
\DoxyCodeLine{5264         \textcolor{keywordtype}{bool} listTests = \textcolor{keyword}{false};}
\DoxyCodeLine{5265         \textcolor{keywordtype}{bool} listTags = \textcolor{keyword}{false};}
\DoxyCodeLine{5266         \textcolor{keywordtype}{bool} listReporters = \textcolor{keyword}{false};}
\DoxyCodeLine{5267         \textcolor{keywordtype}{bool} listTestNamesOnly = \textcolor{keyword}{false};}
\DoxyCodeLine{5268 }
\DoxyCodeLine{5269         \textcolor{keywordtype}{bool} showSuccessfulTests = \textcolor{keyword}{false};}
\DoxyCodeLine{5270         \textcolor{keywordtype}{bool} shouldDebugBreak = \textcolor{keyword}{false};}
\DoxyCodeLine{5271         \textcolor{keywordtype}{bool} noThrow = \textcolor{keyword}{false};}
\DoxyCodeLine{5272         \textcolor{keywordtype}{bool} showHelp = \textcolor{keyword}{false};}
\DoxyCodeLine{5273         \textcolor{keywordtype}{bool} showInvisibles = \textcolor{keyword}{false};}
\DoxyCodeLine{5274         \textcolor{keywordtype}{bool} filenamesAsTags = \textcolor{keyword}{false};}
\DoxyCodeLine{5275         \textcolor{keywordtype}{bool} libIdentify = \textcolor{keyword}{false};}
\DoxyCodeLine{5276 }
\DoxyCodeLine{5277         \textcolor{keywordtype}{int} abortAfter = -\/1;}
\DoxyCodeLine{5278         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed = 0;}
\DoxyCodeLine{5279 }
\DoxyCodeLine{5280         \textcolor{keywordtype}{bool} benchmarkNoAnalysis = \textcolor{keyword}{false};}
\DoxyCodeLine{5281         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} benchmarkSamples = 100;}
\DoxyCodeLine{5282         \textcolor{keywordtype}{double} benchmarkConfidenceInterval = 0.95;}
\DoxyCodeLine{5283         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} benchmarkResamples = 100000;}
\DoxyCodeLine{5284         std::chrono::milliseconds::rep benchmarkWarmupTime = 100;}
\DoxyCodeLine{5285 }
\DoxyCodeLine{5286         Verbosity verbosity = Verbosity::Normal;}
\DoxyCodeLine{5287         WarnAbout::What warnings = WarnAbout::Nothing;}
\DoxyCodeLine{5288         ShowDurations::OrNot showDurations = ShowDurations::DefaultForReporter;}
\DoxyCodeLine{5289         \textcolor{keywordtype}{double} minDuration = -\/1;}
\DoxyCodeLine{5290         RunTests::InWhatOrder runOrder = RunTests::InDeclarationOrder;}
\DoxyCodeLine{5291         UseColour::YesOrNo useColour = UseColour::Auto;}
\DoxyCodeLine{5292         WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;}
\DoxyCodeLine{5293 }
\DoxyCodeLine{5294         std::string outputFilename;}
\DoxyCodeLine{5295         std::string name;}
\DoxyCodeLine{5296         std::string processName;}
\DoxyCodeLine{5297 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_DEFAULT\_REPORTER}}
\DoxyCodeLine{5298 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_DEFAULT\_REPORTER "{}console"{}}}
\DoxyCodeLine{5299 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5300         std::string reporterName = CATCH\_CONFIG\_DEFAULT\_REPORTER;}
\DoxyCodeLine{5301 \textcolor{preprocessor}{\#undef CATCH\_CONFIG\_DEFAULT\_REPORTER}}
\DoxyCodeLine{5302 }
\DoxyCodeLine{5303         std::vector<std::string> testsOrTags;}
\DoxyCodeLine{5304         std::vector<std::string> sectionsToRun;}
\DoxyCodeLine{5305     \};}
\DoxyCodeLine{5306 }
\DoxyCodeLine{5307     \textcolor{keyword}{class }\mbox{\hyperlink{struct_config__}{Config}} : \textcolor{keyword}{public} IConfig \{}
\DoxyCodeLine{5308     \textcolor{keyword}{public}:}
\DoxyCodeLine{5309 }
\DoxyCodeLine{5310         \mbox{\hyperlink{struct_config__}{Config}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5311         \mbox{\hyperlink{struct_config__}{Config}}( ConfigData \textcolor{keyword}{const}\& data );}
\DoxyCodeLine{5312         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_config__}{\string~Config}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5313 }
\DoxyCodeLine{5314         std::string \textcolor{keyword}{const}\& getFilename() \textcolor{keyword}{const};}
\DoxyCodeLine{5315 }
\DoxyCodeLine{5316         \textcolor{keywordtype}{bool} listTests() \textcolor{keyword}{const};}
\DoxyCodeLine{5317         \textcolor{keywordtype}{bool} listTestNamesOnly() \textcolor{keyword}{const};}
\DoxyCodeLine{5318         \textcolor{keywordtype}{bool} listTags() \textcolor{keyword}{const};}
\DoxyCodeLine{5319         \textcolor{keywordtype}{bool} listReporters() \textcolor{keyword}{const};}
\DoxyCodeLine{5320 }
\DoxyCodeLine{5321         std::string getProcessName() \textcolor{keyword}{const};}
\DoxyCodeLine{5322         std::string \textcolor{keyword}{const}\& getReporterName() \textcolor{keyword}{const};}
\DoxyCodeLine{5323 }
\DoxyCodeLine{5324         std::vector<std::string> \textcolor{keyword}{const}\& getTestsOrTags() \textcolor{keyword}{const override};}
\DoxyCodeLine{5325         std::vector<std::string> \textcolor{keyword}{const}\& getSectionsToRun() \textcolor{keyword}{const override};}
\DoxyCodeLine{5326 }
\DoxyCodeLine{5327         TestSpec \textcolor{keyword}{const}\& testSpec() \textcolor{keyword}{const override};}
\DoxyCodeLine{5328         \textcolor{keywordtype}{bool} hasTestFilters() \textcolor{keyword}{const override};}
\DoxyCodeLine{5329 }
\DoxyCodeLine{5330         \textcolor{keywordtype}{bool} showHelp() \textcolor{keyword}{const};}
\DoxyCodeLine{5331 }
\DoxyCodeLine{5332         \textcolor{comment}{// IConfig interface}}
\DoxyCodeLine{5333         \textcolor{keywordtype}{bool} allowThrows() \textcolor{keyword}{const override};}
\DoxyCodeLine{5334         std::ostream\& stream() \textcolor{keyword}{const override};}
\DoxyCodeLine{5335         std::string name() \textcolor{keyword}{const override};}
\DoxyCodeLine{5336         \textcolor{keywordtype}{bool} includeSuccessfulResults() \textcolor{keyword}{const override};}
\DoxyCodeLine{5337         \textcolor{keywordtype}{bool} warnAboutMissingAssertions() \textcolor{keyword}{const override};}
\DoxyCodeLine{5338         \textcolor{keywordtype}{bool} warnAboutNoTests() \textcolor{keyword}{const override};}
\DoxyCodeLine{5339         ShowDurations::OrNot showDurations() \textcolor{keyword}{const override};}
\DoxyCodeLine{5340         \textcolor{keywordtype}{double} minDuration() \textcolor{keyword}{const override};}
\DoxyCodeLine{5341         RunTests::InWhatOrder runOrder() \textcolor{keyword}{const override};}
\DoxyCodeLine{5342         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() \textcolor{keyword}{const override};}
\DoxyCodeLine{5343         UseColour::YesOrNo useColour() \textcolor{keyword}{const override};}
\DoxyCodeLine{5344         \textcolor{keywordtype}{bool} shouldDebugBreak() \textcolor{keyword}{const override};}
\DoxyCodeLine{5345         \textcolor{keywordtype}{int} abortAfter() \textcolor{keyword}{const override};}
\DoxyCodeLine{5346         \textcolor{keywordtype}{bool} showInvisibles() \textcolor{keyword}{const override};}
\DoxyCodeLine{5347         Verbosity verbosity() \textcolor{keyword}{const override};}
\DoxyCodeLine{5348         \textcolor{keywordtype}{bool} benchmarkNoAnalysis() \textcolor{keyword}{const override};}
\DoxyCodeLine{5349         \textcolor{keywordtype}{int} benchmarkSamples() \textcolor{keyword}{const override};}
\DoxyCodeLine{5350         \textcolor{keywordtype}{double} benchmarkConfidenceInterval() \textcolor{keyword}{const override};}
\DoxyCodeLine{5351         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} benchmarkResamples() \textcolor{keyword}{const override};}
\DoxyCodeLine{5352         std::chrono::milliseconds benchmarkWarmupTime() \textcolor{keyword}{const override};}
\DoxyCodeLine{5353 }
\DoxyCodeLine{5354     \textcolor{keyword}{private}:}
\DoxyCodeLine{5355 }
\DoxyCodeLine{5356         IStream \textcolor{keyword}{const}* openStream();}
\DoxyCodeLine{5357         ConfigData m\_data;}
\DoxyCodeLine{5358 }
\DoxyCodeLine{5359         std::unique\_ptr<IStream const> m\_stream;}
\DoxyCodeLine{5360         TestSpec m\_testSpec;}
\DoxyCodeLine{5361         \textcolor{keywordtype}{bool} m\_hasTestFilters = \textcolor{keyword}{false};}
\DoxyCodeLine{5362     \};}
\DoxyCodeLine{5363 }
\DoxyCodeLine{5364 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5365 }
\DoxyCodeLine{5366 \textcolor{comment}{// end catch\_config.hpp}}
\DoxyCodeLine{5367 \textcolor{comment}{// start catch\_assertionresult.h}}
\DoxyCodeLine{5368 }
\DoxyCodeLine{5369 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5370 }
\DoxyCodeLine{5371 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5372 }
\DoxyCodeLine{5373     \textcolor{keyword}{struct }AssertionResultData}
\DoxyCodeLine{5374     \{}
\DoxyCodeLine{5375         AssertionResultData() = \textcolor{keyword}{delete};}
\DoxyCodeLine{5376 }
\DoxyCodeLine{5377         AssertionResultData( ResultWas::OfType \_resultType, LazyExpression \textcolor{keyword}{const}\& \_lazyExpression );}
\DoxyCodeLine{5378 }
\DoxyCodeLine{5379         std::string message;}
\DoxyCodeLine{5380         \textcolor{keyword}{mutable} std::string reconstructedExpression;}
\DoxyCodeLine{5381         LazyExpression lazyExpression;}
\DoxyCodeLine{5382         ResultWas::OfType resultType;}
\DoxyCodeLine{5383 }
\DoxyCodeLine{5384         std::string reconstructExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5385     \};}
\DoxyCodeLine{5386 }
\DoxyCodeLine{5387     \textcolor{keyword}{class }AssertionResult \{}
\DoxyCodeLine{5388     \textcolor{keyword}{public}:}
\DoxyCodeLine{5389         AssertionResult() = \textcolor{keyword}{delete};}
\DoxyCodeLine{5390         AssertionResult( AssertionInfo \textcolor{keyword}{const}\& info, AssertionResultData \textcolor{keyword}{const}\& data );}
\DoxyCodeLine{5391 }
\DoxyCodeLine{5392         \textcolor{keywordtype}{bool} isOk() \textcolor{keyword}{const};}
\DoxyCodeLine{5393         \textcolor{keywordtype}{bool} succeeded() \textcolor{keyword}{const};}
\DoxyCodeLine{5394         ResultWas::OfType getResultType() \textcolor{keyword}{const};}
\DoxyCodeLine{5395         \textcolor{keywordtype}{bool} hasExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5396         \textcolor{keywordtype}{bool} hasMessage() \textcolor{keyword}{const};}
\DoxyCodeLine{5397         std::string getExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5398         std::string getExpressionInMacro() \textcolor{keyword}{const};}
\DoxyCodeLine{5399         \textcolor{keywordtype}{bool} hasExpandedExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5400         std::string getExpandedExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5401         std::string getMessage() \textcolor{keyword}{const};}
\DoxyCodeLine{5402         SourceLineInfo getSourceInfo() \textcolor{keyword}{const};}
\DoxyCodeLine{5403         StringRef getTestMacroName() \textcolor{keyword}{const};}
\DoxyCodeLine{5404 }
\DoxyCodeLine{5405     \textcolor{comment}{//protected:}}
\DoxyCodeLine{5406         AssertionInfo m\_info;}
\DoxyCodeLine{5407         AssertionResultData m\_resultData;}
\DoxyCodeLine{5408     \};}
\DoxyCodeLine{5409 }
\DoxyCodeLine{5410 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5411 }
\DoxyCodeLine{5412 \textcolor{comment}{// end catch\_assertionresult.h}}
\DoxyCodeLine{5413 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{5414 \textcolor{comment}{// start catch\_estimate.hpp}}
\DoxyCodeLine{5415 }
\DoxyCodeLine{5416  \textcolor{comment}{// Statistics estimates}}
\DoxyCodeLine{5417 }
\DoxyCodeLine{5418 }
\DoxyCodeLine{5419 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5420     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{5421         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{5422         \textcolor{keyword}{struct }Estimate \{}
\DoxyCodeLine{5423             Duration point;}
\DoxyCodeLine{5424             Duration lower\_bound;}
\DoxyCodeLine{5425             Duration upper\_bound;}
\DoxyCodeLine{5426             \textcolor{keywordtype}{double} confidence\_interval;}
\DoxyCodeLine{5427 }
\DoxyCodeLine{5428             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{5429             \textcolor{keyword}{operator} Estimate<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5430                 \textcolor{keywordflow}{return} \{ point, lower\_bound, upper\_bound, confidence\_interval \};}
\DoxyCodeLine{5431             \}}
\DoxyCodeLine{5432         \};}
\DoxyCodeLine{5433     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{5434 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{5435 }
\DoxyCodeLine{5436 \textcolor{comment}{// end catch\_estimate.hpp}}
\DoxyCodeLine{5437 \textcolor{comment}{// start catch\_outlier\_classification.hpp}}
\DoxyCodeLine{5438 }
\DoxyCodeLine{5439 \textcolor{comment}{// Outlier information}}
\DoxyCodeLine{5440 }
\DoxyCodeLine{5441 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5442     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{5443         \textcolor{keyword}{struct }OutlierClassification \{}
\DoxyCodeLine{5444             \textcolor{keywordtype}{int} samples\_seen = 0;}
\DoxyCodeLine{5445             \textcolor{keywordtype}{int} low\_severe = 0;     \textcolor{comment}{// more than 3 times IQR below Q1}}
\DoxyCodeLine{5446             \textcolor{keywordtype}{int} low\_mild = 0;       \textcolor{comment}{// 1.5 to 3 times IQR below Q1}}
\DoxyCodeLine{5447             \textcolor{keywordtype}{int} high\_mild = 0;      \textcolor{comment}{// 1.5 to 3 times IQR above Q3}}
\DoxyCodeLine{5448             \textcolor{keywordtype}{int} high\_severe = 0;    \textcolor{comment}{// more than 3 times IQR above Q3}}
\DoxyCodeLine{5449 }
\DoxyCodeLine{5450             \textcolor{keywordtype}{int} total()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5451                 \textcolor{keywordflow}{return} low\_severe + low\_mild + high\_mild + high\_severe;}
\DoxyCodeLine{5452             \}}
\DoxyCodeLine{5453         \};}
\DoxyCodeLine{5454     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{5455 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{5456 }
\DoxyCodeLine{5457 \textcolor{comment}{// end catch\_outlier\_classification.hpp}}
\DoxyCodeLine{5458 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{5459 }
\DoxyCodeLine{5460 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5461 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{5462 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{5463 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{5464 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{5465 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{5466 }
\DoxyCodeLine{5467 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5468 }
\DoxyCodeLine{5469     \textcolor{keyword}{struct }ReporterConfig \{}
\DoxyCodeLine{5470         \textcolor{keyword}{explicit} ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig );}
\DoxyCodeLine{5471 }
\DoxyCodeLine{5472         ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig, std::ostream\& \_stream );}
\DoxyCodeLine{5473 }
\DoxyCodeLine{5474         std::ostream\& stream() \textcolor{keyword}{const};}
\DoxyCodeLine{5475         IConfigPtr fullConfig() \textcolor{keyword}{const};}
\DoxyCodeLine{5476 }
\DoxyCodeLine{5477     \textcolor{keyword}{private}:}
\DoxyCodeLine{5478         std::ostream* m\_stream;}
\DoxyCodeLine{5479         IConfigPtr m\_fullConfig;}
\DoxyCodeLine{5480     \};}
\DoxyCodeLine{5481 }
\DoxyCodeLine{5482     \textcolor{keyword}{struct }ReporterPreferences \{}
\DoxyCodeLine{5483         \textcolor{keywordtype}{bool} shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{5484         \textcolor{keywordtype}{bool} shouldReportAllAssertions = \textcolor{keyword}{false};}
\DoxyCodeLine{5485     \};}
\DoxyCodeLine{5486 }
\DoxyCodeLine{5487     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{5488     \textcolor{keyword}{struct }LazyStat : Option<T> \{}
\DoxyCodeLine{5489         LazyStat\& operator=( T \textcolor{keyword}{const}\& \_value ) \{}
\DoxyCodeLine{5490             Option<T>::operator=( \_value );}
\DoxyCodeLine{5491             used = \textcolor{keyword}{false};}
\DoxyCodeLine{5492             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{5493         \}}
\DoxyCodeLine{5494         \textcolor{keywordtype}{void} reset() \{}
\DoxyCodeLine{5495             Option<T>::reset();}
\DoxyCodeLine{5496             used = \textcolor{keyword}{false};}
\DoxyCodeLine{5497         \}}
\DoxyCodeLine{5498         \textcolor{keywordtype}{bool} used = \textcolor{keyword}{false};}
\DoxyCodeLine{5499     \};}
\DoxyCodeLine{5500 }
\DoxyCodeLine{5501     \textcolor{keyword}{struct }TestRunInfo \{}
\DoxyCodeLine{5502         TestRunInfo( std::string \textcolor{keyword}{const}\& \_name );}
\DoxyCodeLine{5503         std::string name;}
\DoxyCodeLine{5504     \};}
\DoxyCodeLine{5505     \textcolor{keyword}{struct }GroupInfo \{}
\DoxyCodeLine{5506         GroupInfo(  std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{5507                     std::size\_t \_groupIndex,}
\DoxyCodeLine{5508                     std::size\_t \_groupsCount );}
\DoxyCodeLine{5509 }
\DoxyCodeLine{5510         std::string name;}
\DoxyCodeLine{5511         std::size\_t groupIndex;}
\DoxyCodeLine{5512         std::size\_t groupsCounts;}
\DoxyCodeLine{5513     \};}
\DoxyCodeLine{5514 }
\DoxyCodeLine{5515     \textcolor{keyword}{struct }AssertionStats \{}
\DoxyCodeLine{5516         AssertionStats( AssertionResult \textcolor{keyword}{const}\& \_assertionResult,}
\DoxyCodeLine{5517                         std::vector<MessageInfo> \textcolor{keyword}{const}\& \_infoMessages,}
\DoxyCodeLine{5518                         Totals \textcolor{keyword}{const}\& \_totals );}
\DoxyCodeLine{5519 }
\DoxyCodeLine{5520         AssertionStats( AssertionStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5521         AssertionStats( AssertionStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5522         AssertionStats\& operator = ( AssertionStats \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{5523         AssertionStats\& operator = ( AssertionStats \&\& )     = \textcolor{keyword}{delete};}
\DoxyCodeLine{5524         \textcolor{keyword}{virtual} \string~AssertionStats();}
\DoxyCodeLine{5525 }
\DoxyCodeLine{5526         AssertionResult assertionResult;}
\DoxyCodeLine{5527         std::vector<MessageInfo> infoMessages;}
\DoxyCodeLine{5528         Totals totals;}
\DoxyCodeLine{5529     \};}
\DoxyCodeLine{5530 }
\DoxyCodeLine{5531     \textcolor{keyword}{struct }SectionStats \{}
\DoxyCodeLine{5532         SectionStats(   SectionInfo \textcolor{keyword}{const}\& \_sectionInfo,}
\DoxyCodeLine{5533                         Counts \textcolor{keyword}{const}\& \_assertions,}
\DoxyCodeLine{5534                         \textcolor{keywordtype}{double} \_durationInSeconds,}
\DoxyCodeLine{5535                         \textcolor{keywordtype}{bool} \_missingAssertions );}
\DoxyCodeLine{5536         SectionStats( SectionStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5537         SectionStats( SectionStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5538         SectionStats\& operator = ( SectionStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5539         SectionStats\& operator = ( SectionStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5540         \textcolor{keyword}{virtual} \string~SectionStats();}
\DoxyCodeLine{5541 }
\DoxyCodeLine{5542         SectionInfo sectionInfo;}
\DoxyCodeLine{5543         Counts assertions;}
\DoxyCodeLine{5544         \textcolor{keywordtype}{double} durationInSeconds;}
\DoxyCodeLine{5545         \textcolor{keywordtype}{bool} missingAssertions;}
\DoxyCodeLine{5546     \};}
\DoxyCodeLine{5547 }
\DoxyCodeLine{5548     \textcolor{keyword}{struct }TestCaseStats \{}
\DoxyCodeLine{5549         TestCaseStats(  TestCaseInfo \textcolor{keyword}{const}\& \_testInfo,}
\DoxyCodeLine{5550                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{5551                         std::string \textcolor{keyword}{const}\& \_stdOut,}
\DoxyCodeLine{5552                         std::string \textcolor{keyword}{const}\& \_stdErr,}
\DoxyCodeLine{5553                         \textcolor{keywordtype}{bool} \_aborting );}
\DoxyCodeLine{5554 }
\DoxyCodeLine{5555         TestCaseStats( TestCaseStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5556         TestCaseStats( TestCaseStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5557         TestCaseStats\& operator = ( TestCaseStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5558         TestCaseStats\& operator = ( TestCaseStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5559         \textcolor{keyword}{virtual} \string~TestCaseStats();}
\DoxyCodeLine{5560 }
\DoxyCodeLine{5561         TestCaseInfo testInfo;}
\DoxyCodeLine{5562         Totals totals;}
\DoxyCodeLine{5563         std::string stdOut;}
\DoxyCodeLine{5564         std::string stdErr;}
\DoxyCodeLine{5565         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{5566     \};}
\DoxyCodeLine{5567 }
\DoxyCodeLine{5568     \textcolor{keyword}{struct }TestGroupStats \{}
\DoxyCodeLine{5569         TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo,}
\DoxyCodeLine{5570                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{5571                         \textcolor{keywordtype}{bool} \_aborting );}
\DoxyCodeLine{5572         TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo );}
\DoxyCodeLine{5573 }
\DoxyCodeLine{5574         TestGroupStats( TestGroupStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5575         TestGroupStats( TestGroupStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5576         TestGroupStats\& operator = ( TestGroupStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5577         TestGroupStats\& operator = ( TestGroupStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5578         \textcolor{keyword}{virtual} \string~TestGroupStats();}
\DoxyCodeLine{5579 }
\DoxyCodeLine{5580         GroupInfo groupInfo;}
\DoxyCodeLine{5581         Totals totals;}
\DoxyCodeLine{5582         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{5583     \};}
\DoxyCodeLine{5584 }
\DoxyCodeLine{5585     \textcolor{keyword}{struct }TestRunStats \{}
\DoxyCodeLine{5586         TestRunStats(   TestRunInfo \textcolor{keyword}{const}\& \_runInfo,}
\DoxyCodeLine{5587                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{5588                         \textcolor{keywordtype}{bool} \_aborting );}
\DoxyCodeLine{5589 }
\DoxyCodeLine{5590         TestRunStats( TestRunStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5591         TestRunStats( TestRunStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5592         TestRunStats\& operator = ( TestRunStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5593         TestRunStats\& operator = ( TestRunStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5594         \textcolor{keyword}{virtual} \string~TestRunStats();}
\DoxyCodeLine{5595 }
\DoxyCodeLine{5596         TestRunInfo runInfo;}
\DoxyCodeLine{5597         Totals totals;}
\DoxyCodeLine{5598         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{5599     \};}
\DoxyCodeLine{5600 }
\DoxyCodeLine{5601 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{5602     \textcolor{keyword}{struct }BenchmarkInfo \{}
\DoxyCodeLine{5603         std::string name;}
\DoxyCodeLine{5604         \textcolor{keywordtype}{double} estimatedDuration;}
\DoxyCodeLine{5605         \textcolor{keywordtype}{int} iterations;}
\DoxyCodeLine{5606         \textcolor{keywordtype}{int} samples;}
\DoxyCodeLine{5607         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} resamples;}
\DoxyCodeLine{5608         \textcolor{keywordtype}{double} clockResolution;}
\DoxyCodeLine{5609         \textcolor{keywordtype}{double} clockCost;}
\DoxyCodeLine{5610     \};}
\DoxyCodeLine{5611 }
\DoxyCodeLine{5612     \textcolor{keyword}{template} <\textcolor{keyword}{class} Duration>}
\DoxyCodeLine{5613     \textcolor{keyword}{struct }BenchmarkStats \{}
\DoxyCodeLine{5614         BenchmarkInfo info;}
\DoxyCodeLine{5615 }
\DoxyCodeLine{5616         std::vector<Duration> samples;}
\DoxyCodeLine{5617         Benchmark::Estimate<Duration> mean;}
\DoxyCodeLine{5618         Benchmark::Estimate<Duration> standardDeviation;}
\DoxyCodeLine{5619         Benchmark::OutlierClassification outliers;}
\DoxyCodeLine{5620         \textcolor{keywordtype}{double} outlierVariance;}
\DoxyCodeLine{5621 }
\DoxyCodeLine{5622         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{5623         \textcolor{keyword}{operator} BenchmarkStats<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5624             std::vector<Duration2> samples2;}
\DoxyCodeLine{5625             samples2.reserve(samples.size());}
\DoxyCodeLine{5626             std::transform(samples.begin(), samples.end(), std::back\_inserter(samples2), [](Duration d) \{ return Duration2(d); \});}
\DoxyCodeLine{5627             \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{5628                 info,}
\DoxyCodeLine{5629                 std::move(samples2),}
\DoxyCodeLine{5630                 mean,}
\DoxyCodeLine{5631                 standardDeviation,}
\DoxyCodeLine{5632                 outliers,}
\DoxyCodeLine{5633                 outlierVariance,}
\DoxyCodeLine{5634             \};}
\DoxyCodeLine{5635         \}}
\DoxyCodeLine{5636     \};}
\DoxyCodeLine{5637 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{5638 }
\DoxyCodeLine{5639     \textcolor{keyword}{struct }IStreamingReporter \{}
\DoxyCodeLine{5640         \textcolor{keyword}{virtual} \string~IStreamingReporter() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5641 }
\DoxyCodeLine{5642         \textcolor{comment}{// Implementing class must also provide the following static methods:}}
\DoxyCodeLine{5643         \textcolor{comment}{// static std::string getDescription();}}
\DoxyCodeLine{5644         \textcolor{comment}{// static std::set<Verbosity> getSupportedVerbosities()}}
\DoxyCodeLine{5645 }
\DoxyCodeLine{5646         \textcolor{keyword}{virtual} ReporterPreferences getPreferences() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5647 }
\DoxyCodeLine{5648         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) = 0;}
\DoxyCodeLine{5649 }
\DoxyCodeLine{5650         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} reportInvalidArguments(std::string \textcolor{keyword}{const}\&) \{\}}
\DoxyCodeLine{5651 }
\DoxyCodeLine{5652         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testRunInfo ) = 0;}
\DoxyCodeLine{5653         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) = 0;}
\DoxyCodeLine{5654 }
\DoxyCodeLine{5655         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{5656         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) = 0;}
\DoxyCodeLine{5657 }
\DoxyCodeLine{5658 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{5659         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkPreparing( std::string \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{5660         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{5661         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{5662         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkFailed( std::string \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{5663 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{5664 }
\DoxyCodeLine{5665         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& assertionInfo ) = 0;}
\DoxyCodeLine{5666 }
\DoxyCodeLine{5667         \textcolor{comment}{// The return value indicates if the messages buffer should be cleared:}}
\DoxyCodeLine{5668         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) = 0;}
\DoxyCodeLine{5669 }
\DoxyCodeLine{5670         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) = 0;}
\DoxyCodeLine{5671         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) = 0;}
\DoxyCodeLine{5672         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) = 0;}
\DoxyCodeLine{5673         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) = 0;}
\DoxyCodeLine{5674 }
\DoxyCodeLine{5675         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} skipTest( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{5676 }
\DoxyCodeLine{5677         \textcolor{comment}{// Default empty implementation provided}}
\DoxyCodeLine{5678         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} fatalErrorEncountered( StringRef name );}
\DoxyCodeLine{5679 }
\DoxyCodeLine{5680         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isMulti() \textcolor{keyword}{const};}
\DoxyCodeLine{5681     \};}
\DoxyCodeLine{5682     \textcolor{keyword}{using} IStreamingReporterPtr = std::unique\_ptr<IStreamingReporter>;}
\DoxyCodeLine{5683 }
\DoxyCodeLine{5684     \textcolor{keyword}{struct }IReporterFactory \{}
\DoxyCodeLine{5685         \textcolor{keyword}{virtual} \string~IReporterFactory();}
\DoxyCodeLine{5686         \textcolor{keyword}{virtual} IStreamingReporterPtr create( ReporterConfig \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5687         \textcolor{keyword}{virtual} std::string getDescription() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5688     \};}
\DoxyCodeLine{5689     \textcolor{keyword}{using} IReporterFactoryPtr = std::shared\_ptr<IReporterFactory>;}
\DoxyCodeLine{5690 }
\DoxyCodeLine{5691     \textcolor{keyword}{struct }IReporterRegistry \{}
\DoxyCodeLine{5692         \textcolor{keyword}{using} FactoryMap = std::map<std::string, IReporterFactoryPtr>;}
\DoxyCodeLine{5693         \textcolor{keyword}{using} Listeners = std::vector<IReporterFactoryPtr>;}
\DoxyCodeLine{5694 }
\DoxyCodeLine{5695         \textcolor{keyword}{virtual} \string~IReporterRegistry();}
\DoxyCodeLine{5696         \textcolor{keyword}{virtual} IStreamingReporterPtr create( std::string \textcolor{keyword}{const}\& name, IConfigPtr \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5697         \textcolor{keyword}{virtual} FactoryMap \textcolor{keyword}{const}\& getFactories() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5698         \textcolor{keyword}{virtual} Listeners \textcolor{keyword}{const}\& getListeners() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5699     \};}
\DoxyCodeLine{5700 }
\DoxyCodeLine{5701 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5702 }
\DoxyCodeLine{5703 \textcolor{comment}{// end catch\_interfaces\_reporter.h}}
\DoxyCodeLine{5704 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{5705 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{5706 \textcolor{preprocessor}{\#include <cfloat>}}
\DoxyCodeLine{5707 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{5708 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{5709 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{5710 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{5711 }
\DoxyCodeLine{5712 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5713     \textcolor{keywordtype}{void} prepareExpandedExpression(AssertionResult\& result);}
\DoxyCodeLine{5714 }
\DoxyCodeLine{5715     \textcolor{comment}{// Returns double formatted as \%.3f (format expected on output)}}
\DoxyCodeLine{5716     std::string getFormattedDuration( \textcolor{keywordtype}{double} duration );}
\DoxyCodeLine{5717 }
\DoxyCodeLine{5719     \textcolor{keywordtype}{bool} shouldShowDuration( IConfig \textcolor{keyword}{const}\& config, \textcolor{keywordtype}{double} duration );}
\DoxyCodeLine{5720 }
\DoxyCodeLine{5721     std::string serializeFilters( std::vector<std::string> \textcolor{keyword}{const}\& container );}
\DoxyCodeLine{5722 }
\DoxyCodeLine{5723     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{5724     \textcolor{keyword}{struct }StreamingReporterBase : IStreamingReporter \{}
\DoxyCodeLine{5725 }
\DoxyCodeLine{5726         StreamingReporterBase( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{5727         :   m\_config( \_config.fullConfig() ),}
\DoxyCodeLine{5728             stream( \_config.stream() )}
\DoxyCodeLine{5729         \{}
\DoxyCodeLine{5730             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{5731             \textcolor{keywordflow}{if}( !DerivedT::getSupportedVerbosities().count( m\_config-\/>verbosity() ) )}
\DoxyCodeLine{5732                 CATCH\_ERROR( \textcolor{stringliteral}{"{}Verbosity level not supported by this reporter"{}} );}
\DoxyCodeLine{5733         \}}
\DoxyCodeLine{5734 }
\DoxyCodeLine{5735         ReporterPreferences getPreferences()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{5736             \textcolor{keywordflow}{return} m\_reporterPrefs;}
\DoxyCodeLine{5737         \}}
\DoxyCodeLine{5738 }
\DoxyCodeLine{5739         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities() \{}
\DoxyCodeLine{5740             \textcolor{keywordflow}{return} \{ Verbosity::Normal \};}
\DoxyCodeLine{5741         \}}
\DoxyCodeLine{5742 }
\DoxyCodeLine{5743         \string~StreamingReporterBase() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5744 }
\DoxyCodeLine{5745         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5746 }
\DoxyCodeLine{5747         \textcolor{keywordtype}{void} reportInvalidArguments(std::string \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5748 }
\DoxyCodeLine{5749         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& \_testRunInfo)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5750             currentTestRunInfo = \_testRunInfo;}
\DoxyCodeLine{5751         \}}
\DoxyCodeLine{5752 }
\DoxyCodeLine{5753         \textcolor{keywordtype}{void} testGroupStarting(GroupInfo \textcolor{keyword}{const}\& \_groupInfo)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5754             currentGroupInfo = \_groupInfo;}
\DoxyCodeLine{5755         \}}
\DoxyCodeLine{5756 }
\DoxyCodeLine{5757         \textcolor{keywordtype}{void} testCaseStarting(TestCaseInfo \textcolor{keyword}{const}\& \_testInfo)\textcolor{keyword}{ override  }\{}
\DoxyCodeLine{5758             currentTestCaseInfo = \_testInfo;}
\DoxyCodeLine{5759         \}}
\DoxyCodeLine{5760         \textcolor{keywordtype}{void} sectionStarting(SectionInfo \textcolor{keyword}{const}\& \_sectionInfo)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5761             m\_sectionStack.push\_back(\_sectionInfo);}
\DoxyCodeLine{5762         \}}
\DoxyCodeLine{5763 }
\DoxyCodeLine{5764         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_sectionStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5765             m\_sectionStack.pop\_back();}
\DoxyCodeLine{5766         \}}
\DoxyCodeLine{5767         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testCaseStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5768             currentTestCaseInfo.reset();}
\DoxyCodeLine{5769         \}}
\DoxyCodeLine{5770         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testGroupStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5771             currentGroupInfo.reset();}
\DoxyCodeLine{5772         \}}
\DoxyCodeLine{5773         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testRunStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5774             currentTestCaseInfo.reset();}
\DoxyCodeLine{5775             currentGroupInfo.reset();}
\DoxyCodeLine{5776             currentTestRunInfo.reset();}
\DoxyCodeLine{5777         \}}
\DoxyCodeLine{5778 }
\DoxyCodeLine{5779         \textcolor{keywordtype}{void} skipTest(TestCaseInfo \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5780             \textcolor{comment}{// Don't do anything with this by default.}}
\DoxyCodeLine{5781             \textcolor{comment}{// It can optionally be overridden in the derived class.}}
\DoxyCodeLine{5782         \}}
\DoxyCodeLine{5783 }
\DoxyCodeLine{5784         IConfigPtr m\_config;}
\DoxyCodeLine{5785         std::ostream\& stream;}
\DoxyCodeLine{5786 }
\DoxyCodeLine{5787         LazyStat<TestRunInfo> currentTestRunInfo;}
\DoxyCodeLine{5788         LazyStat<GroupInfo> currentGroupInfo;}
\DoxyCodeLine{5789         LazyStat<TestCaseInfo> currentTestCaseInfo;}
\DoxyCodeLine{5790 }
\DoxyCodeLine{5791         std::vector<SectionInfo> m\_sectionStack;}
\DoxyCodeLine{5792         ReporterPreferences m\_reporterPrefs;}
\DoxyCodeLine{5793     \};}
\DoxyCodeLine{5794 }
\DoxyCodeLine{5795     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{5796     \textcolor{keyword}{struct }CumulativeReporterBase : IStreamingReporter \{}
\DoxyCodeLine{5797         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} ChildNodeT>}
\DoxyCodeLine{5798         \textcolor{keyword}{struct }Node \{}
\DoxyCodeLine{5799             \textcolor{keyword}{explicit} Node( T \textcolor{keyword}{const}\& \_value ) : value( \_value ) \{\}}
\DoxyCodeLine{5800             \textcolor{keyword}{virtual} \string~Node() \{\}}
\DoxyCodeLine{5801 }
\DoxyCodeLine{5802             \textcolor{keyword}{using} ChildNodes = std::vector<std::shared\_ptr<ChildNodeT>>;}
\DoxyCodeLine{5803             T value;}
\DoxyCodeLine{5804             ChildNodes children;}
\DoxyCodeLine{5805         \};}
\DoxyCodeLine{5806         \textcolor{keyword}{struct }SectionNode \{}
\DoxyCodeLine{5807             \textcolor{keyword}{explicit} SectionNode(SectionStats \textcolor{keyword}{const}\& \_stats) : stats(\_stats) \{\}}
\DoxyCodeLine{5808             \textcolor{keyword}{virtual} \string~SectionNode() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5809 }
\DoxyCodeLine{5810             \textcolor{keywordtype}{bool} operator == (SectionNode \textcolor{keyword}{const}\& other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5811                 \textcolor{keywordflow}{return} stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;}
\DoxyCodeLine{5812             \}}
\DoxyCodeLine{5813             \textcolor{keywordtype}{bool} operator == (std::shared\_ptr<SectionNode> \textcolor{keyword}{const}\& other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5814                 \textcolor{keywordflow}{return} operator==(*other);}
\DoxyCodeLine{5815             \}}
\DoxyCodeLine{5816 }
\DoxyCodeLine{5817             SectionStats stats;}
\DoxyCodeLine{5818             \textcolor{keyword}{using} ChildSections = std::vector<std::shared\_ptr<SectionNode>>;}
\DoxyCodeLine{5819             \textcolor{keyword}{using} Assertions = std::vector<AssertionStats>;}
\DoxyCodeLine{5820             ChildSections childSections;}
\DoxyCodeLine{5821             Assertions assertions;}
\DoxyCodeLine{5822             std::string stdOut;}
\DoxyCodeLine{5823             std::string stdErr;}
\DoxyCodeLine{5824         \};}
\DoxyCodeLine{5825 }
\DoxyCodeLine{5826         \textcolor{keyword}{struct }BySectionInfo \{}
\DoxyCodeLine{5827             BySectionInfo( SectionInfo \textcolor{keyword}{const}\& other ) : m\_other( other ) \{\}}
\DoxyCodeLine{5828             BySectionInfo( BySectionInfo \textcolor{keyword}{const}\& other ) : m\_other( other.m\_other ) \{\}}
\DoxyCodeLine{5829             \textcolor{keywordtype}{bool} operator() (std::shared\_ptr<SectionNode> \textcolor{keyword}{const}\& node)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5830                 \textcolor{keywordflow}{return} ((node-\/>stats.sectionInfo.name == m\_other.name) \&\&}
\DoxyCodeLine{5831                         (node-\/>stats.sectionInfo.lineInfo == m\_other.lineInfo));}
\DoxyCodeLine{5832             \}}
\DoxyCodeLine{5833             \textcolor{keywordtype}{void} operator=(BySectionInfo \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{5834 }
\DoxyCodeLine{5835         \textcolor{keyword}{private}:}
\DoxyCodeLine{5836             SectionInfo \textcolor{keyword}{const}\& m\_other;}
\DoxyCodeLine{5837         \};}
\DoxyCodeLine{5838 }
\DoxyCodeLine{5839         \textcolor{keyword}{using} TestCaseNode = Node<TestCaseStats, SectionNode>;}
\DoxyCodeLine{5840         \textcolor{keyword}{using} TestGroupNode = Node<TestGroupStats, TestCaseNode>;}
\DoxyCodeLine{5841         \textcolor{keyword}{using} TestRunNode = Node<TestRunStats, TestGroupNode>;}
\DoxyCodeLine{5842 }
\DoxyCodeLine{5843         CumulativeReporterBase( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{5844         :   m\_config( \_config.fullConfig() ),}
\DoxyCodeLine{5845             stream( \_config.stream() )}
\DoxyCodeLine{5846         \{}
\DoxyCodeLine{5847             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{5848             \textcolor{keywordflow}{if}( !DerivedT::getSupportedVerbosities().count( m\_config-\/>verbosity() ) )}
\DoxyCodeLine{5849                 CATCH\_ERROR( \textcolor{stringliteral}{"{}Verbosity level not supported by this reporter"{}} );}
\DoxyCodeLine{5850         \}}
\DoxyCodeLine{5851         \string~CumulativeReporterBase() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5852 }
\DoxyCodeLine{5853         ReporterPreferences getPreferences()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{5854             \textcolor{keywordflow}{return} m\_reporterPrefs;}
\DoxyCodeLine{5855         \}}
\DoxyCodeLine{5856 }
\DoxyCodeLine{5857         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities() \{}
\DoxyCodeLine{5858             \textcolor{keywordflow}{return} \{ Verbosity::Normal \};}
\DoxyCodeLine{5859         \}}
\DoxyCodeLine{5860 }
\DoxyCodeLine{5861         \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5862         \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5863 }
\DoxyCodeLine{5864         \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5865 }
\DoxyCodeLine{5866         \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5867             SectionStats incompleteStats( sectionInfo, Counts(), 0, \textcolor{keyword}{false} );}
\DoxyCodeLine{5868             std::shared\_ptr<SectionNode> node;}
\DoxyCodeLine{5869             \textcolor{keywordflow}{if}( m\_sectionStack.empty() ) \{}
\DoxyCodeLine{5870                 \textcolor{keywordflow}{if}( !m\_rootSection )}
\DoxyCodeLine{5871                     m\_rootSection = std::make\_shared<SectionNode>( incompleteStats );}
\DoxyCodeLine{5872                 node = m\_rootSection;}
\DoxyCodeLine{5873             \}}
\DoxyCodeLine{5874             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5875                 SectionNode\& parentNode = *m\_sectionStack.back();}
\DoxyCodeLine{5876                 \textcolor{keyword}{auto} it =}
\DoxyCodeLine{5877                     std::find\_if(   parentNode.childSections.begin(),}
\DoxyCodeLine{5878                                     parentNode.childSections.end(),}
\DoxyCodeLine{5879                                     BySectionInfo( sectionInfo ) );}
\DoxyCodeLine{5880                 \textcolor{keywordflow}{if}( it == parentNode.childSections.end() ) \{}
\DoxyCodeLine{5881                     node = std::make\_shared<SectionNode>( incompleteStats );}
\DoxyCodeLine{5882                     parentNode.childSections.push\_back( node );}
\DoxyCodeLine{5883                 \}}
\DoxyCodeLine{5884                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{5885                     node = *it;}
\DoxyCodeLine{5886             \}}
\DoxyCodeLine{5887             m\_sectionStack.push\_back( node );}
\DoxyCodeLine{5888             m\_deepestSection = std::move(node);}
\DoxyCodeLine{5889         \}}
\DoxyCodeLine{5890 }
\DoxyCodeLine{5891         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5892 }
\DoxyCodeLine{5893         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& assertionStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5894             assert(!m\_sectionStack.empty());}
\DoxyCodeLine{5895             \textcolor{comment}{// AssertionResult holds a pointer to a temporary DecomposedExpression,}}
\DoxyCodeLine{5896             \textcolor{comment}{// which getExpandedExpression() calls to build the expression string.}}
\DoxyCodeLine{5897             \textcolor{comment}{// Our section stack copy of the assertionResult will likely outlive the}}
\DoxyCodeLine{5898             \textcolor{comment}{// temporary, so it must be expanded or discarded now to avoid calling}}
\DoxyCodeLine{5899             \textcolor{comment}{// a destroyed object later.}}
\DoxyCodeLine{5900             prepareExpandedExpression(\textcolor{keyword}{const\_cast<}AssertionResult\&\textcolor{keyword}{>}( assertionStats.assertionResult ) );}
\DoxyCodeLine{5901             SectionNode\& sectionNode = *m\_sectionStack.back();}
\DoxyCodeLine{5902             sectionNode.assertions.push\_back(assertionStats);}
\DoxyCodeLine{5903             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5904         \}}
\DoxyCodeLine{5905         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& sectionStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5906             assert(!m\_sectionStack.empty());}
\DoxyCodeLine{5907             SectionNode\& node = *m\_sectionStack.back();}
\DoxyCodeLine{5908             node.stats = sectionStats;}
\DoxyCodeLine{5909             m\_sectionStack.pop\_back();}
\DoxyCodeLine{5910         \}}
\DoxyCodeLine{5911         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& testCaseStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5912             \textcolor{keyword}{auto} node = std::make\_shared<TestCaseNode>(testCaseStats);}
\DoxyCodeLine{5913             assert(m\_sectionStack.size() == 0);}
\DoxyCodeLine{5914             node-\/>children.push\_back(m\_rootSection);}
\DoxyCodeLine{5915             m\_testCases.push\_back(node);}
\DoxyCodeLine{5916             m\_rootSection.reset();}
\DoxyCodeLine{5917 }
\DoxyCodeLine{5918             assert(m\_deepestSection);}
\DoxyCodeLine{5919             m\_deepestSection-\/>stdOut = testCaseStats.stdOut;}
\DoxyCodeLine{5920             m\_deepestSection-\/>stdErr = testCaseStats.stdErr;}
\DoxyCodeLine{5921         \}}
\DoxyCodeLine{5922         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& testGroupStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5923             \textcolor{keyword}{auto} node = std::make\_shared<TestGroupNode>(testGroupStats);}
\DoxyCodeLine{5924             node-\/>children.swap(m\_testCases);}
\DoxyCodeLine{5925             m\_testGroups.push\_back(node);}
\DoxyCodeLine{5926         \}}
\DoxyCodeLine{5927         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& testRunStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5928             \textcolor{keyword}{auto} node = std::make\_shared<TestRunNode>(testRunStats);}
\DoxyCodeLine{5929             node-\/>children.swap(m\_testGroups);}
\DoxyCodeLine{5930             m\_testRuns.push\_back(node);}
\DoxyCodeLine{5931             testRunEndedCumulative();}
\DoxyCodeLine{5932         \}}
\DoxyCodeLine{5933         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEndedCumulative() = 0;}
\DoxyCodeLine{5934 }
\DoxyCodeLine{5935         \textcolor{keywordtype}{void} skipTest(TestCaseInfo \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5936 }
\DoxyCodeLine{5937         IConfigPtr m\_config;}
\DoxyCodeLine{5938         std::ostream\& stream;}
\DoxyCodeLine{5939         std::vector<AssertionStats> m\_assertions;}
\DoxyCodeLine{5940         std::vector<std::vector<std::shared\_ptr<SectionNode>>> m\_sections;}
\DoxyCodeLine{5941         std::vector<std::shared\_ptr<TestCaseNode>> m\_testCases;}
\DoxyCodeLine{5942         std::vector<std::shared\_ptr<TestGroupNode>> m\_testGroups;}
\DoxyCodeLine{5943 }
\DoxyCodeLine{5944         std::vector<std::shared\_ptr<TestRunNode>> m\_testRuns;}
\DoxyCodeLine{5945 }
\DoxyCodeLine{5946         std::shared\_ptr<SectionNode> m\_rootSection;}
\DoxyCodeLine{5947         std::shared\_ptr<SectionNode> m\_deepestSection;}
\DoxyCodeLine{5948         std::vector<std::shared\_ptr<SectionNode>> m\_sectionStack;}
\DoxyCodeLine{5949         ReporterPreferences m\_reporterPrefs;}
\DoxyCodeLine{5950     \};}
\DoxyCodeLine{5951 }
\DoxyCodeLine{5952     \textcolor{keyword}{template}<\textcolor{keywordtype}{char} C>}
\DoxyCodeLine{5953     \textcolor{keywordtype}{char} \textcolor{keyword}{const}* getLineOfChars() \{}
\DoxyCodeLine{5954         \textcolor{keyword}{static} \textcolor{keywordtype}{char} line[CATCH\_CONFIG\_CONSOLE\_WIDTH] = \{0\};}
\DoxyCodeLine{5955         \textcolor{keywordflow}{if}( !*line ) \{}
\DoxyCodeLine{5956             std::memset( line, C, CATCH\_CONFIG\_CONSOLE\_WIDTH-\/1 );}
\DoxyCodeLine{5957             line[CATCH\_CONFIG\_CONSOLE\_WIDTH-\/1] = 0;}
\DoxyCodeLine{5958         \}}
\DoxyCodeLine{5959         \textcolor{keywordflow}{return} line;}
\DoxyCodeLine{5960     \}}
\DoxyCodeLine{5961 }
\DoxyCodeLine{5962     \textcolor{keyword}{struct }TestEventListenerBase : StreamingReporterBase<TestEventListenerBase> \{}
\DoxyCodeLine{5963         TestEventListenerBase( ReporterConfig \textcolor{keyword}{const}\& \_config );}
\DoxyCodeLine{5964 }
\DoxyCodeLine{5965         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities();}
\DoxyCodeLine{5966 }
\DoxyCodeLine{5967         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{5968         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{5969     \};}
\DoxyCodeLine{5970 }
\DoxyCodeLine{5971 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5972 }
\DoxyCodeLine{5973 \textcolor{comment}{// end catch\_reporter\_bases.hpp}}
\DoxyCodeLine{5974 \textcolor{comment}{// start catch\_console\_colour.h}}
\DoxyCodeLine{5975 }
\DoxyCodeLine{5976 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5977 }
\DoxyCodeLine{5978     \textcolor{keyword}{struct }Colour \{}
\DoxyCodeLine{5979         \textcolor{keyword}{enum} Code \{}
\DoxyCodeLine{5980             None = 0,}
\DoxyCodeLine{5981 }
\DoxyCodeLine{5982             White,}
\DoxyCodeLine{5983             Red,}
\DoxyCodeLine{5984             Green,}
\DoxyCodeLine{5985             Blue,}
\DoxyCodeLine{5986             Cyan,}
\DoxyCodeLine{5987             Yellow,}
\DoxyCodeLine{5988             Grey,}
\DoxyCodeLine{5989 }
\DoxyCodeLine{5990             Bright = 0x10,}
\DoxyCodeLine{5991 }
\DoxyCodeLine{5992             BrightRed = Bright | Red,}
\DoxyCodeLine{5993             BrightGreen = Bright | Green,}
\DoxyCodeLine{5994             LightGrey = Bright | Grey,}
\DoxyCodeLine{5995             BrightWhite = Bright | White,}
\DoxyCodeLine{5996             BrightYellow = Bright | Yellow,}
\DoxyCodeLine{5997 }
\DoxyCodeLine{5998             \textcolor{comment}{// By intention}}
\DoxyCodeLine{5999             FileName = LightGrey,}
\DoxyCodeLine{6000             Warning = BrightYellow,}
\DoxyCodeLine{6001             ResultError = BrightRed,}
\DoxyCodeLine{6002             ResultSuccess = BrightGreen,}
\DoxyCodeLine{6003             ResultExpectedFailure = Warning,}
\DoxyCodeLine{6004 }
\DoxyCodeLine{6005             Error = BrightRed,}
\DoxyCodeLine{6006             Success = Green,}
\DoxyCodeLine{6007 }
\DoxyCodeLine{6008             OriginalExpression = Cyan,}
\DoxyCodeLine{6009             ReconstructedExpression = BrightYellow,}
\DoxyCodeLine{6010 }
\DoxyCodeLine{6011             SecondaryText = LightGrey,}
\DoxyCodeLine{6012             Headers = White}
\DoxyCodeLine{6013         \};}
\DoxyCodeLine{6014 }
\DoxyCodeLine{6015         \textcolor{comment}{// Use constructed object for RAII guard}}
\DoxyCodeLine{6016         Colour( Code \_colourCode );}
\DoxyCodeLine{6017         Colour( Colour\&\& other ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{6018         Colour\& operator=( Colour\&\& other ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{6019         \string~Colour();}
\DoxyCodeLine{6020 }
\DoxyCodeLine{6021         \textcolor{comment}{// Use static method for one-\/shot changes}}
\DoxyCodeLine{6022         \textcolor{keyword}{static} \textcolor{keywordtype}{void} use( Code \_colourCode );}
\DoxyCodeLine{6023 }
\DoxyCodeLine{6024     \textcolor{keyword}{private}:}
\DoxyCodeLine{6025         \textcolor{keywordtype}{bool} m\_moved = \textcolor{keyword}{false};}
\DoxyCodeLine{6026     \};}
\DoxyCodeLine{6027 }
\DoxyCodeLine{6028     std::ostream\& operator << ( std::ostream\& os, Colour \textcolor{keyword}{const}\& );}
\DoxyCodeLine{6029 }
\DoxyCodeLine{6030 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6031 }
\DoxyCodeLine{6032 \textcolor{comment}{// end catch\_console\_colour.h}}
\DoxyCodeLine{6033 \textcolor{comment}{// start catch\_reporter\_registrars.hpp}}
\DoxyCodeLine{6034 }
\DoxyCodeLine{6035 }
\DoxyCodeLine{6036 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6037 }
\DoxyCodeLine{6038     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6039     \textcolor{keyword}{class }ReporterRegistrar \{}
\DoxyCodeLine{6040 }
\DoxyCodeLine{6041         \textcolor{keyword}{class }ReporterFactory : \textcolor{keyword}{public} IReporterFactory \{}
\DoxyCodeLine{6042 }
\DoxyCodeLine{6043             IStreamingReporterPtr create( ReporterConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6044                 \textcolor{keywordflow}{return} std::unique\_ptr<T>( \textcolor{keyword}{new} T( config ) );}
\DoxyCodeLine{6045             \}}
\DoxyCodeLine{6046 }
\DoxyCodeLine{6047             std::string getDescription()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6048                 \textcolor{keywordflow}{return} T::getDescription();}
\DoxyCodeLine{6049             \}}
\DoxyCodeLine{6050         \};}
\DoxyCodeLine{6051 }
\DoxyCodeLine{6052     \textcolor{keyword}{public}:}
\DoxyCodeLine{6053 }
\DoxyCodeLine{6054         \textcolor{keyword}{explicit} ReporterRegistrar( std::string \textcolor{keyword}{const}\& name ) \{}
\DoxyCodeLine{6055             getMutableRegistryHub().registerReporter( name, std::make\_shared<ReporterFactory>() );}
\DoxyCodeLine{6056         \}}
\DoxyCodeLine{6057     \};}
\DoxyCodeLine{6058 }
\DoxyCodeLine{6059     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6060     \textcolor{keyword}{class }ListenerRegistrar \{}
\DoxyCodeLine{6061 }
\DoxyCodeLine{6062         \textcolor{keyword}{class }ListenerFactory : \textcolor{keyword}{public} IReporterFactory \{}
\DoxyCodeLine{6063 }
\DoxyCodeLine{6064             IStreamingReporterPtr create( ReporterConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6065                 \textcolor{keywordflow}{return} std::unique\_ptr<T>( \textcolor{keyword}{new} T( config ) );}
\DoxyCodeLine{6066             \}}
\DoxyCodeLine{6067             std::string getDescription()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6068                 \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{6069             \}}
\DoxyCodeLine{6070         \};}
\DoxyCodeLine{6071 }
\DoxyCodeLine{6072     \textcolor{keyword}{public}:}
\DoxyCodeLine{6073 }
\DoxyCodeLine{6074         ListenerRegistrar() \{}
\DoxyCodeLine{6075             getMutableRegistryHub().registerListener( std::make\_shared<ListenerFactory>() );}
\DoxyCodeLine{6076         \}}
\DoxyCodeLine{6077     \};}
\DoxyCodeLine{6078 \}}
\DoxyCodeLine{6079 }
\DoxyCodeLine{6080 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{6081 }
\DoxyCodeLine{6082 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_REPORTER( name, reporterType ) \(\backslash\)}}
\DoxyCodeLine{6083 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION         \(\backslash\)}}
\DoxyCodeLine{6084 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS          \(\backslash\)}}
\DoxyCodeLine{6085 \textcolor{preprocessor}{    namespace\{ Catch::ReporterRegistrar<reporterType> catch\_internal\_RegistrarFor\#\#reporterType( name ); \} \(\backslash\)}}
\DoxyCodeLine{6086 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{6087 }
\DoxyCodeLine{6088 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_LISTENER( listenerType ) \(\backslash\)}}
\DoxyCodeLine{6089 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION   \(\backslash\)}}
\DoxyCodeLine{6090 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS    \(\backslash\)}}
\DoxyCodeLine{6091 \textcolor{preprocessor}{    namespace\{ Catch::ListenerRegistrar<listenerType> catch\_internal\_RegistrarFor\#\#listenerType; \} \(\backslash\)}}
\DoxyCodeLine{6092 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{6093 \textcolor{preprocessor}{\#else }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{6094 }
\DoxyCodeLine{6095 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_REPORTER(name, reporterType)}}
\DoxyCodeLine{6096 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_LISTENER(listenerType)}}
\DoxyCodeLine{6097 }
\DoxyCodeLine{6098 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{6099 }
\DoxyCodeLine{6100 \textcolor{comment}{// end catch\_reporter\_registrars.hpp}}
\DoxyCodeLine{6101 \textcolor{comment}{// Allow users to base their work off existing reporters}}
\DoxyCodeLine{6102 \textcolor{comment}{// start catch\_reporter\_compact.h}}
\DoxyCodeLine{6103 }
\DoxyCodeLine{6104 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6105 }
\DoxyCodeLine{6106     \textcolor{keyword}{struct }CompactReporter : StreamingReporterBase<CompactReporter> \{}
\DoxyCodeLine{6107 }
\DoxyCodeLine{6108         \textcolor{keyword}{using} StreamingReporterBase::StreamingReporterBase;}
\DoxyCodeLine{6109 }
\DoxyCodeLine{6110         \string~CompactReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{6111 }
\DoxyCodeLine{6112         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{6113 }
\DoxyCodeLine{6114         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& spec) \textcolor{keyword}{override};}
\DoxyCodeLine{6115 }
\DoxyCodeLine{6116         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6117 }
\DoxyCodeLine{6118         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& \_assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6119 }
\DoxyCodeLine{6120         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6121 }
\DoxyCodeLine{6122         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& \_testRunStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6123 }
\DoxyCodeLine{6124     \};}
\DoxyCodeLine{6125 }
\DoxyCodeLine{6126 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6127 }
\DoxyCodeLine{6128 \textcolor{comment}{// end catch\_reporter\_compact.h}}
\DoxyCodeLine{6129 \textcolor{comment}{// start catch\_reporter\_console.h}}
\DoxyCodeLine{6130 }
\DoxyCodeLine{6131 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{6132 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{6133 \textcolor{preprocessor}{\#pragma warning(disable:4061) }\textcolor{comment}{// Not all labels are EXPLICITLY handled in switch}}
\DoxyCodeLine{6134                               \textcolor{comment}{// Note that 4062 (not all labels are handled}}
\DoxyCodeLine{6135                               \textcolor{comment}{// and default is missing) is enabled}}
\DoxyCodeLine{6136 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6137 }
\DoxyCodeLine{6138 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6139     \textcolor{comment}{// Fwd decls}}
\DoxyCodeLine{6140     \textcolor{keyword}{struct }SummaryColumn;}
\DoxyCodeLine{6141     \textcolor{keyword}{class }TablePrinter;}
\DoxyCodeLine{6142 }
\DoxyCodeLine{6143     \textcolor{keyword}{struct }ConsoleReporter : StreamingReporterBase<ConsoleReporter> \{}
\DoxyCodeLine{6144         std::unique\_ptr<TablePrinter> m\_tablePrinter;}
\DoxyCodeLine{6145 }
\DoxyCodeLine{6146         ConsoleReporter(ReporterConfig \textcolor{keyword}{const}\& config);}
\DoxyCodeLine{6147         \string~ConsoleReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{6148         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{6149 }
\DoxyCodeLine{6150         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& spec) \textcolor{keyword}{override};}
\DoxyCodeLine{6151 }
\DoxyCodeLine{6152         \textcolor{keywordtype}{void} reportInvalidArguments(std::string \textcolor{keyword}{const}\&arg) \textcolor{keyword}{override};}
\DoxyCodeLine{6153 }
\DoxyCodeLine{6154         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6155 }
\DoxyCodeLine{6156         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& \_assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6157 }
\DoxyCodeLine{6158         \textcolor{keywordtype}{void} sectionStarting(SectionInfo \textcolor{keyword}{const}\& \_sectionInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6159         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6160 }
\DoxyCodeLine{6161 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{6162         \textcolor{keywordtype}{void} benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \textcolor{keyword}{override};}
\DoxyCodeLine{6163         \textcolor{keywordtype}{void} benchmarkStarting(BenchmarkInfo \textcolor{keyword}{const}\& info) \textcolor{keyword}{override};}
\DoxyCodeLine{6164         \textcolor{keywordtype}{void} benchmarkEnded(BenchmarkStats<> \textcolor{keyword}{const}\& stats) \textcolor{keyword}{override};}
\DoxyCodeLine{6165         \textcolor{keywordtype}{void} benchmarkFailed(std::string \textcolor{keyword}{const}\& error) \textcolor{keyword}{override};}
\DoxyCodeLine{6166 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{6167 }
\DoxyCodeLine{6168         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& \_testCaseStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6169         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& \_testGroupStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6170         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& \_testRunStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6171         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& \_testRunInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6172     \textcolor{keyword}{private}:}
\DoxyCodeLine{6173 }
\DoxyCodeLine{6174         \textcolor{keywordtype}{void} lazyPrint();}
\DoxyCodeLine{6175 }
\DoxyCodeLine{6176         \textcolor{keywordtype}{void} lazyPrintWithoutClosingBenchmarkTable();}
\DoxyCodeLine{6177         \textcolor{keywordtype}{void} lazyPrintRunInfo();}
\DoxyCodeLine{6178         \textcolor{keywordtype}{void} lazyPrintGroupInfo();}
\DoxyCodeLine{6179         \textcolor{keywordtype}{void} printTestCaseAndSectionHeader();}
\DoxyCodeLine{6180 }
\DoxyCodeLine{6181         \textcolor{keywordtype}{void} printClosedHeader(std::string \textcolor{keyword}{const}\& \_name);}
\DoxyCodeLine{6182         \textcolor{keywordtype}{void} printOpenHeader(std::string \textcolor{keyword}{const}\& \_name);}
\DoxyCodeLine{6183 }
\DoxyCodeLine{6184         \textcolor{comment}{// if string has a : in first line will set indent to follow it on}}
\DoxyCodeLine{6185         \textcolor{comment}{// subsequent lines}}
\DoxyCodeLine{6186         \textcolor{keywordtype}{void} printHeaderString(std::string \textcolor{keyword}{const}\& \_string, std::size\_t indent = 0);}
\DoxyCodeLine{6187 }
\DoxyCodeLine{6188         \textcolor{keywordtype}{void} printTotals(Totals \textcolor{keyword}{const}\& totals);}
\DoxyCodeLine{6189         \textcolor{keywordtype}{void} printSummaryRow(std::string \textcolor{keyword}{const}\& label, std::vector<SummaryColumn> \textcolor{keyword}{const}\& cols, std::size\_t row);}
\DoxyCodeLine{6190 }
\DoxyCodeLine{6191         \textcolor{keywordtype}{void} printTotalsDivider(Totals \textcolor{keyword}{const}\& totals);}
\DoxyCodeLine{6192         \textcolor{keywordtype}{void} printSummaryDivider();}
\DoxyCodeLine{6193         \textcolor{keywordtype}{void} printTestFilters();}
\DoxyCodeLine{6194 }
\DoxyCodeLine{6195     \textcolor{keyword}{private}:}
\DoxyCodeLine{6196         \textcolor{keywordtype}{bool} m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{6197     \};}
\DoxyCodeLine{6198 }
\DoxyCodeLine{6199 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6200 }
\DoxyCodeLine{6201 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{6202 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{6203 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6204 }
\DoxyCodeLine{6205 \textcolor{comment}{// end catch\_reporter\_console.h}}
\DoxyCodeLine{6206 \textcolor{comment}{// start catch\_reporter\_junit.h}}
\DoxyCodeLine{6207 }
\DoxyCodeLine{6208 \textcolor{comment}{// start catch\_xmlwriter.h}}
\DoxyCodeLine{6209 }
\DoxyCodeLine{6210 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{6211 }
\DoxyCodeLine{6212 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6213     \textcolor{keyword}{enum class} XmlFormatting \{}
\DoxyCodeLine{6214         None = 0x00,}
\DoxyCodeLine{6215         Indent = 0x01,}
\DoxyCodeLine{6216         Newline = 0x02,}
\DoxyCodeLine{6217     \};}
\DoxyCodeLine{6218 }
\DoxyCodeLine{6219     XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs);}
\DoxyCodeLine{6220     XmlFormatting operator \& (XmlFormatting lhs, XmlFormatting rhs);}
\DoxyCodeLine{6221 }
\DoxyCodeLine{6222     \textcolor{keyword}{class }XmlEncode \{}
\DoxyCodeLine{6223     \textcolor{keyword}{public}:}
\DoxyCodeLine{6224         \textcolor{keyword}{enum} ForWhat \{ ForTextNodes, ForAttributes \};}
\DoxyCodeLine{6225 }
\DoxyCodeLine{6226         XmlEncode( std::string \textcolor{keyword}{const}\& str, ForWhat forWhat = ForTextNodes );}
\DoxyCodeLine{6227 }
\DoxyCodeLine{6228         \textcolor{keywordtype}{void} encodeTo( std::ostream\& os ) \textcolor{keyword}{const};}
\DoxyCodeLine{6229 }
\DoxyCodeLine{6230         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, XmlEncode \textcolor{keyword}{const}\& xmlEncode );}
\DoxyCodeLine{6231 }
\DoxyCodeLine{6232     \textcolor{keyword}{private}:}
\DoxyCodeLine{6233         std::string m\_str;}
\DoxyCodeLine{6234         ForWhat m\_forWhat;}
\DoxyCodeLine{6235     \};}
\DoxyCodeLine{6236 }
\DoxyCodeLine{6237     \textcolor{keyword}{class }XmlWriter \{}
\DoxyCodeLine{6238     \textcolor{keyword}{public}:}
\DoxyCodeLine{6239 }
\DoxyCodeLine{6240         \textcolor{keyword}{class }ScopedElement \{}
\DoxyCodeLine{6241         \textcolor{keyword}{public}:}
\DoxyCodeLine{6242             ScopedElement( XmlWriter* \mbox{\hyperlink{classbasic__writer}{writer}}, XmlFormatting fmt );}
\DoxyCodeLine{6243 }
\DoxyCodeLine{6244             ScopedElement( ScopedElement\&\& other ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{6245             ScopedElement\& operator=( ScopedElement\&\& other ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{6246 }
\DoxyCodeLine{6247             \string~ScopedElement();}
\DoxyCodeLine{6248 }
\DoxyCodeLine{6249             ScopedElement\& writeText( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent );}
\DoxyCodeLine{6250 }
\DoxyCodeLine{6251             \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6252             ScopedElement\& writeAttribute( std::string \textcolor{keyword}{const}\& name, T \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{6253                 m\_writer-\/>writeAttribute( name, attribute );}
\DoxyCodeLine{6254                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{6255             \}}
\DoxyCodeLine{6256 }
\DoxyCodeLine{6257         \textcolor{keyword}{private}:}
\DoxyCodeLine{6258             \textcolor{keyword}{mutable} XmlWriter* m\_writer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{6259             XmlFormatting m\_fmt;}
\DoxyCodeLine{6260         \};}
\DoxyCodeLine{6261 }
\DoxyCodeLine{6262         XmlWriter( std::ostream\& os = Catch::cout() );}
\DoxyCodeLine{6263         \string~XmlWriter();}
\DoxyCodeLine{6264 }
\DoxyCodeLine{6265         XmlWriter( XmlWriter \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6266         XmlWriter\& operator=( XmlWriter \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6267 }
\DoxyCodeLine{6268         XmlWriter\& startElement( std::string \textcolor{keyword}{const}\& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6269 }
\DoxyCodeLine{6270         ScopedElement scopedElement( std::string \textcolor{keyword}{const}\& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6271 }
\DoxyCodeLine{6272         XmlWriter\& endElement(XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6273 }
\DoxyCodeLine{6274         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& attribute );}
\DoxyCodeLine{6275 }
\DoxyCodeLine{6276         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, \textcolor{keywordtype}{bool} attribute );}
\DoxyCodeLine{6277 }
\DoxyCodeLine{6278         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6279         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, T \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{6280             ReusableStringStream rss;}
\DoxyCodeLine{6281             rss << attribute;}
\DoxyCodeLine{6282             \textcolor{keywordflow}{return} writeAttribute( name, rss.str() );}
\DoxyCodeLine{6283         \}}
\DoxyCodeLine{6284 }
\DoxyCodeLine{6285         XmlWriter\& writeText( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6286 }
\DoxyCodeLine{6287         XmlWriter\& writeComment(std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6288 }
\DoxyCodeLine{6289         \textcolor{keywordtype}{void} writeStylesheetRef( std::string \textcolor{keyword}{const}\& url );}
\DoxyCodeLine{6290 }
\DoxyCodeLine{6291         XmlWriter\& writeBlankLine();}
\DoxyCodeLine{6292 }
\DoxyCodeLine{6293         \textcolor{keywordtype}{void} ensureTagClosed();}
\DoxyCodeLine{6294 }
\DoxyCodeLine{6295     \textcolor{keyword}{private}:}
\DoxyCodeLine{6296 }
\DoxyCodeLine{6297         \textcolor{keywordtype}{void} applyFormatting(XmlFormatting fmt);}
\DoxyCodeLine{6298 }
\DoxyCodeLine{6299         \textcolor{keywordtype}{void} writeDeclaration();}
\DoxyCodeLine{6300 }
\DoxyCodeLine{6301         \textcolor{keywordtype}{void} newlineIfNecessary();}
\DoxyCodeLine{6302 }
\DoxyCodeLine{6303         \textcolor{keywordtype}{bool} m\_tagIsOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{6304         \textcolor{keywordtype}{bool} m\_needsNewline = \textcolor{keyword}{false};}
\DoxyCodeLine{6305         std::vector<std::string> m\_tags;}
\DoxyCodeLine{6306         std::string m\_indent;}
\DoxyCodeLine{6307         std::ostream\& m\_os;}
\DoxyCodeLine{6308     \};}
\DoxyCodeLine{6309 }
\DoxyCodeLine{6310 \}}
\DoxyCodeLine{6311 }
\DoxyCodeLine{6312 \textcolor{comment}{// end catch\_xmlwriter.h}}
\DoxyCodeLine{6313 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6314 }
\DoxyCodeLine{6315     \textcolor{keyword}{class }JunitReporter : \textcolor{keyword}{public} CumulativeReporterBase<JunitReporter> \{}
\DoxyCodeLine{6316     \textcolor{keyword}{public}:}
\DoxyCodeLine{6317         JunitReporter(ReporterConfig \textcolor{keyword}{const}\& \_config);}
\DoxyCodeLine{6318 }
\DoxyCodeLine{6319         \string~JunitReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{6320 }
\DoxyCodeLine{6321         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{6322 }
\DoxyCodeLine{6323         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& \textcolor{comment}{/*spec*/}) \textcolor{keyword}{override};}
\DoxyCodeLine{6324 }
\DoxyCodeLine{6325         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& runInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6326 }
\DoxyCodeLine{6327         \textcolor{keywordtype}{void} testGroupStarting(GroupInfo \textcolor{keyword}{const}\& groupInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6328 }
\DoxyCodeLine{6329         \textcolor{keywordtype}{void} testCaseStarting(TestCaseInfo \textcolor{keyword}{const}\& testCaseInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6330         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6331 }
\DoxyCodeLine{6332         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& testCaseStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6333 }
\DoxyCodeLine{6334         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& testGroupStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6335 }
\DoxyCodeLine{6336         \textcolor{keywordtype}{void} testRunEndedCumulative() \textcolor{keyword}{override};}
\DoxyCodeLine{6337 }
\DoxyCodeLine{6338         \textcolor{keywordtype}{void} writeGroup(TestGroupNode \textcolor{keyword}{const}\& groupNode, \textcolor{keywordtype}{double} suiteTime);}
\DoxyCodeLine{6339 }
\DoxyCodeLine{6340         \textcolor{keywordtype}{void} writeTestCase(TestCaseNode \textcolor{keyword}{const}\& testCaseNode);}
\DoxyCodeLine{6341 }
\DoxyCodeLine{6342         \textcolor{keywordtype}{void} writeSection(std::string \textcolor{keyword}{const}\& className,}
\DoxyCodeLine{6343                           std::string \textcolor{keyword}{const}\& rootName,}
\DoxyCodeLine{6344                           SectionNode \textcolor{keyword}{const}\& sectionNode);}
\DoxyCodeLine{6345 }
\DoxyCodeLine{6346         \textcolor{keywordtype}{void} writeAssertions(SectionNode \textcolor{keyword}{const}\& sectionNode);}
\DoxyCodeLine{6347         \textcolor{keywordtype}{void} writeAssertion(AssertionStats \textcolor{keyword}{const}\& stats);}
\DoxyCodeLine{6348 }
\DoxyCodeLine{6349         XmlWriter xml;}
\DoxyCodeLine{6350         Timer suiteTimer;}
\DoxyCodeLine{6351         std::string stdOutForSuite;}
\DoxyCodeLine{6352         std::string stdErrForSuite;}
\DoxyCodeLine{6353         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} unexpectedExceptions = 0;}
\DoxyCodeLine{6354         \textcolor{keywordtype}{bool} m\_okToFail = \textcolor{keyword}{false};}
\DoxyCodeLine{6355     \};}
\DoxyCodeLine{6356 }
\DoxyCodeLine{6357 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6358 }
\DoxyCodeLine{6359 \textcolor{comment}{// end catch\_reporter\_junit.h}}
\DoxyCodeLine{6360 \textcolor{comment}{// start catch\_reporter\_xml.h}}
\DoxyCodeLine{6361 }
\DoxyCodeLine{6362 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6363     \textcolor{keyword}{class }XmlReporter : \textcolor{keyword}{public} StreamingReporterBase<XmlReporter> \{}
\DoxyCodeLine{6364     \textcolor{keyword}{public}:}
\DoxyCodeLine{6365         XmlReporter(ReporterConfig \textcolor{keyword}{const}\& \_config);}
\DoxyCodeLine{6366 }
\DoxyCodeLine{6367         \string~XmlReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{6368 }
\DoxyCodeLine{6369         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{6370 }
\DoxyCodeLine{6371         \textcolor{keyword}{virtual} std::string getStylesheetRef() \textcolor{keyword}{const};}
\DoxyCodeLine{6372 }
\DoxyCodeLine{6373         \textcolor{keywordtype}{void} writeSourceInfo(SourceLineInfo \textcolor{keyword}{const}\& sourceInfo);}
\DoxyCodeLine{6374 }
\DoxyCodeLine{6375     \textcolor{keyword}{public}: \textcolor{comment}{// StreamingReporterBase}}
\DoxyCodeLine{6376 }
\DoxyCodeLine{6377         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& s) \textcolor{keyword}{override};}
\DoxyCodeLine{6378 }
\DoxyCodeLine{6379         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& testInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6380 }
\DoxyCodeLine{6381         \textcolor{keywordtype}{void} testGroupStarting(GroupInfo \textcolor{keyword}{const}\& groupInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6382 }
\DoxyCodeLine{6383         \textcolor{keywordtype}{void} testCaseStarting(TestCaseInfo \textcolor{keyword}{const}\& testInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6384 }
\DoxyCodeLine{6385         \textcolor{keywordtype}{void} sectionStarting(SectionInfo \textcolor{keyword}{const}\& sectionInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6386 }
\DoxyCodeLine{6387         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6388 }
\DoxyCodeLine{6389         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6390 }
\DoxyCodeLine{6391         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& sectionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6392 }
\DoxyCodeLine{6393         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& testCaseStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6394 }
\DoxyCodeLine{6395         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& testGroupStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6396 }
\DoxyCodeLine{6397         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& testRunStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6398 }
\DoxyCodeLine{6399 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{6400         \textcolor{keywordtype}{void} benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \textcolor{keyword}{override};}
\DoxyCodeLine{6401         \textcolor{keywordtype}{void} benchmarkStarting(BenchmarkInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6402         \textcolor{keywordtype}{void} benchmarkEnded(BenchmarkStats<> \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6403         \textcolor{keywordtype}{void} benchmarkFailed(std::string \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6404 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{6405 }
\DoxyCodeLine{6406     \textcolor{keyword}{private}:}
\DoxyCodeLine{6407         Timer m\_testCaseTimer;}
\DoxyCodeLine{6408         XmlWriter m\_xml;}
\DoxyCodeLine{6409         \textcolor{keywordtype}{int} m\_sectionDepth = 0;}
\DoxyCodeLine{6410     \};}
\DoxyCodeLine{6411 }
\DoxyCodeLine{6412 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6413 }
\DoxyCodeLine{6414 \textcolor{comment}{// end catch\_reporter\_xml.h}}
\DoxyCodeLine{6415 }
\DoxyCodeLine{6416 \textcolor{comment}{// end catch\_external\_interfaces.h}}
\DoxyCodeLine{6417 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6418 }
\DoxyCodeLine{6419 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{6420 \textcolor{comment}{// start catch\_benchmarking\_all.hpp}}
\DoxyCodeLine{6421 }
\DoxyCodeLine{6422 \textcolor{comment}{// A proxy header that includes all of the benchmarking headers to allow}}
\DoxyCodeLine{6423 \textcolor{comment}{// concise include of the benchmarking features. You should prefer the}}
\DoxyCodeLine{6424 \textcolor{comment}{// individual includes in standard use.}}
\DoxyCodeLine{6425 }
\DoxyCodeLine{6426 \textcolor{comment}{// start catch\_benchmark.hpp}}
\DoxyCodeLine{6427 }
\DoxyCodeLine{6428  \textcolor{comment}{// Benchmark}}
\DoxyCodeLine{6429 }
\DoxyCodeLine{6430 \textcolor{comment}{// start catch\_chronometer.hpp}}
\DoxyCodeLine{6431 }
\DoxyCodeLine{6432 \textcolor{comment}{// User-\/facing chronometer}}
\DoxyCodeLine{6433 }
\DoxyCodeLine{6434 }
\DoxyCodeLine{6435 \textcolor{comment}{// start catch\_clock.hpp}}
\DoxyCodeLine{6436 }
\DoxyCodeLine{6437 \textcolor{comment}{// Clocks}}
\DoxyCodeLine{6438 }
\DoxyCodeLine{6439 }
\DoxyCodeLine{6440 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{6441 \textcolor{preprocessor}{\#include <ratio>}}
\DoxyCodeLine{6442 }
\DoxyCodeLine{6443 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6444     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6445         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6446         \textcolor{keyword}{using} ClockDuration = \textcolor{keyword}{typename} Clock::duration;}
\DoxyCodeLine{6447         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6448         \textcolor{keyword}{using} FloatDuration = std::chrono::duration<double, typename Clock::period>;}
\DoxyCodeLine{6449 }
\DoxyCodeLine{6450         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6451         \textcolor{keyword}{using} TimePoint = \textcolor{keyword}{typename} Clock::time\_point;}
\DoxyCodeLine{6452 }
\DoxyCodeLine{6453         \textcolor{keyword}{using} default\_clock = std::chrono::steady\_clock;}
\DoxyCodeLine{6454 }
\DoxyCodeLine{6455         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6456         \textcolor{keyword}{struct }now \{}
\DoxyCodeLine{6457             TimePoint<Clock> operator()()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6458                 \textcolor{keywordflow}{return} Clock::now();}
\DoxyCodeLine{6459             \}}
\DoxyCodeLine{6460         \};}
\DoxyCodeLine{6461 }
\DoxyCodeLine{6462         \textcolor{keyword}{using} fp\_seconds = std::chrono::duration<double, std::ratio<1>>;}
\DoxyCodeLine{6463     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6464 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6465 }
\DoxyCodeLine{6466 \textcolor{comment}{// end catch\_clock.hpp}}
\DoxyCodeLine{6467 \textcolor{comment}{// start catch\_optimizer.hpp}}
\DoxyCodeLine{6468 }
\DoxyCodeLine{6469  \textcolor{comment}{// Hinting the optimizer}}
\DoxyCodeLine{6470 }
\DoxyCodeLine{6471 }
\DoxyCodeLine{6472 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{6473 \textcolor{preprocessor}{\#   include <atomic>} \textcolor{comment}{// atomic\_thread\_fence}}
\DoxyCodeLine{6474 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6475 }
\DoxyCodeLine{6476 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6477     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6478 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) || defined(\_\_clang\_\_)}}
\DoxyCodeLine{6479         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6480         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} keep\_memory(T* p) \{}
\DoxyCodeLine{6481             \textcolor{keyword}{asm} \textcolor{keyword}{volatile}(\textcolor{stringliteral}{"{}"{}} : : \textcolor{stringliteral}{"{}g"{}}(p) : \textcolor{stringliteral}{"{}memory"{}});}
\DoxyCodeLine{6482         \}}
\DoxyCodeLine{6483         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} keep\_memory() \{}
\DoxyCodeLine{6484             \textcolor{keyword}{asm} \textcolor{keyword}{volatile}(\textcolor{stringliteral}{"{}"{}} : : : \textcolor{stringliteral}{"{}memory"{}});}
\DoxyCodeLine{6485         \}}
\DoxyCodeLine{6486 }
\DoxyCodeLine{6487         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6488             \textcolor{keyword}{inline} \textcolor{keywordtype}{void} optimizer\_barrier() \{ keep\_memory(); \}}
\DoxyCodeLine{6489         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6490 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{6491 }
\DoxyCodeLine{6492 \textcolor{preprocessor}{\#pragma optimize("{}"{}}, off)}
\DoxyCodeLine{6493         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6494         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} keep\_memory(T* p) \{}
\DoxyCodeLine{6495             \textcolor{comment}{// thanks @milleniumbug}}
\DoxyCodeLine{6496             *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} volatile*\textcolor{keyword}{>}(p) = *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} \textcolor{keyword}{const }volatile*\textcolor{keyword}{>}(p);}
\DoxyCodeLine{6497         \}}
\DoxyCodeLine{6498         \textcolor{comment}{// TODO equivalent keep\_memory()}}
\DoxyCodeLine{6499 \textcolor{preprocessor}{\#pragma optimize("{}"{}}, on)}
\DoxyCodeLine{6500 }
\DoxyCodeLine{6501         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6502             \textcolor{keyword}{inline} \textcolor{keywordtype}{void} optimizer\_barrier() \{}
\DoxyCodeLine{6503                 std::atomic\_thread\_fence(std::memory\_order\_seq\_cst);}
\DoxyCodeLine{6504             \}}
\DoxyCodeLine{6505         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6506 }
\DoxyCodeLine{6507 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6508 }
\DoxyCodeLine{6509         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6510         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} deoptimize\_value(T\&\& x) \{}
\DoxyCodeLine{6511             keep\_memory(\&x);}
\DoxyCodeLine{6512         \}}
\DoxyCodeLine{6513 }
\DoxyCodeLine{6514         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fn, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6515         \textcolor{keyword}{inline} \textcolor{keyword}{auto} invoke\_deoptimized(Fn\&\& fn, Args\&\&... args) -\/> \textcolor{keyword}{typename} std::enable\_if<!std::is\_same<void, \textcolor{keyword}{decltype}(fn(args...))>::value>::type \{}
\DoxyCodeLine{6516             deoptimize\_value(std::forward<Fn>(fn) (std::forward<Args...>(args...)));}
\DoxyCodeLine{6517         \}}
\DoxyCodeLine{6518 }
\DoxyCodeLine{6519         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fn, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6520         \textcolor{keyword}{inline} \textcolor{keyword}{auto} invoke\_deoptimized(Fn\&\& fn, Args\&\&... args) -\/> \textcolor{keyword}{typename} std::enable\_if<std::is\_same<void, \textcolor{keyword}{decltype}(fn(args...))>::value>::type \{}
\DoxyCodeLine{6521             std::forward<Fn>(fn) (std::forward<Args...>(args...));}
\DoxyCodeLine{6522         \}}
\DoxyCodeLine{6523     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6524 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6525 }
\DoxyCodeLine{6526 \textcolor{comment}{// end catch\_optimizer.hpp}}
\DoxyCodeLine{6527 \textcolor{comment}{// start catch\_complete\_invoke.hpp}}
\DoxyCodeLine{6528 }
\DoxyCodeLine{6529 \textcolor{comment}{// Invoke with a special case for void}}
\DoxyCodeLine{6530 }
\DoxyCodeLine{6531 }
\DoxyCodeLine{6532 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6533 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6534 }
\DoxyCodeLine{6535 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6536     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6537         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6538             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6539             \textcolor{keyword}{struct }CompleteType \{ \textcolor{keyword}{using} type = T; \};}
\DoxyCodeLine{6540             \textcolor{keyword}{template} <>}
\DoxyCodeLine{6541             \textcolor{keyword}{struct }CompleteType<void> \{ \textcolor{keyword}{struct }type \{\}; \};}
\DoxyCodeLine{6542 }
\DoxyCodeLine{6543             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6544             \textcolor{keyword}{using} CompleteType\_t = \textcolor{keyword}{typename} CompleteType<T>::type;}
\DoxyCodeLine{6545 }
\DoxyCodeLine{6546             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result>}
\DoxyCodeLine{6547             \textcolor{keyword}{struct }CompleteInvoker \{}
\DoxyCodeLine{6548                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6549                 \textcolor{keyword}{static} Result invoke(Fun\&\& fun, Args\&\&... args) \{}
\DoxyCodeLine{6550                     \textcolor{keywordflow}{return} std::forward<Fun>(fun)(std::forward<Args>(args)...);}
\DoxyCodeLine{6551                 \}}
\DoxyCodeLine{6552             \};}
\DoxyCodeLine{6553             \textcolor{keyword}{template} <>}
\DoxyCodeLine{6554             \textcolor{keyword}{struct }CompleteInvoker<void> \{}
\DoxyCodeLine{6555                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6556                 \textcolor{keyword}{static} CompleteType\_t<void> invoke(Fun\&\& fun, Args\&\&... args) \{}
\DoxyCodeLine{6557                     std::forward<Fun>(fun)(std::forward<Args>(args)...);}
\DoxyCodeLine{6558                     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{6559                 \}}
\DoxyCodeLine{6560             \};}
\DoxyCodeLine{6561 }
\DoxyCodeLine{6562             \textcolor{comment}{// invoke and not return void :(}}
\DoxyCodeLine{6563             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6564             CompleteType\_t<FunctionReturnType<Fun, Args...>> complete\_invoke(Fun\&\& fun, Args\&\&... args) \{}
\DoxyCodeLine{6565                 \textcolor{keywordflow}{return} CompleteInvoker<FunctionReturnType<Fun, Args...>>::invoke(std::forward<Fun>(fun), std::forward<Args>(args)...);}
\DoxyCodeLine{6566             \}}
\DoxyCodeLine{6567 }
\DoxyCodeLine{6568             \textcolor{keyword}{const} std::string benchmarkErrorMsg = \textcolor{stringliteral}{"{}a benchmark failed to run successfully"{}};}
\DoxyCodeLine{6569         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6570 }
\DoxyCodeLine{6571         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6572         Detail::CompleteType\_t<FunctionReturnType<Fun>> user\_code(Fun\&\& fun) \{}
\DoxyCodeLine{6573             CATCH\_TRY\{}
\DoxyCodeLine{6574                 \textcolor{keywordflow}{return} Detail::complete\_invoke(std::forward<Fun>(fun));}
\DoxyCodeLine{6575             \} CATCH\_CATCH\_ALL\{}
\DoxyCodeLine{6576                 getResultCapture().benchmarkFailed(translateActiveException());}
\DoxyCodeLine{6577                 CATCH\_RUNTIME\_ERROR(Detail::benchmarkErrorMsg);}
\DoxyCodeLine{6578             \}}
\DoxyCodeLine{6579         \}}
\DoxyCodeLine{6580     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6581 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6582 }
\DoxyCodeLine{6583 \textcolor{comment}{// end catch\_complete\_invoke.hpp}}
\DoxyCodeLine{6584 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6585     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6586         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6587             \textcolor{keyword}{struct }ChronometerConcept \{}
\DoxyCodeLine{6588                 \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} start() = 0;}
\DoxyCodeLine{6589                 \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} finish() = 0;}
\DoxyCodeLine{6590                 \textcolor{keyword}{virtual} \string~ChronometerConcept() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{6591             \};}
\DoxyCodeLine{6592             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6593             \textcolor{keyword}{struct }ChronometerModel final : \textcolor{keyword}{public} ChronometerConcept \{}
\DoxyCodeLine{6594                 \textcolor{keywordtype}{void} start()\textcolor{keyword}{ override }\{ started = Clock::now(); \}}
\DoxyCodeLine{6595                 \textcolor{keywordtype}{void} finish()\textcolor{keyword}{ override }\{ finished = Clock::now(); \}}
\DoxyCodeLine{6596 }
\DoxyCodeLine{6597                 ClockDuration<Clock> elapsed()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} finished -\/ started; \}}
\DoxyCodeLine{6598 }
\DoxyCodeLine{6599                 TimePoint<Clock> started;}
\DoxyCodeLine{6600                 TimePoint<Clock> finished;}
\DoxyCodeLine{6601             \};}
\DoxyCodeLine{6602         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6603 }
\DoxyCodeLine{6604         \textcolor{keyword}{struct }Chronometer \{}
\DoxyCodeLine{6605         \textcolor{keyword}{public}:}
\DoxyCodeLine{6606             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6607             \textcolor{keywordtype}{void} measure(Fun\&\& fun) \{ measure(std::forward<Fun>(fun), is\_callable<Fun(\textcolor{keywordtype}{int})>()); \}}
\DoxyCodeLine{6608 }
\DoxyCodeLine{6609             \textcolor{keywordtype}{int} runs()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} k; \}}
\DoxyCodeLine{6610 }
\DoxyCodeLine{6611             Chronometer(Detail::ChronometerConcept\& meter, \textcolor{keywordtype}{int} k)}
\DoxyCodeLine{6612                 : impl(\&meter)}
\DoxyCodeLine{6613                 , k(k) \{\}}
\DoxyCodeLine{6614 }
\DoxyCodeLine{6615         \textcolor{keyword}{private}:}
\DoxyCodeLine{6616             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6617             \textcolor{keywordtype}{void} measure(Fun\&\& fun, std::false\_type) \{}
\DoxyCodeLine{6618                 measure([\&fun](\textcolor{keywordtype}{int}) \{ \textcolor{keywordflow}{return} fun(); \}, std::true\_type());}
\DoxyCodeLine{6619             \}}
\DoxyCodeLine{6620 }
\DoxyCodeLine{6621             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6622             \textcolor{keywordtype}{void} measure(Fun\&\& fun, std::true\_type) \{}
\DoxyCodeLine{6623                 Detail::optimizer\_barrier();}
\DoxyCodeLine{6624                 impl-\/>start();}
\DoxyCodeLine{6625                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < k; ++i) invoke\_deoptimized(fun, i);}
\DoxyCodeLine{6626                 impl-\/>finish();}
\DoxyCodeLine{6627                 Detail::optimizer\_barrier();}
\DoxyCodeLine{6628             \}}
\DoxyCodeLine{6629 }
\DoxyCodeLine{6630             Detail::ChronometerConcept* impl;}
\DoxyCodeLine{6631             \textcolor{keywordtype}{int} k;}
\DoxyCodeLine{6632         \};}
\DoxyCodeLine{6633     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6634 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6635 }
\DoxyCodeLine{6636 \textcolor{comment}{// end catch\_chronometer.hpp}}
\DoxyCodeLine{6637 \textcolor{comment}{// start catch\_environment.hpp}}
\DoxyCodeLine{6638 }
\DoxyCodeLine{6639 \textcolor{comment}{// Environment information}}
\DoxyCodeLine{6640 }
\DoxyCodeLine{6641 }
\DoxyCodeLine{6642 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6643     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6644         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{6645         \textcolor{keyword}{struct }EnvironmentEstimate \{}
\DoxyCodeLine{6646             Duration mean;}
\DoxyCodeLine{6647             OutlierClassification outliers;}
\DoxyCodeLine{6648 }
\DoxyCodeLine{6649             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{6650             \textcolor{keyword}{operator} EnvironmentEstimate<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6651                 \textcolor{keywordflow}{return} \{ mean, outliers \};}
\DoxyCodeLine{6652             \}}
\DoxyCodeLine{6653         \};}
\DoxyCodeLine{6654         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6655         \textcolor{keyword}{struct }Environment \{}
\DoxyCodeLine{6656             \textcolor{keyword}{using} clock\_type = Clock;}
\DoxyCodeLine{6657             EnvironmentEstimate<FloatDuration<Clock>> clock\_resolution;}
\DoxyCodeLine{6658             EnvironmentEstimate<FloatDuration<Clock>> clock\_cost;}
\DoxyCodeLine{6659         \};}
\DoxyCodeLine{6660     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6661 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6662 }
\DoxyCodeLine{6663 \textcolor{comment}{// end catch\_environment.hpp}}
\DoxyCodeLine{6664 \textcolor{comment}{// start catch\_execution\_plan.hpp}}
\DoxyCodeLine{6665 }
\DoxyCodeLine{6666  \textcolor{comment}{// Execution plan}}
\DoxyCodeLine{6667 }
\DoxyCodeLine{6668 }
\DoxyCodeLine{6669 \textcolor{comment}{// start catch\_benchmark\_function.hpp}}
\DoxyCodeLine{6670 }
\DoxyCodeLine{6671  \textcolor{comment}{// Dumb std::function implementation for consistent call overhead}}
\DoxyCodeLine{6672 }
\DoxyCodeLine{6673 }
\DoxyCodeLine{6674 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{6675 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6676 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6677 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{6678 }
\DoxyCodeLine{6679 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6680     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6681         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6682             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6683             \textcolor{keyword}{using} Decay = \textcolor{keyword}{typename} std::decay<T>::type;}
\DoxyCodeLine{6684             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{6685             \textcolor{keyword}{struct }is\_related}
\DoxyCodeLine{6686                 : std::is\_same<Decay<T>, Decay<U>> \{\};}
\DoxyCodeLine{6687 }
\DoxyCodeLine{6695             \textcolor{keyword}{struct }BenchmarkFunction \{}
\DoxyCodeLine{6696             \textcolor{keyword}{private}:}
\DoxyCodeLine{6697                 \textcolor{keyword}{struct }callable \{}
\DoxyCodeLine{6698                     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} call(Chronometer meter) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{6699                     \textcolor{keyword}{virtual} callable* clone() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{6700                     \textcolor{keyword}{virtual} \string~callable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{6701                 \};}
\DoxyCodeLine{6702                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6703                 \textcolor{keyword}{struct }model : \textcolor{keyword}{public} callable \{}
\DoxyCodeLine{6704                     model(Fun\&\& fun) : fun(std::move(fun)) \{\}}
\DoxyCodeLine{6705                     model(Fun \textcolor{keyword}{const}\& fun) : fun(fun) \{\}}
\DoxyCodeLine{6706 }
\DoxyCodeLine{6707                     model<Fun>* clone()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{new} model<Fun>(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{6708 }
\DoxyCodeLine{6709                     \textcolor{keywordtype}{void} call(Chronometer meter)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6710                         call(meter, is\_callable<Fun(Chronometer)>());}
\DoxyCodeLine{6711                     \}}
\DoxyCodeLine{6712                     \textcolor{keywordtype}{void} call(Chronometer meter, std::true\_type)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6713                         fun(meter);}
\DoxyCodeLine{6714                     \}}
\DoxyCodeLine{6715                     \textcolor{keywordtype}{void} call(Chronometer meter, std::false\_type)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6716                         meter.measure(fun);}
\DoxyCodeLine{6717                     \}}
\DoxyCodeLine{6718 }
\DoxyCodeLine{6719                     Fun fun;}
\DoxyCodeLine{6720                 \};}
\DoxyCodeLine{6721 }
\DoxyCodeLine{6722                 \textcolor{keyword}{struct }do\_nothing \{ \textcolor{keywordtype}{void} operator()()\textcolor{keyword}{ const }\{\} \};}
\DoxyCodeLine{6723 }
\DoxyCodeLine{6724                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6725                 BenchmarkFunction(model<T>* c) : f(c) \{\}}
\DoxyCodeLine{6726 }
\DoxyCodeLine{6727             \textcolor{keyword}{public}:}
\DoxyCodeLine{6728                 BenchmarkFunction()}
\DoxyCodeLine{6729                     : f(new model<do\_nothing>\{ \{\} \}) \{\}}
\DoxyCodeLine{6730 }
\DoxyCodeLine{6731                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun,}
\DoxyCodeLine{6732                     \textcolor{keyword}{typename} std::enable\_if<!is\_related<Fun, BenchmarkFunction>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{6733                     BenchmarkFunction(Fun\&\& fun)}
\DoxyCodeLine{6734                     : f(new model<typename std::decay<Fun>::type>(std::forward<Fun>(fun))) \{\}}
\DoxyCodeLine{6735 }
\DoxyCodeLine{6736                 BenchmarkFunction(BenchmarkFunction\&\& that)}
\DoxyCodeLine{6737                     : f(std::move(that.f)) \{\}}
\DoxyCodeLine{6738 }
\DoxyCodeLine{6739                 BenchmarkFunction(BenchmarkFunction \textcolor{keyword}{const}\& that)}
\DoxyCodeLine{6740                     : f(that.f-\/>clone()) \{\}}
\DoxyCodeLine{6741 }
\DoxyCodeLine{6742                 BenchmarkFunction\& operator=(BenchmarkFunction\&\& that) \{}
\DoxyCodeLine{6743                     f = std::move(that.f);}
\DoxyCodeLine{6744                     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{6745                 \}}
\DoxyCodeLine{6746 }
\DoxyCodeLine{6747                 BenchmarkFunction\& operator=(BenchmarkFunction \textcolor{keyword}{const}\& that) \{}
\DoxyCodeLine{6748                     f.reset(that.f-\/>clone());}
\DoxyCodeLine{6749                     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{6750                 \}}
\DoxyCodeLine{6751 }
\DoxyCodeLine{6752                 \textcolor{keywordtype}{void} operator()(Chronometer meter)\textcolor{keyword}{ const }\{ f-\/>call(meter); \}}
\DoxyCodeLine{6753 }
\DoxyCodeLine{6754             \textcolor{keyword}{private}:}
\DoxyCodeLine{6755                 std::unique\_ptr<callable> f;}
\DoxyCodeLine{6756             \};}
\DoxyCodeLine{6757         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6758     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6759 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6760 }
\DoxyCodeLine{6761 \textcolor{comment}{// end catch\_benchmark\_function.hpp}}
\DoxyCodeLine{6762 \textcolor{comment}{// start catch\_repeat.hpp}}
\DoxyCodeLine{6763 }
\DoxyCodeLine{6764 \textcolor{comment}{// repeat algorithm}}
\DoxyCodeLine{6765 }
\DoxyCodeLine{6766 }
\DoxyCodeLine{6767 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6768 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6769 }
\DoxyCodeLine{6770 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6771     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6772         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6773             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6774             \textcolor{keyword}{struct }repeater \{}
\DoxyCodeLine{6775                 \textcolor{keywordtype}{void} operator()(\textcolor{keywordtype}{int} k)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6776                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < k; ++i) \{}
\DoxyCodeLine{6777                         fun();}
\DoxyCodeLine{6778                     \}}
\DoxyCodeLine{6779                 \}}
\DoxyCodeLine{6780                 Fun fun;}
\DoxyCodeLine{6781             \};}
\DoxyCodeLine{6782             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6783             repeater<typename std::decay<Fun>::type> repeat(Fun\&\& fun) \{}
\DoxyCodeLine{6784                 \textcolor{keywordflow}{return} \{ std::forward<Fun>(fun) \};}
\DoxyCodeLine{6785             \}}
\DoxyCodeLine{6786         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6787     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6788 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6789 }
\DoxyCodeLine{6790 \textcolor{comment}{// end catch\_repeat.hpp}}
\DoxyCodeLine{6791 \textcolor{comment}{// start catch\_run\_for\_at\_least.hpp}}
\DoxyCodeLine{6792 }
\DoxyCodeLine{6793 \textcolor{comment}{// Run a function for a minimum amount of time}}
\DoxyCodeLine{6794 }
\DoxyCodeLine{6795 }
\DoxyCodeLine{6796 \textcolor{comment}{// start catch\_measure.hpp}}
\DoxyCodeLine{6797 }
\DoxyCodeLine{6798 \textcolor{comment}{// Measure}}
\DoxyCodeLine{6799 }
\DoxyCodeLine{6800 }
\DoxyCodeLine{6801 \textcolor{comment}{// start catch\_timing.hpp}}
\DoxyCodeLine{6802 }
\DoxyCodeLine{6803 \textcolor{comment}{// Timing}}
\DoxyCodeLine{6804 }
\DoxyCodeLine{6805 }
\DoxyCodeLine{6806 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{6807 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6808 }
\DoxyCodeLine{6809 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6810     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6811         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration, \textcolor{keyword}{typename} Result>}
\DoxyCodeLine{6812         \textcolor{keyword}{struct }Timing \{}
\DoxyCodeLine{6813             Duration elapsed;}
\DoxyCodeLine{6814             Result result;}
\DoxyCodeLine{6815             \textcolor{keywordtype}{int} iterations;}
\DoxyCodeLine{6816         \};}
\DoxyCodeLine{6817         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Func, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6818         \textcolor{keyword}{using} TimingOf = Timing<ClockDuration<Clock>, Detail::CompleteType\_t<FunctionReturnType<Func, Args...>>>;}
\DoxyCodeLine{6819     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6820 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6821 }
\DoxyCodeLine{6822 \textcolor{comment}{// end catch\_timing.hpp}}
\DoxyCodeLine{6823 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6824 }
\DoxyCodeLine{6825 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6826     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6827         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6828             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6829             TimingOf<Clock, Fun, Args...> measure(Fun\&\& fun, Args\&\&... args) \{}
\DoxyCodeLine{6830                 \textcolor{keyword}{auto} start = Clock::now();}
\DoxyCodeLine{6831                 \textcolor{keyword}{auto}\&\& r = Detail::complete\_invoke(fun, std::forward<Args>(args)...);}
\DoxyCodeLine{6832                 \textcolor{keyword}{auto} end = Clock::now();}
\DoxyCodeLine{6833                 \textcolor{keyword}{auto} delta = end -\/ start;}
\DoxyCodeLine{6834                 \textcolor{keywordflow}{return} \{ delta, std::forward<decltype(r)>(r), 1 \};}
\DoxyCodeLine{6835             \}}
\DoxyCodeLine{6836         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6837     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6838 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6839 }
\DoxyCodeLine{6840 \textcolor{comment}{// end catch\_measure.hpp}}
\DoxyCodeLine{6841 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6842 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6843 }
\DoxyCodeLine{6844 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6845     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6846         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6847             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6848             TimingOf<Clock, Fun, int> measure\_one(Fun\&\& fun, \textcolor{keywordtype}{int} iters, std::false\_type) \{}
\DoxyCodeLine{6849                 \textcolor{keywordflow}{return} Detail::measure<Clock>(fun, iters);}
\DoxyCodeLine{6850             \}}
\DoxyCodeLine{6851             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6852             TimingOf<Clock, Fun, Chronometer> measure\_one(Fun\&\& fun, \textcolor{keywordtype}{int} iters, std::true\_type) \{}
\DoxyCodeLine{6853                 Detail::ChronometerModel<Clock> meter;}
\DoxyCodeLine{6854                 \textcolor{keyword}{auto}\&\& result = Detail::complete\_invoke(fun, Chronometer(meter, iters));}
\DoxyCodeLine{6855 }
\DoxyCodeLine{6856                 \textcolor{keywordflow}{return} \{ meter.elapsed(), std::move(result), iters \};}
\DoxyCodeLine{6857             \}}
\DoxyCodeLine{6858 }
\DoxyCodeLine{6859             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6860             \textcolor{keyword}{using} run\_for\_at\_least\_argument\_t = \textcolor{keyword}{typename} std::conditional<is\_callable<Fun(Chronometer)>::value, Chronometer, \textcolor{keywordtype}{int}>::type;}
\DoxyCodeLine{6861 }
\DoxyCodeLine{6862             \textcolor{keyword}{struct }optimized\_away\_error : std::exception \{}
\DoxyCodeLine{6863                 \textcolor{keyword}{const} \textcolor{keywordtype}{char}* what() const noexcept\textcolor{keyword}{ override }\{}
\DoxyCodeLine{6864                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}could not measure benchmark, maybe it was optimized away"{}};}
\DoxyCodeLine{6865                 \}}
\DoxyCodeLine{6866             \};}
\DoxyCodeLine{6867 }
\DoxyCodeLine{6868             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6869             TimingOf<Clock, Fun, run\_for\_at\_least\_argument\_t<Clock, Fun>> run\_for\_at\_least(ClockDuration<Clock> how\_long, \textcolor{keywordtype}{int} seed, Fun\&\& fun) \{}
\DoxyCodeLine{6870                 \textcolor{keyword}{auto} iters = seed;}
\DoxyCodeLine{6871                 \textcolor{keywordflow}{while} (iters < (1 << 30)) \{}
\DoxyCodeLine{6872                     \textcolor{keyword}{auto}\&\& Timing = measure\_one<Clock>(fun, iters, is\_callable<Fun(Chronometer)>());}
\DoxyCodeLine{6873 }
\DoxyCodeLine{6874                     \textcolor{keywordflow}{if} (Timing.elapsed >= how\_long) \{}
\DoxyCodeLine{6875                         \textcolor{keywordflow}{return} \{ Timing.elapsed, std::move(Timing.result), iters \};}
\DoxyCodeLine{6876                     \}}
\DoxyCodeLine{6877                     iters *= 2;}
\DoxyCodeLine{6878                 \}}
\DoxyCodeLine{6879                 \textcolor{keywordflow}{throw} optimized\_away\_error\{\};}
\DoxyCodeLine{6880             \}}
\DoxyCodeLine{6881         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6882     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6883 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6884 }
\DoxyCodeLine{6885 \textcolor{comment}{// end catch\_run\_for\_at\_least.hpp}}
\DoxyCodeLine{6886 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{6887 }
\DoxyCodeLine{6888 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6889     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6890         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{6891         \textcolor{keyword}{struct }ExecutionPlan \{}
\DoxyCodeLine{6892             \textcolor{keywordtype}{int} iterations\_per\_sample;}
\DoxyCodeLine{6893             Duration estimated\_duration;}
\DoxyCodeLine{6894             Detail::BenchmarkFunction benchmark;}
\DoxyCodeLine{6895             Duration warmup\_time;}
\DoxyCodeLine{6896             \textcolor{keywordtype}{int} warmup\_iterations;}
\DoxyCodeLine{6897 }
\DoxyCodeLine{6898             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{6899             \textcolor{keyword}{operator} ExecutionPlan<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6900                 \textcolor{keywordflow}{return} \{ iterations\_per\_sample, estimated\_duration, benchmark, warmup\_time, warmup\_iterations \};}
\DoxyCodeLine{6901             \}}
\DoxyCodeLine{6902 }
\DoxyCodeLine{6903             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6904             std::vector<FloatDuration<Clock>> run(\textcolor{keyword}{const} IConfig \&cfg, Environment<FloatDuration<Clock>> env)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6905                 \textcolor{comment}{// warmup a bit}}
\DoxyCodeLine{6906                 Detail::run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(warmup\_time), warmup\_iterations, Detail::repeat(now<Clock>\{\}));}
\DoxyCodeLine{6907 }
\DoxyCodeLine{6908                 std::vector<FloatDuration<Clock>> times;}
\DoxyCodeLine{6909                 times.reserve(cfg.benchmarkSamples());}
\DoxyCodeLine{6910                 std::generate\_n(std::back\_inserter(times), cfg.benchmarkSamples(), [\textcolor{keyword}{this}, env] \{}
\DoxyCodeLine{6911                     Detail::ChronometerModel<Clock> model;}
\DoxyCodeLine{6912                     this-\/>benchmark(Chronometer(model, iterations\_per\_sample));}
\DoxyCodeLine{6913                     auto sample\_time = model.elapsed() -\/ env.clock\_cost.mean;}
\DoxyCodeLine{6914                     if (sample\_time < FloatDuration<Clock>::zero()) sample\_time = FloatDuration<Clock>::zero();}
\DoxyCodeLine{6915                     return sample\_time / iterations\_per\_sample;}
\DoxyCodeLine{6916                 \});}
\DoxyCodeLine{6917                 \textcolor{keywordflow}{return} times;}
\DoxyCodeLine{6918             \}}
\DoxyCodeLine{6919         \};}
\DoxyCodeLine{6920     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6921 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6922 }
\DoxyCodeLine{6923 \textcolor{comment}{// end catch\_execution\_plan.hpp}}
\DoxyCodeLine{6924 \textcolor{comment}{// start catch\_estimate\_clock.hpp}}
\DoxyCodeLine{6925 }
\DoxyCodeLine{6926  \textcolor{comment}{// Environment measurement}}
\DoxyCodeLine{6927 }
\DoxyCodeLine{6928 }
\DoxyCodeLine{6929 \textcolor{comment}{// start catch\_stats.hpp}}
\DoxyCodeLine{6930 }
\DoxyCodeLine{6931 \textcolor{comment}{// Statistical analysis tools}}
\DoxyCodeLine{6932 }
\DoxyCodeLine{6933 }
\DoxyCodeLine{6934 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{6935 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{6936 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{6937 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{6938 \textcolor{preprocessor}{\#include <numeric>}}
\DoxyCodeLine{6939 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{6940 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{6941 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6942 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{6943 \textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{6944 }
\DoxyCodeLine{6945 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6946     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6947         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6948             \textcolor{keyword}{using} sample = std::vector<double>;}
\DoxyCodeLine{6949 }
\DoxyCodeLine{6950             \textcolor{keywordtype}{double} weighted\_average\_quantile(\textcolor{keywordtype}{int} k, \textcolor{keywordtype}{int} q, std::vector<double>::iterator first, std::vector<double>::iterator last);}
\DoxyCodeLine{6951 }
\DoxyCodeLine{6952             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{6953             OutlierClassification classify\_outliers(Iterator first, Iterator last) \{}
\DoxyCodeLine{6954                 std::vector<double> \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{copy}}(first, last);}
\DoxyCodeLine{6955 }
\DoxyCodeLine{6956                 \textcolor{keyword}{auto} q1 = weighted\_average\_quantile(1, 4, \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{copy}}.begin(), \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{copy}}.end());}
\DoxyCodeLine{6957                 \textcolor{keyword}{auto} q3 = weighted\_average\_quantile(3, 4, \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{copy}}.begin(), \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{copy}}.end());}
\DoxyCodeLine{6958                 \textcolor{keyword}{auto} iqr = q3 -\/ q1;}
\DoxyCodeLine{6959                 \textcolor{keyword}{auto} los = q1 -\/ (iqr * 3.);}
\DoxyCodeLine{6960                 \textcolor{keyword}{auto} lom = q1 -\/ (iqr * 1.5);}
\DoxyCodeLine{6961                 \textcolor{keyword}{auto} him = q3 + (iqr * 1.5);}
\DoxyCodeLine{6962                 \textcolor{keyword}{auto} his = q3 + (iqr * 3.);}
\DoxyCodeLine{6963 }
\DoxyCodeLine{6964                 OutlierClassification o;}
\DoxyCodeLine{6965                 \textcolor{keywordflow}{for} (; first != last; ++first) \{}
\DoxyCodeLine{6966                     \textcolor{keyword}{auto}\&\& t = *first;}
\DoxyCodeLine{6967                     \textcolor{keywordflow}{if} (t < los) ++o.low\_severe;}
\DoxyCodeLine{6968                     \textcolor{keywordflow}{else} if (t < lom) ++o.low\_mild;}
\DoxyCodeLine{6969                     \textcolor{keywordflow}{else} if (t > his) ++o.high\_severe;}
\DoxyCodeLine{6970                     \textcolor{keywordflow}{else} if (t > him) ++o.high\_mild;}
\DoxyCodeLine{6971                     ++o.samples\_seen;}
\DoxyCodeLine{6972                 \}}
\DoxyCodeLine{6973                 \textcolor{keywordflow}{return} o;}
\DoxyCodeLine{6974             \}}
\DoxyCodeLine{6975 }
\DoxyCodeLine{6976             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{6977             \textcolor{keywordtype}{double} mean(Iterator first, Iterator last) \{}
\DoxyCodeLine{6978                 \textcolor{keyword}{auto} count = last -\/ first;}
\DoxyCodeLine{6979                 \textcolor{keywordtype}{double} sum = std::accumulate(first, last, 0.);}
\DoxyCodeLine{6980                 \textcolor{keywordflow}{return} sum / count;}
\DoxyCodeLine{6981             \}}
\DoxyCodeLine{6982 }
\DoxyCodeLine{6983             \textcolor{keyword}{template} <\textcolor{keyword}{typename} URng, \textcolor{keyword}{typename} Iterator, \textcolor{keyword}{typename} Estimator>}
\DoxyCodeLine{6984             sample resample(URng\& rng, \textcolor{keywordtype}{int} resamples, Iterator first, Iterator last, Estimator\& estimator) \{}
\DoxyCodeLine{6985                 \textcolor{keyword}{auto} n = last -\/ first;}
\DoxyCodeLine{6986                 std::uniform\_int\_distribution<\textcolor{keyword}{decltype}(n)> dist(0, n -\/ 1);}
\DoxyCodeLine{6987 }
\DoxyCodeLine{6988                 sample out;}
\DoxyCodeLine{6989                 out.reserve(resamples);}
\DoxyCodeLine{6990                 std::generate\_n(std::back\_inserter(out), resamples, [n, first, \&estimator, \&dist, \&rng] \{}
\DoxyCodeLine{6991                     std::vector<double> resampled;}
\DoxyCodeLine{6992                     resampled.reserve(n);}
\DoxyCodeLine{6993                     std::generate\_n(std::back\_inserter(resampled), n, [first, \&dist, \&rng] \{ \textcolor{keywordflow}{return} first[dist(rng)]; \});}
\DoxyCodeLine{6994                     \textcolor{keywordflow}{return} estimator(resampled.begin(), resampled.end());}
\DoxyCodeLine{6995                 \});}
\DoxyCodeLine{6996                 std::sort(out.begin(), out.end());}
\DoxyCodeLine{6997                 \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{6998             \}}
\DoxyCodeLine{6999 }
\DoxyCodeLine{7000             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Estimator, \textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{7001             sample jackknife(Estimator\&\& estimator, Iterator first, Iterator last) \{}
\DoxyCodeLine{7002                 \textcolor{keyword}{auto} n = last -\/ first;}
\DoxyCodeLine{7003                 \textcolor{keyword}{auto} second = std::next(first);}
\DoxyCodeLine{7004                 sample results;}
\DoxyCodeLine{7005                 results.reserve(n);}
\DoxyCodeLine{7006 }
\DoxyCodeLine{7007                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = first; it != last; ++it) \{}
\DoxyCodeLine{7008                     std::iter\_swap(it, first);}
\DoxyCodeLine{7009                     results.push\_back(estimator(second, last));}
\DoxyCodeLine{7010                 \}}
\DoxyCodeLine{7011 }
\DoxyCodeLine{7012                 \textcolor{keywordflow}{return} results;}
\DoxyCodeLine{7013             \}}
\DoxyCodeLine{7014 }
\DoxyCodeLine{7015             \textcolor{keyword}{inline} \textcolor{keywordtype}{double} normal\_cdf(\textcolor{keywordtype}{double} x) \{}
\DoxyCodeLine{7016                 \textcolor{keywordflow}{return} std::erfc(-\/x / std::sqrt(2.0)) / 2.0;}
\DoxyCodeLine{7017             \}}
\DoxyCodeLine{7018 }
\DoxyCodeLine{7019             \textcolor{keywordtype}{double} erfc\_inv(\textcolor{keywordtype}{double} x);}
\DoxyCodeLine{7020 }
\DoxyCodeLine{7021             \textcolor{keywordtype}{double} normal\_quantile(\textcolor{keywordtype}{double} p);}
\DoxyCodeLine{7022 }
\DoxyCodeLine{7023             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator, \textcolor{keyword}{typename} Estimator>}
\DoxyCodeLine{7024             Estimate<double> bootstrap(\textcolor{keywordtype}{double} confidence\_level, Iterator first, Iterator last, sample \textcolor{keyword}{const}\& resample, Estimator\&\& estimator) \{}
\DoxyCodeLine{7025                 \textcolor{keyword}{auto} n\_samples = last -\/ first;}
\DoxyCodeLine{7026 }
\DoxyCodeLine{7027                 \textcolor{keywordtype}{double} point = estimator(first, last);}
\DoxyCodeLine{7028                 \textcolor{comment}{// Degenerate case with a single sample}}
\DoxyCodeLine{7029                 \textcolor{keywordflow}{if} (n\_samples == 1) \textcolor{keywordflow}{return} \{ point, point, point, confidence\_level \};}
\DoxyCodeLine{7030 }
\DoxyCodeLine{7031                 sample jack = jackknife(estimator, first, last);}
\DoxyCodeLine{7032                 \textcolor{keywordtype}{double} jack\_mean = mean(jack.begin(), jack.end());}
\DoxyCodeLine{7033                 \textcolor{keywordtype}{double} sum\_squares, sum\_cubes;}
\DoxyCodeLine{7034                 std::tie(sum\_squares, sum\_cubes) = std::accumulate(jack.begin(), jack.end(), std::make\_pair(0., 0.), [jack\_mean](std::pair<double, double> sqcb, \textcolor{keywordtype}{double} x) -\/> std::pair<double, double> \{}
\DoxyCodeLine{7035                     auto d = jack\_mean -\/ x;}
\DoxyCodeLine{7036                     auto d2 = d * d;}
\DoxyCodeLine{7037                     auto d3 = d2 * d;}
\DoxyCodeLine{7038                     return \{ sqcb.first + d2, sqcb.second + d3 \};}
\DoxyCodeLine{7039                 \});}
\DoxyCodeLine{7040 }
\DoxyCodeLine{7041                 \textcolor{keywordtype}{double} accel = sum\_cubes / (6 * std::pow(sum\_squares, 1.5));}
\DoxyCodeLine{7042                 \textcolor{keywordtype}{int} n = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(resample.size());}
\DoxyCodeLine{7043                 \textcolor{keywordtype}{double} prob\_n = std::count\_if(resample.begin(), resample.end(), [point](\textcolor{keywordtype}{double} x) \{ return x < point; \}) / (double)n;}
\DoxyCodeLine{7044                 \textcolor{comment}{// degenerate case with uniform samples}}
\DoxyCodeLine{7045                 \textcolor{keywordflow}{if} (prob\_n == 0) \textcolor{keywordflow}{return} \{ point, point, point, confidence\_level \};}
\DoxyCodeLine{7046 }
\DoxyCodeLine{7047                 \textcolor{keywordtype}{double} bias = normal\_quantile(prob\_n);}
\DoxyCodeLine{7048                 \textcolor{keywordtype}{double} z1 = normal\_quantile((1. -\/ confidence\_level) / 2.);}
\DoxyCodeLine{7049 }
\DoxyCodeLine{7050                 \textcolor{keyword}{auto} cumn = [n](\textcolor{keywordtype}{double} x) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{7051                     \textcolor{keywordflow}{return} std::lround(normal\_cdf(x) * n); \};}
\DoxyCodeLine{7052                 \textcolor{keyword}{auto} a = [bias, accel](\textcolor{keywordtype}{double} b) \{ \textcolor{keywordflow}{return} bias + b / (1. -\/ accel * b); \};}
\DoxyCodeLine{7053                 \textcolor{keywordtype}{double} b1 = bias + z1;}
\DoxyCodeLine{7054                 \textcolor{keywordtype}{double} b2 = bias -\/ z1;}
\DoxyCodeLine{7055                 \textcolor{keywordtype}{double} a1 = a(b1);}
\DoxyCodeLine{7056                 \textcolor{keywordtype}{double} a2 = a(b2);}
\DoxyCodeLine{7057                 \textcolor{keyword}{auto} lo = std::max(cumn(a1), 0);}
\DoxyCodeLine{7058                 \textcolor{keyword}{auto} hi = std::min(cumn(a2), n -\/ 1);}
\DoxyCodeLine{7059 }
\DoxyCodeLine{7060                 \textcolor{keywordflow}{return} \{ point, resample[lo], resample[hi], confidence\_level \};}
\DoxyCodeLine{7061             \}}
\DoxyCodeLine{7062 }
\DoxyCodeLine{7063             \textcolor{keywordtype}{double} outlier\_variance(Estimate<double> mean, Estimate<double> stddev, \textcolor{keywordtype}{int} n);}
\DoxyCodeLine{7064 }
\DoxyCodeLine{7065             \textcolor{keyword}{struct }bootstrap\_analysis \{}
\DoxyCodeLine{7066                 Estimate<double> mean;}
\DoxyCodeLine{7067                 Estimate<double> standard\_deviation;}
\DoxyCodeLine{7068                 \textcolor{keywordtype}{double} outlier\_variance;}
\DoxyCodeLine{7069             \};}
\DoxyCodeLine{7070 }
\DoxyCodeLine{7071             bootstrap\_analysis analyse\_samples(\textcolor{keywordtype}{double} confidence\_level, \textcolor{keywordtype}{int} n\_resamples, std::vector<double>::iterator first, std::vector<double>::iterator last);}
\DoxyCodeLine{7072         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{7073     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7074 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7075 }
\DoxyCodeLine{7076 \textcolor{comment}{// end catch\_stats.hpp}}
\DoxyCodeLine{7077 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{7078 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{7079 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{7080 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7081 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{7082 }
\DoxyCodeLine{7083 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7084     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7085         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7086             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7087             std::vector<double> resolution(\textcolor{keywordtype}{int} k) \{}
\DoxyCodeLine{7088                 std::vector<TimePoint<Clock>> times;}
\DoxyCodeLine{7089                 times.reserve(k + 1);}
\DoxyCodeLine{7090                 std::generate\_n(std::back\_inserter(times), k + 1, now<Clock>\{\});}
\DoxyCodeLine{7091 }
\DoxyCodeLine{7092                 std::vector<double> deltas;}
\DoxyCodeLine{7093                 deltas.reserve(k);}
\DoxyCodeLine{7094                 std::transform(std::next(times.begin()), times.end(), times.begin(),}
\DoxyCodeLine{7095                     std::back\_inserter(deltas),}
\DoxyCodeLine{7096                     [](TimePoint<Clock> a, TimePoint<Clock> b) \{ return static\_cast<double>((a -\/ b).count()); \});}
\DoxyCodeLine{7097 }
\DoxyCodeLine{7098                 \textcolor{keywordflow}{return} deltas;}
\DoxyCodeLine{7099             \}}
\DoxyCodeLine{7100 }
\DoxyCodeLine{7101             \textcolor{keyword}{const} \textcolor{keyword}{auto} warmup\_iterations = 10000;}
\DoxyCodeLine{7102             \textcolor{keyword}{const} \textcolor{keyword}{auto} warmup\_time = std::chrono::milliseconds(100);}
\DoxyCodeLine{7103             \textcolor{keyword}{const} \textcolor{keyword}{auto} minimum\_ticks = 1000;}
\DoxyCodeLine{7104             \textcolor{keyword}{const} \textcolor{keyword}{auto} warmup\_seed = 10000;}
\DoxyCodeLine{7105             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_resolution\_estimation\_time = std::chrono::milliseconds(500);}
\DoxyCodeLine{7106             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_cost\_estimation\_time\_limit = std::chrono::seconds(1);}
\DoxyCodeLine{7107             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_cost\_estimation\_tick\_limit = 100000;}
\DoxyCodeLine{7108             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_cost\_estimation\_time = std::chrono::milliseconds(10);}
\DoxyCodeLine{7109             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_cost\_estimation\_iterations = 10000;}
\DoxyCodeLine{7110 }
\DoxyCodeLine{7111             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7112             \textcolor{keywordtype}{int} warmup() \{}
\DoxyCodeLine{7113                 \textcolor{keywordflow}{return} run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(warmup\_time), warmup\_seed, \&resolution<Clock>)}
\DoxyCodeLine{7114                     .iterations;}
\DoxyCodeLine{7115             \}}
\DoxyCodeLine{7116             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7117             EnvironmentEstimate<FloatDuration<Clock>> estimate\_clock\_resolution(\textcolor{keywordtype}{int} iterations) \{}
\DoxyCodeLine{7118                 \textcolor{keyword}{auto} r = run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(clock\_resolution\_estimation\_time), iterations, \&resolution<Clock>)}
\DoxyCodeLine{7119                     .result;}
\DoxyCodeLine{7120                 \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7121                     FloatDuration<Clock>(mean(r.begin(), r.end())),}
\DoxyCodeLine{7122                     classify\_outliers(r.begin(), r.end()),}
\DoxyCodeLine{7123                 \};}
\DoxyCodeLine{7124             \}}
\DoxyCodeLine{7125             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7126             EnvironmentEstimate<FloatDuration<Clock>> estimate\_clock\_cost(FloatDuration<Clock> resolution) \{}
\DoxyCodeLine{7127                 \textcolor{keyword}{auto} time\_limit = std::min(resolution * clock\_cost\_estimation\_tick\_limit, FloatDuration<Clock>(clock\_cost\_estimation\_time\_limit));}
\DoxyCodeLine{7128                 \textcolor{keyword}{auto} time\_clock = [](\textcolor{keywordtype}{int} k) \{}
\DoxyCodeLine{7129                     \textcolor{keywordflow}{return} Detail::measure<Clock>([k] \{}
\DoxyCodeLine{7130                         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < k; ++i) \{}
\DoxyCodeLine{7131                             \textcolor{keyword}{volatile} \textcolor{keyword}{auto} ignored = Clock::now();}
\DoxyCodeLine{7132                             (void)ignored;}
\DoxyCodeLine{7133                         \}}
\DoxyCodeLine{7134                     \}).elapsed;}
\DoxyCodeLine{7135                 \};}
\DoxyCodeLine{7136                 time\_clock(1);}
\DoxyCodeLine{7137                 \textcolor{keywordtype}{int} iters = clock\_cost\_estimation\_iterations;}
\DoxyCodeLine{7138                 \textcolor{keyword}{auto}\&\& r = run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(clock\_cost\_estimation\_time), iters, time\_clock);}
\DoxyCodeLine{7139                 std::vector<double> times;}
\DoxyCodeLine{7140                 \textcolor{keywordtype}{int} nsamples = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(std::ceil(time\_limit / r.elapsed));}
\DoxyCodeLine{7141                 times.reserve(nsamples);}
\DoxyCodeLine{7142                 std::generate\_n(std::back\_inserter(times), nsamples, [time\_clock, \&r] \{}
\DoxyCodeLine{7143                     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}((time\_clock(r.iterations) / r.iterations).count());}
\DoxyCodeLine{7144                 \});}
\DoxyCodeLine{7145                 \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7146                     FloatDuration<Clock>(mean(times.begin(), times.end())),}
\DoxyCodeLine{7147                     classify\_outliers(times.begin(), times.end()),}
\DoxyCodeLine{7148                 \};}
\DoxyCodeLine{7149             \}}
\DoxyCodeLine{7150 }
\DoxyCodeLine{7151             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7152             Environment<FloatDuration<Clock>> measure\_environment() \{}
\DoxyCodeLine{7153                 \textcolor{keyword}{static} Environment<FloatDuration<Clock>>* env = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{7154                 \textcolor{keywordflow}{if} (env) \{}
\DoxyCodeLine{7155                     \textcolor{keywordflow}{return} *env;}
\DoxyCodeLine{7156                 \}}
\DoxyCodeLine{7157 }
\DoxyCodeLine{7158                 \textcolor{keyword}{auto} iters = Detail::warmup<Clock>();}
\DoxyCodeLine{7159                 \textcolor{keyword}{auto} resolution = Detail::estimate\_clock\_resolution<Clock>(iters);}
\DoxyCodeLine{7160                 \textcolor{keyword}{auto} cost = Detail::estimate\_clock\_cost<Clock>(resolution.mean);}
\DoxyCodeLine{7161 }
\DoxyCodeLine{7162                 env = \textcolor{keyword}{new} Environment<FloatDuration<Clock>>\{ resolution, cost \};}
\DoxyCodeLine{7163                 \textcolor{keywordflow}{return} *env;}
\DoxyCodeLine{7164             \}}
\DoxyCodeLine{7165         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{7166     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7167 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7168 }
\DoxyCodeLine{7169 \textcolor{comment}{// end catch\_estimate\_clock.hpp}}
\DoxyCodeLine{7170 \textcolor{comment}{// start catch\_analyse.hpp}}
\DoxyCodeLine{7171 }
\DoxyCodeLine{7172  \textcolor{comment}{// Run and analyse one benchmark}}
\DoxyCodeLine{7173 }
\DoxyCodeLine{7174 }
\DoxyCodeLine{7175 \textcolor{comment}{// start catch\_sample\_analysis.hpp}}
\DoxyCodeLine{7176 }
\DoxyCodeLine{7177 \textcolor{comment}{// Benchmark results}}
\DoxyCodeLine{7178 }
\DoxyCodeLine{7179 }
\DoxyCodeLine{7180 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{7181 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7182 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{7183 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{7184 }
\DoxyCodeLine{7185 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7186     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7187         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{7188         \textcolor{keyword}{struct }SampleAnalysis \{}
\DoxyCodeLine{7189             std::vector<Duration> samples;}
\DoxyCodeLine{7190             Estimate<Duration> mean;}
\DoxyCodeLine{7191             Estimate<Duration> standard\_deviation;}
\DoxyCodeLine{7192             OutlierClassification outliers;}
\DoxyCodeLine{7193             \textcolor{keywordtype}{double} outlier\_variance;}
\DoxyCodeLine{7194 }
\DoxyCodeLine{7195             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{7196             \textcolor{keyword}{operator} SampleAnalysis<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7197                 std::vector<Duration2> samples2;}
\DoxyCodeLine{7198                 samples2.reserve(samples.size());}
\DoxyCodeLine{7199                 std::transform(samples.begin(), samples.end(), std::back\_inserter(samples2), [](Duration d) \{ return Duration2(d); \});}
\DoxyCodeLine{7200                 \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7201                     std::move(samples2),}
\DoxyCodeLine{7202                     mean,}
\DoxyCodeLine{7203                     standard\_deviation,}
\DoxyCodeLine{7204                     outliers,}
\DoxyCodeLine{7205                     outlier\_variance,}
\DoxyCodeLine{7206                 \};}
\DoxyCodeLine{7207             \}}
\DoxyCodeLine{7208         \};}
\DoxyCodeLine{7209     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7210 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7211 }
\DoxyCodeLine{7212 \textcolor{comment}{// end catch\_sample\_analysis.hpp}}
\DoxyCodeLine{7213 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{7214 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{7215 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7216 }
\DoxyCodeLine{7217 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7218     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7219         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7220             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration, \textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{7221             SampleAnalysis<Duration> analyse(\textcolor{keyword}{const} IConfig \&cfg, Environment<Duration>, Iterator first, Iterator last) \{}
\DoxyCodeLine{7222                 \textcolor{keywordflow}{if} (!cfg.benchmarkNoAnalysis()) \{}
\DoxyCodeLine{7223                     std::vector<double> samples;}
\DoxyCodeLine{7224                     samples.reserve(last -\/ first);}
\DoxyCodeLine{7225                     std::transform(first, last, std::back\_inserter(samples), [](Duration d) \{ \textcolor{keywordflow}{return} d.count(); \});}
\DoxyCodeLine{7226 }
\DoxyCodeLine{7227                     \textcolor{keyword}{auto} analysis = Catch::Benchmark::Detail::analyse\_samples(cfg.benchmarkConfidenceInterval(), cfg.benchmarkResamples(), samples.begin(), samples.end());}
\DoxyCodeLine{7228                     \textcolor{keyword}{auto} outliers = Catch::Benchmark::Detail::classify\_outliers(samples.begin(), samples.end());}
\DoxyCodeLine{7229 }
\DoxyCodeLine{7230                     \textcolor{keyword}{auto} wrap\_estimate = [](Estimate<double> e) \{}
\DoxyCodeLine{7231                         \textcolor{keywordflow}{return} Estimate<Duration> \{}
\DoxyCodeLine{7232                             Duration(e.point),}
\DoxyCodeLine{7233                                 Duration(e.lower\_bound),}
\DoxyCodeLine{7234                                 Duration(e.upper\_bound),}
\DoxyCodeLine{7235                                 e.confidence\_interval,}
\DoxyCodeLine{7236                         \};}
\DoxyCodeLine{7237                     \};}
\DoxyCodeLine{7238                     std::vector<Duration> samples2;}
\DoxyCodeLine{7239                     samples2.reserve(samples.size());}
\DoxyCodeLine{7240                     std::transform(samples.begin(), samples.end(), std::back\_inserter(samples2), [](\textcolor{keywordtype}{double} d) \{ return Duration(d); \});}
\DoxyCodeLine{7241                     \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7242                         std::move(samples2),}
\DoxyCodeLine{7243                         wrap\_estimate(analysis.mean),}
\DoxyCodeLine{7244                         wrap\_estimate(analysis.standard\_deviation),}
\DoxyCodeLine{7245                         outliers,}
\DoxyCodeLine{7246                         analysis.outlier\_variance,}
\DoxyCodeLine{7247                     \};}
\DoxyCodeLine{7248                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{7249                     std::vector<Duration> samples;}
\DoxyCodeLine{7250                     samples.reserve(last -\/ first);}
\DoxyCodeLine{7251 }
\DoxyCodeLine{7252                     Duration mean = Duration(0);}
\DoxyCodeLine{7253                     \textcolor{keywordtype}{int} i = 0;}
\DoxyCodeLine{7254                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = first; it < last; ++it, ++i) \{}
\DoxyCodeLine{7255                         samples.push\_back(Duration(*it));}
\DoxyCodeLine{7256                         mean += Duration(*it);}
\DoxyCodeLine{7257                     \}}
\DoxyCodeLine{7258                     mean /= i;}
\DoxyCodeLine{7259 }
\DoxyCodeLine{7260                     \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7261                         std::move(samples),}
\DoxyCodeLine{7262                         Estimate<Duration>\{mean, mean, mean, 0.0\},}
\DoxyCodeLine{7263                         Estimate<Duration>\{Duration(0), Duration(0), Duration(0), 0.0\},}
\DoxyCodeLine{7264                         OutlierClassification\{\},}
\DoxyCodeLine{7265                         0.0}
\DoxyCodeLine{7266                     \};}
\DoxyCodeLine{7267                 \}}
\DoxyCodeLine{7268             \}}
\DoxyCodeLine{7269         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{7270     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7271 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7272 }
\DoxyCodeLine{7273 \textcolor{comment}{// end catch\_analyse.hpp}}
\DoxyCodeLine{7274 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{7275 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{7276 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{7277 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7278 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{7279 }
\DoxyCodeLine{7280 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7281     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7282         \textcolor{keyword}{struct }Benchmark \{}
\DoxyCodeLine{7283             Benchmark(std::string \&\&name)}
\DoxyCodeLine{7284                 : name(std::move(name)) \{\}}
\DoxyCodeLine{7285 }
\DoxyCodeLine{7286             \textcolor{keyword}{template} <\textcolor{keyword}{class} FUN>}
\DoxyCodeLine{7287             Benchmark(std::string \&\&name, FUN \&\&func)}
\DoxyCodeLine{7288                 : fun(std::move(func)), name(std::move(name)) \{\}}
\DoxyCodeLine{7289 }
\DoxyCodeLine{7290             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7291             ExecutionPlan<FloatDuration<Clock>> prepare(\textcolor{keyword}{const} IConfig \&cfg, Environment<FloatDuration<Clock>> env)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7292                 \textcolor{keyword}{auto} min\_time = env.clock\_resolution.mean * Detail::minimum\_ticks;}
\DoxyCodeLine{7293                 \textcolor{keyword}{auto} run\_time = std::max(min\_time, std::chrono::duration\_cast<\textcolor{keyword}{decltype}(min\_time)>(cfg.benchmarkWarmupTime()));}
\DoxyCodeLine{7294                 \textcolor{keyword}{auto}\&\& test = Detail::run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(run\_time), 1, fun);}
\DoxyCodeLine{7295                 \textcolor{keywordtype}{int} new\_iters = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(std::ceil(min\_time * test.iterations / test.elapsed));}
\DoxyCodeLine{7296                 \textcolor{keywordflow}{return} \{ new\_iters, test.elapsed / test.iterations * new\_iters * cfg.benchmarkSamples(), fun, std::chrono::duration\_cast<FloatDuration<Clock>>(cfg.benchmarkWarmupTime()), Detail::warmup\_iterations \};}
\DoxyCodeLine{7297             \}}
\DoxyCodeLine{7298 }
\DoxyCodeLine{7299             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock = default\_clock>}
\DoxyCodeLine{7300             \textcolor{keywordtype}{void} run() \{}
\DoxyCodeLine{7301                 IConfigPtr cfg = getCurrentContext().getConfig();}
\DoxyCodeLine{7302 }
\DoxyCodeLine{7303                 \textcolor{keyword}{auto} env = Detail::measure\_environment<Clock>();}
\DoxyCodeLine{7304 }
\DoxyCodeLine{7305                 getResultCapture().benchmarkPreparing(name);}
\DoxyCodeLine{7306                 CATCH\_TRY\{}
\DoxyCodeLine{7307                     \textcolor{keyword}{auto} plan = user\_code([\&] \{}
\DoxyCodeLine{7308                         \textcolor{keywordflow}{return} prepare<Clock>(*cfg, env);}
\DoxyCodeLine{7309                     \});}
\DoxyCodeLine{7310 }
\DoxyCodeLine{7311                     BenchmarkInfo info \{}
\DoxyCodeLine{7312                         name,}
\DoxyCodeLine{7313                         plan.estimated\_duration.count(),}
\DoxyCodeLine{7314                         plan.iterations\_per\_sample,}
\DoxyCodeLine{7315                         cfg-\/>benchmarkSamples(),}
\DoxyCodeLine{7316                         cfg-\/>benchmarkResamples(),}
\DoxyCodeLine{7317                         env.clock\_resolution.mean.count(),}
\DoxyCodeLine{7318                         env.clock\_cost.mean.count()}
\DoxyCodeLine{7319                     \};}
\DoxyCodeLine{7320 }
\DoxyCodeLine{7321                     getResultCapture().benchmarkStarting(info);}
\DoxyCodeLine{7322 }
\DoxyCodeLine{7323                     \textcolor{keyword}{auto} samples = user\_code([\&] \{}
\DoxyCodeLine{7324                         \textcolor{keywordflow}{return} plan.template run<Clock>(*cfg, env);}
\DoxyCodeLine{7325                     \});}
\DoxyCodeLine{7326 }
\DoxyCodeLine{7327                     \textcolor{keyword}{auto} analysis = Detail::analyse(*cfg, env, samples.begin(), samples.end());}
\DoxyCodeLine{7328                     BenchmarkStats<FloatDuration<Clock>> stats\{ info, analysis.samples, analysis.mean, analysis.standard\_deviation, analysis.outliers, analysis.outlier\_variance \};}
\DoxyCodeLine{7329                     getResultCapture().benchmarkEnded(stats);}
\DoxyCodeLine{7330 }
\DoxyCodeLine{7331                 \} CATCH\_CATCH\_ALL\{}
\DoxyCodeLine{7332                     \textcolor{keywordflow}{if} (translateActiveException() != Detail::benchmarkErrorMsg) \textcolor{comment}{// benchmark errors have been reported, otherwise rethrow.}}
\DoxyCodeLine{7333                         std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{7334                 \}}
\DoxyCodeLine{7335             \}}
\DoxyCodeLine{7336 }
\DoxyCodeLine{7337             \textcolor{comment}{// sets lambda to be used in fun *and* executes benchmark!}}
\DoxyCodeLine{7338             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun,}
\DoxyCodeLine{7339                 \textcolor{keyword}{typename} std::enable\_if<!Detail::is\_related<Fun, Benchmark>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{7340                 Benchmark \& operator=(Fun func) \{}
\DoxyCodeLine{7341                 fun = Detail::BenchmarkFunction(func);}
\DoxyCodeLine{7342                 run();}
\DoxyCodeLine{7343                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{7344             \}}
\DoxyCodeLine{7345 }
\DoxyCodeLine{7346             \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() \{}
\DoxyCodeLine{7347                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7348             \}}
\DoxyCodeLine{7349 }
\DoxyCodeLine{7350         \textcolor{keyword}{private}:}
\DoxyCodeLine{7351             Detail::BenchmarkFunction fun;}
\DoxyCodeLine{7352             std::string name;}
\DoxyCodeLine{7353         \};}
\DoxyCodeLine{7354     \}}
\DoxyCodeLine{7355 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7356 }
\DoxyCodeLine{7357 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_GET\_1\_ARG(arg1, arg2, ...) arg1}}
\DoxyCodeLine{7358 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_GET\_2\_ARG(arg1, arg2, ...) arg2}}
\DoxyCodeLine{7359 }
\DoxyCodeLine{7360 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_BENCHMARK(BenchmarkName, name, benchmarkIndex)\(\backslash\)}}
\DoxyCodeLine{7361 \textcolor{preprocessor}{    if( Catch::Benchmark::Benchmark BenchmarkName\{name\} ) \(\backslash\)}}
\DoxyCodeLine{7362 \textcolor{preprocessor}{        BenchmarkName = [\&](int benchmarkIndex)}}
\DoxyCodeLine{7363 }
\DoxyCodeLine{7364 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_BENCHMARK\_ADVANCED(BenchmarkName, name)\(\backslash\)}}
\DoxyCodeLine{7365 \textcolor{preprocessor}{    if( Catch::Benchmark::Benchmark BenchmarkName\{name\} ) \(\backslash\)}}
\DoxyCodeLine{7366 \textcolor{preprocessor}{        BenchmarkName = [\&]}}
\DoxyCodeLine{7367 }
\DoxyCodeLine{7368 \textcolor{comment}{// end catch\_benchmark.hpp}}
\DoxyCodeLine{7369 \textcolor{comment}{// start catch\_constructor.hpp}}
\DoxyCodeLine{7370 }
\DoxyCodeLine{7371 \textcolor{comment}{// Constructor and destructor helpers}}
\DoxyCodeLine{7372 }
\DoxyCodeLine{7373 }
\DoxyCodeLine{7374 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{7375 }
\DoxyCodeLine{7376 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7377     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7378         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7379             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} Destruct>}
\DoxyCodeLine{7380             \textcolor{keyword}{struct }ObjectStorage}
\DoxyCodeLine{7381             \{}
\DoxyCodeLine{7382                 \textcolor{keyword}{using} TStorage = \textcolor{keyword}{typename} std::aligned\_storage<\textcolor{keyword}{sizeof}(T), std::alignment\_of<T>::value>::type;}
\DoxyCodeLine{7383 }
\DoxyCodeLine{7384                 ObjectStorage() : data() \{\}}
\DoxyCodeLine{7385 }
\DoxyCodeLine{7386                 ObjectStorage(\textcolor{keyword}{const} ObjectStorage\& other)}
\DoxyCodeLine{7387                 \{}
\DoxyCodeLine{7388                     \textcolor{keyword}{new}(\&data) T(other.stored\_object());}
\DoxyCodeLine{7389                 \}}
\DoxyCodeLine{7390 }
\DoxyCodeLine{7391                 ObjectStorage(ObjectStorage\&\& other)}
\DoxyCodeLine{7392                 \{}
\DoxyCodeLine{7393                     \textcolor{keyword}{new}(\&data) T(std::move(other.stored\_object()));}
\DoxyCodeLine{7394                 \}}
\DoxyCodeLine{7395 }
\DoxyCodeLine{7396                 \string~ObjectStorage() \{ destruct\_on\_exit<T>(); \}}
\DoxyCodeLine{7397 }
\DoxyCodeLine{7398                 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{7399                 \textcolor{keywordtype}{void} construct(Args\&\&... args)}
\DoxyCodeLine{7400                 \{}
\DoxyCodeLine{7401                     \textcolor{keyword}{new} (\&data) T(std::forward<Args>(args)...);}
\DoxyCodeLine{7402                 \}}
\DoxyCodeLine{7403 }
\DoxyCodeLine{7404                 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} AllowManualDestruction = !Destruct>}
\DoxyCodeLine{7405                 \textcolor{keyword}{typename} std::enable\_if<AllowManualDestruction>::type destruct()}
\DoxyCodeLine{7406                 \{}
\DoxyCodeLine{7407                     stored\_object().\string~T();}
\DoxyCodeLine{7408                 \}}
\DoxyCodeLine{7409 }
\DoxyCodeLine{7410             \textcolor{keyword}{private}:}
\DoxyCodeLine{7411                 \textcolor{comment}{// If this is a constructor benchmark, destruct the underlying object}}
\DoxyCodeLine{7412                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{7413                 \textcolor{keywordtype}{void} destruct\_on\_exit(\textcolor{keyword}{typename} std::enable\_if<Destruct, U>::type* = 0) \{ destruct<true>(); \}}
\DoxyCodeLine{7414                 \textcolor{comment}{// Otherwise, don't}}
\DoxyCodeLine{7415                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{7416                 \textcolor{keywordtype}{void} destruct\_on\_exit(\textcolor{keyword}{typename} std::enable\_if<!Destruct, U>::type* = 0) \{ \}}
\DoxyCodeLine{7417 }
\DoxyCodeLine{7418                 T\& stored\_object() \{}
\DoxyCodeLine{7419                     \textcolor{keywordflow}{return} *\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&data));}
\DoxyCodeLine{7420                 \}}
\DoxyCodeLine{7421 }
\DoxyCodeLine{7422                 T \textcolor{keyword}{const}\& stored\_object()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7423                     \textcolor{keywordflow}{return} *\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&data));}
\DoxyCodeLine{7424                 \}}
\DoxyCodeLine{7425 }
\DoxyCodeLine{7426                 TStorage data;}
\DoxyCodeLine{7427             \};}
\DoxyCodeLine{7428         \}}
\DoxyCodeLine{7429 }
\DoxyCodeLine{7430         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7431         \textcolor{keyword}{using} storage\_for = Detail::ObjectStorage<T, true>;}
\DoxyCodeLine{7432 }
\DoxyCodeLine{7433         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7434         \textcolor{keyword}{using} destructable\_object = Detail::ObjectStorage<T, false>;}
\DoxyCodeLine{7435     \}}
\DoxyCodeLine{7436 \}}
\DoxyCodeLine{7437 }
\DoxyCodeLine{7438 \textcolor{comment}{// end catch\_constructor.hpp}}
\DoxyCodeLine{7439 \textcolor{comment}{// end catch\_benchmarking\_all.hpp}}
\DoxyCodeLine{7440 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7441 }
\DoxyCodeLine{7442 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// ! CATCH\_CONFIG\_IMPL\_ONLY}}
\DoxyCodeLine{7443 }
\DoxyCodeLine{7444 \textcolor{preprocessor}{\#ifdef CATCH\_IMPL}}
\DoxyCodeLine{7445 \textcolor{comment}{// start catch\_impl.hpp}}
\DoxyCodeLine{7446 }
\DoxyCodeLine{7447 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{7448 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{7449 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wweak-\/vtables"{}}}
\DoxyCodeLine{7450 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7451 }
\DoxyCodeLine{7452 \textcolor{comment}{// Keep these here for external reporters}}
\DoxyCodeLine{7453 \textcolor{comment}{// start catch\_test\_case\_tracker.h}}
\DoxyCodeLine{7454 }
\DoxyCodeLine{7455 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{7456 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7457 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{7458 }
\DoxyCodeLine{7459 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7460 \textcolor{keyword}{namespace }TestCaseTracking \{}
\DoxyCodeLine{7461 }
\DoxyCodeLine{7462     \textcolor{keyword}{struct }NameAndLocation \{}
\DoxyCodeLine{7463         std::string name;}
\DoxyCodeLine{7464         SourceLineInfo location;}
\DoxyCodeLine{7465 }
\DoxyCodeLine{7466         NameAndLocation( std::string \textcolor{keyword}{const}\& \_name, SourceLineInfo \textcolor{keyword}{const}\& \_location );}
\DoxyCodeLine{7467         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator==(NameAndLocation \textcolor{keyword}{const}\& lhs, NameAndLocation \textcolor{keyword}{const}\& rhs) \{}
\DoxyCodeLine{7468             \textcolor{keywordflow}{return} lhs.name == rhs.name}
\DoxyCodeLine{7469                 \&\& lhs.location == rhs.location;}
\DoxyCodeLine{7470         \}}
\DoxyCodeLine{7471     \};}
\DoxyCodeLine{7472 }
\DoxyCodeLine{7473     \textcolor{keyword}{class }ITracker;}
\DoxyCodeLine{7474 }
\DoxyCodeLine{7475     \textcolor{keyword}{using} ITrackerPtr = std::shared\_ptr<ITracker>;}
\DoxyCodeLine{7476 }
\DoxyCodeLine{7477     \textcolor{keyword}{class  }ITracker \{}
\DoxyCodeLine{7478         NameAndLocation m\_nameAndLocation;}
\DoxyCodeLine{7479 }
\DoxyCodeLine{7480     \textcolor{keyword}{public}:}
\DoxyCodeLine{7481         ITracker(NameAndLocation \textcolor{keyword}{const}\& nameAndLoc) :}
\DoxyCodeLine{7482             m\_nameAndLocation(nameAndLoc)}
\DoxyCodeLine{7483         \{\}}
\DoxyCodeLine{7484 }
\DoxyCodeLine{7485         \textcolor{comment}{// static queries}}
\DoxyCodeLine{7486         NameAndLocation \textcolor{keyword}{const}\& nameAndLocation()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7487             \textcolor{keywordflow}{return} m\_nameAndLocation;}
\DoxyCodeLine{7488         \}}
\DoxyCodeLine{7489 }
\DoxyCodeLine{7490         \textcolor{keyword}{virtual} \string~ITracker();}
\DoxyCodeLine{7491 }
\DoxyCodeLine{7492         \textcolor{comment}{// dynamic queries}}
\DoxyCodeLine{7493         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isComplete() \textcolor{keyword}{const} = 0; \textcolor{comment}{// Successfully completed or failed}}
\DoxyCodeLine{7494         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isSuccessfullyCompleted() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7495         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isOpen() \textcolor{keyword}{const} = 0; \textcolor{comment}{// Started but not complete}}
\DoxyCodeLine{7496         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} hasChildren() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7497         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} hasStarted() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7498 }
\DoxyCodeLine{7499         \textcolor{keyword}{virtual} ITracker\& parent() = 0;}
\DoxyCodeLine{7500 }
\DoxyCodeLine{7501         \textcolor{comment}{// actions}}
\DoxyCodeLine{7502         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} close() = 0; \textcolor{comment}{// Successfully complete}}
\DoxyCodeLine{7503         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} fail() = 0;}
\DoxyCodeLine{7504         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} markAsNeedingAnotherRun() = 0;}
\DoxyCodeLine{7505 }
\DoxyCodeLine{7506         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} addChild( ITrackerPtr \textcolor{keyword}{const}\& child ) = 0;}
\DoxyCodeLine{7507         \textcolor{keyword}{virtual} ITrackerPtr findChild( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) = 0;}
\DoxyCodeLine{7508         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} openChild() = 0;}
\DoxyCodeLine{7509 }
\DoxyCodeLine{7510         \textcolor{comment}{// Debug/ checking}}
\DoxyCodeLine{7511         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isSectionTracker() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7512         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isGeneratorTracker() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7513     \};}
\DoxyCodeLine{7514 }
\DoxyCodeLine{7515     \textcolor{keyword}{class }TrackerContext \{}
\DoxyCodeLine{7516 }
\DoxyCodeLine{7517         \textcolor{keyword}{enum} RunState \{}
\DoxyCodeLine{7518             NotStarted,}
\DoxyCodeLine{7519             Executing,}
\DoxyCodeLine{7520             CompletedCycle}
\DoxyCodeLine{7521         \};}
\DoxyCodeLine{7522 }
\DoxyCodeLine{7523         ITrackerPtr m\_rootTracker;}
\DoxyCodeLine{7524         ITracker* m\_currentTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{7525         RunState m\_runState = NotStarted;}
\DoxyCodeLine{7526 }
\DoxyCodeLine{7527     \textcolor{keyword}{public}:}
\DoxyCodeLine{7528 }
\DoxyCodeLine{7529         ITracker\& startRun();}
\DoxyCodeLine{7530         \textcolor{keywordtype}{void} endRun();}
\DoxyCodeLine{7531 }
\DoxyCodeLine{7532         \textcolor{keywordtype}{void} startCycle();}
\DoxyCodeLine{7533         \textcolor{keywordtype}{void} completeCycle();}
\DoxyCodeLine{7534 }
\DoxyCodeLine{7535         \textcolor{keywordtype}{bool} completedCycle() \textcolor{keyword}{const};}
\DoxyCodeLine{7536         ITracker\& currentTracker();}
\DoxyCodeLine{7537         \textcolor{keywordtype}{void} setCurrentTracker( ITracker* tracker );}
\DoxyCodeLine{7538     \};}
\DoxyCodeLine{7539 }
\DoxyCodeLine{7540     \textcolor{keyword}{class }TrackerBase : \textcolor{keyword}{public} ITracker \{}
\DoxyCodeLine{7541     \textcolor{keyword}{protected}:}
\DoxyCodeLine{7542         \textcolor{keyword}{enum} CycleState \{}
\DoxyCodeLine{7543             NotStarted,}
\DoxyCodeLine{7544             Executing,}
\DoxyCodeLine{7545             ExecutingChildren,}
\DoxyCodeLine{7546             NeedsAnotherRun,}
\DoxyCodeLine{7547             CompletedSuccessfully,}
\DoxyCodeLine{7548             Failed}
\DoxyCodeLine{7549         \};}
\DoxyCodeLine{7550 }
\DoxyCodeLine{7551         \textcolor{keyword}{using} Children = std::vector<ITrackerPtr>;}
\DoxyCodeLine{7552         TrackerContext\& m\_ctx;}
\DoxyCodeLine{7553         ITracker* m\_parent;}
\DoxyCodeLine{7554         Children m\_children;}
\DoxyCodeLine{7555         CycleState m\_runState = NotStarted;}
\DoxyCodeLine{7556 }
\DoxyCodeLine{7557     \textcolor{keyword}{public}:}
\DoxyCodeLine{7558         TrackerBase( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent );}
\DoxyCodeLine{7559 }
\DoxyCodeLine{7560         \textcolor{keywordtype}{bool} isComplete() \textcolor{keyword}{const override};}
\DoxyCodeLine{7561         \textcolor{keywordtype}{bool} isSuccessfullyCompleted() \textcolor{keyword}{const override};}
\DoxyCodeLine{7562         \textcolor{keywordtype}{bool} isOpen() \textcolor{keyword}{const override};}
\DoxyCodeLine{7563         \textcolor{keywordtype}{bool} hasChildren() \textcolor{keyword}{const override};}
\DoxyCodeLine{7564         \textcolor{keywordtype}{bool} hasStarted()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{7565             \textcolor{keywordflow}{return} m\_runState != NotStarted;}
\DoxyCodeLine{7566         \}}
\DoxyCodeLine{7567 }
\DoxyCodeLine{7568         \textcolor{keywordtype}{void} addChild( ITrackerPtr \textcolor{keyword}{const}\& child ) \textcolor{keyword}{override};}
\DoxyCodeLine{7569 }
\DoxyCodeLine{7570         ITrackerPtr findChild( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \textcolor{keyword}{override};}
\DoxyCodeLine{7571         ITracker\& parent() \textcolor{keyword}{override};}
\DoxyCodeLine{7572 }
\DoxyCodeLine{7573         \textcolor{keywordtype}{void} openChild() \textcolor{keyword}{override};}
\DoxyCodeLine{7574 }
\DoxyCodeLine{7575         \textcolor{keywordtype}{bool} isSectionTracker() \textcolor{keyword}{const override};}
\DoxyCodeLine{7576         \textcolor{keywordtype}{bool} isGeneratorTracker() \textcolor{keyword}{const override};}
\DoxyCodeLine{7577 }
\DoxyCodeLine{7578         \textcolor{keywordtype}{void} open();}
\DoxyCodeLine{7579 }
\DoxyCodeLine{7580         \textcolor{keywordtype}{void} close() \textcolor{keyword}{override};}
\DoxyCodeLine{7581         \textcolor{keywordtype}{void} fail() \textcolor{keyword}{override};}
\DoxyCodeLine{7582         \textcolor{keywordtype}{void} markAsNeedingAnotherRun() \textcolor{keyword}{override};}
\DoxyCodeLine{7583 }
\DoxyCodeLine{7584     \textcolor{keyword}{private}:}
\DoxyCodeLine{7585         \textcolor{keywordtype}{void} moveToParent();}
\DoxyCodeLine{7586         \textcolor{keywordtype}{void} moveToThis();}
\DoxyCodeLine{7587     \};}
\DoxyCodeLine{7588 }
\DoxyCodeLine{7589     \textcolor{keyword}{class }SectionTracker : \textcolor{keyword}{public} TrackerBase \{}
\DoxyCodeLine{7590         std::vector<std::string> m\_filters;}
\DoxyCodeLine{7591         std::string m\_trimmed\_name;}
\DoxyCodeLine{7592     \textcolor{keyword}{public}:}
\DoxyCodeLine{7593         SectionTracker( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent );}
\DoxyCodeLine{7594 }
\DoxyCodeLine{7595         \textcolor{keywordtype}{bool} isSectionTracker() \textcolor{keyword}{const override};}
\DoxyCodeLine{7596 }
\DoxyCodeLine{7597         \textcolor{keywordtype}{bool} isComplete() \textcolor{keyword}{const override};}
\DoxyCodeLine{7598 }
\DoxyCodeLine{7599         \textcolor{keyword}{static} SectionTracker\& acquire( TrackerContext\& ctx, NameAndLocation \textcolor{keyword}{const}\& nameAndLocation );}
\DoxyCodeLine{7600 }
\DoxyCodeLine{7601         \textcolor{keywordtype}{void} tryOpen();}
\DoxyCodeLine{7602 }
\DoxyCodeLine{7603         \textcolor{keywordtype}{void} addInitialFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters );}
\DoxyCodeLine{7604         \textcolor{keywordtype}{void} addNextFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters );}
\DoxyCodeLine{7606         std::vector<std::string> \textcolor{keyword}{const}\& getFilters() \textcolor{keyword}{const};}
\DoxyCodeLine{7608         std::string \textcolor{keyword}{const}\& trimmedName() \textcolor{keyword}{const};}
\DoxyCodeLine{7609     \};}
\DoxyCodeLine{7610 }
\DoxyCodeLine{7611 \} \textcolor{comment}{// namespace TestCaseTracking}}
\DoxyCodeLine{7612 }
\DoxyCodeLine{7613 \textcolor{keyword}{using} TestCaseTracking::ITracker;}
\DoxyCodeLine{7614 \textcolor{keyword}{using} TestCaseTracking::TrackerContext;}
\DoxyCodeLine{7615 \textcolor{keyword}{using} TestCaseTracking::SectionTracker;}
\DoxyCodeLine{7616 }
\DoxyCodeLine{7617 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7618 }
\DoxyCodeLine{7619 \textcolor{comment}{// end catch\_test\_case\_tracker.h}}
\DoxyCodeLine{7620 }
\DoxyCodeLine{7621 \textcolor{comment}{// start catch\_leak\_detector.h}}
\DoxyCodeLine{7622 }
\DoxyCodeLine{7623 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7624 }
\DoxyCodeLine{7625     \textcolor{keyword}{struct }LeakDetector \{}
\DoxyCodeLine{7626         LeakDetector();}
\DoxyCodeLine{7627         \string~LeakDetector();}
\DoxyCodeLine{7628     \};}
\DoxyCodeLine{7629 }
\DoxyCodeLine{7630 \}}
\DoxyCodeLine{7631 \textcolor{comment}{// end catch\_leak\_detector.h}}
\DoxyCodeLine{7632 \textcolor{comment}{// Cpp files will be included in the single-\/header file here}}
\DoxyCodeLine{7633 \textcolor{comment}{// start catch\_stats.cpp}}
\DoxyCodeLine{7634 }
\DoxyCodeLine{7635 \textcolor{comment}{// Statistical analysis tools}}
\DoxyCodeLine{7636 }
\DoxyCodeLine{7637 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{7638 }
\DoxyCodeLine{7639 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{7640 \textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{7641 }
\DoxyCodeLine{7642 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_USE\_ASYNC)}}
\DoxyCodeLine{7643 \textcolor{preprocessor}{\#include <future>}}
\DoxyCodeLine{7644 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7645 }
\DoxyCodeLine{7646 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{7647     \textcolor{keywordtype}{double} erf\_inv(\textcolor{keywordtype}{double} x) \{}
\DoxyCodeLine{7648         \textcolor{comment}{// Code accompanying the article "{}Approximating the erfinv function"{} in GPU Computing Gems, Volume 2}}
\DoxyCodeLine{7649         \textcolor{keywordtype}{double} w, p;}
\DoxyCodeLine{7650 }
\DoxyCodeLine{7651         w = -\/log((1.0 -\/ x) * (1.0 + x));}
\DoxyCodeLine{7652 }
\DoxyCodeLine{7653         \textcolor{keywordflow}{if} (w < 6.250000) \{}
\DoxyCodeLine{7654             w = w -\/ 3.125000;}
\DoxyCodeLine{7655             p = -\/3.6444120640178196996e-\/21;}
\DoxyCodeLine{7656             p = -\/1.685059138182016589e-\/19 + p * w;}
\DoxyCodeLine{7657             p = 1.2858480715256400167e-\/18 + p * w;}
\DoxyCodeLine{7658             p = 1.115787767802518096e-\/17 + p * w;}
\DoxyCodeLine{7659             p = -\/1.333171662854620906e-\/16 + p * w;}
\DoxyCodeLine{7660             p = 2.0972767875968561637e-\/17 + p * w;}
\DoxyCodeLine{7661             p = 6.6376381343583238325e-\/15 + p * w;}
\DoxyCodeLine{7662             p = -\/4.0545662729752068639e-\/14 + p * w;}
\DoxyCodeLine{7663             p = -\/8.1519341976054721522e-\/14 + p * w;}
\DoxyCodeLine{7664             p = 2.6335093153082322977e-\/12 + p * w;}
\DoxyCodeLine{7665             p = -\/1.2975133253453532498e-\/11 + p * w;}
\DoxyCodeLine{7666             p = -\/5.4154120542946279317e-\/11 + p * w;}
\DoxyCodeLine{7667             p = 1.051212273321532285e-\/09 + p * w;}
\DoxyCodeLine{7668             p = -\/4.1126339803469836976e-\/09 + p * w;}
\DoxyCodeLine{7669             p = -\/2.9070369957882005086e-\/08 + p * w;}
\DoxyCodeLine{7670             p = 4.2347877827932403518e-\/07 + p * w;}
\DoxyCodeLine{7671             p = -\/1.3654692000834678645e-\/06 + p * w;}
\DoxyCodeLine{7672             p = -\/1.3882523362786468719e-\/05 + p * w;}
\DoxyCodeLine{7673             p = 0.0001867342080340571352 + p * w;}
\DoxyCodeLine{7674             p = -\/0.00074070253416626697512 + p * w;}
\DoxyCodeLine{7675             p = -\/0.0060336708714301490533 + p * w;}
\DoxyCodeLine{7676             p = 0.24015818242558961693 + p * w;}
\DoxyCodeLine{7677             p = 1.6536545626831027356 + p * w;}
\DoxyCodeLine{7678         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (w < 16.000000) \{}
\DoxyCodeLine{7679             w = sqrt(w) -\/ 3.250000;}
\DoxyCodeLine{7680             p = 2.2137376921775787049e-\/09;}
\DoxyCodeLine{7681             p = 9.0756561938885390979e-\/08 + p * w;}
\DoxyCodeLine{7682             p = -\/2.7517406297064545428e-\/07 + p * w;}
\DoxyCodeLine{7683             p = 1.8239629214389227755e-\/08 + p * w;}
\DoxyCodeLine{7684             p = 1.5027403968909827627e-\/06 + p * w;}
\DoxyCodeLine{7685             p = -\/4.013867526981545969e-\/06 + p * w;}
\DoxyCodeLine{7686             p = 2.9234449089955446044e-\/06 + p * w;}
\DoxyCodeLine{7687             p = 1.2475304481671778723e-\/05 + p * w;}
\DoxyCodeLine{7688             p = -\/4.7318229009055733981e-\/05 + p * w;}
\DoxyCodeLine{7689             p = 6.8284851459573175448e-\/05 + p * w;}
\DoxyCodeLine{7690             p = 2.4031110387097893999e-\/05 + p * w;}
\DoxyCodeLine{7691             p = -\/0.0003550375203628474796 + p * w;}
\DoxyCodeLine{7692             p = 0.00095328937973738049703 + p * w;}
\DoxyCodeLine{7693             p = -\/0.0016882755560235047313 + p * w;}
\DoxyCodeLine{7694             p = 0.0024914420961078508066 + p * w;}
\DoxyCodeLine{7695             p = -\/0.0037512085075692412107 + p * w;}
\DoxyCodeLine{7696             p = 0.005370914553590063617 + p * w;}
\DoxyCodeLine{7697             p = 1.0052589676941592334 + p * w;}
\DoxyCodeLine{7698             p = 3.0838856104922207635 + p * w;}
\DoxyCodeLine{7699         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{7700             w = sqrt(w) -\/ 5.000000;}
\DoxyCodeLine{7701             p = -\/2.7109920616438573243e-\/11;}
\DoxyCodeLine{7702             p = -\/2.5556418169965252055e-\/10 + p * w;}
\DoxyCodeLine{7703             p = 1.5076572693500548083e-\/09 + p * w;}
\DoxyCodeLine{7704             p = -\/3.7894654401267369937e-\/09 + p * w;}
\DoxyCodeLine{7705             p = 7.6157012080783393804e-\/09 + p * w;}
\DoxyCodeLine{7706             p = -\/1.4960026627149240478e-\/08 + p * w;}
\DoxyCodeLine{7707             p = 2.9147953450901080826e-\/08 + p * w;}
\DoxyCodeLine{7708             p = -\/6.7711997758452339498e-\/08 + p * w;}
\DoxyCodeLine{7709             p = 2.2900482228026654717e-\/07 + p * w;}
\DoxyCodeLine{7710             p = -\/9.9298272942317002539e-\/07 + p * w;}
\DoxyCodeLine{7711             p = 4.5260625972231537039e-\/06 + p * w;}
\DoxyCodeLine{7712             p = -\/1.9681778105531670567e-\/05 + p * w;}
\DoxyCodeLine{7713             p = 7.5995277030017761139e-\/05 + p * w;}
\DoxyCodeLine{7714             p = -\/0.00021503011930044477347 + p * w;}
\DoxyCodeLine{7715             p = -\/0.00013871931833623122026 + p * w;}
\DoxyCodeLine{7716             p = 1.0103004648645343977 + p * w;}
\DoxyCodeLine{7717             p = 4.8499064014085844221 + p * w;}
\DoxyCodeLine{7718         \}}
\DoxyCodeLine{7719         \textcolor{keywordflow}{return} p * x;}
\DoxyCodeLine{7720     \}}
\DoxyCodeLine{7721 }
\DoxyCodeLine{7722     \textcolor{keywordtype}{double} standard\_deviation(std::vector<double>::iterator first, std::vector<double>::iterator last) \{}
\DoxyCodeLine{7723         \textcolor{keyword}{auto} m = Catch::Benchmark::Detail::mean(first, last);}
\DoxyCodeLine{7724         \textcolor{keywordtype}{double} variance = std::accumulate(first, last, 0., [m](\textcolor{keywordtype}{double} a, \textcolor{keywordtype}{double} b) \{}
\DoxyCodeLine{7725             \textcolor{keywordtype}{double} diff = b -\/ m;}
\DoxyCodeLine{7726             \textcolor{keywordflow}{return} a + diff * diff;}
\DoxyCodeLine{7727             \}) / (last -\/ first);}
\DoxyCodeLine{7728             \textcolor{keywordflow}{return} std::sqrt(variance);}
\DoxyCodeLine{7729     \}}
\DoxyCodeLine{7730 }
\DoxyCodeLine{7731 \}}
\DoxyCodeLine{7732 }
\DoxyCodeLine{7733 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7734     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7735         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7736 }
\DoxyCodeLine{7737             \textcolor{keywordtype}{double} weighted\_average\_quantile(\textcolor{keywordtype}{int} k, \textcolor{keywordtype}{int} q, std::vector<double>::iterator first, std::vector<double>::iterator last) \{}
\DoxyCodeLine{7738                 \textcolor{keyword}{auto} count = last -\/ first;}
\DoxyCodeLine{7739                 \textcolor{keywordtype}{double} idx = (count -\/ 1) * k / static\_cast<double>(q);}
\DoxyCodeLine{7740                 \textcolor{keywordtype}{int} j = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(idx);}
\DoxyCodeLine{7741                 \textcolor{keywordtype}{double} g = idx -\/ j;}
\DoxyCodeLine{7742                 std::nth\_element(first, first + j, last);}
\DoxyCodeLine{7743                 \textcolor{keyword}{auto} xj = first[j];}
\DoxyCodeLine{7744                 \textcolor{keywordflow}{if} (g == 0) \textcolor{keywordflow}{return} xj;}
\DoxyCodeLine{7745 }
\DoxyCodeLine{7746                 \textcolor{keyword}{auto} xj1 = *std::min\_element(first + (j + 1), last);}
\DoxyCodeLine{7747                 \textcolor{keywordflow}{return} xj + g * (xj1 -\/ xj);}
\DoxyCodeLine{7748             \}}
\DoxyCodeLine{7749 }
\DoxyCodeLine{7750             \textcolor{keywordtype}{double} erfc\_inv(\textcolor{keywordtype}{double} x) \{}
\DoxyCodeLine{7751                 \textcolor{keywordflow}{return} erf\_inv(1.0 -\/ x);}
\DoxyCodeLine{7752             \}}
\DoxyCodeLine{7753 }
\DoxyCodeLine{7754             \textcolor{keywordtype}{double} normal\_quantile(\textcolor{keywordtype}{double} p) \{}
\DoxyCodeLine{7755                 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} ROOT\_TWO = std::sqrt(2.0);}
\DoxyCodeLine{7756 }
\DoxyCodeLine{7757                 \textcolor{keywordtype}{double} result = 0.0;}
\DoxyCodeLine{7758                 assert(p >= 0 \&\& p <= 1);}
\DoxyCodeLine{7759                 \textcolor{keywordflow}{if} (p < 0 || p > 1) \{}
\DoxyCodeLine{7760                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{7761                 \}}
\DoxyCodeLine{7762 }
\DoxyCodeLine{7763                 result = -\/erfc\_inv(2.0 * p);}
\DoxyCodeLine{7764                 \textcolor{comment}{// result *= normal distribution standard deviation (1.0) * sqrt(2)}}
\DoxyCodeLine{7765                 result *= \textcolor{comment}{/*sd * */} ROOT\_TWO;}
\DoxyCodeLine{7766                 \textcolor{comment}{// result += normal disttribution mean (0)}}
\DoxyCodeLine{7767                 \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{7768             \}}
\DoxyCodeLine{7769 }
\DoxyCodeLine{7770             \textcolor{keywordtype}{double} outlier\_variance(Estimate<double> mean, Estimate<double> stddev, \textcolor{keywordtype}{int} n) \{}
\DoxyCodeLine{7771                 \textcolor{keywordtype}{double} sb = stddev.point;}
\DoxyCodeLine{7772                 \textcolor{keywordtype}{double} mn = mean.point / n;}
\DoxyCodeLine{7773                 \textcolor{keywordtype}{double} mg\_min = mn / 2.;}
\DoxyCodeLine{7774                 \textcolor{keywordtype}{double} sg = std::min(mg\_min / 4., sb / std::sqrt(n));}
\DoxyCodeLine{7775                 \textcolor{keywordtype}{double} sg2 = sg * sg;}
\DoxyCodeLine{7776                 \textcolor{keywordtype}{double} sb2 = sb * sb;}
\DoxyCodeLine{7777 }
\DoxyCodeLine{7778                 \textcolor{keyword}{auto} c\_max = [n, mn, sb2, sg2](\textcolor{keywordtype}{double} x) -\/> \textcolor{keywordtype}{double} \{}
\DoxyCodeLine{7779                     \textcolor{keywordtype}{double} k = mn -\/ x;}
\DoxyCodeLine{7780                     \textcolor{keywordtype}{double} d = k * k;}
\DoxyCodeLine{7781                     \textcolor{keywordtype}{double} nd = n * d;}
\DoxyCodeLine{7782                     \textcolor{keywordtype}{double} k0 = -\/n * nd;}
\DoxyCodeLine{7783                     \textcolor{keywordtype}{double} k1 = sb2 -\/ n * sg2 + nd;}
\DoxyCodeLine{7784                     \textcolor{keywordtype}{double} det = k1 * k1 -\/ 4 * sg2 * k0;}
\DoxyCodeLine{7785                     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{int})(-\/2. * k0 / (k1 + std::sqrt(det)));}
\DoxyCodeLine{7786                 \};}
\DoxyCodeLine{7787 }
\DoxyCodeLine{7788                 \textcolor{keyword}{auto} var\_out = [n, sb2, sg2](\textcolor{keywordtype}{double} c) \{}
\DoxyCodeLine{7789                     \textcolor{keywordtype}{double} nc = n -\/ c;}
\DoxyCodeLine{7790                     \textcolor{keywordflow}{return} (nc / n) * (sb2 -\/ nc * sg2);}
\DoxyCodeLine{7791                 \};}
\DoxyCodeLine{7792 }
\DoxyCodeLine{7793                 \textcolor{keywordflow}{return} std::min(var\_out(1), var\_out(std::min(c\_max(0.), c\_max(mg\_min)))) / sb2;}
\DoxyCodeLine{7794             \}}
\DoxyCodeLine{7795 }
\DoxyCodeLine{7796             bootstrap\_analysis analyse\_samples(\textcolor{keywordtype}{double} confidence\_level, \textcolor{keywordtype}{int} n\_resamples, std::vector<double>::iterator first, std::vector<double>::iterator last) \{}
\DoxyCodeLine{7797                 CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION}
\DoxyCodeLine{7798                 CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS}
\DoxyCodeLine{7799                 \textcolor{keyword}{static} std::random\_device entropy;}
\DoxyCodeLine{7800                 CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}
\DoxyCodeLine{7801 }
\DoxyCodeLine{7802                 \textcolor{keyword}{auto} n = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(last -\/ first); \textcolor{comment}{// seriously, one can't use integral types without hell in C++}}
\DoxyCodeLine{7803 }
\DoxyCodeLine{7804                 \textcolor{keyword}{auto} mean = \&Detail::mean<std::vector<double>::iterator>;}
\DoxyCodeLine{7805                 \textcolor{keyword}{auto} stddev = \&standard\_deviation;}
\DoxyCodeLine{7806 }
\DoxyCodeLine{7807 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_USE\_ASYNC)}}
\DoxyCodeLine{7808                 \textcolor{keyword}{auto} Estimate = [=](double(*f)(std::vector<double>::iterator, std::vector<double>::iterator)) \{}
\DoxyCodeLine{7809                     \textcolor{keyword}{auto} seed = entropy();}
\DoxyCodeLine{7810                     \textcolor{keywordflow}{return} std::async(std::launch::async, [=] \{}
\DoxyCodeLine{7811                         std::mt19937 rng(seed);}
\DoxyCodeLine{7812                         \textcolor{keyword}{auto} resampled = resample(rng, n\_resamples, first, last, f);}
\DoxyCodeLine{7813                         \textcolor{keywordflow}{return} bootstrap(confidence\_level, first, last, resampled, f);}
\DoxyCodeLine{7814                     \});}
\DoxyCodeLine{7815                 \};}
\DoxyCodeLine{7816 }
\DoxyCodeLine{7817                 \textcolor{keyword}{auto} mean\_future = Estimate(mean);}
\DoxyCodeLine{7818                 \textcolor{keyword}{auto} stddev\_future = Estimate(stddev);}
\DoxyCodeLine{7819 }
\DoxyCodeLine{7820                 \textcolor{keyword}{auto} mean\_estimate = mean\_future.get();}
\DoxyCodeLine{7821                 \textcolor{keyword}{auto} stddev\_estimate = stddev\_future.get();}
\DoxyCodeLine{7822 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{7823                 \textcolor{keyword}{auto} Estimate = [=](double(*f)(std::vector<double>::iterator, std::vector<double>::iterator)) \{}
\DoxyCodeLine{7824                     \textcolor{keyword}{auto} seed = entropy();}
\DoxyCodeLine{7825                     std::mt19937 rng(seed);}
\DoxyCodeLine{7826                     \textcolor{keyword}{auto} resampled = resample(rng, n\_resamples, first, last, f);}
\DoxyCodeLine{7827                     \textcolor{keywordflow}{return} bootstrap(confidence\_level, first, last, resampled, f);}
\DoxyCodeLine{7828                 \};}
\DoxyCodeLine{7829 }
\DoxyCodeLine{7830                 \textcolor{keyword}{auto} mean\_estimate = Estimate(mean);}
\DoxyCodeLine{7831                 \textcolor{keyword}{auto} stddev\_estimate = Estimate(stddev);}
\DoxyCodeLine{7832 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_USE\_ASYNC}}
\DoxyCodeLine{7833 }
\DoxyCodeLine{7834                 \textcolor{keywordtype}{double} outlier\_variance = Detail::outlier\_variance(mean\_estimate, stddev\_estimate, n);}
\DoxyCodeLine{7835 }
\DoxyCodeLine{7836                 \textcolor{keywordflow}{return} \{ mean\_estimate, stddev\_estimate, outlier\_variance \};}
\DoxyCodeLine{7837             \}}
\DoxyCodeLine{7838         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{7839     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7840 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7841 }
\DoxyCodeLine{7842 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{7843 \textcolor{comment}{// end catch\_stats.cpp}}
\DoxyCodeLine{7844 \textcolor{comment}{// start catch\_approx.cpp}}
\DoxyCodeLine{7845 }
\DoxyCodeLine{7846 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{7847 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{7848 }
\DoxyCodeLine{7849 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{7850 }
\DoxyCodeLine{7851 \textcolor{comment}{// Performs equivalent check of std::fabs(lhs -\/ rhs) <= margin}}
\DoxyCodeLine{7852 \textcolor{comment}{// But without the subtraction to allow for INFINITY in comparison}}
\DoxyCodeLine{7853 \textcolor{keywordtype}{bool} marginComparison(\textcolor{keywordtype}{double} lhs, \textcolor{keywordtype}{double} rhs, \textcolor{keywordtype}{double} margin) \{}
\DoxyCodeLine{7854     \textcolor{keywordflow}{return} (lhs + margin >= rhs) \&\& (rhs + margin >= lhs);}
\DoxyCodeLine{7855 \}}
\DoxyCodeLine{7856 }
\DoxyCodeLine{7857 \}}
\DoxyCodeLine{7858 }
\DoxyCodeLine{7859 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7860 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7861 }
\DoxyCodeLine{7862     Approx::Approx ( \textcolor{keywordtype}{double} value )}
\DoxyCodeLine{7863     :   m\_epsilon( std::numeric\_limits<float>::epsilon()*100 ),}
\DoxyCodeLine{7864         m\_margin( 0.0 ),}
\DoxyCodeLine{7865         m\_scale( 0.0 ),}
\DoxyCodeLine{7866         m\_value( value )}
\DoxyCodeLine{7867     \{\}}
\DoxyCodeLine{7868 }
\DoxyCodeLine{7869     \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} Approx::custom() \{}
\DoxyCodeLine{7870         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}}( 0 );}
\DoxyCodeLine{7871     \}}
\DoxyCodeLine{7872 }
\DoxyCodeLine{7873     \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} Approx::operator-\/()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7874         \textcolor{keyword}{auto} temp(*\textcolor{keyword}{this});}
\DoxyCodeLine{7875         temp.m\_value = -\/temp.m\_value;}
\DoxyCodeLine{7876         \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{7877     \}}
\DoxyCodeLine{7878 }
\DoxyCodeLine{7879     std::string Approx::toString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7880         ReusableStringStream rss;}
\DoxyCodeLine{7881         rss << \textcolor{stringliteral}{"{}Approx( "{}} << ::Catch::Detail::stringify( m\_value ) << \textcolor{stringliteral}{"{} )"{}};}
\DoxyCodeLine{7882         \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{7883     \}}
\DoxyCodeLine{7884 }
\DoxyCodeLine{7885     \textcolor{keywordtype}{bool} Approx::equalityComparisonImpl(\textcolor{keyword}{const} \textcolor{keywordtype}{double} other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7886         \textcolor{comment}{// First try with fixed margin, then compute margin based on epsilon, scale and Approx's value}}
\DoxyCodeLine{7887         \textcolor{comment}{// Thanks to Richard Harris for his help refining the scaled margin value}}
\DoxyCodeLine{7888         \textcolor{keywordflow}{return} marginComparison(m\_value, other, m\_margin)}
\DoxyCodeLine{7889             || marginComparison(m\_value, other, m\_epsilon * (m\_scale + std::fabs(std::isinf(m\_value)? 0 : m\_value)));}
\DoxyCodeLine{7890     \}}
\DoxyCodeLine{7891 }
\DoxyCodeLine{7892     \textcolor{keywordtype}{void} Approx::setMargin(\textcolor{keywordtype}{double} newMargin) \{}
\DoxyCodeLine{7893         CATCH\_ENFORCE(newMargin >= 0,}
\DoxyCodeLine{7894             \textcolor{stringliteral}{"{}Invalid Approx::margin: "{}} << newMargin << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{7895             << \textcolor{stringliteral}{"{} Approx::Margin has to be non-\/negative."{}});}
\DoxyCodeLine{7896         m\_margin = newMargin;}
\DoxyCodeLine{7897     \}}
\DoxyCodeLine{7898 }
\DoxyCodeLine{7899     \textcolor{keywordtype}{void} Approx::setEpsilon(\textcolor{keywordtype}{double} newEpsilon) \{}
\DoxyCodeLine{7900         CATCH\_ENFORCE(newEpsilon >= 0 \&\& newEpsilon <= 1.0,}
\DoxyCodeLine{7901             \textcolor{stringliteral}{"{}Invalid Approx::epsilon: "{}} << newEpsilon << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{7902             << \textcolor{stringliteral}{"{} Approx::epsilon has to be in [0, 1]"{}});}
\DoxyCodeLine{7903         m\_epsilon = newEpsilon;}
\DoxyCodeLine{7904     \}}
\DoxyCodeLine{7905 }
\DoxyCodeLine{7906 \} \textcolor{comment}{// end namespace Detail}}
\DoxyCodeLine{7907 }
\DoxyCodeLine{7908 \textcolor{keyword}{namespace }literals \{}
\DoxyCodeLine{7909     Detail::Approx \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} val) \{}
\DoxyCodeLine{7910         \textcolor{keywordflow}{return} Detail::Approx(val);}
\DoxyCodeLine{7911     \}}
\DoxyCodeLine{7912     Detail::Approx \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val) \{}
\DoxyCodeLine{7913         \textcolor{keywordflow}{return} Detail::Approx(val);}
\DoxyCodeLine{7914     \}}
\DoxyCodeLine{7915 \} \textcolor{comment}{// end namespace literals}}
\DoxyCodeLine{7916 }
\DoxyCodeLine{7917 std::string StringMaker<Catch::Detail::Approx>::convert(\mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Catch::Detail::Approx}} \textcolor{keyword}{const}\& value) \{}
\DoxyCodeLine{7918     \textcolor{keywordflow}{return} value.toString();}
\DoxyCodeLine{7919 \}}
\DoxyCodeLine{7920 }
\DoxyCodeLine{7921 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{7922 \textcolor{comment}{// end catch\_approx.cpp}}
\DoxyCodeLine{7923 \textcolor{comment}{// start catch\_assertionhandler.cpp}}
\DoxyCodeLine{7924 }
\DoxyCodeLine{7925 \textcolor{comment}{// start catch\_debugger.h}}
\DoxyCodeLine{7926 }
\DoxyCodeLine{7927 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7928     \textcolor{keywordtype}{bool} isDebuggerActive();}
\DoxyCodeLine{7929 \}}
\DoxyCodeLine{7930 }
\DoxyCodeLine{7931 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{7932 }
\DoxyCodeLine{7933 \textcolor{preprocessor}{    \#if defined(\_\_i386\_\_) || defined(\_\_x86\_64\_\_)}}
\DoxyCodeLine{7934 \textcolor{preprocessor}{        \#define CATCH\_TRAP() \_\_asm\_\_("{}int \$3\(\backslash\)n"{}} : : ) \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{}}
\DoxyCodeLine{7935 \textcolor{preprocessor}{    \#elif defined(\_\_aarch64\_\_)}}
\DoxyCodeLine{7936 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}.inst 0xd4200000"{}})}
\DoxyCodeLine{7937 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{7938 }
\DoxyCodeLine{7939 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_IPHONE)}}
\DoxyCodeLine{7940 }
\DoxyCodeLine{7941     \textcolor{comment}{// use inline assembler}}
\DoxyCodeLine{7942 \textcolor{preprocessor}{    \#if defined(\_\_i386\_\_) || defined(\_\_x86\_64\_\_)}}
\DoxyCodeLine{7943 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}int \$3"{}})}
\DoxyCodeLine{7944 \textcolor{preprocessor}{    \#elif defined(\_\_aarch64\_\_)}}
\DoxyCodeLine{7945 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}.inst 0xd4200000"{}})}
\DoxyCodeLine{7946 \textcolor{preprocessor}{    \#elif defined(\_\_arm\_\_) \&\& !defined(\_\_thumb\_\_)}}
\DoxyCodeLine{7947 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}.inst 0xe7f001f0"{}})}
\DoxyCodeLine{7948 \textcolor{preprocessor}{    \#elif defined(\_\_arm\_\_) \&\&  defined(\_\_thumb\_\_)}}
\DoxyCodeLine{7949 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}.inst 0xde01"{}})}
\DoxyCodeLine{7950 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{7951 }
\DoxyCodeLine{7952 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_LINUX)}}
\DoxyCodeLine{7953     \textcolor{comment}{// If we can use inline assembler, do it because this allows us to break}}
\DoxyCodeLine{7954     \textcolor{comment}{// directly at the location of the failing check instead of breaking inside}}
\DoxyCodeLine{7955     \textcolor{comment}{// raise() called from it, i.e. one stack frame below.}}
\DoxyCodeLine{7956 \textcolor{preprocessor}{    \#if defined(\_\_GNUC\_\_) \&\& (defined(\_\_i386) || defined(\_\_x86\_64))}}
\DoxyCodeLine{7957 \textcolor{preprocessor}{        \#define CATCH\_TRAP() asm volatile ("{}int \$3"{}}) \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{}}
\DoxyCodeLine{7958 \textcolor{preprocessor}{    \#else }\textcolor{comment}{// Fall back to the generic way.}}
\DoxyCodeLine{7959 \textcolor{preprocessor}{        \#include <signal.h>}}
\DoxyCodeLine{7960 }
\DoxyCodeLine{7961 \textcolor{preprocessor}{        \#define CATCH\_TRAP() raise(SIGTRAP)}}
\DoxyCodeLine{7962 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{7963 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{7964 \textcolor{preprocessor}{    \#define CATCH\_TRAP() \_\_debugbreak()}}
\DoxyCodeLine{7965 \textcolor{preprocessor}{\#elif defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{7966     \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \_\_declspec(dllimport) \textcolor{keywordtype}{void} \_\_stdcall DebugBreak();}
\DoxyCodeLine{7967 \textcolor{preprocessor}{    \#define CATCH\_TRAP() DebugBreak()}}
\DoxyCodeLine{7968 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7969 }
\DoxyCodeLine{7970 \textcolor{preprocessor}{\#ifndef CATCH\_BREAK\_INTO\_DEBUGGER}}
\DoxyCodeLine{7971 \textcolor{preprocessor}{    \#ifdef CATCH\_TRAP}}
\DoxyCodeLine{7972 \textcolor{preprocessor}{        \#define CATCH\_BREAK\_INTO\_DEBUGGER() []\{ if( Catch::isDebuggerActive() ) \{ CATCH\_TRAP(); \} \}()}}
\DoxyCodeLine{7973 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{7974 \textcolor{preprocessor}{        \#define CATCH\_BREAK\_INTO\_DEBUGGER() []\{\}()}}
\DoxyCodeLine{7975 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{7976 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7977 }
\DoxyCodeLine{7978 \textcolor{comment}{// end catch\_debugger.h}}
\DoxyCodeLine{7979 \textcolor{comment}{// start catch\_run\_context.h}}
\DoxyCodeLine{7980 }
\DoxyCodeLine{7981 \textcolor{comment}{// start catch\_fatal\_condition.h}}
\DoxyCodeLine{7982 }
\DoxyCodeLine{7983 \textcolor{comment}{// start catch\_windows\_h\_proxy.h}}
\DoxyCodeLine{7984 }
\DoxyCodeLine{7985 }
\DoxyCodeLine{7986 \textcolor{preprocessor}{\#if defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{7987 }
\DoxyCodeLine{7988 \textcolor{preprocessor}{\#if !defined(NOMINMAX) \&\& !defined(CATCH\_CONFIG\_NO\_NOMINMAX)}}
\DoxyCodeLine{7989 \textcolor{preprocessor}{\#  define CATCH\_DEFINED\_NOMINMAX}}
\DoxyCodeLine{7990 \textcolor{preprocessor}{\#  define NOMINMAX}}
\DoxyCodeLine{7991 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7992 \textcolor{preprocessor}{\#if !defined(WIN32\_LEAN\_AND\_MEAN) \&\& !defined(CATCH\_CONFIG\_NO\_WIN32\_LEAN\_AND\_MEAN)}}
\DoxyCodeLine{7993 \textcolor{preprocessor}{\#  define CATCH\_DEFINED\_WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{7994 \textcolor{preprocessor}{\#  define WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{7995 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7996 }
\DoxyCodeLine{7997 \textcolor{preprocessor}{\#ifdef \_\_AFXDLL}}
\DoxyCodeLine{7998 \textcolor{preprocessor}{\#include <AfxWin.h>}}
\DoxyCodeLine{7999 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{8000 \textcolor{preprocessor}{\#include <windows.h>}}
\DoxyCodeLine{8001 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8002 }
\DoxyCodeLine{8003 \textcolor{preprocessor}{\#ifdef CATCH\_DEFINED\_NOMINMAX}}
\DoxyCodeLine{8004 \textcolor{preprocessor}{\#  undef NOMINMAX}}
\DoxyCodeLine{8005 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8006 \textcolor{preprocessor}{\#ifdef CATCH\_DEFINED\_WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{8007 \textcolor{preprocessor}{\#  undef WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{8008 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8009 }
\DoxyCodeLine{8010 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{8011 }
\DoxyCodeLine{8012 \textcolor{comment}{// end catch\_windows\_h\_proxy.h}}
\DoxyCodeLine{8013 \textcolor{preprocessor}{\#if defined( CATCH\_CONFIG\_WINDOWS\_SEH )}}
\DoxyCodeLine{8014 }
\DoxyCodeLine{8015 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8016 }
\DoxyCodeLine{8017     \textcolor{keyword}{struct }FatalConditionHandler \{}
\DoxyCodeLine{8018 }
\DoxyCodeLine{8019         \textcolor{keyword}{static} LONG CALLBACK handleVectoredException(PEXCEPTION\_POINTERS ExceptionInfo);}
\DoxyCodeLine{8020         FatalConditionHandler();}
\DoxyCodeLine{8021         \textcolor{keyword}{static} \textcolor{keywordtype}{void} reset();}
\DoxyCodeLine{8022         \string~FatalConditionHandler();}
\DoxyCodeLine{8023 }
\DoxyCodeLine{8024     \textcolor{keyword}{private}:}
\DoxyCodeLine{8025         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} isSet;}
\DoxyCodeLine{8026         \textcolor{keyword}{static} ULONG guaranteeSize;}
\DoxyCodeLine{8027         \textcolor{keyword}{static} PVOID exceptionHandlerHandle;}
\DoxyCodeLine{8028     \};}
\DoxyCodeLine{8029 }
\DoxyCodeLine{8030 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{8031 }
\DoxyCodeLine{8032 \textcolor{preprocessor}{\#elif defined ( CATCH\_CONFIG\_POSIX\_SIGNALS )}}
\DoxyCodeLine{8033 }
\DoxyCodeLine{8034 \textcolor{preprocessor}{\#include <signal.h>}}
\DoxyCodeLine{8035 }
\DoxyCodeLine{8036 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8037 }
\DoxyCodeLine{8038     \textcolor{keyword}{struct }FatalConditionHandler \{}
\DoxyCodeLine{8039 }
\DoxyCodeLine{8040         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} isSet;}
\DoxyCodeLine{8041         \textcolor{keyword}{static} \textcolor{keyword}{struct }sigaction oldSigActions[];}
\DoxyCodeLine{8042         \textcolor{keyword}{static} stack\_t oldSigStack;}
\DoxyCodeLine{8043         \textcolor{keyword}{static} \textcolor{keywordtype}{char} altStackMem[];}
\DoxyCodeLine{8044 }
\DoxyCodeLine{8045         \textcolor{keyword}{static} \textcolor{keywordtype}{void} handleSignal( \textcolor{keywordtype}{int} sig );}
\DoxyCodeLine{8046 }
\DoxyCodeLine{8047         FatalConditionHandler();}
\DoxyCodeLine{8048         \string~FatalConditionHandler();}
\DoxyCodeLine{8049         \textcolor{keyword}{static} \textcolor{keywordtype}{void} reset();}
\DoxyCodeLine{8050     \};}
\DoxyCodeLine{8051 }
\DoxyCodeLine{8052 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{8053 }
\DoxyCodeLine{8054 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{8055 }
\DoxyCodeLine{8056 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8057     \textcolor{keyword}{struct }FatalConditionHandler \{}
\DoxyCodeLine{8058         \textcolor{keywordtype}{void} reset();}
\DoxyCodeLine{8059     \};}
\DoxyCodeLine{8060 \}}
\DoxyCodeLine{8061 }
\DoxyCodeLine{8062 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8063 }
\DoxyCodeLine{8064 \textcolor{comment}{// end catch\_fatal\_condition.h}}
\DoxyCodeLine{8065 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{8066 }
\DoxyCodeLine{8067 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8068 }
\DoxyCodeLine{8069     \textcolor{keyword}{struct }IMutableContext;}
\DoxyCodeLine{8070 }
\DoxyCodeLine{8072 }
\DoxyCodeLine{8073     \textcolor{keyword}{class }RunContext : \textcolor{keyword}{public} IResultCapture, \textcolor{keyword}{public} IRunner \{}
\DoxyCodeLine{8074 }
\DoxyCodeLine{8075     \textcolor{keyword}{public}:}
\DoxyCodeLine{8076         RunContext( RunContext \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{8077         RunContext\& operator =( RunContext \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{8078 }
\DoxyCodeLine{8079         \textcolor{keyword}{explicit} RunContext( IConfigPtr \textcolor{keyword}{const}\& \_config, IStreamingReporterPtr\&\& reporter );}
\DoxyCodeLine{8080 }
\DoxyCodeLine{8081         \string~RunContext() \textcolor{keyword}{override};}
\DoxyCodeLine{8082 }
\DoxyCodeLine{8083         \textcolor{keywordtype}{void} testGroupStarting( std::string \textcolor{keyword}{const}\& testSpec, std::size\_t groupIndex, std::size\_t groupsCount );}
\DoxyCodeLine{8084         \textcolor{keywordtype}{void} testGroupEnded( std::string \textcolor{keyword}{const}\& testSpec, Totals \textcolor{keyword}{const}\& totals, std::size\_t groupIndex, std::size\_t groupsCount );}
\DoxyCodeLine{8085 }
\DoxyCodeLine{8086         Totals runTest(TestCase \textcolor{keyword}{const}\& testCase);}
\DoxyCodeLine{8087 }
\DoxyCodeLine{8088         IConfigPtr config() \textcolor{keyword}{const};}
\DoxyCodeLine{8089         IStreamingReporter\& reporter() \textcolor{keyword}{const};}
\DoxyCodeLine{8090 }
\DoxyCodeLine{8091     \textcolor{keyword}{public}: \textcolor{comment}{// IResultCapture}}
\DoxyCodeLine{8092 }
\DoxyCodeLine{8093         \textcolor{comment}{// Assertion handlers}}
\DoxyCodeLine{8094         \textcolor{keywordtype}{void} handleExpr}
\DoxyCodeLine{8095                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{8096                     ITransientExpression \textcolor{keyword}{const}\& expr,}
\DoxyCodeLine{8097                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8098         \textcolor{keywordtype}{void} handleMessage}
\DoxyCodeLine{8099                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{8100                     ResultWas::OfType resultType,}
\DoxyCodeLine{8101                     StringRef \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{8102                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8103         \textcolor{keywordtype}{void} handleUnexpectedExceptionNotThrown}
\DoxyCodeLine{8104                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{8105                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8106         \textcolor{keywordtype}{void} handleUnexpectedInflightException}
\DoxyCodeLine{8107                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{8108                     std::string \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{8109                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8110         \textcolor{keywordtype}{void} handleIncomplete}
\DoxyCodeLine{8111                 (   AssertionInfo \textcolor{keyword}{const}\& info ) \textcolor{keyword}{override};}
\DoxyCodeLine{8112         \textcolor{keywordtype}{void} handleNonExpr}
\DoxyCodeLine{8113                 (   AssertionInfo \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{8114                     ResultWas::OfType resultType,}
\DoxyCodeLine{8115                     AssertionReaction \&reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8116 }
\DoxyCodeLine{8117         \textcolor{keywordtype}{bool} sectionStarted( SectionInfo \textcolor{keyword}{const}\& sectionInfo, Counts\& assertions ) \textcolor{keyword}{override};}
\DoxyCodeLine{8118 }
\DoxyCodeLine{8119         \textcolor{keywordtype}{void} sectionEnded( SectionEndInfo \textcolor{keyword}{const}\& endInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{8120         \textcolor{keywordtype}{void} sectionEndedEarly( SectionEndInfo \textcolor{keyword}{const}\& endInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{8121 }
\DoxyCodeLine{8122         \textcolor{keyword}{auto} acquireGeneratorTracker( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -\/> IGeneratorTracker\& \textcolor{keyword}{override};}
\DoxyCodeLine{8123 }
\DoxyCodeLine{8124 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{8125         \textcolor{keywordtype}{void} benchmarkPreparing( std::string \textcolor{keyword}{const}\& name ) \textcolor{keyword}{override};}
\DoxyCodeLine{8126         \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& info ) \textcolor{keyword}{override};}
\DoxyCodeLine{8127         \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& stats ) \textcolor{keyword}{override};}
\DoxyCodeLine{8128         \textcolor{keywordtype}{void} benchmarkFailed( std::string \textcolor{keyword}{const}\& error ) \textcolor{keyword}{override};}
\DoxyCodeLine{8129 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{8130 }
\DoxyCodeLine{8131         \textcolor{keywordtype}{void} pushScopedMessage( MessageInfo \textcolor{keyword}{const}\& message ) \textcolor{keyword}{override};}
\DoxyCodeLine{8132         \textcolor{keywordtype}{void} popScopedMessage( MessageInfo \textcolor{keyword}{const}\& message ) \textcolor{keyword}{override};}
\DoxyCodeLine{8133 }
\DoxyCodeLine{8134         \textcolor{keywordtype}{void} emplaceUnscopedMessage( MessageBuilder \textcolor{keyword}{const}\& builder ) \textcolor{keyword}{override};}
\DoxyCodeLine{8135 }
\DoxyCodeLine{8136         std::string getCurrentTestName() \textcolor{keyword}{const override};}
\DoxyCodeLine{8137 }
\DoxyCodeLine{8138         \textcolor{keyword}{const} AssertionResult* getLastResult() \textcolor{keyword}{const override};}
\DoxyCodeLine{8139 }
\DoxyCodeLine{8140         \textcolor{keywordtype}{void} exceptionEarlyReported() \textcolor{keyword}{override};}
\DoxyCodeLine{8141 }
\DoxyCodeLine{8142         \textcolor{keywordtype}{void} handleFatalErrorCondition( StringRef message ) \textcolor{keyword}{override};}
\DoxyCodeLine{8143 }
\DoxyCodeLine{8144         \textcolor{keywordtype}{bool} lastAssertionPassed() \textcolor{keyword}{override};}
\DoxyCodeLine{8145 }
\DoxyCodeLine{8146         \textcolor{keywordtype}{void} assertionPassed() \textcolor{keyword}{override};}
\DoxyCodeLine{8147 }
\DoxyCodeLine{8148     \textcolor{keyword}{public}:}
\DoxyCodeLine{8149         \textcolor{comment}{// !TBD We need to do this another way!}}
\DoxyCodeLine{8150         \textcolor{keywordtype}{bool} aborting() const final;}
\DoxyCodeLine{8151 }
\DoxyCodeLine{8152     private:}
\DoxyCodeLine{8153 }
\DoxyCodeLine{8154         \textcolor{keywordtype}{void} runCurrentTest( std::\textcolor{keywordtype}{string}\& redirectedCout, std::\textcolor{keywordtype}{string}\& redirectedCerr );}
\DoxyCodeLine{8155         \textcolor{keywordtype}{void} invokeActiveTestCase();}
\DoxyCodeLine{8156 }
\DoxyCodeLine{8157         \textcolor{keywordtype}{void} resetAssertionInfo();}
\DoxyCodeLine{8158         \textcolor{keywordtype}{bool} testForMissingAssertions( Counts\& assertions );}
\DoxyCodeLine{8159 }
\DoxyCodeLine{8160         \textcolor{keywordtype}{void} assertionEnded( AssertionResult const\& result );}
\DoxyCodeLine{8161         \textcolor{keywordtype}{void} reportExpr}
\DoxyCodeLine{8162                 (   AssertionInfo const \&info,}
\DoxyCodeLine{8163                     ResultWas::OfType resultType,}
\DoxyCodeLine{8164                     ITransientExpression const *expr,}
\DoxyCodeLine{8165                     \textcolor{keywordtype}{bool} negated );}
\DoxyCodeLine{8166 }
\DoxyCodeLine{8167         \textcolor{keywordtype}{void} populateReaction( AssertionReaction\& reaction );}
\DoxyCodeLine{8168 }
\DoxyCodeLine{8169     private:}
\DoxyCodeLine{8170 }
\DoxyCodeLine{8171         \textcolor{keywordtype}{void} handleUnfinishedSections();}
\DoxyCodeLine{8172 }
\DoxyCodeLine{8173         TestRunInfo m\_runInfo;}
\DoxyCodeLine{8174         IMutableContext\& m\_context;}
\DoxyCodeLine{8175         TestCase const* m\_activeTestCase = \textcolor{keywordtype}{nullptr};}
\DoxyCodeLine{8176         ITracker* m\_testCaseTracker = \textcolor{keywordtype}{nullptr};}
\DoxyCodeLine{8177         Option<AssertionResult> m\_lastResult;}
\DoxyCodeLine{8178 }
\DoxyCodeLine{8179         IConfigPtr m\_config;}
\DoxyCodeLine{8180         Totals m\_totals;}
\DoxyCodeLine{8181         IStreamingReporterPtr m\_reporter;}
\DoxyCodeLine{8182         std::vector<MessageInfo> m\_messages;}
\DoxyCodeLine{8183         std::vector<ScopedMessage> m\_messageScopes; \textcolor{comment}{/* Keeps owners of so-\/called unscoped messages. */}}
\DoxyCodeLine{8184         AssertionInfo m\_lastAssertionInfo;}
\DoxyCodeLine{8185         std::vector<SectionEndInfo> m\_unfinishedSections;}
\DoxyCodeLine{8186         std::vector<ITracker*> m\_activeSections;}
\DoxyCodeLine{8187         TrackerContext m\_trackerContext;}
\DoxyCodeLine{8188         \textcolor{keywordtype}{bool} m\_lastAssertionPassed = false;}
\DoxyCodeLine{8189         \textcolor{keywordtype}{bool} m\_shouldReportUnexpected = true;}
\DoxyCodeLine{8190         \textcolor{keywordtype}{bool} m\_includeSuccessfulResults;}
\DoxyCodeLine{8191     \};}
\DoxyCodeLine{8192 }
\DoxyCodeLine{8193     \textcolor{keywordtype}{void} seedRng(IConfig const\& config);}
\DoxyCodeLine{8194     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed();}
\DoxyCodeLine{8195 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8196 }
\DoxyCodeLine{8197 \textcolor{comment}{// end catch\_run\_context.h}}
\DoxyCodeLine{8198 namespace Catch \{}
\DoxyCodeLine{8199 }
\DoxyCodeLine{8200     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{8201         \textcolor{keyword}{auto} operator <<( std::ostream\& os, ITransientExpression \textcolor{keyword}{const}\& expr ) -\/> std::ostream\& \{}
\DoxyCodeLine{8202             expr.streamReconstructedExpression( os );}
\DoxyCodeLine{8203             \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8204         \}}
\DoxyCodeLine{8205     \}}
\DoxyCodeLine{8206 }
\DoxyCodeLine{8207     LazyExpression::LazyExpression( \textcolor{keywordtype}{bool} isNegated )}
\DoxyCodeLine{8208     :   m\_isNegated( isNegated )}
\DoxyCodeLine{8209     \{\}}
\DoxyCodeLine{8210 }
\DoxyCodeLine{8211     LazyExpression::LazyExpression( LazyExpression \textcolor{keyword}{const}\& other ) : m\_isNegated( other.m\_isNegated ) \{\}}
\DoxyCodeLine{8212 }
\DoxyCodeLine{8213     LazyExpression::operator bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8214         \textcolor{keywordflow}{return} m\_transientExpression != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{8215     \}}
\DoxyCodeLine{8216 }
\DoxyCodeLine{8217     \textcolor{keyword}{auto} operator << ( std::ostream\& os, LazyExpression \textcolor{keyword}{const}\& lazyExpr ) -\/> std::ostream\& \{}
\DoxyCodeLine{8218         \textcolor{keywordflow}{if}( lazyExpr.m\_isNegated )}
\DoxyCodeLine{8219             os << \textcolor{stringliteral}{"{}!"{}};}
\DoxyCodeLine{8220 }
\DoxyCodeLine{8221         \textcolor{keywordflow}{if}( lazyExpr ) \{}
\DoxyCodeLine{8222             \textcolor{keywordflow}{if}( lazyExpr.m\_isNegated \&\& lazyExpr.m\_transientExpression-\/>isBinaryExpression() )}
\DoxyCodeLine{8223                 os << \textcolor{stringliteral}{"{}("{}} << *lazyExpr.m\_transientExpression << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{8224             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8225                 os << *lazyExpr.m\_transientExpression;}
\DoxyCodeLine{8226         \}}
\DoxyCodeLine{8227         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8228             os << \textcolor{stringliteral}{"{}\{** error -\/ unchecked empty expression requested **\}"{}};}
\DoxyCodeLine{8229         \}}
\DoxyCodeLine{8230         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8231     \}}
\DoxyCodeLine{8232 }
\DoxyCodeLine{8233     AssertionHandler::AssertionHandler}
\DoxyCodeLine{8234         (   StringRef \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{8235             SourceLineInfo \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{8236             StringRef capturedExpression,}
\DoxyCodeLine{8237             ResultDisposition::Flags resultDisposition )}
\DoxyCodeLine{8238     :   m\_assertionInfo\{ macroName, lineInfo, capturedExpression, resultDisposition \},}
\DoxyCodeLine{8239         m\_resultCapture( getResultCapture() )}
\DoxyCodeLine{8240     \{\}}
\DoxyCodeLine{8241 }
\DoxyCodeLine{8242     \textcolor{keywordtype}{void} AssertionHandler::handleExpr( ITransientExpression \textcolor{keyword}{const}\& expr ) \{}
\DoxyCodeLine{8243         m\_resultCapture.handleExpr( m\_assertionInfo, expr, m\_reaction );}
\DoxyCodeLine{8244     \}}
\DoxyCodeLine{8245     \textcolor{keywordtype}{void} AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef \textcolor{keyword}{const}\& message) \{}
\DoxyCodeLine{8246         m\_resultCapture.handleMessage( m\_assertionInfo, resultType, message, m\_reaction );}
\DoxyCodeLine{8247     \}}
\DoxyCodeLine{8248 }
\DoxyCodeLine{8249     \textcolor{keyword}{auto} AssertionHandler::allowThrows() const -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8250         \textcolor{keywordflow}{return} getCurrentContext().getConfig()-\/>allowThrows();}
\DoxyCodeLine{8251     \}}
\DoxyCodeLine{8252 }
\DoxyCodeLine{8253     \textcolor{keywordtype}{void} AssertionHandler::complete() \{}
\DoxyCodeLine{8254         setCompleted();}
\DoxyCodeLine{8255         \textcolor{keywordflow}{if}( m\_reaction.shouldDebugBreak ) \{}
\DoxyCodeLine{8256 }
\DoxyCodeLine{8257             \textcolor{comment}{// If you find your debugger stopping you here then go one level up on the}}
\DoxyCodeLine{8258             \textcolor{comment}{// call-\/stack for the code that caused it (typically a failed assertion)}}
\DoxyCodeLine{8259 }
\DoxyCodeLine{8260             \textcolor{comment}{// (To go back to the test and change execution, jump over the throw, next)}}
\DoxyCodeLine{8261             CATCH\_BREAK\_INTO\_DEBUGGER();}
\DoxyCodeLine{8262         \}}
\DoxyCodeLine{8263         \textcolor{keywordflow}{if} (m\_reaction.shouldThrow) \{}
\DoxyCodeLine{8264 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{8265             \textcolor{keywordflow}{throw} \mbox{\hyperlink{struct_catch_1_1_test_failure_exception}{Catch::TestFailureException}}();}
\DoxyCodeLine{8266 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{8267             CATCH\_ERROR( \textcolor{stringliteral}{"{}Test failure requires aborting test!"{}} );}
\DoxyCodeLine{8268 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8269         \}}
\DoxyCodeLine{8270     \}}
\DoxyCodeLine{8271     \textcolor{keywordtype}{void} AssertionHandler::setCompleted() \{}
\DoxyCodeLine{8272         m\_completed = \textcolor{keyword}{true};}
\DoxyCodeLine{8273     \}}
\DoxyCodeLine{8274 }
\DoxyCodeLine{8275     \textcolor{keywordtype}{void} AssertionHandler::handleUnexpectedInflightException() \{}
\DoxyCodeLine{8276         m\_resultCapture.handleUnexpectedInflightException( m\_assertionInfo, Catch::translateActiveException(), m\_reaction );}
\DoxyCodeLine{8277     \}}
\DoxyCodeLine{8278 }
\DoxyCodeLine{8279     \textcolor{keywordtype}{void} AssertionHandler::handleExceptionThrownAsExpected() \{}
\DoxyCodeLine{8280         m\_resultCapture.handleNonExpr(m\_assertionInfo, ResultWas::Ok, m\_reaction);}
\DoxyCodeLine{8281     \}}
\DoxyCodeLine{8282     \textcolor{keywordtype}{void} AssertionHandler::handleExceptionNotThrownAsExpected() \{}
\DoxyCodeLine{8283         m\_resultCapture.handleNonExpr(m\_assertionInfo, ResultWas::Ok, m\_reaction);}
\DoxyCodeLine{8284     \}}
\DoxyCodeLine{8285 }
\DoxyCodeLine{8286     \textcolor{keywordtype}{void} AssertionHandler::handleUnexpectedExceptionNotThrown() \{}
\DoxyCodeLine{8287         m\_resultCapture.handleUnexpectedExceptionNotThrown( m\_assertionInfo, m\_reaction );}
\DoxyCodeLine{8288     \}}
\DoxyCodeLine{8289 }
\DoxyCodeLine{8290     \textcolor{keywordtype}{void} AssertionHandler::handleThrowingCallSkipped() \{}
\DoxyCodeLine{8291         m\_resultCapture.handleNonExpr(m\_assertionInfo, ResultWas::Ok, m\_reaction);}
\DoxyCodeLine{8292     \}}
\DoxyCodeLine{8293 }
\DoxyCodeLine{8294     \textcolor{comment}{// This is the overload that takes a string and infers the Equals matcher from it}}
\DoxyCodeLine{8295     \textcolor{comment}{// The more general overload, that takes any string matcher, is in catch\_capture\_matchers.cpp}}
\DoxyCodeLine{8296     \textcolor{keywordtype}{void} handleExceptionMatchExpr( AssertionHandler\& handler, std::string \textcolor{keyword}{const}\& str, StringRef \textcolor{keyword}{const}\& matcherString  ) \{}
\DoxyCodeLine{8297         handleExceptionMatchExpr( handler, Matchers::Equals( str ), matcherString );}
\DoxyCodeLine{8298     \}}
\DoxyCodeLine{8299 }
\DoxyCodeLine{8300 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{8301 \textcolor{comment}{// end catch\_assertionhandler.cpp}}
\DoxyCodeLine{8302 \textcolor{comment}{// start catch\_assertionresult.cpp}}
\DoxyCodeLine{8303 }
\DoxyCodeLine{8304 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8305     AssertionResultData::AssertionResultData(ResultWas::OfType \_resultType, LazyExpression \textcolor{keyword}{const} \& \_lazyExpression):}
\DoxyCodeLine{8306         lazyExpression(\_lazyExpression),}
\DoxyCodeLine{8307         resultType(\_resultType) \{\}}
\DoxyCodeLine{8308 }
\DoxyCodeLine{8309     std::string AssertionResultData::reconstructExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8310 }
\DoxyCodeLine{8311         \textcolor{keywordflow}{if}( reconstructedExpression.empty() ) \{}
\DoxyCodeLine{8312             \textcolor{keywordflow}{if}( lazyExpression ) \{}
\DoxyCodeLine{8313                 ReusableStringStream rss;}
\DoxyCodeLine{8314                 rss << lazyExpression;}
\DoxyCodeLine{8315                 reconstructedExpression = rss.str();}
\DoxyCodeLine{8316             \}}
\DoxyCodeLine{8317         \}}
\DoxyCodeLine{8318         \textcolor{keywordflow}{return} reconstructedExpression;}
\DoxyCodeLine{8319     \}}
\DoxyCodeLine{8320 }
\DoxyCodeLine{8321     AssertionResult::AssertionResult( AssertionInfo \textcolor{keyword}{const}\& info, AssertionResultData \textcolor{keyword}{const}\& data )}
\DoxyCodeLine{8322     :   m\_info( info ),}
\DoxyCodeLine{8323         m\_resultData( data )}
\DoxyCodeLine{8324     \{\}}
\DoxyCodeLine{8325 }
\DoxyCodeLine{8326     \textcolor{comment}{// Result was a success}}
\DoxyCodeLine{8327     \textcolor{keywordtype}{bool} AssertionResult::succeeded()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8328         \textcolor{keywordflow}{return} Catch::isOk( m\_resultData.resultType );}
\DoxyCodeLine{8329     \}}
\DoxyCodeLine{8330 }
\DoxyCodeLine{8331     \textcolor{comment}{// Result was a success, or failure is suppressed}}
\DoxyCodeLine{8332     \textcolor{keywordtype}{bool} AssertionResult::isOk()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8333         \textcolor{keywordflow}{return} Catch::isOk( m\_resultData.resultType ) || shouldSuppressFailure( m\_info.resultDisposition );}
\DoxyCodeLine{8334     \}}
\DoxyCodeLine{8335 }
\DoxyCodeLine{8336     ResultWas::OfType AssertionResult::getResultType()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8337         \textcolor{keywordflow}{return} m\_resultData.resultType;}
\DoxyCodeLine{8338     \}}
\DoxyCodeLine{8339 }
\DoxyCodeLine{8340     \textcolor{keywordtype}{bool} AssertionResult::hasExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8341         \textcolor{keywordflow}{return} !m\_info.capturedExpression.empty();}
\DoxyCodeLine{8342     \}}
\DoxyCodeLine{8343 }
\DoxyCodeLine{8344     \textcolor{keywordtype}{bool} AssertionResult::hasMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8345         \textcolor{keywordflow}{return} !m\_resultData.message.empty();}
\DoxyCodeLine{8346     \}}
\DoxyCodeLine{8347 }
\DoxyCodeLine{8348     std::string AssertionResult::getExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8349         \textcolor{comment}{// Possibly overallocating by 3 characters should be basically free}}
\DoxyCodeLine{8350         std::string expr; expr.reserve(m\_info.capturedExpression.size() + 3);}
\DoxyCodeLine{8351         \textcolor{keywordflow}{if} (isFalseTest(m\_info.resultDisposition)) \{}
\DoxyCodeLine{8352             expr += "{}!("{};}
\DoxyCodeLine{8353         \}}
\DoxyCodeLine{8354         expr += m\_info.capturedExpression;}
\DoxyCodeLine{8355         \textcolor{keywordflow}{if} (isFalseTest(m\_info.resultDisposition)) \{}
\DoxyCodeLine{8356             expr += ')';}
\DoxyCodeLine{8357         \}}
\DoxyCodeLine{8358         \textcolor{keywordflow}{return} expr;}
\DoxyCodeLine{8359     \}}
\DoxyCodeLine{8360 }
\DoxyCodeLine{8361     std::string AssertionResult::getExpressionInMacro()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8362         std::string expr;}
\DoxyCodeLine{8363         \textcolor{keywordflow}{if}( m\_info.macroName.empty() )}
\DoxyCodeLine{8364             expr = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(m\_info.capturedExpression);}
\DoxyCodeLine{8365         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8366             expr.reserve( m\_info.macroName.size() + m\_info.capturedExpression.size() + 4 );}
\DoxyCodeLine{8367             expr += m\_info.macroName;}
\DoxyCodeLine{8368             expr += "{}( "{};}
\DoxyCodeLine{8369             expr += m\_info.capturedExpression;}
\DoxyCodeLine{8370             expr += "{} )"{};}
\DoxyCodeLine{8371         \}}
\DoxyCodeLine{8372         \textcolor{keywordflow}{return} expr;}
\DoxyCodeLine{8373     \}}
\DoxyCodeLine{8374 }
\DoxyCodeLine{8375     \textcolor{keywordtype}{bool} AssertionResult::hasExpandedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8376         \textcolor{keywordflow}{return} hasExpression() \&\& getExpandedExpression() != getExpression();}
\DoxyCodeLine{8377     \}}
\DoxyCodeLine{8378 }
\DoxyCodeLine{8379     std::string AssertionResult::getExpandedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8380         std::string expr = m\_resultData.reconstructExpression();}
\DoxyCodeLine{8381         \textcolor{keywordflow}{return} expr.empty()}
\DoxyCodeLine{8382                 ? getExpression()}
\DoxyCodeLine{8383                 : expr;}
\DoxyCodeLine{8384     \}}
\DoxyCodeLine{8385 }
\DoxyCodeLine{8386     std::string AssertionResult::getMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8387         \textcolor{keywordflow}{return} m\_resultData.message;}
\DoxyCodeLine{8388     \}}
\DoxyCodeLine{8389     SourceLineInfo AssertionResult::getSourceInfo()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8390         \textcolor{keywordflow}{return} m\_info.lineInfo;}
\DoxyCodeLine{8391     \}}
\DoxyCodeLine{8392 }
\DoxyCodeLine{8393     StringRef AssertionResult::getTestMacroName()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8394         \textcolor{keywordflow}{return} m\_info.macroName;}
\DoxyCodeLine{8395     \}}
\DoxyCodeLine{8396 }
\DoxyCodeLine{8397 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8398 \textcolor{comment}{// end catch\_assertionresult.cpp}}
\DoxyCodeLine{8399 \textcolor{comment}{// start catch\_capture\_matchers.cpp}}
\DoxyCodeLine{8400 }
\DoxyCodeLine{8401 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8402 }
\DoxyCodeLine{8403     \textcolor{keyword}{using} StringMatcher = Matchers::Impl::MatcherBase<std::string>;}
\DoxyCodeLine{8404 }
\DoxyCodeLine{8405     \textcolor{comment}{// This is the general overload that takes a any string matcher}}
\DoxyCodeLine{8406     \textcolor{comment}{// There is another overload, in catch\_assertionhandler.h/.cpp, that only takes a string and infers}}
\DoxyCodeLine{8407     \textcolor{comment}{// the Equals matcher (so the header does not mention matchers)}}
\DoxyCodeLine{8408     \textcolor{keywordtype}{void} handleExceptionMatchExpr( AssertionHandler\& handler, StringMatcher \textcolor{keyword}{const}\& matcher, StringRef \textcolor{keyword}{const}\& matcherString  ) \{}
\DoxyCodeLine{8409         std::string exceptionMessage = Catch::translateActiveException();}
\DoxyCodeLine{8410         MatchExpr<std::string, StringMatcher const\&> expr( exceptionMessage, matcher, matcherString );}
\DoxyCodeLine{8411         handler.handleExpr( expr );}
\DoxyCodeLine{8412     \}}
\DoxyCodeLine{8413 }
\DoxyCodeLine{8414 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{8415 \textcolor{comment}{// end catch\_capture\_matchers.cpp}}
\DoxyCodeLine{8416 \textcolor{comment}{// start catch\_commandline.cpp}}
\DoxyCodeLine{8417 }
\DoxyCodeLine{8418 \textcolor{comment}{// start catch\_commandline.h}}
\DoxyCodeLine{8419 }
\DoxyCodeLine{8420 \textcolor{comment}{// start catch\_clara.h}}
\DoxyCodeLine{8421 }
\DoxyCodeLine{8422 \textcolor{comment}{// Use Catch's value for console width (store Clara's off to the side, if present)}}
\DoxyCodeLine{8423 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8424 \textcolor{preprocessor}{\#define CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8425 \textcolor{preprocessor}{\#undef CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8426 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8427 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH CATCH\_CONFIG\_CONSOLE\_WIDTH-\/1}}
\DoxyCodeLine{8428 }
\DoxyCodeLine{8429 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{8430 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{8431 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wweak-\/vtables"{}}}
\DoxyCodeLine{8432 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wexit-\/time-\/destructors"{}}}
\DoxyCodeLine{8433 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wshadow"{}}}
\DoxyCodeLine{8434 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8435 }
\DoxyCodeLine{8436 \textcolor{comment}{// start clara.hpp}}
\DoxyCodeLine{8437 \textcolor{comment}{// Copyright 2017 Two Blue Cubes Ltd. All rights reserved.}}
\DoxyCodeLine{8438 \textcolor{comment}{//}}
\DoxyCodeLine{8439 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0. (See accompanying}}
\DoxyCodeLine{8440 \textcolor{comment}{// file LICENSE\_1\_0.txt or copy at http://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{8441 \textcolor{comment}{//}}
\DoxyCodeLine{8442 \textcolor{comment}{// See https://github.com/philsquared/Clara for more details}}
\DoxyCodeLine{8443 }
\DoxyCodeLine{8444 \textcolor{comment}{// Clara v1.1.5}}
\DoxyCodeLine{8445 }
\DoxyCodeLine{8446 }
\DoxyCodeLine{8447 \textcolor{preprocessor}{\#ifndef CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8448 \textcolor{preprocessor}{\#define CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH 80}}
\DoxyCodeLine{8449 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8450 }
\DoxyCodeLine{8451 \textcolor{preprocessor}{\#ifndef CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8452 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8453 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8454 }
\DoxyCodeLine{8455 \textcolor{preprocessor}{\#ifndef CLARA\_CONFIG\_OPTIONAL\_TYPE}}
\DoxyCodeLine{8456 \textcolor{preprocessor}{\#ifdef \_\_has\_include}}
\DoxyCodeLine{8457 \textcolor{preprocessor}{\#if \_\_has\_include(<optional>) \&\& \_\_cplusplus >= 201703L}}
\DoxyCodeLine{8458 \textcolor{preprocessor}{\#include <optional>}}
\DoxyCodeLine{8459 \textcolor{preprocessor}{\#define CLARA\_CONFIG\_OPTIONAL\_TYPE std::optional}}
\DoxyCodeLine{8460 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8461 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8462 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8463 }
\DoxyCodeLine{8464 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ \#included from clara\_textflow.hpp -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{8465 }
\DoxyCodeLine{8466 \textcolor{comment}{// TextFlowCpp}}
\DoxyCodeLine{8467 \textcolor{comment}{//}}
\DoxyCodeLine{8468 \textcolor{comment}{// A single-\/header library for wrapping and laying out basic text, by Phil Nash}}
\DoxyCodeLine{8469 \textcolor{comment}{//}}
\DoxyCodeLine{8470 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0. (See accompanying}}
\DoxyCodeLine{8471 \textcolor{comment}{// file LICENSE.txt or copy at http://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{8472 \textcolor{comment}{//}}
\DoxyCodeLine{8473 \textcolor{comment}{// This project is hosted at https://github.com/philsquared/textflowcpp}}
\DoxyCodeLine{8474 }
\DoxyCodeLine{8475 }
\DoxyCodeLine{8476 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{8477 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{8478 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{8479 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{8480 }
\DoxyCodeLine{8481 \textcolor{preprocessor}{\#ifndef CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8482 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH 80}}
\DoxyCodeLine{8483 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8484 }
\DoxyCodeLine{8485 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8486 \textcolor{keyword}{namespace }clara \{}
\DoxyCodeLine{8487 \textcolor{keyword}{namespace }TextFlow \{}
\DoxyCodeLine{8488 }
\DoxyCodeLine{8489 \textcolor{keyword}{inline} \textcolor{keyword}{auto} isWhitespace(\textcolor{keywordtype}{char} c) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8490     \textcolor{keyword}{static} std::string chars = \textcolor{stringliteral}{"{} \(\backslash\)t\(\backslash\)n\(\backslash\)r"{}};}
\DoxyCodeLine{8491     \textcolor{keywordflow}{return} chars.find(c) != std::string::npos;}
\DoxyCodeLine{8492 \}}
\DoxyCodeLine{8493 \textcolor{keyword}{inline} \textcolor{keyword}{auto} isBreakableBefore(\textcolor{keywordtype}{char} c) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8494     \textcolor{keyword}{static} std::string chars = \textcolor{stringliteral}{"{}[(\{<|"{}};}
\DoxyCodeLine{8495     \textcolor{keywordflow}{return} chars.find(c) != std::string::npos;}
\DoxyCodeLine{8496 \}}
\DoxyCodeLine{8497 \textcolor{keyword}{inline} \textcolor{keyword}{auto} isBreakableAfter(\textcolor{keywordtype}{char} c) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8498     \textcolor{keyword}{static} std::string chars = \textcolor{stringliteral}{"{}])\}>.,:;*+-\/=\&/\(\backslash\)\(\backslash\)"{}};}
\DoxyCodeLine{8499     \textcolor{keywordflow}{return} chars.find(c) != std::string::npos;}
\DoxyCodeLine{8500 \}}
\DoxyCodeLine{8501 }
\DoxyCodeLine{8502 \textcolor{keyword}{class }Columns;}
\DoxyCodeLine{8503 }
\DoxyCodeLine{8504 \textcolor{keyword}{class }Column \{}
\DoxyCodeLine{8505     std::vector<std::string> m\_strings;}
\DoxyCodeLine{8506     \textcolor{keywordtype}{size\_t} m\_width = CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH;}
\DoxyCodeLine{8507     \textcolor{keywordtype}{size\_t} m\_indent = 0;}
\DoxyCodeLine{8508     \textcolor{keywordtype}{size\_t} m\_initialIndent = std::string::npos;}
\DoxyCodeLine{8509 }
\DoxyCodeLine{8510 \textcolor{keyword}{public}:}
\DoxyCodeLine{8511     \textcolor{keyword}{class }iterator \{}
\DoxyCodeLine{8512         \textcolor{keyword}{friend} Column;}
\DoxyCodeLine{8513 }
\DoxyCodeLine{8514         Column \textcolor{keyword}{const}\& m\_column;}
\DoxyCodeLine{8515         \textcolor{keywordtype}{size\_t} m\_stringIndex = 0;}
\DoxyCodeLine{8516         \textcolor{keywordtype}{size\_t} m\_pos = 0;}
\DoxyCodeLine{8517 }
\DoxyCodeLine{8518         \textcolor{keywordtype}{size\_t} m\_len = 0;}
\DoxyCodeLine{8519         \textcolor{keywordtype}{size\_t} m\_end = 0;}
\DoxyCodeLine{8520         \textcolor{keywordtype}{bool} m\_suffix = \textcolor{keyword}{false};}
\DoxyCodeLine{8521 }
\DoxyCodeLine{8522         iterator(Column \textcolor{keyword}{const}\& column, \textcolor{keywordtype}{size\_t} stringIndex)}
\DoxyCodeLine{8523             : m\_column(column),}
\DoxyCodeLine{8524             m\_stringIndex(stringIndex) \{\}}
\DoxyCodeLine{8525 }
\DoxyCodeLine{8526         \textcolor{keyword}{auto} line() const -\/> std::\textcolor{keywordtype}{string} const\& \{ \textcolor{keywordflow}{return} m\_column.m\_strings[m\_stringIndex]; \}}
\DoxyCodeLine{8527 }
\DoxyCodeLine{8528         \textcolor{keyword}{auto} isBoundary(\textcolor{keywordtype}{size\_t} at) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8529             assert(at > 0);}
\DoxyCodeLine{8530             assert(at <= line().size());}
\DoxyCodeLine{8531 }
\DoxyCodeLine{8532             \textcolor{keywordflow}{return} at == line().size() ||}
\DoxyCodeLine{8533                 (isWhitespace(line()[at]) \&\& !isWhitespace(line()[at -\/ 1])) ||}
\DoxyCodeLine{8534                 isBreakableBefore(line()[at]) ||}
\DoxyCodeLine{8535                 isBreakableAfter(line()[at -\/ 1]);}
\DoxyCodeLine{8536         \}}
\DoxyCodeLine{8537 }
\DoxyCodeLine{8538         \textcolor{keywordtype}{void} calcLength() \{}
\DoxyCodeLine{8539             assert(m\_stringIndex < m\_column.m\_strings.size());}
\DoxyCodeLine{8540 }
\DoxyCodeLine{8541             m\_suffix = \textcolor{keyword}{false};}
\DoxyCodeLine{8542             \textcolor{keyword}{auto} width = m\_column.m\_width -\/ indent();}
\DoxyCodeLine{8543             m\_end = m\_pos;}
\DoxyCodeLine{8544             \textcolor{keywordflow}{if} (line()[m\_pos] == \textcolor{charliteral}{'\(\backslash\)n'}) \{}
\DoxyCodeLine{8545                 ++m\_end;}
\DoxyCodeLine{8546             \}}
\DoxyCodeLine{8547             \textcolor{keywordflow}{while} (m\_end < line().size() \&\& line()[m\_end] != \textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{8548                 ++m\_end;}
\DoxyCodeLine{8549 }
\DoxyCodeLine{8550             \textcolor{keywordflow}{if} (m\_end < m\_pos + width) \{}
\DoxyCodeLine{8551                 m\_len = m\_end -\/ m\_pos;}
\DoxyCodeLine{8552             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8553                 \textcolor{keywordtype}{size\_t} len = width;}
\DoxyCodeLine{8554                 \textcolor{keywordflow}{while} (len > 0 \&\& !isBoundary(m\_pos + len))}
\DoxyCodeLine{8555                     -\/-\/len;}
\DoxyCodeLine{8556                 \textcolor{keywordflow}{while} (len > 0 \&\& isWhitespace(line()[m\_pos + len -\/ 1]))}
\DoxyCodeLine{8557                     -\/-\/len;}
\DoxyCodeLine{8558 }
\DoxyCodeLine{8559                 \textcolor{keywordflow}{if} (len > 0) \{}
\DoxyCodeLine{8560                     m\_len = len;}
\DoxyCodeLine{8561                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8562                     m\_suffix = \textcolor{keyword}{true};}
\DoxyCodeLine{8563                     m\_len = width -\/ 1;}
\DoxyCodeLine{8564                 \}}
\DoxyCodeLine{8565             \}}
\DoxyCodeLine{8566         \}}
\DoxyCodeLine{8567 }
\DoxyCodeLine{8568         \textcolor{keyword}{auto} indent() const -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{8569             \textcolor{keyword}{auto} initial = m\_pos == 0 \&\& m\_stringIndex == 0 ? m\_column.m\_initialIndent : std::string::npos;}
\DoxyCodeLine{8570             \textcolor{keywordflow}{return} initial == std::string::npos ? m\_column.m\_indent : initial;}
\DoxyCodeLine{8571         \}}
\DoxyCodeLine{8572 }
\DoxyCodeLine{8573         \textcolor{keyword}{auto} addIndentAndSuffix(std::string \textcolor{keyword}{const} \&plain) \textcolor{keyword}{const} -\/> std::string \{}
\DoxyCodeLine{8574             \textcolor{keywordflow}{return} std::string(indent(), \textcolor{charliteral}{' '}) + (m\_suffix ? plain + "{}-\/"{} : plain);}
\DoxyCodeLine{8575         \}}
\DoxyCodeLine{8576 }
\DoxyCodeLine{8577     \textcolor{keyword}{public}:}
\DoxyCodeLine{8578         \textcolor{keyword}{using} difference\_type = std::ptrdiff\_t;}
\DoxyCodeLine{8579         \textcolor{keyword}{using} value\_type = std::string;}
\DoxyCodeLine{8580         \textcolor{keyword}{using} pointer = value\_type * ;}
\DoxyCodeLine{8581         \textcolor{keyword}{using} reference = value\_type \& ;}
\DoxyCodeLine{8582         \textcolor{keyword}{using} iterator\_category = std::forward\_iterator\_tag;}
\DoxyCodeLine{8583 }
\DoxyCodeLine{8584         \textcolor{keyword}{explicit} iterator(Column \textcolor{keyword}{const}\& column) : m\_column(column) \{}
\DoxyCodeLine{8585             assert(m\_column.m\_width > m\_column.m\_indent);}
\DoxyCodeLine{8586             assert(m\_column.m\_initialIndent == std::string::npos || m\_column.m\_width > m\_column.m\_initialIndent);}
\DoxyCodeLine{8587             calcLength();}
\DoxyCodeLine{8588             \textcolor{keywordflow}{if} (m\_len == 0)}
\DoxyCodeLine{8589                 m\_stringIndex++; \textcolor{comment}{// Empty string}}
\DoxyCodeLine{8590         \}}
\DoxyCodeLine{8591 }
\DoxyCodeLine{8592         \textcolor{keyword}{auto} operator *() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8593             assert(m\_stringIndex < m\_column.m\_strings.size());}
\DoxyCodeLine{8594             assert(m\_pos <= m\_end);}
\DoxyCodeLine{8595             \textcolor{keywordflow}{return} addIndentAndSuffix(line().substr(m\_pos, m\_len));}
\DoxyCodeLine{8596         \}}
\DoxyCodeLine{8597 }
\DoxyCodeLine{8598         \textcolor{keyword}{auto} operator ++() -\/> iterator\& \{}
\DoxyCodeLine{8599             m\_pos += m\_len;}
\DoxyCodeLine{8600             \textcolor{keywordflow}{if} (m\_pos < line().size() \&\& line()[m\_pos] == \textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{8601                 m\_pos += 1;}
\DoxyCodeLine{8602             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8603                 \textcolor{keywordflow}{while} (m\_pos < line().size() \&\& isWhitespace(line()[m\_pos]))}
\DoxyCodeLine{8604                     ++m\_pos;}
\DoxyCodeLine{8605 }
\DoxyCodeLine{8606             \textcolor{keywordflow}{if} (m\_pos == line().size()) \{}
\DoxyCodeLine{8607                 m\_pos = 0;}
\DoxyCodeLine{8608                 ++m\_stringIndex;}
\DoxyCodeLine{8609             \}}
\DoxyCodeLine{8610             \textcolor{keywordflow}{if} (m\_stringIndex < m\_column.m\_strings.size())}
\DoxyCodeLine{8611                 calcLength();}
\DoxyCodeLine{8612             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8613         \}}
\DoxyCodeLine{8614         \textcolor{keyword}{auto} operator ++(\textcolor{keywordtype}{int}) -\/> iterator \{}
\DoxyCodeLine{8615             iterator prev(*\textcolor{keyword}{this});}
\DoxyCodeLine{8616             operator++();}
\DoxyCodeLine{8617             \textcolor{keywordflow}{return} prev;}
\DoxyCodeLine{8618         \}}
\DoxyCodeLine{8619 }
\DoxyCodeLine{8620         \textcolor{keyword}{auto} operator ==(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8621             \textcolor{keywordflow}{return}}
\DoxyCodeLine{8622                 m\_pos == other.m\_pos \&\&}
\DoxyCodeLine{8623                 m\_stringIndex == other.m\_stringIndex \&\&}
\DoxyCodeLine{8624                 \&m\_column == \&other.m\_column;}
\DoxyCodeLine{8625         \}}
\DoxyCodeLine{8626         \textcolor{keyword}{auto} operator !=(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8627             \textcolor{keywordflow}{return} !operator==(other);}
\DoxyCodeLine{8628         \}}
\DoxyCodeLine{8629     \};}
\DoxyCodeLine{8630     \textcolor{keyword}{using} const\_iterator = iterator;}
\DoxyCodeLine{8631 }
\DoxyCodeLine{8632     \textcolor{keyword}{explicit} Column(std::string \textcolor{keyword}{const}\& text) \{ m\_strings.push\_back(text); \}}
\DoxyCodeLine{8633 }
\DoxyCodeLine{8634     \textcolor{keyword}{auto} width(\textcolor{keywordtype}{size\_t} newWidth) -\/> Column\& \{}
\DoxyCodeLine{8635         assert(newWidth > 0);}
\DoxyCodeLine{8636         m\_width = newWidth;}
\DoxyCodeLine{8637         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8638     \}}
\DoxyCodeLine{8639     \textcolor{keyword}{auto} indent(\textcolor{keywordtype}{size\_t} newIndent) -\/> Column\& \{}
\DoxyCodeLine{8640         m\_indent = newIndent;}
\DoxyCodeLine{8641         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8642     \}}
\DoxyCodeLine{8643     \textcolor{keyword}{auto} initialIndent(\textcolor{keywordtype}{size\_t} newIndent) -\/> Column\& \{}
\DoxyCodeLine{8644         m\_initialIndent = newIndent;}
\DoxyCodeLine{8645         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8646     \}}
\DoxyCodeLine{8647 }
\DoxyCodeLine{8648     \textcolor{keyword}{auto} width() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} m\_width; \}}
\DoxyCodeLine{8649     \textcolor{keyword}{auto} begin() const -\/> iterator \{ \textcolor{keywordflow}{return} iterator(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{8650     \textcolor{keyword}{auto} end() const -\/> iterator \{ \textcolor{keywordflow}{return} \{ *\textcolor{keyword}{this}, m\_strings.size() \}; \}}
\DoxyCodeLine{8651 }
\DoxyCodeLine{8652     \textcolor{keyword}{inline} \textcolor{keyword}{friend} std::ostream\& operator << (std::ostream\& os, Column \textcolor{keyword}{const}\& col) \{}
\DoxyCodeLine{8653         \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{8654         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} line : col) \{}
\DoxyCodeLine{8655             \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{8656                 first = \textcolor{keyword}{false};}
\DoxyCodeLine{8657             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8658                 os << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{8659             os << line;}
\DoxyCodeLine{8660         \}}
\DoxyCodeLine{8661         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8662     \}}
\DoxyCodeLine{8663 }
\DoxyCodeLine{8664     \textcolor{keyword}{auto} operator + (Column \textcolor{keyword}{const}\& other)-\/>Columns;}
\DoxyCodeLine{8665 }
\DoxyCodeLine{8666     \textcolor{keyword}{auto} \mbox{\hyperlink{namespaceappsdk_a431e485084f4c10f3183e92896fdd143}{toString}}() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8667         std::ostringstream oss;}
\DoxyCodeLine{8668         oss << *\textcolor{keyword}{this};}
\DoxyCodeLine{8669         \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{8670     \}}
\DoxyCodeLine{8671 \};}
\DoxyCodeLine{8672 }
\DoxyCodeLine{8673 \textcolor{keyword}{class }Spacer : \textcolor{keyword}{public} Column \{}
\DoxyCodeLine{8674 }
\DoxyCodeLine{8675 \textcolor{keyword}{public}:}
\DoxyCodeLine{8676     \textcolor{keyword}{explicit} Spacer(\textcolor{keywordtype}{size\_t} spaceWidth) : Column(\textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{8677         width(spaceWidth);}
\DoxyCodeLine{8678     \}}
\DoxyCodeLine{8679 \};}
\DoxyCodeLine{8680 }
\DoxyCodeLine{8681 \textcolor{keyword}{class }Columns \{}
\DoxyCodeLine{8682     std::vector<Column> m\_columns;}
\DoxyCodeLine{8683 }
\DoxyCodeLine{8684 \textcolor{keyword}{public}:}
\DoxyCodeLine{8685 }
\DoxyCodeLine{8686     \textcolor{keyword}{class }iterator \{}
\DoxyCodeLine{8687         \textcolor{keyword}{friend} Columns;}
\DoxyCodeLine{8688         \textcolor{keyword}{struct }EndTag \{\};}
\DoxyCodeLine{8689 }
\DoxyCodeLine{8690         std::vector<Column> \textcolor{keyword}{const}\& m\_columns;}
\DoxyCodeLine{8691         std::vector<Column::iterator> m\_iterators;}
\DoxyCodeLine{8692         \textcolor{keywordtype}{size\_t} m\_activeIterators;}
\DoxyCodeLine{8693 }
\DoxyCodeLine{8694         iterator(Columns \textcolor{keyword}{const}\& columns, EndTag)}
\DoxyCodeLine{8695             : m\_columns(columns.m\_columns),}
\DoxyCodeLine{8696             m\_activeIterators(0) \{}
\DoxyCodeLine{8697             m\_iterators.reserve(m\_columns.size());}
\DoxyCodeLine{8698 }
\DoxyCodeLine{8699             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& col : m\_columns)}
\DoxyCodeLine{8700                 m\_iterators.push\_back(col.end());}
\DoxyCodeLine{8701         \}}
\DoxyCodeLine{8702 }
\DoxyCodeLine{8703     \textcolor{keyword}{public}:}
\DoxyCodeLine{8704         \textcolor{keyword}{using} difference\_type = std::ptrdiff\_t;}
\DoxyCodeLine{8705         \textcolor{keyword}{using} value\_type = std::string;}
\DoxyCodeLine{8706         \textcolor{keyword}{using} pointer = value\_type * ;}
\DoxyCodeLine{8707         \textcolor{keyword}{using} reference = value\_type \& ;}
\DoxyCodeLine{8708         \textcolor{keyword}{using} iterator\_category = std::forward\_iterator\_tag;}
\DoxyCodeLine{8709 }
\DoxyCodeLine{8710         \textcolor{keyword}{explicit} iterator(Columns \textcolor{keyword}{const}\& columns)}
\DoxyCodeLine{8711             : m\_columns(columns.m\_columns),}
\DoxyCodeLine{8712             m\_activeIterators(m\_columns.size()) \{}
\DoxyCodeLine{8713             m\_iterators.reserve(m\_columns.size());}
\DoxyCodeLine{8714 }
\DoxyCodeLine{8715             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& col : m\_columns)}
\DoxyCodeLine{8716                 m\_iterators.push\_back(col.begin());}
\DoxyCodeLine{8717         \}}
\DoxyCodeLine{8718 }
\DoxyCodeLine{8719         \textcolor{keyword}{auto} operator ==(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8720             \textcolor{keywordflow}{return} m\_iterators == other.m\_iterators;}
\DoxyCodeLine{8721         \}}
\DoxyCodeLine{8722         \textcolor{keyword}{auto} operator !=(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8723             \textcolor{keywordflow}{return} m\_iterators != other.m\_iterators;}
\DoxyCodeLine{8724         \}}
\DoxyCodeLine{8725         \textcolor{keyword}{auto} operator *() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8726             std::string row, padding;}
\DoxyCodeLine{8727 }
\DoxyCodeLine{8728             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < m\_columns.size(); ++i) \{}
\DoxyCodeLine{8729                 \textcolor{keyword}{auto} width = m\_columns[i].width();}
\DoxyCodeLine{8730                 \textcolor{keywordflow}{if} (m\_iterators[i] != m\_columns[i].end()) \{}
\DoxyCodeLine{8731                     std::string col = *m\_iterators[i];}
\DoxyCodeLine{8732                     row += padding + col;}
\DoxyCodeLine{8733                     \textcolor{keywordflow}{if} (col.size() < width)}
\DoxyCodeLine{8734                         padding = std::string(width -\/ col.size(), \textcolor{charliteral}{' '});}
\DoxyCodeLine{8735                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{8736                         padding = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{8737                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8738                     padding += std::string(width, ' ');}
\DoxyCodeLine{8739                 \}}
\DoxyCodeLine{8740             \}}
\DoxyCodeLine{8741             \textcolor{keywordflow}{return} row;}
\DoxyCodeLine{8742         \}}
\DoxyCodeLine{8743         \textcolor{keyword}{auto} operator ++() -\/> iterator\& \{}
\DoxyCodeLine{8744             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < m\_columns.size(); ++i) \{}
\DoxyCodeLine{8745                 \textcolor{keywordflow}{if} (m\_iterators[i] != m\_columns[i].end())}
\DoxyCodeLine{8746                     ++m\_iterators[i];}
\DoxyCodeLine{8747             \}}
\DoxyCodeLine{8748             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8749         \}}
\DoxyCodeLine{8750         \textcolor{keyword}{auto} operator ++(\textcolor{keywordtype}{int}) -\/> iterator \{}
\DoxyCodeLine{8751             iterator prev(*\textcolor{keyword}{this});}
\DoxyCodeLine{8752             operator++();}
\DoxyCodeLine{8753             \textcolor{keywordflow}{return} prev;}
\DoxyCodeLine{8754         \}}
\DoxyCodeLine{8755     \};}
\DoxyCodeLine{8756     \textcolor{keyword}{using} const\_iterator = iterator;}
\DoxyCodeLine{8757 }
\DoxyCodeLine{8758     \textcolor{keyword}{auto} begin() const -\/> iterator \{ \textcolor{keywordflow}{return} iterator(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{8759     \textcolor{keyword}{auto} end() const -\/> iterator \{ \textcolor{keywordflow}{return} \{ *\textcolor{keyword}{this}, iterator::EndTag() \}; \}}
\DoxyCodeLine{8760 }
\DoxyCodeLine{8761     \textcolor{keyword}{auto} operator += (Column \textcolor{keyword}{const}\& col) -\/> Columns\& \{}
\DoxyCodeLine{8762         m\_columns.push\_back(col);}
\DoxyCodeLine{8763         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8764     \}}
\DoxyCodeLine{8765     \textcolor{keyword}{auto} operator + (Column \textcolor{keyword}{const}\& col) -\/> Columns \{}
\DoxyCodeLine{8766         Columns combined = *\textcolor{keyword}{this};}
\DoxyCodeLine{8767         combined += col;}
\DoxyCodeLine{8768         \textcolor{keywordflow}{return} combined;}
\DoxyCodeLine{8769     \}}
\DoxyCodeLine{8770 }
\DoxyCodeLine{8771     \textcolor{keyword}{inline} \textcolor{keyword}{friend} std::ostream\& operator << (std::ostream\& os, Columns \textcolor{keyword}{const}\& cols) \{}
\DoxyCodeLine{8772 }
\DoxyCodeLine{8773         \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{8774         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} line : cols) \{}
\DoxyCodeLine{8775             \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{8776                 first = \textcolor{keyword}{false};}
\DoxyCodeLine{8777             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8778                 os << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{8779             os << line;}
\DoxyCodeLine{8780         \}}
\DoxyCodeLine{8781         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8782     \}}
\DoxyCodeLine{8783 }
\DoxyCodeLine{8784     \textcolor{keyword}{auto} \mbox{\hyperlink{namespaceappsdk_a431e485084f4c10f3183e92896fdd143}{toString}}() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8785         std::ostringstream oss;}
\DoxyCodeLine{8786         oss << *\textcolor{keyword}{this};}
\DoxyCodeLine{8787         \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{8788     \}}
\DoxyCodeLine{8789 \};}
\DoxyCodeLine{8790 }
\DoxyCodeLine{8791 \textcolor{keyword}{inline} \textcolor{keyword}{auto} Column::operator + (Column \textcolor{keyword}{const}\& other) -\/> Columns \{}
\DoxyCodeLine{8792     Columns cols;}
\DoxyCodeLine{8793     cols += *this;}
\DoxyCodeLine{8794     cols += other;}
\DoxyCodeLine{8795     \textcolor{keywordflow}{return} cols;}
\DoxyCodeLine{8796 \}}
\DoxyCodeLine{8797 \}}
\DoxyCodeLine{8798 }
\DoxyCodeLine{8799 \}}
\DoxyCodeLine{8800 \}}
\DoxyCodeLine{8801 }
\DoxyCodeLine{8802 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ end of \#include from clara\_textflow.hpp -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{8803 \textcolor{comment}{// ........... back in clara.hpp}}
\DoxyCodeLine{8804 }
\DoxyCodeLine{8805 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{8806 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{8807 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{8808 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{8809 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{8810 }
\DoxyCodeLine{8811 \textcolor{preprocessor}{\#if !defined(CATCH\_PLATFORM\_WINDOWS) \&\& ( defined(WIN32) || defined(\_\_WIN32\_\_) || defined(\_WIN32) || defined(\_MSC\_VER) )}}
\DoxyCodeLine{8812 \textcolor{preprocessor}{\#define CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{8813 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8814 }
\DoxyCodeLine{8815 \textcolor{keyword}{namespace }Catch \{ \textcolor{keyword}{namespace }clara \{}
\DoxyCodeLine{8816 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{8817 }
\DoxyCodeLine{8818     \textcolor{comment}{// Traits for extracting arg and return type of lambdas (for single argument lambdas)}}
\DoxyCodeLine{8819     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{8820     \textcolor{keyword}{struct }UnaryLambdaTraits : UnaryLambdaTraits<decltype( \&L::operator() )> \{\};}
\DoxyCodeLine{8821 }
\DoxyCodeLine{8822     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ClassT, \textcolor{keyword}{typename} ReturnT, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{8823     \textcolor{keyword}{struct }UnaryLambdaTraits<ReturnT( ClassT::* )( Args... ) const> \{}
\DoxyCodeLine{8824         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isValid = \textcolor{keyword}{false};}
\DoxyCodeLine{8825     \};}
\DoxyCodeLine{8826 }
\DoxyCodeLine{8827     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ClassT, \textcolor{keyword}{typename} ReturnT, \textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{8828     \textcolor{keyword}{struct }UnaryLambdaTraits<ReturnT( ClassT::* )( ArgT ) const> \{}
\DoxyCodeLine{8829         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isValid = \textcolor{keyword}{true};}
\DoxyCodeLine{8830         \textcolor{keyword}{using} ArgType = \textcolor{keyword}{typename} std::remove\_const<typename std::remove\_reference<ArgT>::type>::type;}
\DoxyCodeLine{8831         \textcolor{keyword}{using} ReturnType = ReturnT;}
\DoxyCodeLine{8832     \};}
\DoxyCodeLine{8833 }
\DoxyCodeLine{8834     \textcolor{keyword}{class }TokenStream;}
\DoxyCodeLine{8835 }
\DoxyCodeLine{8836     \textcolor{comment}{// Transport for raw args (copied from main args, or supplied via init list for testing)}}
\DoxyCodeLine{8837     \textcolor{keyword}{class }Args \{}
\DoxyCodeLine{8838         \textcolor{keyword}{friend} TokenStream;}
\DoxyCodeLine{8839         std::string m\_exeName;}
\DoxyCodeLine{8840         std::vector<std::string> m\_args;}
\DoxyCodeLine{8841 }
\DoxyCodeLine{8842     \textcolor{keyword}{public}:}
\DoxyCodeLine{8843         Args( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \textcolor{keyword}{const}* argv )}
\DoxyCodeLine{8844             : m\_exeName(argv[0]),}
\DoxyCodeLine{8845               m\_args(argv + 1, argv + argc) \{\}}
\DoxyCodeLine{8846 }
\DoxyCodeLine{8847         Args( std::initializer\_list<std::string> args )}
\DoxyCodeLine{8848         :   m\_exeName( *args.begin() ),}
\DoxyCodeLine{8849             m\_args( args.begin()+1, args.end() )}
\DoxyCodeLine{8850         \{\}}
\DoxyCodeLine{8851 }
\DoxyCodeLine{8852         \textcolor{keyword}{auto} exeName() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8853             \textcolor{keywordflow}{return} m\_exeName;}
\DoxyCodeLine{8854         \}}
\DoxyCodeLine{8855     \};}
\DoxyCodeLine{8856 }
\DoxyCodeLine{8857     \textcolor{comment}{// Wraps a token coming from a token stream. These may not directly correspond to strings as a single string}}
\DoxyCodeLine{8858     \textcolor{comment}{// may encode an option + its argument if the : or = form is used}}
\DoxyCodeLine{8859     \textcolor{keyword}{enum class} TokenType \{}
\DoxyCodeLine{8860         Option, Argument}
\DoxyCodeLine{8861     \};}
\DoxyCodeLine{8862     \textcolor{keyword}{struct }Token \{}
\DoxyCodeLine{8863         TokenType type;}
\DoxyCodeLine{8864         std::string token;}
\DoxyCodeLine{8865     \};}
\DoxyCodeLine{8866 }
\DoxyCodeLine{8867     \textcolor{keyword}{inline} \textcolor{keyword}{auto} isOptPrefix( \textcolor{keywordtype}{char} c ) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8868         \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'-\/'}}
\DoxyCodeLine{8869 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{8870             || c == \textcolor{charliteral}{'/'}}
\DoxyCodeLine{8871 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8872         ;}
\DoxyCodeLine{8873     \}}
\DoxyCodeLine{8874 }
\DoxyCodeLine{8875     \textcolor{comment}{// Abstracts iterators into args as a stream of tokens, with option arguments uniformly handled}}
\DoxyCodeLine{8876     \textcolor{keyword}{class }TokenStream \{}
\DoxyCodeLine{8877         \textcolor{keyword}{using} Iterator = std::vector<std::string>::const\_iterator;}
\DoxyCodeLine{8878         Iterator it;}
\DoxyCodeLine{8879         Iterator itEnd;}
\DoxyCodeLine{8880         std::vector<Token> m\_tokenBuffer;}
\DoxyCodeLine{8881 }
\DoxyCodeLine{8882         \textcolor{keywordtype}{void} loadBuffer() \{}
\DoxyCodeLine{8883             m\_tokenBuffer.resize( 0 );}
\DoxyCodeLine{8884 }
\DoxyCodeLine{8885             \textcolor{comment}{// Skip any empty strings}}
\DoxyCodeLine{8886             \textcolor{keywordflow}{while}( it != itEnd \&\& it-\/>empty() )}
\DoxyCodeLine{8887                 ++it;}
\DoxyCodeLine{8888 }
\DoxyCodeLine{8889             \textcolor{keywordflow}{if}( it != itEnd ) \{}
\DoxyCodeLine{8890                 \textcolor{keyword}{auto} \textcolor{keyword}{const} \&next = *it;}
\DoxyCodeLine{8891                 \textcolor{keywordflow}{if}( isOptPrefix( next[0] ) ) \{}
\DoxyCodeLine{8892                     \textcolor{keyword}{auto} delimiterPos = next.find\_first\_of( \textcolor{stringliteral}{"{} :="{}} );}
\DoxyCodeLine{8893                     \textcolor{keywordflow}{if}( delimiterPos != std::string::npos ) \{}
\DoxyCodeLine{8894                         m\_tokenBuffer.push\_back( \{ TokenType::Option, next.substr( 0, delimiterPos ) \} );}
\DoxyCodeLine{8895                         m\_tokenBuffer.push\_back( \{ TokenType::Argument, next.substr( delimiterPos + 1 ) \} );}
\DoxyCodeLine{8896                     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8897                         \textcolor{keywordflow}{if}( next[1] != \textcolor{charliteral}{'-\/'} \&\& next.size() > 2 ) \{}
\DoxyCodeLine{8898                             std::string opt = \textcolor{stringliteral}{"{}-\/ "{}};}
\DoxyCodeLine{8899                             \textcolor{keywordflow}{for}( \textcolor{keywordtype}{size\_t} i = 1; i < next.size(); ++i ) \{}
\DoxyCodeLine{8900                                 opt[1] = next[i];}
\DoxyCodeLine{8901                                 m\_tokenBuffer.push\_back( \{ TokenType::Option, opt \} );}
\DoxyCodeLine{8902                             \}}
\DoxyCodeLine{8903                         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8904                             m\_tokenBuffer.push\_back( \{ TokenType::Option, next \} );}
\DoxyCodeLine{8905                         \}}
\DoxyCodeLine{8906                     \}}
\DoxyCodeLine{8907                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8908                     m\_tokenBuffer.push\_back( \{ TokenType::Argument, next \} );}
\DoxyCodeLine{8909                 \}}
\DoxyCodeLine{8910             \}}
\DoxyCodeLine{8911         \}}
\DoxyCodeLine{8912 }
\DoxyCodeLine{8913     \textcolor{keyword}{public}:}
\DoxyCodeLine{8914         \textcolor{keyword}{explicit} TokenStream( Args \textcolor{keyword}{const} \&args ) : TokenStream( args.m\_args.begin(), args.m\_args.end() ) \{\}}
\DoxyCodeLine{8915 }
\DoxyCodeLine{8916         TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) \{}
\DoxyCodeLine{8917             loadBuffer();}
\DoxyCodeLine{8918         \}}
\DoxyCodeLine{8919 }
\DoxyCodeLine{8920         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8921             \textcolor{keywordflow}{return} !m\_tokenBuffer.empty() || it != itEnd;}
\DoxyCodeLine{8922         \}}
\DoxyCodeLine{8923 }
\DoxyCodeLine{8924         \textcolor{keyword}{auto} count() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} m\_tokenBuffer.size() + (itEnd -\/ it); \}}
\DoxyCodeLine{8925 }
\DoxyCodeLine{8926         \textcolor{keyword}{auto} operator*() const -\/> Token \{}
\DoxyCodeLine{8927             assert( !m\_tokenBuffer.empty() );}
\DoxyCodeLine{8928             \textcolor{keywordflow}{return} m\_tokenBuffer.front();}
\DoxyCodeLine{8929         \}}
\DoxyCodeLine{8930 }
\DoxyCodeLine{8931         \textcolor{keyword}{auto} operator-\/>() const -\/> Token const * \{}
\DoxyCodeLine{8932             assert( !m\_tokenBuffer.empty() );}
\DoxyCodeLine{8933             \textcolor{keywordflow}{return} \&m\_tokenBuffer.front();}
\DoxyCodeLine{8934         \}}
\DoxyCodeLine{8935 }
\DoxyCodeLine{8936         \textcolor{keyword}{auto} operator++() -\/> TokenStream \& \{}
\DoxyCodeLine{8937             \textcolor{keywordflow}{if}( m\_tokenBuffer.size() >= 2 ) \{}
\DoxyCodeLine{8938                 m\_tokenBuffer.erase( m\_tokenBuffer.begin() );}
\DoxyCodeLine{8939             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8940                 \textcolor{keywordflow}{if}( it != itEnd )}
\DoxyCodeLine{8941                     ++it;}
\DoxyCodeLine{8942                 loadBuffer();}
\DoxyCodeLine{8943             \}}
\DoxyCodeLine{8944             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8945         \}}
\DoxyCodeLine{8946     \};}
\DoxyCodeLine{8947 }
\DoxyCodeLine{8948     \textcolor{keyword}{class }ResultBase \{}
\DoxyCodeLine{8949     \textcolor{keyword}{public}:}
\DoxyCodeLine{8950         \textcolor{keyword}{enum} Type \{}
\DoxyCodeLine{8951             Ok, LogicError, RuntimeError}
\DoxyCodeLine{8952         \};}
\DoxyCodeLine{8953 }
\DoxyCodeLine{8954     \textcolor{keyword}{protected}:}
\DoxyCodeLine{8955         ResultBase( Type type ) : m\_type( type ) \{\}}
\DoxyCodeLine{8956         \textcolor{keyword}{virtual} \string~ResultBase() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{8957 }
\DoxyCodeLine{8958         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} enforceOk() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{8959 }
\DoxyCodeLine{8960         Type m\_type;}
\DoxyCodeLine{8961     \};}
\DoxyCodeLine{8962 }
\DoxyCodeLine{8963     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{8964     \textcolor{keyword}{class }ResultValueBase : \textcolor{keyword}{public} ResultBase \{}
\DoxyCodeLine{8965     \textcolor{keyword}{public}:}
\DoxyCodeLine{8966         \textcolor{keyword}{auto} value() const -\/> T const \& \{}
\DoxyCodeLine{8967             enforceOk();}
\DoxyCodeLine{8968             \textcolor{keywordflow}{return} m\_value;}
\DoxyCodeLine{8969         \}}
\DoxyCodeLine{8970 }
\DoxyCodeLine{8971     \textcolor{keyword}{protected}:}
\DoxyCodeLine{8972         ResultValueBase( Type type ) : ResultBase( type ) \{\}}
\DoxyCodeLine{8973 }
\DoxyCodeLine{8974         ResultValueBase( ResultValueBase \textcolor{keyword}{const} \&other ) : ResultBase( other ) \{}
\DoxyCodeLine{8975             \textcolor{keywordflow}{if}( m\_type == ResultBase::Ok )}
\DoxyCodeLine{8976                 \textcolor{keyword}{new}( \&m\_value ) T( other.m\_value );}
\DoxyCodeLine{8977         \}}
\DoxyCodeLine{8978 }
\DoxyCodeLine{8979         ResultValueBase( Type, T \textcolor{keyword}{const} \&value ) : ResultBase( Ok ) \{}
\DoxyCodeLine{8980             \textcolor{keyword}{new}( \&m\_value ) T( value );}
\DoxyCodeLine{8981         \}}
\DoxyCodeLine{8982 }
\DoxyCodeLine{8983         \textcolor{keyword}{auto} operator=( ResultValueBase \textcolor{keyword}{const} \&other ) -\/> ResultValueBase \& \{}
\DoxyCodeLine{8984             \textcolor{keywordflow}{if}( m\_type == ResultBase::Ok )}
\DoxyCodeLine{8985                 m\_value.\string~T();}
\DoxyCodeLine{8986             ResultBase::operator=(other);}
\DoxyCodeLine{8987             \textcolor{keywordflow}{if}( m\_type == ResultBase::Ok )}
\DoxyCodeLine{8988                 \textcolor{keyword}{new}( \&m\_value ) T( other.m\_value );}
\DoxyCodeLine{8989             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8990         \}}
\DoxyCodeLine{8991 }
\DoxyCodeLine{8992         \string~ResultValueBase()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{8993             \textcolor{keywordflow}{if}( m\_type == Ok )}
\DoxyCodeLine{8994                 m\_value.\string~T();}
\DoxyCodeLine{8995         \}}
\DoxyCodeLine{8996 }
\DoxyCodeLine{8997         \textcolor{keyword}{union }\{}
\DoxyCodeLine{8998             T m\_value;}
\DoxyCodeLine{8999         \};}
\DoxyCodeLine{9000     \};}
\DoxyCodeLine{9001 }
\DoxyCodeLine{9002     \textcolor{keyword}{template}<>}
\DoxyCodeLine{9003     \textcolor{keyword}{class }ResultValueBase<void> : \textcolor{keyword}{public} ResultBase \{}
\DoxyCodeLine{9004     \textcolor{keyword}{protected}:}
\DoxyCodeLine{9005         \textcolor{keyword}{using} ResultBase::ResultBase;}
\DoxyCodeLine{9006     \};}
\DoxyCodeLine{9007 }
\DoxyCodeLine{9008     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{9009     \textcolor{keyword}{class }BasicResult : \textcolor{keyword}{public} ResultValueBase<T> \{}
\DoxyCodeLine{9010     \textcolor{keyword}{public}:}
\DoxyCodeLine{9011         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{9012         \textcolor{keyword}{explicit} BasicResult( BasicResult<U> \textcolor{keyword}{const} \&other )}
\DoxyCodeLine{9013         :   ResultValueBase<T>( other.type() ),}
\DoxyCodeLine{9014             m\_errorMessage( other.errorMessage() )}
\DoxyCodeLine{9015         \{}
\DoxyCodeLine{9016             assert( type() != ResultBase::Ok );}
\DoxyCodeLine{9017         \}}
\DoxyCodeLine{9018 }
\DoxyCodeLine{9019         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{9020         \textcolor{keyword}{static} \textcolor{keyword}{auto} ok( U \textcolor{keyword}{const} \&value ) -\/> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::Ok, value \}; \}}
\DoxyCodeLine{9021         \textcolor{keyword}{static} \textcolor{keyword}{auto} ok() -\/> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::Ok \}; \}}
\DoxyCodeLine{9022         \textcolor{keyword}{static} \textcolor{keyword}{auto} logicError( std::string \textcolor{keyword}{const} \&message ) -\/> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::LogicError, message \}; \}}
\DoxyCodeLine{9023         \textcolor{keyword}{static} \textcolor{keyword}{auto} runtimeError( std::string \textcolor{keyword}{const} \&message ) -\/> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::RuntimeError, message \}; \}}
\DoxyCodeLine{9024 }
\DoxyCodeLine{9025         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_type == ResultBase::Ok; \}}
\DoxyCodeLine{9026         \textcolor{keyword}{auto} type() const -\/> ResultBase::Type \{ \textcolor{keywordflow}{return} m\_type; \}}
\DoxyCodeLine{9027         \textcolor{keyword}{auto} errorMessage() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_errorMessage; \}}
\DoxyCodeLine{9028 }
\DoxyCodeLine{9029     \textcolor{keyword}{protected}:}
\DoxyCodeLine{9030         \textcolor{keywordtype}{void} enforceOk()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{9031 }
\DoxyCodeLine{9032             \textcolor{comment}{// Errors shouldn't reach this point, but if they do}}
\DoxyCodeLine{9033             \textcolor{comment}{// the actual error message will be in m\_errorMessage}}
\DoxyCodeLine{9034             assert( m\_type != ResultBase::LogicError );}
\DoxyCodeLine{9035             assert( m\_type != ResultBase::RuntimeError );}
\DoxyCodeLine{9036             \textcolor{keywordflow}{if}( m\_type != ResultBase::Ok )}
\DoxyCodeLine{9037                 std::abort();}
\DoxyCodeLine{9038         \}}
\DoxyCodeLine{9039 }
\DoxyCodeLine{9040         std::string m\_errorMessage; \textcolor{comment}{// Only populated if resultType is an error}}
\DoxyCodeLine{9041 }
\DoxyCodeLine{9042         BasicResult( ResultBase::Type type, std::string \textcolor{keyword}{const} \&message )}
\DoxyCodeLine{9043         :   ResultValueBase<T>(type),}
\DoxyCodeLine{9044             m\_errorMessage(message)}
\DoxyCodeLine{9045         \{}
\DoxyCodeLine{9046             assert( m\_type != ResultBase::Ok );}
\DoxyCodeLine{9047         \}}
\DoxyCodeLine{9048 }
\DoxyCodeLine{9049         \textcolor{keyword}{using} ResultValueBase<T>::ResultValueBase;}
\DoxyCodeLine{9050         \textcolor{keyword}{using} ResultBase::m\_type;}
\DoxyCodeLine{9051     \};}
\DoxyCodeLine{9052 }
\DoxyCodeLine{9053     \textcolor{keyword}{enum class} ParseResultType \{}
\DoxyCodeLine{9054         Matched, NoMatch, ShortCircuitAll, ShortCircuitSame}
\DoxyCodeLine{9055     \};}
\DoxyCodeLine{9056 }
\DoxyCodeLine{9057     \textcolor{keyword}{class }ParseState \{}
\DoxyCodeLine{9058     \textcolor{keyword}{public}:}
\DoxyCodeLine{9059 }
\DoxyCodeLine{9060         ParseState( ParseResultType type, TokenStream \textcolor{keyword}{const} \&remainingTokens )}
\DoxyCodeLine{9061         : m\_type(type),}
\DoxyCodeLine{9062           m\_remainingTokens( remainingTokens )}
\DoxyCodeLine{9063         \{\}}
\DoxyCodeLine{9064 }
\DoxyCodeLine{9065         \textcolor{keyword}{auto} type() const -\/> ParseResultType \{ \textcolor{keywordflow}{return} m\_type; \}}
\DoxyCodeLine{9066         \textcolor{keyword}{auto} remainingTokens() const -\/> TokenStream \{ \textcolor{keywordflow}{return} m\_remainingTokens; \}}
\DoxyCodeLine{9067 }
\DoxyCodeLine{9068     \textcolor{keyword}{private}:}
\DoxyCodeLine{9069         ParseResultType m\_type;}
\DoxyCodeLine{9070         TokenStream m\_remainingTokens;}
\DoxyCodeLine{9071     \};}
\DoxyCodeLine{9072 }
\DoxyCodeLine{9073     \textcolor{keyword}{using} Result = BasicResult<void>;}
\DoxyCodeLine{9074     \textcolor{keyword}{using} ParserResult = BasicResult<ParseResultType>;}
\DoxyCodeLine{9075     \textcolor{keyword}{using} InternalParseResult = BasicResult<ParseState>;}
\DoxyCodeLine{9076 }
\DoxyCodeLine{9077     \textcolor{keyword}{struct }HelpColumns \{}
\DoxyCodeLine{9078         std::string left;}
\DoxyCodeLine{9079         std::string right;}
\DoxyCodeLine{9080     \};}
\DoxyCodeLine{9081 }
\DoxyCodeLine{9082     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9083     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, T\& target ) -\/> ParserResult \{}
\DoxyCodeLine{9084         std::stringstream ss;}
\DoxyCodeLine{9085         ss << source;}
\DoxyCodeLine{9086         ss >> target;}
\DoxyCodeLine{9087         \textcolor{keywordflow}{if}( ss.fail() )}
\DoxyCodeLine{9088             \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unable to convert '"{}} + source + \textcolor{stringliteral}{"{}' to destination type"{}} );}
\DoxyCodeLine{9089         \textcolor{keywordflow}{else}}
\DoxyCodeLine{9090             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9091     \}}
\DoxyCodeLine{9092     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, std::string\& target ) -\/> ParserResult \{}
\DoxyCodeLine{9093         target = source;}
\DoxyCodeLine{9094         \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9095     \}}
\DoxyCodeLine{9096     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, \textcolor{keywordtype}{bool} \&target ) -\/> ParserResult \{}
\DoxyCodeLine{9097         std::string srcLC = source;}
\DoxyCodeLine{9098         std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c ) \{ return static\_cast<char>( std::tolower(c) ); \} );}
\DoxyCodeLine{9099         \textcolor{keywordflow}{if} (srcLC == \textcolor{stringliteral}{"{}y"{}} || srcLC == \textcolor{stringliteral}{"{}1"{}} || srcLC == \textcolor{stringliteral}{"{}true"{}} || srcLC == \textcolor{stringliteral}{"{}yes"{}} || srcLC == \textcolor{stringliteral}{"{}on"{}})}
\DoxyCodeLine{9100             target = \textcolor{keyword}{true};}
\DoxyCodeLine{9101         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (srcLC == \textcolor{stringliteral}{"{}n"{}} || srcLC == \textcolor{stringliteral}{"{}0"{}} || srcLC == \textcolor{stringliteral}{"{}false"{}} || srcLC == \textcolor{stringliteral}{"{}no"{}} || srcLC == \textcolor{stringliteral}{"{}off"{}})}
\DoxyCodeLine{9102             target = \textcolor{keyword}{false};}
\DoxyCodeLine{9103         \textcolor{keywordflow}{else}}
\DoxyCodeLine{9104             \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Expected a boolean value but did not recognise: '"{}} + source + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9105         \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9106     \}}
\DoxyCodeLine{9107 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_OPTIONAL\_TYPE}}
\DoxyCodeLine{9108     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9109     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, CLARA\_CONFIG\_OPTIONAL\_TYPE<T>\& target ) -\/> ParserResult \{}
\DoxyCodeLine{9110         T temp;}
\DoxyCodeLine{9111         \textcolor{keyword}{auto} result = convertInto( source, temp );}
\DoxyCodeLine{9112         \textcolor{keywordflow}{if}( result )}
\DoxyCodeLine{9113             target = std::move(temp);}
\DoxyCodeLine{9114         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9115     \}}
\DoxyCodeLine{9116 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CLARA\_CONFIG\_OPTIONAL\_TYPE}}
\DoxyCodeLine{9117 }
\DoxyCodeLine{9118     \textcolor{keyword}{struct }NonCopyable \{}
\DoxyCodeLine{9119         NonCopyable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9120         NonCopyable( NonCopyable \textcolor{keyword}{const} \& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{9121         NonCopyable( NonCopyable \&\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{9122         NonCopyable \&operator=( NonCopyable \textcolor{keyword}{const} \& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{9123         NonCopyable \&operator=( NonCopyable \&\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{9124     \};}
\DoxyCodeLine{9125 }
\DoxyCodeLine{9126     \textcolor{keyword}{struct }BoundRef : NonCopyable \{}
\DoxyCodeLine{9127         \textcolor{keyword}{virtual} \string~BoundRef() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9128         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} isContainer() const -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{9129         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} isFlag() const -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{9130     \};}
\DoxyCodeLine{9131     \textcolor{keyword}{struct }BoundValueRefBase : BoundRef \{}
\DoxyCodeLine{9132         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult = 0;}
\DoxyCodeLine{9133     \};}
\DoxyCodeLine{9134     \textcolor{keyword}{struct }BoundFlagRefBase : BoundRef \{}
\DoxyCodeLine{9135         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} setFlag( \textcolor{keywordtype}{bool} flag ) -\/> ParserResult = 0;}
\DoxyCodeLine{9136         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} isFlag() const -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{9137     \};}
\DoxyCodeLine{9138 }
\DoxyCodeLine{9139     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9140     \textcolor{keyword}{struct }BoundValueRef : BoundValueRefBase \{}
\DoxyCodeLine{9141         T \&m\_ref;}
\DoxyCodeLine{9142 }
\DoxyCodeLine{9143         \textcolor{keyword}{explicit} BoundValueRef( T \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{9144 }
\DoxyCodeLine{9145         \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9146             \textcolor{keywordflow}{return} convertInto( arg, m\_ref );}
\DoxyCodeLine{9147         \}}
\DoxyCodeLine{9148     \};}
\DoxyCodeLine{9149 }
\DoxyCodeLine{9150     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9151     \textcolor{keyword}{struct }BoundValueRef<std::vector<T>> : BoundValueRefBase \{}
\DoxyCodeLine{9152         std::vector<T> \&m\_ref;}
\DoxyCodeLine{9153 }
\DoxyCodeLine{9154         \textcolor{keyword}{explicit} BoundValueRef( std::vector<T> \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{9155 }
\DoxyCodeLine{9156         \textcolor{keyword}{auto} isContainer() const -\/> \textcolor{keywordtype}{bool}\textcolor{keyword}{ override }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{9157 }
\DoxyCodeLine{9158         \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9159             T temp;}
\DoxyCodeLine{9160             \textcolor{keyword}{auto} result = convertInto( arg, temp );}
\DoxyCodeLine{9161             \textcolor{keywordflow}{if}( result )}
\DoxyCodeLine{9162                 m\_ref.push\_back( temp );}
\DoxyCodeLine{9163             \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9164         \}}
\DoxyCodeLine{9165     \};}
\DoxyCodeLine{9166 }
\DoxyCodeLine{9167     \textcolor{keyword}{struct }BoundFlagRef : BoundFlagRefBase \{}
\DoxyCodeLine{9168         \textcolor{keywordtype}{bool} \&m\_ref;}
\DoxyCodeLine{9169 }
\DoxyCodeLine{9170         \textcolor{keyword}{explicit} BoundFlagRef( \textcolor{keywordtype}{bool} \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{9171 }
\DoxyCodeLine{9172         \textcolor{keyword}{auto} setFlag( \textcolor{keywordtype}{bool} flag ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9173             m\_ref = flag;}
\DoxyCodeLine{9174             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9175         \}}
\DoxyCodeLine{9176     \};}
\DoxyCodeLine{9177 }
\DoxyCodeLine{9178     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReturnType>}
\DoxyCodeLine{9179     \textcolor{keyword}{struct }LambdaInvoker \{}
\DoxyCodeLine{9180         \textcolor{keyword}{static\_assert}( std::is\_same<ReturnType, ParserResult>::value, \textcolor{stringliteral}{"{}Lambda must return void or clara::ParserResult"{}} );}
\DoxyCodeLine{9181 }
\DoxyCodeLine{9182         \textcolor{keyword}{template}<\textcolor{keyword}{typename} L, \textcolor{keyword}{typename} ArgType>}
\DoxyCodeLine{9183         \textcolor{keyword}{static} \textcolor{keyword}{auto} invoke( L \textcolor{keyword}{const} \&lambda, ArgType \textcolor{keyword}{const} \&arg ) -\/> ParserResult \{}
\DoxyCodeLine{9184             \textcolor{keywordflow}{return} lambda( arg );}
\DoxyCodeLine{9185         \}}
\DoxyCodeLine{9186     \};}
\DoxyCodeLine{9187 }
\DoxyCodeLine{9188     \textcolor{keyword}{template}<>}
\DoxyCodeLine{9189     \textcolor{keyword}{struct }LambdaInvoker<void> \{}
\DoxyCodeLine{9190         \textcolor{keyword}{template}<\textcolor{keyword}{typename} L, \textcolor{keyword}{typename} ArgType>}
\DoxyCodeLine{9191         \textcolor{keyword}{static} \textcolor{keyword}{auto} invoke( L \textcolor{keyword}{const} \&lambda, ArgType \textcolor{keyword}{const} \&arg ) -\/> ParserResult \{}
\DoxyCodeLine{9192             lambda( arg );}
\DoxyCodeLine{9193             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9194         \}}
\DoxyCodeLine{9195     \};}
\DoxyCodeLine{9196 }
\DoxyCodeLine{9197     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} L>}
\DoxyCodeLine{9198     \textcolor{keyword}{inline} \textcolor{keyword}{auto} invokeLambda( L \textcolor{keyword}{const} \&lambda, std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult \{}
\DoxyCodeLine{9199         ArgType temp\{\};}
\DoxyCodeLine{9200         \textcolor{keyword}{auto} result = convertInto( arg, temp );}
\DoxyCodeLine{9201         \textcolor{keywordflow}{return} !result}
\DoxyCodeLine{9202            ? result}
\DoxyCodeLine{9203            : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );}
\DoxyCodeLine{9204     \}}
\DoxyCodeLine{9205 }
\DoxyCodeLine{9206     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{9207     \textcolor{keyword}{struct }BoundLambda : BoundValueRefBase \{}
\DoxyCodeLine{9208         L m\_lambda;}
\DoxyCodeLine{9209 }
\DoxyCodeLine{9210         \textcolor{keyword}{static\_assert}( UnaryLambdaTraits<L>::isValid, \textcolor{stringliteral}{"{}Supplied lambda must take exactly one argument"{}} );}
\DoxyCodeLine{9211         \textcolor{keyword}{explicit} BoundLambda( L \textcolor{keyword}{const} \&lambda ) : m\_lambda( lambda ) \{\}}
\DoxyCodeLine{9212 }
\DoxyCodeLine{9213         \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9214             \textcolor{keywordflow}{return} invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m\_lambda, arg );}
\DoxyCodeLine{9215         \}}
\DoxyCodeLine{9216     \};}
\DoxyCodeLine{9217 }
\DoxyCodeLine{9218     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{9219     \textcolor{keyword}{struct }BoundFlagLambda : BoundFlagRefBase \{}
\DoxyCodeLine{9220         L m\_lambda;}
\DoxyCodeLine{9221 }
\DoxyCodeLine{9222         \textcolor{keyword}{static\_assert}( UnaryLambdaTraits<L>::isValid, \textcolor{stringliteral}{"{}Supplied lambda must take exactly one argument"{}} );}
\DoxyCodeLine{9223         \textcolor{keyword}{static\_assert}( std::is\_same<typename UnaryLambdaTraits<L>::ArgType, \textcolor{keywordtype}{bool}>::value, \textcolor{stringliteral}{"{}flags must be boolean"{}} );}
\DoxyCodeLine{9224 }
\DoxyCodeLine{9225         \textcolor{keyword}{explicit} BoundFlagLambda( L \textcolor{keyword}{const} \&lambda ) : m\_lambda( lambda ) \{\}}
\DoxyCodeLine{9226 }
\DoxyCodeLine{9227         \textcolor{keyword}{auto} setFlag( \textcolor{keywordtype}{bool} flag ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9228             \textcolor{keywordflow}{return} LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m\_lambda, flag );}
\DoxyCodeLine{9229         \}}
\DoxyCodeLine{9230     \};}
\DoxyCodeLine{9231 }
\DoxyCodeLine{9232     \textcolor{keyword}{enum class} Optionality \{ Optional, Required \};}
\DoxyCodeLine{9233 }
\DoxyCodeLine{9234     \textcolor{keyword}{struct }Parser;}
\DoxyCodeLine{9235 }
\DoxyCodeLine{9236     \textcolor{keyword}{class }ParserBase \{}
\DoxyCodeLine{9237     \textcolor{keyword}{public}:}
\DoxyCodeLine{9238         \textcolor{keyword}{virtual} \string~ParserBase() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9239         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} validate() const -\/> Result \{ \textcolor{keywordflow}{return} Result::ok(); \}}
\DoxyCodeLine{9240         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\& exeName, TokenStream \textcolor{keyword}{const} \&tokens) \textcolor{keyword}{const} -\/> InternalParseResult  = 0;}
\DoxyCodeLine{9241         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} cardinality() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} 1; \}}
\DoxyCodeLine{9242 }
\DoxyCodeLine{9243         \textcolor{keyword}{auto} parse( Args \textcolor{keyword}{const} \&args ) \textcolor{keyword}{const} -\/> InternalParseResult \{}
\DoxyCodeLine{9244             \textcolor{keywordflow}{return} parse( args.exeName(), TokenStream( args ) );}
\DoxyCodeLine{9245         \}}
\DoxyCodeLine{9246     \};}
\DoxyCodeLine{9247 }
\DoxyCodeLine{9248     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{9249     \textcolor{keyword}{class }ComposableParserImpl : \textcolor{keyword}{public} ParserBase \{}
\DoxyCodeLine{9250     \textcolor{keyword}{public}:}
\DoxyCodeLine{9251         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9252         \textcolor{keyword}{auto} operator|( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser;}
\DoxyCodeLine{9253 }
\DoxyCodeLine{9254         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9255         \textcolor{keyword}{auto} operator+( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser;}
\DoxyCodeLine{9256     \};}
\DoxyCodeLine{9257 }
\DoxyCodeLine{9258     \textcolor{comment}{// Common code and state for Args and Opts}}
\DoxyCodeLine{9259     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{9260     \textcolor{keyword}{class }ParserRefImpl : \textcolor{keyword}{public} ComposableParserImpl<DerivedT> \{}
\DoxyCodeLine{9261     \textcolor{keyword}{protected}:}
\DoxyCodeLine{9262         Optionality m\_optionality = Optionality::Optional;}
\DoxyCodeLine{9263         std::shared\_ptr<BoundRef> m\_ref;}
\DoxyCodeLine{9264         std::string m\_hint;}
\DoxyCodeLine{9265         std::string m\_description;}
\DoxyCodeLine{9266 }
\DoxyCodeLine{9267         \textcolor{keyword}{explicit} ParserRefImpl( std::shared\_ptr<BoundRef> \textcolor{keyword}{const} \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{9268 }
\DoxyCodeLine{9269     \textcolor{keyword}{public}:}
\DoxyCodeLine{9270         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9271         ParserRefImpl( T \&ref, std::string \textcolor{keyword}{const} \&hint )}
\DoxyCodeLine{9272         :   m\_ref( std::make\_shared<BoundValueRef<T>>( ref ) ),}
\DoxyCodeLine{9273             m\_hint( hint )}
\DoxyCodeLine{9274         \{\}}
\DoxyCodeLine{9275 }
\DoxyCodeLine{9276         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9277         ParserRefImpl( LambdaT \textcolor{keyword}{const} \&ref, std::string \textcolor{keyword}{const} \&hint )}
\DoxyCodeLine{9278         :   m\_ref( std::make\_shared<BoundLambda<LambdaT>>( ref ) ),}
\DoxyCodeLine{9279             m\_hint(hint)}
\DoxyCodeLine{9280         \{\}}
\DoxyCodeLine{9281 }
\DoxyCodeLine{9282         \textcolor{keyword}{auto} operator()( std::string \textcolor{keyword}{const} \&description ) -\/> DerivedT \& \{}
\DoxyCodeLine{9283             m\_description = description;}
\DoxyCodeLine{9284             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}DerivedT \&\textcolor{keyword}{>}( *this );}
\DoxyCodeLine{9285         \}}
\DoxyCodeLine{9286 }
\DoxyCodeLine{9287         \textcolor{keyword}{auto} optional() -\/> DerivedT \& \{}
\DoxyCodeLine{9288             m\_optionality = Optionality::Optional;}
\DoxyCodeLine{9289             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}DerivedT \&\textcolor{keyword}{>}( *this );}
\DoxyCodeLine{9290         \};}
\DoxyCodeLine{9291 }
\DoxyCodeLine{9292         \textcolor{keyword}{auto} required() -\/> DerivedT \& \{}
\DoxyCodeLine{9293             m\_optionality = Optionality::Required;}
\DoxyCodeLine{9294             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}DerivedT \&\textcolor{keyword}{>}( *this );}
\DoxyCodeLine{9295         \};}
\DoxyCodeLine{9296 }
\DoxyCodeLine{9297         \textcolor{keyword}{auto} isOptional() const -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{9298             \textcolor{keywordflow}{return} m\_optionality == Optionality::Optional;}
\DoxyCodeLine{9299         \}}
\DoxyCodeLine{9300 }
\DoxyCodeLine{9301         \textcolor{keyword}{auto} cardinality() const -\/> \textcolor{keywordtype}{size\_t}\textcolor{keyword}{ override }\{}
\DoxyCodeLine{9302             \textcolor{keywordflow}{if}( m\_ref-\/>isContainer() )}
\DoxyCodeLine{9303                 \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{9304             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9305                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{9306         \}}
\DoxyCodeLine{9307 }
\DoxyCodeLine{9308         \textcolor{keyword}{auto} hint() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_hint; \}}
\DoxyCodeLine{9309     \};}
\DoxyCodeLine{9310 }
\DoxyCodeLine{9311     \textcolor{keyword}{class }ExeName : \textcolor{keyword}{public} ComposableParserImpl<ExeName> \{}
\DoxyCodeLine{9312         std::shared\_ptr<std::string> m\_name;}
\DoxyCodeLine{9313         std::shared\_ptr<BoundValueRefBase> m\_ref;}
\DoxyCodeLine{9314 }
\DoxyCodeLine{9315         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9316         \textcolor{keyword}{static} \textcolor{keyword}{auto} makeRef(LambdaT \textcolor{keyword}{const} \&lambda) -\/> std::shared\_ptr<BoundValueRefBase> \{}
\DoxyCodeLine{9317             \textcolor{keywordflow}{return} std::make\_shared<BoundLambda<LambdaT>>( lambda) ;}
\DoxyCodeLine{9318         \}}
\DoxyCodeLine{9319 }
\DoxyCodeLine{9320     \textcolor{keyword}{public}:}
\DoxyCodeLine{9321         ExeName() : m\_name( std::make\_shared<std::string>( \textcolor{stringliteral}{"{}<executable>"{}} ) ) \{\}}
\DoxyCodeLine{9322 }
\DoxyCodeLine{9323         \textcolor{keyword}{explicit} ExeName( std::string \&ref ) : ExeName() \{}
\DoxyCodeLine{9324             m\_ref = std::make\_shared<BoundValueRef<std::string>>( ref );}
\DoxyCodeLine{9325         \}}
\DoxyCodeLine{9326 }
\DoxyCodeLine{9327         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9328         \textcolor{keyword}{explicit} ExeName( LambdaT \textcolor{keyword}{const}\& lambda ) : ExeName() \{}
\DoxyCodeLine{9329             m\_ref = std::make\_shared<BoundLambda<LambdaT>>( lambda );}
\DoxyCodeLine{9330         \}}
\DoxyCodeLine{9331 }
\DoxyCodeLine{9332         \textcolor{comment}{// The exe name is not parsed out of the normal tokens, but is handled specially}}
\DoxyCodeLine{9333         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\&, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -\/> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9334             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );}
\DoxyCodeLine{9335         \}}
\DoxyCodeLine{9336 }
\DoxyCodeLine{9337         \textcolor{keyword}{auto} name() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} *m\_name; \}}
\DoxyCodeLine{9338         \textcolor{keyword}{auto} set( std::string \textcolor{keyword}{const}\& newName ) -\/> ParserResult \{}
\DoxyCodeLine{9339 }
\DoxyCodeLine{9340             \textcolor{keyword}{auto} lastSlash = newName.find\_last\_of( \textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)/"{}} );}
\DoxyCodeLine{9341             \textcolor{keyword}{auto} filename = ( lastSlash == std::string::npos )}
\DoxyCodeLine{9342                     ? newName}
\DoxyCodeLine{9343                     : newName.substr( lastSlash+1 );}
\DoxyCodeLine{9344 }
\DoxyCodeLine{9345             *m\_name = filename;}
\DoxyCodeLine{9346             \textcolor{keywordflow}{if}( m\_ref )}
\DoxyCodeLine{9347                 \textcolor{keywordflow}{return} m\_ref-\/>setValue( filename );}
\DoxyCodeLine{9348             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9349                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9350         \}}
\DoxyCodeLine{9351     \};}
\DoxyCodeLine{9352 }
\DoxyCodeLine{9353     \textcolor{keyword}{class }Arg : \textcolor{keyword}{public} ParserRefImpl<Arg> \{}
\DoxyCodeLine{9354     \textcolor{keyword}{public}:}
\DoxyCodeLine{9355         \textcolor{keyword}{using} ParserRefImpl::ParserRefImpl;}
\DoxyCodeLine{9356 }
\DoxyCodeLine{9357         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const} \&, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -\/> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9358             \textcolor{keyword}{auto} validationResult = validate();}
\DoxyCodeLine{9359             \textcolor{keywordflow}{if}( !validationResult )}
\DoxyCodeLine{9360                 \textcolor{keywordflow}{return} InternalParseResult( validationResult );}
\DoxyCodeLine{9361 }
\DoxyCodeLine{9362             \textcolor{keyword}{auto} remainingTokens = tokens;}
\DoxyCodeLine{9363             \textcolor{keyword}{auto} \textcolor{keyword}{const} \&token = *remainingTokens;}
\DoxyCodeLine{9364             \textcolor{keywordflow}{if}( token.type != TokenType::Argument )}
\DoxyCodeLine{9365                 \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );}
\DoxyCodeLine{9366 }
\DoxyCodeLine{9367             assert( !m\_ref-\/>isFlag() );}
\DoxyCodeLine{9368             \textcolor{keyword}{auto} valueRef = \textcolor{keyword}{static\_cast<}detail::BoundValueRefBase*\textcolor{keyword}{>}( m\_ref.get() );}
\DoxyCodeLine{9369 }
\DoxyCodeLine{9370             \textcolor{keyword}{auto} result = valueRef-\/>setValue( remainingTokens-\/>token );}
\DoxyCodeLine{9371             \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9372                 \textcolor{keywordflow}{return} InternalParseResult( result );}
\DoxyCodeLine{9373             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9374                 \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );}
\DoxyCodeLine{9375         \}}
\DoxyCodeLine{9376     \};}
\DoxyCodeLine{9377 }
\DoxyCodeLine{9378     \textcolor{keyword}{inline} \textcolor{keyword}{auto} normaliseOpt( std::string \textcolor{keyword}{const} \&optName ) -\/> std::string \{}
\DoxyCodeLine{9379 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{9380         \textcolor{keywordflow}{if}( optName[0] == \textcolor{charliteral}{'/'} )}
\DoxyCodeLine{9381             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}-\/"{}} + optName.substr( 1 );}
\DoxyCodeLine{9382         \textcolor{keywordflow}{else}}
\DoxyCodeLine{9383 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9384             \textcolor{keywordflow}{return} optName;}
\DoxyCodeLine{9385     \}}
\DoxyCodeLine{9386 }
\DoxyCodeLine{9387     \textcolor{keyword}{class }Opt : \textcolor{keyword}{public} ParserRefImpl<Opt> \{}
\DoxyCodeLine{9388     \textcolor{keyword}{protected}:}
\DoxyCodeLine{9389         std::vector<std::string> m\_optNames;}
\DoxyCodeLine{9390 }
\DoxyCodeLine{9391     \textcolor{keyword}{public}:}
\DoxyCodeLine{9392         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9393         \textcolor{keyword}{explicit} Opt( LambdaT \textcolor{keyword}{const} \&ref ) : ParserRefImpl( std::make\_shared<BoundFlagLambda<LambdaT>>( ref ) ) \{\}}
\DoxyCodeLine{9394 }
\DoxyCodeLine{9395         \textcolor{keyword}{explicit} Opt( \textcolor{keywordtype}{bool} \&ref ) : ParserRefImpl( std::make\_shared<BoundFlagRef>( ref ) ) \{\}}
\DoxyCodeLine{9396 }
\DoxyCodeLine{9397         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9398         Opt( LambdaT \textcolor{keyword}{const} \&ref, std::string \textcolor{keyword}{const} \&hint ) : ParserRefImpl( ref, hint ) \{\}}
\DoxyCodeLine{9399 }
\DoxyCodeLine{9400         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9401         Opt( T \&ref, std::string \textcolor{keyword}{const} \&hint ) : ParserRefImpl( ref, hint ) \{\}}
\DoxyCodeLine{9402 }
\DoxyCodeLine{9403         \textcolor{keyword}{auto} operator[]( std::string \textcolor{keyword}{const} \&optName ) -\/> Opt \& \{}
\DoxyCodeLine{9404             m\_optNames.push\_back( optName );}
\DoxyCodeLine{9405             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9406         \}}
\DoxyCodeLine{9407 }
\DoxyCodeLine{9408         \textcolor{keyword}{auto} getHelpColumns() const -\/> std::vector<HelpColumns> \{}
\DoxyCodeLine{9409             std::ostringstream oss;}
\DoxyCodeLine{9410             \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{9411             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&opt : m\_optNames ) \{}
\DoxyCodeLine{9412                 \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{9413                     first = \textcolor{keyword}{false};}
\DoxyCodeLine{9414                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{9415                     oss << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{9416                 oss << opt;}
\DoxyCodeLine{9417             \}}
\DoxyCodeLine{9418             \textcolor{keywordflow}{if}( !m\_hint.empty() )}
\DoxyCodeLine{9419                 oss << \textcolor{stringliteral}{"{} <"{}} << m\_hint << \textcolor{stringliteral}{"{}>"{}};}
\DoxyCodeLine{9420             \textcolor{keywordflow}{return} \{ \{ oss.str(), m\_description \} \};}
\DoxyCodeLine{9421         \}}
\DoxyCodeLine{9422 }
\DoxyCodeLine{9423         \textcolor{keyword}{auto} isMatch( std::string \textcolor{keyword}{const} \&optToken ) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{9424             \textcolor{keyword}{auto} normalisedToken = normaliseOpt( optToken );}
\DoxyCodeLine{9425             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&name : m\_optNames ) \{}
\DoxyCodeLine{9426                 \textcolor{keywordflow}{if}( normaliseOpt( name ) == normalisedToken )}
\DoxyCodeLine{9427                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{9428             \}}
\DoxyCodeLine{9429             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9430         \}}
\DoxyCodeLine{9431 }
\DoxyCodeLine{9432         \textcolor{keyword}{using} ParserBase::parse;}
\DoxyCodeLine{9433 }
\DoxyCodeLine{9434         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\&, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -\/> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9435             \textcolor{keyword}{auto} validationResult = validate();}
\DoxyCodeLine{9436             \textcolor{keywordflow}{if}( !validationResult )}
\DoxyCodeLine{9437                 \textcolor{keywordflow}{return} InternalParseResult( validationResult );}
\DoxyCodeLine{9438 }
\DoxyCodeLine{9439             \textcolor{keyword}{auto} remainingTokens = tokens;}
\DoxyCodeLine{9440             \textcolor{keywordflow}{if}( remainingTokens \&\& remainingTokens-\/>type == TokenType::Option ) \{}
\DoxyCodeLine{9441                 \textcolor{keyword}{auto} \textcolor{keyword}{const} \&token = *remainingTokens;}
\DoxyCodeLine{9442                 \textcolor{keywordflow}{if}( isMatch(token.token ) ) \{}
\DoxyCodeLine{9443                     \textcolor{keywordflow}{if}( m\_ref-\/>isFlag() ) \{}
\DoxyCodeLine{9444                         \textcolor{keyword}{auto} flagRef = \textcolor{keyword}{static\_cast<}detail::BoundFlagRefBase*\textcolor{keyword}{>}( m\_ref.get() );}
\DoxyCodeLine{9445                         \textcolor{keyword}{auto} result = flagRef-\/>setFlag( \textcolor{keyword}{true} );}
\DoxyCodeLine{9446                         \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9447                             \textcolor{keywordflow}{return} InternalParseResult( result );}
\DoxyCodeLine{9448                         \textcolor{keywordflow}{if}( result.value() == ParseResultType::ShortCircuitAll )}
\DoxyCodeLine{9449                             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );}
\DoxyCodeLine{9450                     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{9451                         \textcolor{keyword}{auto} valueRef = \textcolor{keyword}{static\_cast<}detail::BoundValueRefBase*\textcolor{keyword}{>}( m\_ref.get() );}
\DoxyCodeLine{9452                         ++remainingTokens;}
\DoxyCodeLine{9453                         \textcolor{keywordflow}{if}( !remainingTokens )}
\DoxyCodeLine{9454                             \textcolor{keywordflow}{return} InternalParseResult::runtimeError( \textcolor{stringliteral}{"{}Expected argument following "{}} + token.token );}
\DoxyCodeLine{9455                         \textcolor{keyword}{auto} \textcolor{keyword}{const} \&argToken = *remainingTokens;}
\DoxyCodeLine{9456                         \textcolor{keywordflow}{if}( argToken.type != TokenType::Argument )}
\DoxyCodeLine{9457                             \textcolor{keywordflow}{return} InternalParseResult::runtimeError( \textcolor{stringliteral}{"{}Expected argument following "{}} + token.token );}
\DoxyCodeLine{9458                         \textcolor{keyword}{auto} result = valueRef-\/>setValue( argToken.token );}
\DoxyCodeLine{9459                         \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9460                             \textcolor{keywordflow}{return} InternalParseResult( result );}
\DoxyCodeLine{9461                         \textcolor{keywordflow}{if}( result.value() == ParseResultType::ShortCircuitAll )}
\DoxyCodeLine{9462                             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );}
\DoxyCodeLine{9463                     \}}
\DoxyCodeLine{9464                     \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );}
\DoxyCodeLine{9465                 \}}
\DoxyCodeLine{9466             \}}
\DoxyCodeLine{9467             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );}
\DoxyCodeLine{9468         \}}
\DoxyCodeLine{9469 }
\DoxyCodeLine{9470         \textcolor{keyword}{auto} validate() const -\/> Result\textcolor{keyword}{ override }\{}
\DoxyCodeLine{9471             \textcolor{keywordflow}{if}( m\_optNames.empty() )}
\DoxyCodeLine{9472                 \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"{}No options supplied to Opt"{}} );}
\DoxyCodeLine{9473             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&name : m\_optNames ) \{}
\DoxyCodeLine{9474                 \textcolor{keywordflow}{if}( name.empty() )}
\DoxyCodeLine{9475                     \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"{}Option name cannot be empty"{}} );}
\DoxyCodeLine{9476 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{9477                 \textcolor{keywordflow}{if}( name[0] != \textcolor{charliteral}{'-\/'} \&\& name[0] != \textcolor{charliteral}{'/'} )}
\DoxyCodeLine{9478                     \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"{}Option name must begin with '-\/' or '/'"{}} );}
\DoxyCodeLine{9479 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{9480                 \textcolor{keywordflow}{if}( name[0] != \textcolor{charliteral}{'-\/'} )}
\DoxyCodeLine{9481                     \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"{}Option name must begin with '-\/'"{}} );}
\DoxyCodeLine{9482 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9483             \}}
\DoxyCodeLine{9484             \textcolor{keywordflow}{return} ParserRefImpl::validate();}
\DoxyCodeLine{9485         \}}
\DoxyCodeLine{9486     \};}
\DoxyCodeLine{9487 }
\DoxyCodeLine{9488     \textcolor{keyword}{struct }Help : Opt \{}
\DoxyCodeLine{9489         Help( \textcolor{keywordtype}{bool} \&showHelpFlag )}
\DoxyCodeLine{9490         :   Opt([\&]( bool flag ) \{}
\DoxyCodeLine{9491                 showHelpFlag = flag;}
\DoxyCodeLine{9492                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::ShortCircuitAll );}
\DoxyCodeLine{9493             \})}
\DoxyCodeLine{9494         \{}
\DoxyCodeLine{9495             \textcolor{keyword}{static\_cast<}Opt \&\textcolor{keyword}{>}( *this )}
\DoxyCodeLine{9496                     (\textcolor{stringliteral}{"{}display usage information"{}})}
\DoxyCodeLine{9497                     [\textcolor{stringliteral}{"{}-\/?"{}}][\textcolor{stringliteral}{"{}-\/h"{}}][\textcolor{stringliteral}{"{}-\/-\/help"{}}]}
\DoxyCodeLine{9498                     .optional();}
\DoxyCodeLine{9499         \}}
\DoxyCodeLine{9500     \};}
\DoxyCodeLine{9501 }
\DoxyCodeLine{9502     \textcolor{keyword}{struct }Parser : ParserBase \{}
\DoxyCodeLine{9503 }
\DoxyCodeLine{9504         \textcolor{keyword}{mutable} ExeName m\_exeName;}
\DoxyCodeLine{9505         std::vector<Opt> m\_options;}
\DoxyCodeLine{9506         std::vector<Arg> m\_args;}
\DoxyCodeLine{9507 }
\DoxyCodeLine{9508         \textcolor{keyword}{auto} operator|=( ExeName \textcolor{keyword}{const} \&exeName ) -\/> Parser \& \{}
\DoxyCodeLine{9509             m\_exeName = exeName;}
\DoxyCodeLine{9510             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9511         \}}
\DoxyCodeLine{9512 }
\DoxyCodeLine{9513         \textcolor{keyword}{auto} operator|=( Arg \textcolor{keyword}{const} \&arg ) -\/> Parser \& \{}
\DoxyCodeLine{9514             m\_args.push\_back(arg);}
\DoxyCodeLine{9515             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9516         \}}
\DoxyCodeLine{9517 }
\DoxyCodeLine{9518         \textcolor{keyword}{auto} operator|=( Opt \textcolor{keyword}{const} \&opt ) -\/> Parser \& \{}
\DoxyCodeLine{9519             m\_options.push\_back(opt);}
\DoxyCodeLine{9520             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9521         \}}
\DoxyCodeLine{9522 }
\DoxyCodeLine{9523         \textcolor{keyword}{auto} operator|=( Parser \textcolor{keyword}{const} \&other ) -\/> Parser \& \{}
\DoxyCodeLine{9524             m\_options.insert(m\_options.end(), other.m\_options.begin(), other.m\_options.end());}
\DoxyCodeLine{9525             m\_args.insert(m\_args.end(), other.m\_args.begin(), other.m\_args.end());}
\DoxyCodeLine{9526             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9527         \}}
\DoxyCodeLine{9528 }
\DoxyCodeLine{9529         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9530         \textcolor{keyword}{auto} operator|( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser \{}
\DoxyCodeLine{9531             \textcolor{keywordflow}{return} Parser( *\textcolor{keyword}{this} ) |= other;}
\DoxyCodeLine{9532         \}}
\DoxyCodeLine{9533 }
\DoxyCodeLine{9534         \textcolor{comment}{// Forward deprecated interface with '+' instead of '|'}}
\DoxyCodeLine{9535         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9536         \textcolor{keyword}{auto} operator+=( T \textcolor{keyword}{const} \&other ) -\/> Parser \& \{ \textcolor{keywordflow}{return} operator|=( other ); \}}
\DoxyCodeLine{9537         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9538         \textcolor{keyword}{auto} operator+( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser \{ \textcolor{keywordflow}{return} operator|( other ); \}}
\DoxyCodeLine{9539 }
\DoxyCodeLine{9540         \textcolor{keyword}{auto} getHelpColumns() const -\/> std::vector<HelpColumns> \{}
\DoxyCodeLine{9541             std::vector<HelpColumns> cols;}
\DoxyCodeLine{9542             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const} \&o : m\_options) \{}
\DoxyCodeLine{9543                 \textcolor{keyword}{auto} childCols = o.getHelpColumns();}
\DoxyCodeLine{9544                 cols.insert( cols.end(), childCols.begin(), childCols.end() );}
\DoxyCodeLine{9545             \}}
\DoxyCodeLine{9546             \textcolor{keywordflow}{return} cols;}
\DoxyCodeLine{9547         \}}
\DoxyCodeLine{9548 }
\DoxyCodeLine{9549         \textcolor{keywordtype}{void} writeToStream( std::ostream \&os )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9550             \textcolor{keywordflow}{if} (!m\_exeName.name().empty()) \{}
\DoxyCodeLine{9551                 os << \textcolor{stringliteral}{"{}usage:\(\backslash\)n"{}} << \textcolor{stringliteral}{"{}  "{}} << m\_exeName.name() << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{9552                 \textcolor{keywordtype}{bool} required = \textcolor{keyword}{true}, first = \textcolor{keyword}{true};}
\DoxyCodeLine{9553                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&arg : m\_args ) \{}
\DoxyCodeLine{9554                     \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{9555                         first = \textcolor{keyword}{false};}
\DoxyCodeLine{9556                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{9557                         os << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{9558                     \textcolor{keywordflow}{if}( arg.isOptional() \&\& required ) \{}
\DoxyCodeLine{9559                         os << \textcolor{stringliteral}{"{}["{}};}
\DoxyCodeLine{9560                         required = \textcolor{keyword}{false};}
\DoxyCodeLine{9561                     \}}
\DoxyCodeLine{9562                     os << \textcolor{stringliteral}{"{}<"{}} << arg.hint() << \textcolor{stringliteral}{"{}>"{}};}
\DoxyCodeLine{9563                     \textcolor{keywordflow}{if}( arg.cardinality() == 0 )}
\DoxyCodeLine{9564                         os << \textcolor{stringliteral}{"{} ... "{}};}
\DoxyCodeLine{9565                 \}}
\DoxyCodeLine{9566                 \textcolor{keywordflow}{if}( !required )}
\DoxyCodeLine{9567                     os << \textcolor{stringliteral}{"{}]"{}};}
\DoxyCodeLine{9568                 \textcolor{keywordflow}{if}( !m\_options.empty() )}
\DoxyCodeLine{9569                     os << \textcolor{stringliteral}{"{} options"{}};}
\DoxyCodeLine{9570                 os << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)nwhere options are:"{}} << std::endl;}
\DoxyCodeLine{9571             \}}
\DoxyCodeLine{9572 }
\DoxyCodeLine{9573             \textcolor{keyword}{auto} rows = getHelpColumns();}
\DoxyCodeLine{9574             \textcolor{keywordtype}{size\_t} consoleWidth = CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH;}
\DoxyCodeLine{9575             \textcolor{keywordtype}{size\_t} optWidth = 0;}
\DoxyCodeLine{9576             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&cols : rows )}
\DoxyCodeLine{9577                 optWidth = (std::max)(optWidth, cols.left.size() + 2);}
\DoxyCodeLine{9578 }
\DoxyCodeLine{9579             optWidth = (std::min)(optWidth, consoleWidth/2);}
\DoxyCodeLine{9580 }
\DoxyCodeLine{9581             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&cols : rows ) \{}
\DoxyCodeLine{9582                 \textcolor{keyword}{auto} row =}
\DoxyCodeLine{9583                         TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +}
\DoxyCodeLine{9584                         TextFlow::Spacer(4) +}
\DoxyCodeLine{9585                         TextFlow::Column( cols.right ).width( consoleWidth -\/ 7 -\/ optWidth );}
\DoxyCodeLine{9586                 os << row << std::endl;}
\DoxyCodeLine{9587             \}}
\DoxyCodeLine{9588         \}}
\DoxyCodeLine{9589 }
\DoxyCodeLine{9590         \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator<<( std::ostream \&os, Parser \textcolor{keyword}{const} \&parser ) -\/> std::ostream\& \{}
\DoxyCodeLine{9591             parser.writeToStream( os );}
\DoxyCodeLine{9592             \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{9593         \}}
\DoxyCodeLine{9594 }
\DoxyCodeLine{9595         \textcolor{keyword}{auto} validate() const -\/> Result\textcolor{keyword}{ override }\{}
\DoxyCodeLine{9596             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&opt : m\_options ) \{}
\DoxyCodeLine{9597                 \textcolor{keyword}{auto} result = opt.validate();}
\DoxyCodeLine{9598                 \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9599                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9600             \}}
\DoxyCodeLine{9601             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&arg : m\_args ) \{}
\DoxyCodeLine{9602                 \textcolor{keyword}{auto} result = arg.validate();}
\DoxyCodeLine{9603                 \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9604                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9605             \}}
\DoxyCodeLine{9606             \textcolor{keywordflow}{return} Result::ok();}
\DoxyCodeLine{9607         \}}
\DoxyCodeLine{9608 }
\DoxyCodeLine{9609         \textcolor{keyword}{using} ParserBase::parse;}
\DoxyCodeLine{9610 }
\DoxyCodeLine{9611         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\& exeName, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -\/> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9612 }
\DoxyCodeLine{9613             \textcolor{keyword}{struct }ParserInfo \{}
\DoxyCodeLine{9614                 ParserBase \textcolor{keyword}{const}* parser = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{9615                 \textcolor{keywordtype}{size\_t} count = 0;}
\DoxyCodeLine{9616             \};}
\DoxyCodeLine{9617             \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} totalParsers = m\_options.size() + m\_args.size();}
\DoxyCodeLine{9618             assert( totalParsers < 512 );}
\DoxyCodeLine{9619             \textcolor{comment}{// ParserInfo parseInfos[totalParsers]; // <-\/-\/ this is what we really want to do}}
\DoxyCodeLine{9620             ParserInfo parseInfos[512];}
\DoxyCodeLine{9621 }
\DoxyCodeLine{9622             \{}
\DoxyCodeLine{9623                 \textcolor{keywordtype}{size\_t} i = 0;}
\DoxyCodeLine{9624                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const} \&opt : m\_options) parseInfos[i++].parser = \&opt;}
\DoxyCodeLine{9625                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const} \&arg : m\_args) parseInfos[i++].parser = \&arg;}
\DoxyCodeLine{9626             \}}
\DoxyCodeLine{9627 }
\DoxyCodeLine{9628             m\_exeName.set( exeName );}
\DoxyCodeLine{9629 }
\DoxyCodeLine{9630             \textcolor{keyword}{auto} result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );}
\DoxyCodeLine{9631             \textcolor{keywordflow}{while}( result.value().remainingTokens() ) \{}
\DoxyCodeLine{9632                 \textcolor{keywordtype}{bool} tokenParsed = \textcolor{keyword}{false};}
\DoxyCodeLine{9633 }
\DoxyCodeLine{9634                 \textcolor{keywordflow}{for}( \textcolor{keywordtype}{size\_t} i = 0; i < totalParsers; ++i ) \{}
\DoxyCodeLine{9635                     \textcolor{keyword}{auto}\&  parseInfo = parseInfos[i];}
\DoxyCodeLine{9636                     \textcolor{keywordflow}{if}( parseInfo.parser-\/>cardinality() == 0 || parseInfo.count < parseInfo.parser-\/>cardinality() ) \{}
\DoxyCodeLine{9637                         result = parseInfo.parser-\/>parse(exeName, result.value().remainingTokens());}
\DoxyCodeLine{9638                         if (!result)}
\DoxyCodeLine{9639                             return result;}
\DoxyCodeLine{9640                         if (result.value().type() != ParseResultType::NoMatch) \{}
\DoxyCodeLine{9641                             tokenParsed = true;}
\DoxyCodeLine{9642                             ++parseInfo.count;}
\DoxyCodeLine{9643                             break;}
\DoxyCodeLine{9644                         \}}
\DoxyCodeLine{9645                     \}}
\DoxyCodeLine{9646                 \}}
\DoxyCodeLine{9647 }
\DoxyCodeLine{9648                 \textcolor{keywordflow}{if}( result.value().type() == ParseResultType::ShortCircuitAll )}
\DoxyCodeLine{9649                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9650                 \textcolor{keywordflow}{if}( !tokenParsed )}
\DoxyCodeLine{9651                     \textcolor{keywordflow}{return} InternalParseResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognised token: "{}} + result.value().remainingTokens()-\/>token );}
\DoxyCodeLine{9652             \}}
\DoxyCodeLine{9653             \textcolor{comment}{// !TBD Check missing required options}}
\DoxyCodeLine{9654             \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9655         \}}
\DoxyCodeLine{9656     \};}
\DoxyCodeLine{9657 }
\DoxyCodeLine{9658     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{9659     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9660     \textcolor{keyword}{auto} ComposableParserImpl<DerivedT>::operator|( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser \{}
\DoxyCodeLine{9661         \textcolor{keywordflow}{return} Parser() | \textcolor{keyword}{static\_cast<}DerivedT \textcolor{keyword}{const }\&\textcolor{keyword}{>}( *this ) | other;}
\DoxyCodeLine{9662     \}}
\DoxyCodeLine{9663 \} \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{9664 }
\DoxyCodeLine{9665 \textcolor{comment}{// A Combined parser}}
\DoxyCodeLine{9666 \textcolor{keyword}{using} detail::Parser;}
\DoxyCodeLine{9667 }
\DoxyCodeLine{9668 \textcolor{comment}{// A parser for options}}
\DoxyCodeLine{9669 \textcolor{keyword}{using} detail::Opt;}
\DoxyCodeLine{9670 }
\DoxyCodeLine{9671 \textcolor{comment}{// A parser for arguments}}
\DoxyCodeLine{9672 \textcolor{keyword}{using} detail::Arg;}
\DoxyCodeLine{9673 }
\DoxyCodeLine{9674 \textcolor{comment}{// Wrapper for argc, argv from main()}}
\DoxyCodeLine{9675 \textcolor{keyword}{using} detail::Args;}
\DoxyCodeLine{9676 }
\DoxyCodeLine{9677 \textcolor{comment}{// Specifies the name of the executable}}
\DoxyCodeLine{9678 \textcolor{keyword}{using} detail::ExeName;}
\DoxyCodeLine{9679 }
\DoxyCodeLine{9680 \textcolor{comment}{// Convenience wrapper for option parser that specifies the help option}}
\DoxyCodeLine{9681 \textcolor{keyword}{using} detail::Help;}
\DoxyCodeLine{9682 }
\DoxyCodeLine{9683 \textcolor{comment}{// enum of result types from a parse}}
\DoxyCodeLine{9684 \textcolor{keyword}{using} detail::ParseResultType;}
\DoxyCodeLine{9685 }
\DoxyCodeLine{9686 \textcolor{comment}{// Result type for parser operation}}
\DoxyCodeLine{9687 \textcolor{keyword}{using} detail::ParserResult;}
\DoxyCodeLine{9688 }
\DoxyCodeLine{9689 \}\} \textcolor{comment}{// namespace Catch::clara}}
\DoxyCodeLine{9690 }
\DoxyCodeLine{9691 \textcolor{comment}{// end clara.hpp}}
\DoxyCodeLine{9692 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{9693 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{9694 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9695 }
\DoxyCodeLine{9696 \textcolor{comment}{// Restore Clara's value for console width, if present}}
\DoxyCodeLine{9697 \textcolor{preprocessor}{\#ifdef CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{9698 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{9699 \textcolor{preprocessor}{\#undef CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{9700 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9701 }
\DoxyCodeLine{9702 \textcolor{comment}{// end catch\_clara.h}}
\DoxyCodeLine{9703 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9704 }
\DoxyCodeLine{9705     \mbox{\hyperlink{structclara_1_1detail_1_1_parser}{clara::Parser}} makeCommandLineParser( ConfigData\& config );}
\DoxyCodeLine{9706 }
\DoxyCodeLine{9707 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{9708 }
\DoxyCodeLine{9709 \textcolor{comment}{// end catch\_commandline.h}}
\DoxyCodeLine{9710 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{9711 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{9712 }
\DoxyCodeLine{9713 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9714 }
\DoxyCodeLine{9715     \mbox{\hyperlink{structclara_1_1detail_1_1_parser}{clara::Parser}} makeCommandLineParser( ConfigData\& config ) \{}
\DoxyCodeLine{9716 }
\DoxyCodeLine{9717         \textcolor{keyword}{using namespace }clara;}
\DoxyCodeLine{9718 }
\DoxyCodeLine{9719         \textcolor{keyword}{auto} \textcolor{keyword}{const} setWarning = [\&]( std::string \textcolor{keyword}{const}\& warning ) \{}
\DoxyCodeLine{9720                 \textcolor{keyword}{auto} warningSet = [\&]() \{}
\DoxyCodeLine{9721                     \textcolor{keywordflow}{if}( warning == \textcolor{stringliteral}{"{}NoAssertions"{}} )}
\DoxyCodeLine{9722                         \textcolor{keywordflow}{return} WarnAbout::NoAssertions;}
\DoxyCodeLine{9723 }
\DoxyCodeLine{9724                     \textcolor{keywordflow}{if} ( warning == \textcolor{stringliteral}{"{}NoTests"{}} )}
\DoxyCodeLine{9725                         \textcolor{keywordflow}{return} WarnAbout::NoTests;}
\DoxyCodeLine{9726 }
\DoxyCodeLine{9727                     \textcolor{keywordflow}{return} WarnAbout::Nothing;}
\DoxyCodeLine{9728                 \}();}
\DoxyCodeLine{9729 }
\DoxyCodeLine{9730                 \textcolor{keywordflow}{if} (warningSet == WarnAbout::Nothing)}
\DoxyCodeLine{9731                     \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognised warning: '"{}} + warning + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9732                 config.warnings = \textcolor{keyword}{static\_cast<}WarnAbout::What\textcolor{keyword}{>}( config.warnings | warningSet );}
\DoxyCodeLine{9733                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9734             \};}
\DoxyCodeLine{9735         \textcolor{keyword}{auto} \textcolor{keyword}{const} loadTestNamesFromFile = [\&]( std::string \textcolor{keyword}{const}\& filename ) \{}
\DoxyCodeLine{9736                 std::ifstream f( filename.c\_str() );}
\DoxyCodeLine{9737                 \textcolor{keywordflow}{if}( !f.is\_open() )}
\DoxyCodeLine{9738                     \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unable to load input file: '"{}} + filename + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9739 }
\DoxyCodeLine{9740                 std::string line;}
\DoxyCodeLine{9741                 \textcolor{keywordflow}{while}( std::getline( f, line ) ) \{}
\DoxyCodeLine{9742                     line = trim(line);}
\DoxyCodeLine{9743                     \textcolor{keywordflow}{if}( !line.empty() \&\& !startsWith( line, \textcolor{charliteral}{'\#'} ) ) \{}
\DoxyCodeLine{9744                         \textcolor{keywordflow}{if}( !startsWith( line, \textcolor{charliteral}{'"{}'} ) )}
\DoxyCodeLine{9745                             line = \textcolor{charliteral}{'"{}'} + line + '"{}';}
\DoxyCodeLine{9746                         config.testsOrTags.push\_back( line );}
\DoxyCodeLine{9747                         config.testsOrTags.emplace\_back( \textcolor{stringliteral}{"{},"{}} );}
\DoxyCodeLine{9748                     \}}
\DoxyCodeLine{9749                 \}}
\DoxyCodeLine{9750                 \textcolor{comment}{//Remove comma in the end}}
\DoxyCodeLine{9751                 \textcolor{keywordflow}{if}(!config.testsOrTags.empty())}
\DoxyCodeLine{9752                     config.testsOrTags.erase( config.testsOrTags.end()-\/1 );}
\DoxyCodeLine{9753 }
\DoxyCodeLine{9754                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9755             \};}
\DoxyCodeLine{9756         \textcolor{keyword}{auto} \textcolor{keyword}{const} setTestOrder = [\&]( std::string \textcolor{keyword}{const}\& order ) \{}
\DoxyCodeLine{9757                 \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"{}declared"{}}, order ) )}
\DoxyCodeLine{9758                     config.runOrder = RunTests::InDeclarationOrder;}
\DoxyCodeLine{9759                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"{}lexical"{}}, order ) )}
\DoxyCodeLine{9760                     config.runOrder = RunTests::InLexicographicalOrder;}
\DoxyCodeLine{9761                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"{}random"{}}, order ) )}
\DoxyCodeLine{9762                     config.runOrder = RunTests::InRandomOrder;}
\DoxyCodeLine{9763                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{9764                     \textcolor{keywordflow}{return} clara::ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognised ordering: '"{}} + order + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9765                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9766             \};}
\DoxyCodeLine{9767         \textcolor{keyword}{auto} \textcolor{keyword}{const} setRngSeed = [\&]( std::string \textcolor{keyword}{const}\& seed ) \{}
\DoxyCodeLine{9768                 \textcolor{keywordflow}{if}( seed != \textcolor{stringliteral}{"{}time"{}} )}
\DoxyCodeLine{9769                     \textcolor{keywordflow}{return} clara::detail::convertInto( seed, config.rngSeed );}
\DoxyCodeLine{9770                 config.rngSeed = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}( std::time(\textcolor{keyword}{nullptr}) );}
\DoxyCodeLine{9771                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9772             \};}
\DoxyCodeLine{9773         \textcolor{keyword}{auto} \textcolor{keyword}{const} setColourUsage = [\&]( std::string \textcolor{keyword}{const}\& useColour ) \{}
\DoxyCodeLine{9774                     \textcolor{keyword}{auto} mode = toLower( useColour );}
\DoxyCodeLine{9775 }
\DoxyCodeLine{9776                     \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"{}yes"{}} )}
\DoxyCodeLine{9777                         config.useColour = UseColour::Yes;}
\DoxyCodeLine{9778                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"{}no"{}} )}
\DoxyCodeLine{9779                         config.useColour = UseColour::No;}
\DoxyCodeLine{9780                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"{}auto"{}} )}
\DoxyCodeLine{9781                         config.useColour = UseColour::Auto;}
\DoxyCodeLine{9782                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{9783                         \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}colour mode must be one of: auto, yes or no. '"{}} + useColour + \textcolor{stringliteral}{"{}' not recognised"{}} );}
\DoxyCodeLine{9784                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9785             \};}
\DoxyCodeLine{9786         \textcolor{keyword}{auto} \textcolor{keyword}{const} setWaitForKeypress = [\&]( std::string \textcolor{keyword}{const}\& keypress ) \{}
\DoxyCodeLine{9787                 \textcolor{keyword}{auto} keypressLc = toLower( keypress );}
\DoxyCodeLine{9788                 \textcolor{keywordflow}{if} (keypressLc == \textcolor{stringliteral}{"{}never"{}})}
\DoxyCodeLine{9789                     config.waitForKeypress = WaitForKeypress::Never;}
\DoxyCodeLine{9790                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"{}start"{}} )}
\DoxyCodeLine{9791                     config.waitForKeypress = WaitForKeypress::BeforeStart;}
\DoxyCodeLine{9792                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"{}exit"{}} )}
\DoxyCodeLine{9793                     config.waitForKeypress = WaitForKeypress::BeforeExit;}
\DoxyCodeLine{9794                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"{}both"{}} )}
\DoxyCodeLine{9795                     config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;}
\DoxyCodeLine{9796                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{9797                     \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}keypress argument must be one of: never, start, exit or both. '"{}} + keypress + \textcolor{stringliteral}{"{}' not recognised"{}} );}
\DoxyCodeLine{9798             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9799             \};}
\DoxyCodeLine{9800         \textcolor{keyword}{auto} \textcolor{keyword}{const} setVerbosity = [\&]( std::string \textcolor{keyword}{const}\& verbosity ) \{}
\DoxyCodeLine{9801             \textcolor{keyword}{auto} lcVerbosity = toLower( verbosity );}
\DoxyCodeLine{9802             \textcolor{keywordflow}{if}( lcVerbosity == \textcolor{stringliteral}{"{}quiet"{}} )}
\DoxyCodeLine{9803                 config.verbosity = Verbosity::Quiet;}
\DoxyCodeLine{9804             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( lcVerbosity == \textcolor{stringliteral}{"{}normal"{}} )}
\DoxyCodeLine{9805                 config.verbosity = Verbosity::Normal;}
\DoxyCodeLine{9806             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( lcVerbosity == \textcolor{stringliteral}{"{}high"{}} )}
\DoxyCodeLine{9807                 config.verbosity = Verbosity::High;}
\DoxyCodeLine{9808             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9809                 \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognised verbosity, '"{}} + verbosity + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9810             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9811         \};}
\DoxyCodeLine{9812         \textcolor{keyword}{auto} \textcolor{keyword}{const} setReporter = [\&]( std::string \textcolor{keyword}{const}\& reporter ) \{}
\DoxyCodeLine{9813             IReporterRegistry::FactoryMap \textcolor{keyword}{const}\& factories = getRegistryHub().getReporterRegistry().getFactories();}
\DoxyCodeLine{9814 }
\DoxyCodeLine{9815             \textcolor{keyword}{auto} lcReporter = toLower( reporter );}
\DoxyCodeLine{9816             \textcolor{keyword}{auto} result = factories.find( lcReporter );}
\DoxyCodeLine{9817 }
\DoxyCodeLine{9818             \textcolor{keywordflow}{if}( factories.end() != result )}
\DoxyCodeLine{9819                 config.reporterName = lcReporter;}
\DoxyCodeLine{9820             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9821                 \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognized reporter, '"{}} + reporter + \textcolor{stringliteral}{"{}'. Check available with -\/-\/list-\/reporters"{}} );}
\DoxyCodeLine{9822             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9823         \};}
\DoxyCodeLine{9824 }
\DoxyCodeLine{9825         \textcolor{keyword}{auto} cli}
\DoxyCodeLine{9826             = ExeName( config.processName )}
\DoxyCodeLine{9827             | Help( config.showHelp )}
\DoxyCodeLine{9828             | Opt( config.listTests )}
\DoxyCodeLine{9829                 ["{}-\/l"{}]["{}-\/-\/list-\/tests"{}]}
\DoxyCodeLine{9830                 ( \textcolor{stringliteral}{"{}list all/matching test cases"{}} )}
\DoxyCodeLine{9831             | Opt( config.listTags )}
\DoxyCodeLine{9832                 ["{}-\/t"{}]["{}-\/-\/list-\/tags"{}]}
\DoxyCodeLine{9833                 ( \textcolor{stringliteral}{"{}list all/matching tags"{}} )}
\DoxyCodeLine{9834             | Opt( config.showSuccessfulTests )}
\DoxyCodeLine{9835                 ["{}-\/s"{}]["{}-\/-\/success"{}]}
\DoxyCodeLine{9836                 ( \textcolor{stringliteral}{"{}include successful tests in output"{}} )}
\DoxyCodeLine{9837             | Opt( config.shouldDebugBreak )}
\DoxyCodeLine{9838                 ["{}-\/b"{}]["{}-\/-\/break"{}]}
\DoxyCodeLine{9839                 ( \textcolor{stringliteral}{"{}break into debugger on failure"{}} )}
\DoxyCodeLine{9840             | Opt( config.noThrow )}
\DoxyCodeLine{9841                 ["{}-\/e"{}]["{}-\/-\/nothrow"{}]}
\DoxyCodeLine{9842                 ( \textcolor{stringliteral}{"{}skip exception tests"{}} )}
\DoxyCodeLine{9843             | Opt( config.showInvisibles )}
\DoxyCodeLine{9844                 ["{}-\/i"{}]["{}-\/-\/invisibles"{}]}
\DoxyCodeLine{9845                 ( \textcolor{stringliteral}{"{}show invisibles (tabs, newlines)"{}} )}
\DoxyCodeLine{9846             | Opt( config.outputFilename, \textcolor{stringliteral}{"{}filename"{}} )}
\DoxyCodeLine{9847                 ["{}-\/o"{}]["{}-\/-\/out"{}]}
\DoxyCodeLine{9848                 ( \textcolor{stringliteral}{"{}output filename"{}} )}
\DoxyCodeLine{9849             | Opt( setReporter, \textcolor{stringliteral}{"{}name"{}} )}
\DoxyCodeLine{9850                 ["{}-\/r"{}]["{}-\/-\/reporter"{}]}
\DoxyCodeLine{9851                 ( \textcolor{stringliteral}{"{}reporter to use (defaults to console)"{}} )}
\DoxyCodeLine{9852             | Opt( config.name, \textcolor{stringliteral}{"{}name"{}} )}
\DoxyCodeLine{9853                 ["{}-\/n"{}]["{}-\/-\/name"{}]}
\DoxyCodeLine{9854                 ( \textcolor{stringliteral}{"{}suite name"{}} )}
\DoxyCodeLine{9855             | Opt( [\&]( \textcolor{keywordtype}{bool} )\{ config.abortAfter = 1; \} )}
\DoxyCodeLine{9856                 [\textcolor{stringliteral}{"{}-\/a"{}}][\textcolor{stringliteral}{"{}-\/-\/abort"{}}]}
\DoxyCodeLine{9857                 ( \textcolor{stringliteral}{"{}abort at first failure"{}} )}
\DoxyCodeLine{9858             | Opt( [\&]( \textcolor{keywordtype}{int} x )\{ config.abortAfter = x; \}, \textcolor{stringliteral}{"{}no. failures"{}} )}
\DoxyCodeLine{9859                 [\textcolor{stringliteral}{"{}-\/x"{}}][\textcolor{stringliteral}{"{}-\/-\/abortx"{}}]}
\DoxyCodeLine{9860                 ( \textcolor{stringliteral}{"{}abort after x failures"{}} )}
\DoxyCodeLine{9861             | Opt( setWarning, \textcolor{stringliteral}{"{}warning name"{}} )}
\DoxyCodeLine{9862                 ["{}-\/w"{}]["{}-\/-\/warn"{}]}
\DoxyCodeLine{9863                 ( \textcolor{stringliteral}{"{}enable warnings"{}} )}
\DoxyCodeLine{9864             | Opt( [\&]( \textcolor{keywordtype}{bool} flag ) \{ config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; \}, \textcolor{stringliteral}{"{}yes|no"{}} )}
\DoxyCodeLine{9865                 [\textcolor{stringliteral}{"{}-\/d"{}}][\textcolor{stringliteral}{"{}-\/-\/durations"{}}]}
\DoxyCodeLine{9866                 ( \textcolor{stringliteral}{"{}show test durations"{}} )}
\DoxyCodeLine{9867             | Opt( config.minDuration, \textcolor{stringliteral}{"{}seconds"{}} )}
\DoxyCodeLine{9868                 ["{}-\/D"{}]["{}-\/-\/min-\/duration"{}]}
\DoxyCodeLine{9869                 ( \textcolor{stringliteral}{"{}show test durations for tests taking at least the given number of seconds"{}} )}
\DoxyCodeLine{9870             | Opt( loadTestNamesFromFile, \textcolor{stringliteral}{"{}filename"{}} )}
\DoxyCodeLine{9871                 ["{}-\/f"{}]["{}-\/-\/input-\/file"{}]}
\DoxyCodeLine{9872                 ( \textcolor{stringliteral}{"{}load test names to run from a file"{}} )}
\DoxyCodeLine{9873             | Opt( config.filenamesAsTags )}
\DoxyCodeLine{9874                 ["{}-\/\#"{}]["{}-\/-\/filenames-\/as-\/tags"{}]}
\DoxyCodeLine{9875                 ( \textcolor{stringliteral}{"{}adds a tag for the filename"{}} )}
\DoxyCodeLine{9876             | Opt( config.sectionsToRun, \textcolor{stringliteral}{"{}section name"{}} )}
\DoxyCodeLine{9877                 ["{}-\/c"{}]["{}-\/-\/section"{}]}
\DoxyCodeLine{9878                 ( \textcolor{stringliteral}{"{}specify section to run"{}} )}
\DoxyCodeLine{9879             | Opt( setVerbosity, \textcolor{stringliteral}{"{}quiet|normal|high"{}} )}
\DoxyCodeLine{9880                 ["{}-\/v"{}]["{}-\/-\/verbosity"{}]}
\DoxyCodeLine{9881                 ( \textcolor{stringliteral}{"{}set output verbosity"{}} )}
\DoxyCodeLine{9882             | Opt( config.listTestNamesOnly )}
\DoxyCodeLine{9883                 ["{}-\/-\/list-\/test-\/names-\/only"{}]}
\DoxyCodeLine{9884                 ( \textcolor{stringliteral}{"{}list all/matching test cases names only"{}} )}
\DoxyCodeLine{9885             | Opt( config.listReporters )}
\DoxyCodeLine{9886                 ["{}-\/-\/list-\/reporters"{}]}
\DoxyCodeLine{9887                 ( \textcolor{stringliteral}{"{}list all reporters"{}} )}
\DoxyCodeLine{9888             | Opt( setTestOrder, \textcolor{stringliteral}{"{}decl|lex|rand"{}} )}
\DoxyCodeLine{9889                 ["{}-\/-\/order"{}]}
\DoxyCodeLine{9890                 ( \textcolor{stringliteral}{"{}test case order (defaults to decl)"{}} )}
\DoxyCodeLine{9891             | Opt( setRngSeed, \textcolor{stringliteral}{"{}'time'|number"{}} )}
\DoxyCodeLine{9892                 ["{}-\/-\/rng-\/seed"{}]}
\DoxyCodeLine{9893                 ( \textcolor{stringliteral}{"{}set a specific seed for random numbers"{}} )}
\DoxyCodeLine{9894             | Opt( setColourUsage, \textcolor{stringliteral}{"{}yes|no"{}} )}
\DoxyCodeLine{9895                 ["{}-\/-\/use-\/colour"{}]}
\DoxyCodeLine{9896                 ( \textcolor{stringliteral}{"{}should output be colourised"{}} )}
\DoxyCodeLine{9897             | Opt( config.libIdentify )}
\DoxyCodeLine{9898                 ["{}-\/-\/libidentify"{}]}
\DoxyCodeLine{9899                 ( \textcolor{stringliteral}{"{}report name and version according to libidentify standard"{}} )}
\DoxyCodeLine{9900             | Opt( setWaitForKeypress, \textcolor{stringliteral}{"{}never|start|exit|both"{}} )}
\DoxyCodeLine{9901                 ["{}-\/-\/wait-\/for-\/keypress"{}]}
\DoxyCodeLine{9902                 ( \textcolor{stringliteral}{"{}waits for a keypress before exiting"{}} )}
\DoxyCodeLine{9903             | Opt( config.benchmarkSamples, \textcolor{stringliteral}{"{}samples"{}} )}
\DoxyCodeLine{9904                 ["{}-\/-\/benchmark-\/samples"{}]}
\DoxyCodeLine{9905                 ( \textcolor{stringliteral}{"{}number of samples to collect (default: 100)"{}} )}
\DoxyCodeLine{9906             | Opt( config.benchmarkResamples, \textcolor{stringliteral}{"{}resamples"{}} )}
\DoxyCodeLine{9907                 ["{}-\/-\/benchmark-\/resamples"{}]}
\DoxyCodeLine{9908                 ( \textcolor{stringliteral}{"{}number of resamples for the bootstrap (default: 100000)"{}} )}
\DoxyCodeLine{9909             | Opt( config.benchmarkConfidenceInterval, \textcolor{stringliteral}{"{}confidence interval"{}} )}
\DoxyCodeLine{9910                 ["{}-\/-\/benchmark-\/confidence-\/interval"{}]}
\DoxyCodeLine{9911                 ( \textcolor{stringliteral}{"{}confidence interval for the bootstrap (between 0 and 1, default: 0.95)"{}} )}
\DoxyCodeLine{9912             | Opt( config.benchmarkNoAnalysis )}
\DoxyCodeLine{9913                 ["{}-\/-\/benchmark-\/no-\/analysis"{}]}
\DoxyCodeLine{9914                 ( \textcolor{stringliteral}{"{}perform only measurements; do not perform any analysis"{}} )}
\DoxyCodeLine{9915             | Opt( config.benchmarkWarmupTime, \textcolor{stringliteral}{"{}benchmarkWarmupTime"{}} )}
\DoxyCodeLine{9916                 ["{}-\/-\/benchmark-\/warmup-\/time"{}]}
\DoxyCodeLine{9917                 ( \textcolor{stringliteral}{"{}amount of time in milliseconds spent on warming up each test (default: 100)"{}} )}
\DoxyCodeLine{9918             | Arg( config.testsOrTags, \textcolor{stringliteral}{"{}test name|pattern|tags"{}} )}
\DoxyCodeLine{9919                 ( \textcolor{stringliteral}{"{}which test or tests to use"{}} );}
\DoxyCodeLine{9920 }
\DoxyCodeLine{9921         \textcolor{keywordflow}{return} cli;}
\DoxyCodeLine{9922     \}}
\DoxyCodeLine{9923 }
\DoxyCodeLine{9924 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{9925 \textcolor{comment}{// end catch\_commandline.cpp}}
\DoxyCodeLine{9926 \textcolor{comment}{// start catch\_common.cpp}}
\DoxyCodeLine{9927 }
\DoxyCodeLine{9928 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{9929 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{9930 }
\DoxyCodeLine{9931 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9932 }
\DoxyCodeLine{9933     \textcolor{keywordtype}{bool} SourceLineInfo::operator == ( SourceLineInfo \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{9934         \textcolor{keywordflow}{return} line == other.line \&\& (\mbox{\hyperlink{classfile}{file}} == other.file || std::strcmp(\mbox{\hyperlink{classfile}{file}}, other.file) == 0);}
\DoxyCodeLine{9935     \}}
\DoxyCodeLine{9936     \textcolor{keywordtype}{bool} SourceLineInfo::operator < ( SourceLineInfo \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{9937         \textcolor{comment}{// We can assume that the same file will usually have the same pointer.}}
\DoxyCodeLine{9938         \textcolor{comment}{// Thus, if the pointers are the same, there is no point in calling the strcmp}}
\DoxyCodeLine{9939         \textcolor{keywordflow}{return} line < other.line || ( line == other.line \&\& \mbox{\hyperlink{classfile}{file}} != other.file \&\& (std::strcmp(\mbox{\hyperlink{classfile}{file}}, other.file) < 0));}
\DoxyCodeLine{9940     \}}
\DoxyCodeLine{9941 }
\DoxyCodeLine{9942     std::ostream\& operator << ( std::ostream\& os, SourceLineInfo \textcolor{keyword}{const}\& info ) \{}
\DoxyCodeLine{9943 \textcolor{preprocessor}{\#ifndef \_\_GNUG\_\_}}
\DoxyCodeLine{9944         os << info.file << \textcolor{charliteral}{'('} << info.line << \textcolor{charliteral}{')'};}
\DoxyCodeLine{9945 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{9946         os << info.file << \textcolor{charliteral}{':'} << info.line;}
\DoxyCodeLine{9947 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9948         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{9949     \}}
\DoxyCodeLine{9950 }
\DoxyCodeLine{9951     std::string StreamEndStop::operator+()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9952         \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{9953     \}}
\DoxyCodeLine{9954 }
\DoxyCodeLine{9955     NonCopyable::NonCopyable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9956     NonCopyable::\string~NonCopyable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9957 }
\DoxyCodeLine{9958 \}}
\DoxyCodeLine{9959 \textcolor{comment}{// end catch\_common.cpp}}
\DoxyCodeLine{9960 \textcolor{comment}{// start catch\_config.cpp}}
\DoxyCodeLine{9961 }
\DoxyCodeLine{9962 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9963 }
\DoxyCodeLine{9964     Config::Config( ConfigData \textcolor{keyword}{const}\& data )}
\DoxyCodeLine{9965     :   m\_data( data ),}
\DoxyCodeLine{9966         m\_stream( openStream() )}
\DoxyCodeLine{9967     \{}
\DoxyCodeLine{9968         \textcolor{comment}{// We need to trim filter specs to avoid trouble with superfluous}}
\DoxyCodeLine{9969         \textcolor{comment}{// whitespace (esp. important for bdd macros, as those are manually}}
\DoxyCodeLine{9970         \textcolor{comment}{// aligned with whitespace).}}
\DoxyCodeLine{9971 }
\DoxyCodeLine{9972         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& elem : m\_data.testsOrTags) \{}
\DoxyCodeLine{9973             elem = trim(elem);}
\DoxyCodeLine{9974         \}}
\DoxyCodeLine{9975         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& elem : m\_data.sectionsToRun) \{}
\DoxyCodeLine{9976             elem = trim(elem);}
\DoxyCodeLine{9977         \}}
\DoxyCodeLine{9978 }
\DoxyCodeLine{9979         TestSpecParser parser(ITagAliasRegistry::get());}
\DoxyCodeLine{9980         \textcolor{keywordflow}{if} (!m\_data.testsOrTags.empty()) \{}
\DoxyCodeLine{9981             m\_hasTestFilters = \textcolor{keyword}{true};}
\DoxyCodeLine{9982             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& testOrTags : m\_data.testsOrTags) \{}
\DoxyCodeLine{9983                 parser.parse(testOrTags);}
\DoxyCodeLine{9984             \}}
\DoxyCodeLine{9985         \}}
\DoxyCodeLine{9986         m\_testSpec = parser.testSpec();}
\DoxyCodeLine{9987     \}}
\DoxyCodeLine{9988 }
\DoxyCodeLine{9989     std::string \textcolor{keyword}{const}\& Config::getFilename()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9990         \textcolor{keywordflow}{return} m\_data.outputFilename ;}
\DoxyCodeLine{9991     \}}
\DoxyCodeLine{9992 }
\DoxyCodeLine{9993     \textcolor{keywordtype}{bool} Config::listTests()\textcolor{keyword}{ const          }\{ \textcolor{keywordflow}{return} m\_data.listTests; \}}
\DoxyCodeLine{9994     \textcolor{keywordtype}{bool} Config::listTestNamesOnly()\textcolor{keyword}{ const  }\{ \textcolor{keywordflow}{return} m\_data.listTestNamesOnly; \}}
\DoxyCodeLine{9995     \textcolor{keywordtype}{bool} Config::listTags()\textcolor{keyword}{ const           }\{ \textcolor{keywordflow}{return} m\_data.listTags; \}}
\DoxyCodeLine{9996     \textcolor{keywordtype}{bool} Config::listReporters()\textcolor{keyword}{ const      }\{ \textcolor{keywordflow}{return} m\_data.listReporters; \}}
\DoxyCodeLine{9997 }
\DoxyCodeLine{9998     std::string Config::getProcessName()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.processName; \}}
\DoxyCodeLine{9999     std::string \textcolor{keyword}{const}\& Config::getReporterName()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.reporterName; \}}
\DoxyCodeLine{10000 }
\DoxyCodeLine{10001     std::vector<std::string> \textcolor{keyword}{const}\& Config::getTestsOrTags()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.testsOrTags; \}}
\DoxyCodeLine{10002     std::vector<std::string> \textcolor{keyword}{const}\& Config::getSectionsToRun()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.sectionsToRun; \}}
\DoxyCodeLine{10003 }
\DoxyCodeLine{10004     TestSpec \textcolor{keyword}{const}\& Config::testSpec()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_testSpec; \}}
\DoxyCodeLine{10005     \textcolor{keywordtype}{bool} Config::hasTestFilters()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_hasTestFilters; \}}
\DoxyCodeLine{10006 }
\DoxyCodeLine{10007     \textcolor{keywordtype}{bool} Config::showHelp()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.showHelp; \}}
\DoxyCodeLine{10008 }
\DoxyCodeLine{10009     \textcolor{comment}{// IConfig interface}}
\DoxyCodeLine{10010     \textcolor{keywordtype}{bool} Config::allowThrows()\textcolor{keyword}{ const                   }\{ \textcolor{keywordflow}{return} !m\_data.noThrow; \}}
\DoxyCodeLine{10011     std::ostream\& Config::stream()\textcolor{keyword}{ const               }\{ \textcolor{keywordflow}{return} m\_stream-\/>stream(); \}}
\DoxyCodeLine{10012     std::string Config::name()\textcolor{keyword}{ const                   }\{ \textcolor{keywordflow}{return} m\_data.name.empty() ? m\_data.processName : m\_data.name; \}}
\DoxyCodeLine{10013     \textcolor{keywordtype}{bool} Config::includeSuccessfulResults()\textcolor{keyword}{ const      }\{ \textcolor{keywordflow}{return} m\_data.showSuccessfulTests; \}}
\DoxyCodeLine{10014     \textcolor{keywordtype}{bool} Config::warnAboutMissingAssertions()\textcolor{keyword}{ const    }\{ \textcolor{keywordflow}{return} !!(m\_data.warnings \& WarnAbout::NoAssertions); \}}
\DoxyCodeLine{10015     \textcolor{keywordtype}{bool} Config::warnAboutNoTests()\textcolor{keyword}{ const              }\{ \textcolor{keywordflow}{return} !!(m\_data.warnings \& WarnAbout::NoTests); \}}
\DoxyCodeLine{10016     ShowDurations::OrNot Config::showDurations()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.showDurations; \}}
\DoxyCodeLine{10017     \textcolor{keywordtype}{double} Config::minDuration()\textcolor{keyword}{ const                 }\{ \textcolor{keywordflow}{return} m\_data.minDuration; \}}
\DoxyCodeLine{10018     RunTests::InWhatOrder Config::runOrder()\textcolor{keyword}{ const     }\{ \textcolor{keywordflow}{return} m\_data.runOrder; \}}
\DoxyCodeLine{10019     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Config::rngSeed()\textcolor{keyword}{ const               }\{ \textcolor{keywordflow}{return} m\_data.rngSeed; \}}
\DoxyCodeLine{10020     UseColour::YesOrNo Config::useColour()\textcolor{keyword}{ const       }\{ \textcolor{keywordflow}{return} m\_data.useColour; \}}
\DoxyCodeLine{10021     \textcolor{keywordtype}{bool} Config::shouldDebugBreak()\textcolor{keyword}{ const              }\{ \textcolor{keywordflow}{return} m\_data.shouldDebugBreak; \}}
\DoxyCodeLine{10022     \textcolor{keywordtype}{int} Config::abortAfter()\textcolor{keyword}{ const                     }\{ \textcolor{keywordflow}{return} m\_data.abortAfter; \}}
\DoxyCodeLine{10023     \textcolor{keywordtype}{bool} Config::showInvisibles()\textcolor{keyword}{ const                }\{ \textcolor{keywordflow}{return} m\_data.showInvisibles; \}}
\DoxyCodeLine{10024     Verbosity Config::verbosity()\textcolor{keyword}{ const                }\{ \textcolor{keywordflow}{return} m\_data.verbosity; \}}
\DoxyCodeLine{10025 }
\DoxyCodeLine{10026     \textcolor{keywordtype}{bool} Config::benchmarkNoAnalysis()\textcolor{keyword}{ const                      }\{ \textcolor{keywordflow}{return} m\_data.benchmarkNoAnalysis; \}}
\DoxyCodeLine{10027     \textcolor{keywordtype}{int} Config::benchmarkSamples()\textcolor{keyword}{ const                          }\{ \textcolor{keywordflow}{return} m\_data.benchmarkSamples; \}}
\DoxyCodeLine{10028     \textcolor{keywordtype}{double} Config::benchmarkConfidenceInterval()\textcolor{keyword}{ const            }\{ \textcolor{keywordflow}{return} m\_data.benchmarkConfidenceInterval; \}}
\DoxyCodeLine{10029     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Config::benchmarkResamples()\textcolor{keyword}{ const               }\{ \textcolor{keywordflow}{return} m\_data.benchmarkResamples; \}}
\DoxyCodeLine{10030     std::chrono::milliseconds Config::benchmarkWarmupTime()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} std::chrono::milliseconds(m\_data.benchmarkWarmupTime); \}}
\DoxyCodeLine{10031 }
\DoxyCodeLine{10032     IStream \textcolor{keyword}{const}* Config::openStream() \{}
\DoxyCodeLine{10033         \textcolor{keywordflow}{return} Catch::makeStream(m\_data.outputFilename);}
\DoxyCodeLine{10034     \}}
\DoxyCodeLine{10035 }
\DoxyCodeLine{10036 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10037 \textcolor{comment}{// end catch\_config.cpp}}
\DoxyCodeLine{10038 \textcolor{comment}{// start catch\_console\_colour.cpp}}
\DoxyCodeLine{10039 }
\DoxyCodeLine{10040 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{10041 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{10042 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wexit-\/time-\/destructors"{}}}
\DoxyCodeLine{10043 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10044 }
\DoxyCodeLine{10045 \textcolor{comment}{// start catch\_errno\_guard.h}}
\DoxyCodeLine{10046 }
\DoxyCodeLine{10047 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10048 }
\DoxyCodeLine{10049     \textcolor{keyword}{class }ErrnoGuard \{}
\DoxyCodeLine{10050     \textcolor{keyword}{public}:}
\DoxyCodeLine{10051         ErrnoGuard();}
\DoxyCodeLine{10052         \string~ErrnoGuard();}
\DoxyCodeLine{10053     \textcolor{keyword}{private}:}
\DoxyCodeLine{10054         \textcolor{keywordtype}{int} m\_oldErrno;}
\DoxyCodeLine{10055     \};}
\DoxyCodeLine{10056 }
\DoxyCodeLine{10057 \}}
\DoxyCodeLine{10058 }
\DoxyCodeLine{10059 \textcolor{comment}{// end catch\_errno\_guard.h}}
\DoxyCodeLine{10060 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{10061 }
\DoxyCodeLine{10062 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10063     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10064 }
\DoxyCodeLine{10065         \textcolor{keyword}{struct }IColourImpl \{}
\DoxyCodeLine{10066             \textcolor{keyword}{virtual} \string~IColourImpl() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10067             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} use( Colour::Code \_colourCode ) = 0;}
\DoxyCodeLine{10068         \};}
\DoxyCodeLine{10069 }
\DoxyCodeLine{10070         \textcolor{keyword}{struct }NoColourImpl : IColourImpl \{}
\DoxyCodeLine{10071             \textcolor{keywordtype}{void} use( Colour::Code )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{10072 }
\DoxyCodeLine{10073             \textcolor{keyword}{static} IColourImpl* instance() \{}
\DoxyCodeLine{10074                 \textcolor{keyword}{static} NoColourImpl s\_instance;}
\DoxyCodeLine{10075                 \textcolor{keywordflow}{return} \&s\_instance;}
\DoxyCodeLine{10076             \}}
\DoxyCodeLine{10077         \};}
\DoxyCodeLine{10078 }
\DoxyCodeLine{10079     \} \textcolor{comment}{// anon namespace}}
\DoxyCodeLine{10080 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10081 }
\DoxyCodeLine{10082 \textcolor{preprocessor}{\#if !defined( CATCH\_CONFIG\_COLOUR\_NONE ) \&\& !defined( CATCH\_CONFIG\_COLOUR\_WINDOWS ) \&\& !defined( CATCH\_CONFIG\_COLOUR\_ANSI )}}
\DoxyCodeLine{10083 \textcolor{preprocessor}{\#   ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{10084 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_WINDOWS}}
\DoxyCodeLine{10085 \textcolor{preprocessor}{\#   else}}
\DoxyCodeLine{10086 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_ANSI}}
\DoxyCodeLine{10087 \textcolor{preprocessor}{\#   endif}}
\DoxyCodeLine{10088 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10089 }
\DoxyCodeLine{10090 \textcolor{preprocessor}{\#if defined ( CATCH\_CONFIG\_COLOUR\_WINDOWS ) }}
\DoxyCodeLine{10091 }
\DoxyCodeLine{10092 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10093 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10094 }
\DoxyCodeLine{10095     \textcolor{keyword}{class }Win32ColourImpl : \textcolor{keyword}{public} IColourImpl \{}
\DoxyCodeLine{10096     \textcolor{keyword}{public}:}
\DoxyCodeLine{10097         Win32ColourImpl() : stdoutHandle( GetStdHandle(STD\_OUTPUT\_HANDLE) )}
\DoxyCodeLine{10098         \{}
\DoxyCodeLine{10099             CONSOLE\_SCREEN\_BUFFER\_INFO csbiInfo;}
\DoxyCodeLine{10100             GetConsoleScreenBufferInfo( stdoutHandle, \&csbiInfo );}
\DoxyCodeLine{10101             originalForegroundAttributes = csbiInfo.wAttributes \& \string~( BACKGROUND\_GREEN | BACKGROUND\_RED | BACKGROUND\_BLUE | BACKGROUND\_INTENSITY );}
\DoxyCodeLine{10102             originalBackgroundAttributes = csbiInfo.wAttributes \& \string~( FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE | FOREGROUND\_INTENSITY );}
\DoxyCodeLine{10103         \}}
\DoxyCodeLine{10104 }
\DoxyCodeLine{10105         \textcolor{keywordtype}{void} use( Colour::Code \_colourCode )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10106             \textcolor{keywordflow}{switch}( \_colourCode ) \{}
\DoxyCodeLine{10107                 \textcolor{keywordflow}{case} Colour::None:      \textcolor{keywordflow}{return} setTextAttribute( originalForegroundAttributes );}
\DoxyCodeLine{10108                 \textcolor{keywordflow}{case} Colour::White:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE );}
\DoxyCodeLine{10109                 \textcolor{keywordflow}{case} Colour::Red:       \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_RED );}
\DoxyCodeLine{10110                 \textcolor{keywordflow}{case} Colour::Green:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_GREEN );}
\DoxyCodeLine{10111                 \textcolor{keywordflow}{case} Colour::Blue:      \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_BLUE );}
\DoxyCodeLine{10112                 \textcolor{keywordflow}{case} Colour::Cyan:      \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_BLUE | FOREGROUND\_GREEN );}
\DoxyCodeLine{10113                 \textcolor{keywordflow}{case} Colour::Yellow:    \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_RED | FOREGROUND\_GREEN );}
\DoxyCodeLine{10114                 \textcolor{keywordflow}{case} Colour::Grey:      \textcolor{keywordflow}{return} setTextAttribute( 0 );}
\DoxyCodeLine{10115 }
\DoxyCodeLine{10116                 \textcolor{keywordflow}{case} Colour::LightGrey:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY );}
\DoxyCodeLine{10117                 \textcolor{keywordflow}{case} Colour::BrightRed:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_RED );}
\DoxyCodeLine{10118                 \textcolor{keywordflow}{case} Colour::BrightGreen:   \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_GREEN );}
\DoxyCodeLine{10119                 \textcolor{keywordflow}{case} Colour::BrightWhite:   \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE );}
\DoxyCodeLine{10120                 \textcolor{keywordflow}{case} Colour::BrightYellow:  \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_RED | FOREGROUND\_GREEN );}
\DoxyCodeLine{10121 }
\DoxyCodeLine{10122                 \textcolor{keywordflow}{case} Colour::Bright: CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}not a colour"{}} );}
\DoxyCodeLine{10123 }
\DoxyCodeLine{10124                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{10125                     CATCH\_ERROR( \textcolor{stringliteral}{"{}Unknown colour requested"{}} );}
\DoxyCodeLine{10126             \}}
\DoxyCodeLine{10127         \}}
\DoxyCodeLine{10128 }
\DoxyCodeLine{10129     \textcolor{keyword}{private}:}
\DoxyCodeLine{10130         \textcolor{keywordtype}{void} setTextAttribute( WORD \_textAttribute ) \{}
\DoxyCodeLine{10131             SetConsoleTextAttribute( stdoutHandle, \_textAttribute | originalBackgroundAttributes );}
\DoxyCodeLine{10132         \}}
\DoxyCodeLine{10133         HANDLE stdoutHandle;}
\DoxyCodeLine{10134         WORD originalForegroundAttributes;}
\DoxyCodeLine{10135         WORD originalBackgroundAttributes;}
\DoxyCodeLine{10136     \};}
\DoxyCodeLine{10137 }
\DoxyCodeLine{10138     IColourImpl* platformColourInstance() \{}
\DoxyCodeLine{10139         \textcolor{keyword}{static} Win32ColourImpl s\_instance;}
\DoxyCodeLine{10140 }
\DoxyCodeLine{10141         IConfigPtr config = getCurrentContext().getConfig();}
\DoxyCodeLine{10142         UseColour::YesOrNo colourMode = config}
\DoxyCodeLine{10143             ? config-\/>useColour()}
\DoxyCodeLine{10144             : UseColour::Auto;}
\DoxyCodeLine{10145         \textcolor{keywordflow}{if}( colourMode == UseColour::Auto )}
\DoxyCodeLine{10146             colourMode = UseColour::Yes;}
\DoxyCodeLine{10147         \textcolor{keywordflow}{return} colourMode == UseColour::Yes}
\DoxyCodeLine{10148             ? \&s\_instance}
\DoxyCodeLine{10149             : NoColourImpl::instance();}
\DoxyCodeLine{10150     \}}
\DoxyCodeLine{10151 }
\DoxyCodeLine{10152 \} \textcolor{comment}{// end anon namespace}}
\DoxyCodeLine{10153 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10154 }
\DoxyCodeLine{10155 \textcolor{preprocessor}{\#elif defined( CATCH\_CONFIG\_COLOUR\_ANSI ) }}
\DoxyCodeLine{10156 }
\DoxyCodeLine{10157 \textcolor{preprocessor}{\#include <unistd.h>}}
\DoxyCodeLine{10158 }
\DoxyCodeLine{10159 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10160 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10161 }
\DoxyCodeLine{10162     \textcolor{comment}{// use POSIX/ ANSI console terminal codes}}
\DoxyCodeLine{10163     \textcolor{comment}{// Thanks to Adam Strzelecki for original contribution}}
\DoxyCodeLine{10164     \textcolor{comment}{// (http://github.com/nanoant)}}
\DoxyCodeLine{10165     \textcolor{comment}{// https://github.com/philsquared/Catch/pull/131}}
\DoxyCodeLine{10166     \textcolor{keyword}{class }PosixColourImpl : \textcolor{keyword}{public} IColourImpl \{}
\DoxyCodeLine{10167     \textcolor{keyword}{public}:}
\DoxyCodeLine{10168         \textcolor{keywordtype}{void} use( Colour::Code \_colourCode )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10169             \textcolor{keywordflow}{switch}( \_colourCode ) \{}
\DoxyCodeLine{10170                 \textcolor{keywordflow}{case} Colour::None:}
\DoxyCodeLine{10171                 \textcolor{keywordflow}{case} Colour::White:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0m"{}} );}
\DoxyCodeLine{10172                 \textcolor{keywordflow}{case} Colour::Red:       \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;31m"{}} );}
\DoxyCodeLine{10173                 \textcolor{keywordflow}{case} Colour::Green:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;32m"{}} );}
\DoxyCodeLine{10174                 \textcolor{keywordflow}{case} Colour::Blue:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;34m"{}} );}
\DoxyCodeLine{10175                 \textcolor{keywordflow}{case} Colour::Cyan:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;36m"{}} );}
\DoxyCodeLine{10176                 \textcolor{keywordflow}{case} Colour::Yellow:    \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;33m"{}} );}
\DoxyCodeLine{10177                 \textcolor{keywordflow}{case} Colour::Grey:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;30m"{}} );}
\DoxyCodeLine{10178 }
\DoxyCodeLine{10179                 \textcolor{keywordflow}{case} Colour::LightGrey:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;37m"{}} );}
\DoxyCodeLine{10180                 \textcolor{keywordflow}{case} Colour::BrightRed:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;31m"{}} );}
\DoxyCodeLine{10181                 \textcolor{keywordflow}{case} Colour::BrightGreen:   \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;32m"{}} );}
\DoxyCodeLine{10182                 \textcolor{keywordflow}{case} Colour::BrightWhite:   \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;37m"{}} );}
\DoxyCodeLine{10183                 \textcolor{keywordflow}{case} Colour::BrightYellow:  \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;33m"{}} );}
\DoxyCodeLine{10184 }
\DoxyCodeLine{10185                 \textcolor{keywordflow}{case} Colour::Bright: CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}not a colour"{}} );}
\DoxyCodeLine{10186                 \textcolor{keywordflow}{default}: CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Unknown colour requested"{}} );}
\DoxyCodeLine{10187             \}}
\DoxyCodeLine{10188         \}}
\DoxyCodeLine{10189         \textcolor{keyword}{static} IColourImpl* instance() \{}
\DoxyCodeLine{10190             \textcolor{keyword}{static} PosixColourImpl s\_instance;}
\DoxyCodeLine{10191             \textcolor{keywordflow}{return} \&s\_instance;}
\DoxyCodeLine{10192         \}}
\DoxyCodeLine{10193 }
\DoxyCodeLine{10194     \textcolor{keyword}{private}:}
\DoxyCodeLine{10195         \textcolor{keywordtype}{void} setColour( \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \_escapeCode ) \{}
\DoxyCodeLine{10196             getCurrentContext().getConfig()-\/>stream()}
\DoxyCodeLine{10197                 << \textcolor{charliteral}{'\(\backslash\)033'} << \_escapeCode;}
\DoxyCodeLine{10198         \}}
\DoxyCodeLine{10199     \};}
\DoxyCodeLine{10200 }
\DoxyCodeLine{10201     \textcolor{keywordtype}{bool} useColourOnPlatform() \{}
\DoxyCodeLine{10202         \textcolor{keywordflow}{return}}
\DoxyCodeLine{10203 \textcolor{preprocessor}{\#if defined(CATCH\_PLATFORM\_MAC) || defined(CATCH\_PLATFORM\_IPHONE)}}
\DoxyCodeLine{10204             !isDebuggerActive() \&\&}
\DoxyCodeLine{10205 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10206 \textcolor{preprocessor}{\#if !(defined(\_\_DJGPP\_\_) \&\& defined(\_\_STRICT\_ANSI\_\_))}}
\DoxyCodeLine{10207             isatty(STDOUT\_FILENO)}
\DoxyCodeLine{10208 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10209             \textcolor{keyword}{false}}
\DoxyCodeLine{10210 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10211             ;}
\DoxyCodeLine{10212     \}}
\DoxyCodeLine{10213     IColourImpl* platformColourInstance() \{}
\DoxyCodeLine{10214         ErrnoGuard guard;}
\DoxyCodeLine{10215         IConfigPtr config = getCurrentContext().getConfig();}
\DoxyCodeLine{10216         UseColour::YesOrNo colourMode = config}
\DoxyCodeLine{10217             ? config-\/>useColour()}
\DoxyCodeLine{10218             : UseColour::Auto;}
\DoxyCodeLine{10219         \textcolor{keywordflow}{if}( colourMode == UseColour::Auto )}
\DoxyCodeLine{10220             colourMode = useColourOnPlatform()}
\DoxyCodeLine{10221                 ? UseColour::Yes}
\DoxyCodeLine{10222                 : UseColour::No;}
\DoxyCodeLine{10223         \textcolor{keywordflow}{return} colourMode == UseColour::Yes}
\DoxyCodeLine{10224             ? PosixColourImpl::instance()}
\DoxyCodeLine{10225             : NoColourImpl::instance();}
\DoxyCodeLine{10226     \}}
\DoxyCodeLine{10227 }
\DoxyCodeLine{10228 \} \textcolor{comment}{// end anon namespace}}
\DoxyCodeLine{10229 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10230 }
\DoxyCodeLine{10231 \textcolor{preprocessor}{\#else  }\textcolor{comment}{// not Windows or ANSI ///////////////////////////////////////////////}}
\DoxyCodeLine{10232 }
\DoxyCodeLine{10233 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10234 }
\DoxyCodeLine{10235     \textcolor{keyword}{static} IColourImpl* platformColourInstance() \{ \textcolor{keywordflow}{return} NoColourImpl::instance(); \}}
\DoxyCodeLine{10236 }
\DoxyCodeLine{10237 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10238 }
\DoxyCodeLine{10239 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// Windows/ ANSI/ None}}
\DoxyCodeLine{10240 }
\DoxyCodeLine{10241 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10242 }
\DoxyCodeLine{10243     Colour::Colour( Code \_colourCode ) \{ use( \_colourCode ); \}}
\DoxyCodeLine{10244     Colour::Colour( Colour\&\& other ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{10245         m\_moved = other.m\_moved;}
\DoxyCodeLine{10246         other.m\_moved = \textcolor{keyword}{true};}
\DoxyCodeLine{10247     \}}
\DoxyCodeLine{10248     Colour\& Colour::operator=( Colour\&\& other ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{10249         m\_moved = other.m\_moved;}
\DoxyCodeLine{10250         other.m\_moved  = \textcolor{keyword}{true};}
\DoxyCodeLine{10251         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{10252     \}}
\DoxyCodeLine{10253 }
\DoxyCodeLine{10254     Colour::\string~Colour()\{ \textcolor{keywordflow}{if}( !m\_moved ) use( None ); \}}
\DoxyCodeLine{10255 }
\DoxyCodeLine{10256     \textcolor{keywordtype}{void} Colour::use( Code \_colourCode ) \{}
\DoxyCodeLine{10257         \textcolor{keyword}{static} IColourImpl* impl = platformColourInstance();}
\DoxyCodeLine{10258         \textcolor{comment}{// Strictly speaking, this cannot possibly happen.}}
\DoxyCodeLine{10259         \textcolor{comment}{// However, under some conditions it does happen (see \#1626),}}
\DoxyCodeLine{10260         \textcolor{comment}{// and this change is small enough that we can let practicality}}
\DoxyCodeLine{10261         \textcolor{comment}{// triumph over purity in this case.}}
\DoxyCodeLine{10262         \textcolor{keywordflow}{if} (impl != \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{10263             impl-\/>use( \_colourCode );}
\DoxyCodeLine{10264         \}}
\DoxyCodeLine{10265     \}}
\DoxyCodeLine{10266 }
\DoxyCodeLine{10267     std::ostream\& operator << ( std::ostream\& os, Colour \textcolor{keyword}{const}\& ) \{}
\DoxyCodeLine{10268         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{10269     \}}
\DoxyCodeLine{10270 }
\DoxyCodeLine{10271 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10272 }
\DoxyCodeLine{10273 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{10274 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{10275 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10276 }
\DoxyCodeLine{10277 \textcolor{comment}{// end catch\_console\_colour.cpp}}
\DoxyCodeLine{10278 \textcolor{comment}{// start catch\_context.cpp}}
\DoxyCodeLine{10279 }
\DoxyCodeLine{10280 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10281 }
\DoxyCodeLine{10282     \textcolor{keyword}{class }Context : \textcolor{keyword}{public} IMutableContext, NonCopyable \{}
\DoxyCodeLine{10283 }
\DoxyCodeLine{10284     \textcolor{keyword}{public}: \textcolor{comment}{// IContext}}
\DoxyCodeLine{10285         IResultCapture* getResultCapture()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10286             \textcolor{keywordflow}{return} m\_resultCapture;}
\DoxyCodeLine{10287         \}}
\DoxyCodeLine{10288         IRunner* getRunner()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10289             \textcolor{keywordflow}{return} m\_runner;}
\DoxyCodeLine{10290         \}}
\DoxyCodeLine{10291 }
\DoxyCodeLine{10292         IConfigPtr \textcolor{keyword}{const}\& getConfig()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{10293             \textcolor{keywordflow}{return} m\_config;}
\DoxyCodeLine{10294         \}}
\DoxyCodeLine{10295 }
\DoxyCodeLine{10296         \string~Context() \textcolor{keyword}{override};}
\DoxyCodeLine{10297 }
\DoxyCodeLine{10298     \textcolor{keyword}{public}: \textcolor{comment}{// IMutableContext}}
\DoxyCodeLine{10299         \textcolor{keywordtype}{void} setResultCapture( IResultCapture* resultCapture )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10300             m\_resultCapture = resultCapture;}
\DoxyCodeLine{10301         \}}
\DoxyCodeLine{10302         \textcolor{keywordtype}{void} setRunner( IRunner* runner )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10303             m\_runner = runner;}
\DoxyCodeLine{10304         \}}
\DoxyCodeLine{10305         \textcolor{keywordtype}{void} setConfig( IConfigPtr \textcolor{keyword}{const}\& config )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10306             m\_config = config;}
\DoxyCodeLine{10307         \}}
\DoxyCodeLine{10308 }
\DoxyCodeLine{10309         \textcolor{keyword}{friend} IMutableContext\& getCurrentMutableContext();}
\DoxyCodeLine{10310 }
\DoxyCodeLine{10311     \textcolor{keyword}{private}:}
\DoxyCodeLine{10312         IConfigPtr m\_config;}
\DoxyCodeLine{10313         IRunner* m\_runner = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10314         IResultCapture* m\_resultCapture = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10315     \};}
\DoxyCodeLine{10316 }
\DoxyCodeLine{10317     IMutableContext *IMutableContext::currentContext = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10318 }
\DoxyCodeLine{10319     \textcolor{keywordtype}{void} IMutableContext::createContext()}
\DoxyCodeLine{10320     \{}
\DoxyCodeLine{10321         currentContext = \textcolor{keyword}{new} Context();}
\DoxyCodeLine{10322     \}}
\DoxyCodeLine{10323 }
\DoxyCodeLine{10324     \textcolor{keywordtype}{void} cleanUpContext() \{}
\DoxyCodeLine{10325         \textcolor{keyword}{delete} IMutableContext::currentContext;}
\DoxyCodeLine{10326         IMutableContext::currentContext = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10327     \}}
\DoxyCodeLine{10328     IContext::\string~IContext() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10329     IMutableContext::\string~IMutableContext() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10330     Context::\string~Context() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10331 }
\DoxyCodeLine{10332     SimplePcg32\& rng() \{}
\DoxyCodeLine{10333         \textcolor{keyword}{static} SimplePcg32 s\_rng;}
\DoxyCodeLine{10334         \textcolor{keywordflow}{return} s\_rng;}
\DoxyCodeLine{10335     \}}
\DoxyCodeLine{10336 }
\DoxyCodeLine{10337 \}}
\DoxyCodeLine{10338 \textcolor{comment}{// end catch\_context.cpp}}
\DoxyCodeLine{10339 \textcolor{comment}{// start catch\_debug\_console.cpp}}
\DoxyCodeLine{10340 }
\DoxyCodeLine{10341 \textcolor{comment}{// start catch\_debug\_console.h}}
\DoxyCodeLine{10342 }
\DoxyCodeLine{10343 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{10344 }
\DoxyCodeLine{10345 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10346     \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text );}
\DoxyCodeLine{10347 \}}
\DoxyCodeLine{10348 }
\DoxyCodeLine{10349 \textcolor{comment}{// end catch\_debug\_console.h}}
\DoxyCodeLine{10350 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ANDROID\_LOGWRITE)}}
\DoxyCodeLine{10351 \textcolor{preprocessor}{\#include <android/log.h>}}
\DoxyCodeLine{10352 }
\DoxyCodeLine{10353     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10354         \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{10355             \_\_android\_log\_write( ANDROID\_LOG\_DEBUG, \textcolor{stringliteral}{"{}Catch"{}}, text.c\_str() );}
\DoxyCodeLine{10356         \}}
\DoxyCodeLine{10357     \}}
\DoxyCodeLine{10358 }
\DoxyCodeLine{10359 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{10360 }
\DoxyCodeLine{10361     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10362         \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{10363             ::OutputDebugStringA( text.c\_str() );}
\DoxyCodeLine{10364         \}}
\DoxyCodeLine{10365     \}}
\DoxyCodeLine{10366 }
\DoxyCodeLine{10367 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10368 }
\DoxyCodeLine{10369     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10370         \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{10371             \textcolor{comment}{// !TBD: Need a version for Mac/ XCode and other IDEs}}
\DoxyCodeLine{10372             Catch::cout() << text;}
\DoxyCodeLine{10373         \}}
\DoxyCodeLine{10374     \}}
\DoxyCodeLine{10375 }
\DoxyCodeLine{10376 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// Platform}}
\DoxyCodeLine{10377 \textcolor{comment}{// end catch\_debug\_console.cpp}}
\DoxyCodeLine{10378 \textcolor{comment}{// start catch\_debugger.cpp}}
\DoxyCodeLine{10379 }
\DoxyCodeLine{10380 \textcolor{preprocessor}{\#if defined(CATCH\_PLATFORM\_MAC) || defined(CATCH\_PLATFORM\_IPHONE)}}
\DoxyCodeLine{10381 }
\DoxyCodeLine{10382 \textcolor{preprocessor}{\#  include <cassert>}}
\DoxyCodeLine{10383 \textcolor{preprocessor}{\#  include <sys/types.h>}}
\DoxyCodeLine{10384 \textcolor{preprocessor}{\#  include <unistd.h>}}
\DoxyCodeLine{10385 \textcolor{preprocessor}{\#  include <cstddef>}}
\DoxyCodeLine{10386 \textcolor{preprocessor}{\#  include <ostream>}}
\DoxyCodeLine{10387 }
\DoxyCodeLine{10388 \textcolor{preprocessor}{\#ifdef \_\_apple\_build\_version\_\_}}
\DoxyCodeLine{10389     \textcolor{comment}{// These headers will only compile with AppleClang (XCode)}}
\DoxyCodeLine{10390     \textcolor{comment}{// For other compilers (Clang, GCC, ... ) we need to exclude them}}
\DoxyCodeLine{10391 \textcolor{preprocessor}{\#  include <sys/sysctl.h>}}
\DoxyCodeLine{10392 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10393 }
\DoxyCodeLine{10394     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10395 \textcolor{preprocessor}{        \#ifdef \_\_apple\_build\_version\_\_}}
\DoxyCodeLine{10396         \textcolor{comment}{// The following function is taken directly from the following technical note:}}
\DoxyCodeLine{10397         \textcolor{comment}{// https://developer.apple.com/library/archive/qa/qa1361/\_index.html}}
\DoxyCodeLine{10398 }
\DoxyCodeLine{10399         \textcolor{comment}{// Returns true if the current process is being debugged (either}}
\DoxyCodeLine{10400         \textcolor{comment}{// running under the debugger or has a debugger attached post facto).}}
\DoxyCodeLine{10401         \textcolor{keywordtype}{bool} isDebuggerActive()\{}
\DoxyCodeLine{10402             \textcolor{keywordtype}{int}                 mib[4];}
\DoxyCodeLine{10403             \textcolor{keyword}{struct }kinfo\_proc   info;}
\DoxyCodeLine{10404             std::size\_t         size;}
\DoxyCodeLine{10405 }
\DoxyCodeLine{10406             \textcolor{comment}{// Initialize the flags so that, if sysctl fails for some bizarre}}
\DoxyCodeLine{10407             \textcolor{comment}{// reason, we get a predictable result.}}
\DoxyCodeLine{10408 }
\DoxyCodeLine{10409             info.kp\_proc.p\_flag = 0;}
\DoxyCodeLine{10410 }
\DoxyCodeLine{10411             \textcolor{comment}{// Initialize mib, which tells sysctl the info we want, in this case}}
\DoxyCodeLine{10412             \textcolor{comment}{// we're looking for information about a specific process ID.}}
\DoxyCodeLine{10413 }
\DoxyCodeLine{10414             mib[0] = CTL\_KERN;}
\DoxyCodeLine{10415             mib[1] = KERN\_PROC;}
\DoxyCodeLine{10416             mib[2] = KERN\_PROC\_PID;}
\DoxyCodeLine{10417             mib[3] = getpid();}
\DoxyCodeLine{10418 }
\DoxyCodeLine{10419             \textcolor{comment}{// Call sysctl.}}
\DoxyCodeLine{10420 }
\DoxyCodeLine{10421             size = \textcolor{keyword}{sizeof}(info);}
\DoxyCodeLine{10422             \textcolor{keywordflow}{if}( sysctl(mib, \textcolor{keyword}{sizeof}(mib) / \textcolor{keyword}{sizeof}(*mib), \&info, \&size, \textcolor{keyword}{nullptr}, 0) != 0 ) \{}
\DoxyCodeLine{10423                 Catch::cerr() << \textcolor{stringliteral}{"{}\(\backslash\)n** Call to sysctl failed -\/ unable to determine if debugger is active **\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{10424                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10425             \}}
\DoxyCodeLine{10426 }
\DoxyCodeLine{10427             \textcolor{comment}{// We're being debugged if the P\_TRACED flag is set.}}
\DoxyCodeLine{10428 }
\DoxyCodeLine{10429             \textcolor{keywordflow}{return} ( (info.kp\_proc.p\_flag \& P\_TRACED) != 0 );}
\DoxyCodeLine{10430         \}}
\DoxyCodeLine{10431 \textcolor{preprocessor}{        \#else}}
\DoxyCodeLine{10432         \textcolor{keywordtype}{bool} isDebuggerActive() \{}
\DoxyCodeLine{10433             \textcolor{comment}{// We need to find another way to determine this for non-\/appleclang compilers on macOS}}
\DoxyCodeLine{10434             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10435         \}}
\DoxyCodeLine{10436 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{10437     \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10438 }
\DoxyCodeLine{10439 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_LINUX)}}
\DoxyCodeLine{10440 \textcolor{preprocessor}{    \#include <fstream>}}
\DoxyCodeLine{10441 \textcolor{preprocessor}{    \#include <string>}}
\DoxyCodeLine{10442 }
\DoxyCodeLine{10443     \textcolor{keyword}{namespace }Catch\{}
\DoxyCodeLine{10444         \textcolor{comment}{// The standard POSIX way of detecting a debugger is to attempt to}}
\DoxyCodeLine{10445         \textcolor{comment}{// ptrace() the process, but this needs to be done from a child and not}}
\DoxyCodeLine{10446         \textcolor{comment}{// this process itself to still allow attaching to this process later}}
\DoxyCodeLine{10447         \textcolor{comment}{// if wanted, so is rather heavy. Under Linux we have the PID of the}}
\DoxyCodeLine{10448         \textcolor{comment}{// "{}debugger"{} (which doesn't need to be gdb, of course, it could also}}
\DoxyCodeLine{10449         \textcolor{comment}{// be strace, for example) in /proc/\$PID/status, so just get it from}}
\DoxyCodeLine{10450         \textcolor{comment}{// there instead.}}
\DoxyCodeLine{10451         \textcolor{keywordtype}{bool} isDebuggerActive()\{}
\DoxyCodeLine{10452             \textcolor{comment}{// Libstdc++ has a bug, where std::ifstream sets errno to 0}}
\DoxyCodeLine{10453             \textcolor{comment}{// This way our users can properly assert over errno values}}
\DoxyCodeLine{10454             ErrnoGuard guard;}
\DoxyCodeLine{10455             std::ifstream in(\textcolor{stringliteral}{"{}/proc/self/status"{}});}
\DoxyCodeLine{10456             \textcolor{keywordflow}{for}( std::string line; std::getline(in, line); ) \{}
\DoxyCodeLine{10457                 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PREFIX\_LEN = 11;}
\DoxyCodeLine{10458                 \textcolor{keywordflow}{if}( line.compare(0, PREFIX\_LEN, \textcolor{stringliteral}{"{}TracerPid:\(\backslash\)t"{}}) == 0 ) \{}
\DoxyCodeLine{10459                     \textcolor{comment}{// We're traced if the PID is not 0 and no other PID starts}}
\DoxyCodeLine{10460                     \textcolor{comment}{// with 0 digit, so it's enough to check for just a single}}
\DoxyCodeLine{10461                     \textcolor{comment}{// character.}}
\DoxyCodeLine{10462                     \textcolor{keywordflow}{return} line.length() > PREFIX\_LEN \&\& line[PREFIX\_LEN] != \textcolor{charliteral}{'0'};}
\DoxyCodeLine{10463                 \}}
\DoxyCodeLine{10464             \}}
\DoxyCodeLine{10465 }
\DoxyCodeLine{10466             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10467         \}}
\DoxyCodeLine{10468     \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10469 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{10470     \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \_\_declspec(dllimport) \textcolor{keywordtype}{int} \_\_stdcall IsDebuggerPresent();}
\DoxyCodeLine{10471     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10472         \textcolor{keywordtype}{bool} isDebuggerActive() \{}
\DoxyCodeLine{10473             \textcolor{keywordflow}{return} IsDebuggerPresent() != 0;}
\DoxyCodeLine{10474         \}}
\DoxyCodeLine{10475     \}}
\DoxyCodeLine{10476 \textcolor{preprocessor}{\#elif defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{10477     \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \_\_declspec(dllimport) \textcolor{keywordtype}{int} \_\_stdcall IsDebuggerPresent();}
\DoxyCodeLine{10478     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10479         \textcolor{keywordtype}{bool} isDebuggerActive() \{}
\DoxyCodeLine{10480             \textcolor{keywordflow}{return} IsDebuggerPresent() != 0;}
\DoxyCodeLine{10481         \}}
\DoxyCodeLine{10482     \}}
\DoxyCodeLine{10483 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10484     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10485        \textcolor{keywordtype}{bool} isDebuggerActive() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{10486     \}}
\DoxyCodeLine{10487 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// Platform}}
\DoxyCodeLine{10488 \textcolor{comment}{// end catch\_debugger.cpp}}
\DoxyCodeLine{10489 \textcolor{comment}{// start catch\_decomposer.cpp}}
\DoxyCodeLine{10490 }
\DoxyCodeLine{10491 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10492 }
\DoxyCodeLine{10493     ITransientExpression::\string~ITransientExpression() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10494 }
\DoxyCodeLine{10495     \textcolor{keywordtype}{void} formatReconstructedExpression( std::ostream \&os, std::string \textcolor{keyword}{const}\& lhs, StringRef op, std::string \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{10496         \textcolor{keywordflow}{if}( lhs.size() + rhs.size() < 40 \&\&}
\DoxyCodeLine{10497                 lhs.find(\textcolor{charliteral}{'\(\backslash\)n'}) == std::string::npos \&\&}
\DoxyCodeLine{10498                 rhs.find(\textcolor{charliteral}{'\(\backslash\)n'}) == std::string::npos )}
\DoxyCodeLine{10499             os << lhs << \textcolor{stringliteral}{"{} "{}} << op << \textcolor{stringliteral}{"{} "{}} << rhs;}
\DoxyCodeLine{10500         \textcolor{keywordflow}{else}}
\DoxyCodeLine{10501             os << lhs << \textcolor{stringliteral}{"{}\(\backslash\)n"{}} << op << \textcolor{stringliteral}{"{}\(\backslash\)n"{}} << rhs;}
\DoxyCodeLine{10502     \}}
\DoxyCodeLine{10503 \}}
\DoxyCodeLine{10504 \textcolor{comment}{// end catch\_decomposer.cpp}}
\DoxyCodeLine{10505 \textcolor{comment}{// start catch\_enforce.cpp}}
\DoxyCodeLine{10506 }
\DoxyCodeLine{10507 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{10508 }
\DoxyCodeLine{10509 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10510 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS) \&\& !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS\_CUSTOM\_HANDLER)}}
\DoxyCodeLine{10511     [[noreturn]]}
\DoxyCodeLine{10512     \textcolor{keywordtype}{void} throw\_exception(std::exception \textcolor{keyword}{const}\& e) \{}
\DoxyCodeLine{10513         Catch::cerr() << \textcolor{stringliteral}{"{}Catch will terminate because it needed to throw an exception.\(\backslash\)n"{}}}
\DoxyCodeLine{10514                       << \textcolor{stringliteral}{"{}The message was: "{}} << e.what() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10515         std::terminate();}
\DoxyCodeLine{10516     \}}
\DoxyCodeLine{10517 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10518 }
\DoxyCodeLine{10519     [[noreturn]]}
\DoxyCodeLine{10520     \textcolor{keywordtype}{void} throw\_logic\_error(std::string \textcolor{keyword}{const}\& msg) \{}
\DoxyCodeLine{10521         throw\_exception(std::logic\_error(msg));}
\DoxyCodeLine{10522     \}}
\DoxyCodeLine{10523 }
\DoxyCodeLine{10524     [[noreturn]]}
\DoxyCodeLine{10525     \textcolor{keywordtype}{void} throw\_domain\_error(std::string \textcolor{keyword}{const}\& msg) \{}
\DoxyCodeLine{10526         throw\_exception(std::domain\_error(msg));}
\DoxyCodeLine{10527     \}}
\DoxyCodeLine{10528 }
\DoxyCodeLine{10529     [[noreturn]]}
\DoxyCodeLine{10530     \textcolor{keywordtype}{void} throw\_runtime\_error(std::string \textcolor{keyword}{const}\& msg) \{}
\DoxyCodeLine{10531         throw\_exception(std::runtime\_error(msg));}
\DoxyCodeLine{10532     \}}
\DoxyCodeLine{10533 }
\DoxyCodeLine{10534 \} \textcolor{comment}{// namespace Catch;}}
\DoxyCodeLine{10535 \textcolor{comment}{// end catch\_enforce.cpp}}
\DoxyCodeLine{10536 \textcolor{comment}{// start catch\_enum\_values\_registry.cpp}}
\DoxyCodeLine{10537 \textcolor{comment}{// start catch\_enum\_values\_registry.h}}
\DoxyCodeLine{10538 }
\DoxyCodeLine{10539 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{10540 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{10541 }
\DoxyCodeLine{10542 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10543 }
\DoxyCodeLine{10544     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{10545 }
\DoxyCodeLine{10546         std::unique\_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> \textcolor{keyword}{const}\& values );}
\DoxyCodeLine{10547 }
\DoxyCodeLine{10548         \textcolor{keyword}{class }EnumValuesRegistry : \textcolor{keyword}{public} IMutableEnumValuesRegistry \{}
\DoxyCodeLine{10549 }
\DoxyCodeLine{10550             std::vector<std::unique\_ptr<EnumInfo>> m\_enumInfos;}
\DoxyCodeLine{10551 }
\DoxyCodeLine{10552             EnumInfo \textcolor{keyword}{const}\& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> \textcolor{keyword}{const}\& values) \textcolor{keyword}{override};}
\DoxyCodeLine{10553         \};}
\DoxyCodeLine{10554 }
\DoxyCodeLine{10555         std::vector<StringRef> parseEnums( StringRef enums );}
\DoxyCodeLine{10556 }
\DoxyCodeLine{10557     \} \textcolor{comment}{// Detail}}
\DoxyCodeLine{10558 }
\DoxyCodeLine{10559 \} \textcolor{comment}{// Catch}}
\DoxyCodeLine{10560 }
\DoxyCodeLine{10561 \textcolor{comment}{// end catch\_enum\_values\_registry.h}}
\DoxyCodeLine{10562 }
\DoxyCodeLine{10563 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{10564 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{10565 }
\DoxyCodeLine{10566 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10567 }
\DoxyCodeLine{10568     IMutableEnumValuesRegistry::\string~IMutableEnumValuesRegistry() \{\}}
\DoxyCodeLine{10569 }
\DoxyCodeLine{10570     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{10571 }
\DoxyCodeLine{10572         \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10573             \textcolor{comment}{// Extracts the actual name part of an enum instance}}
\DoxyCodeLine{10574             \textcolor{comment}{// In other words, it returns the Blue part of Bikeshed::Colour::Blue}}
\DoxyCodeLine{10575             StringRef extractInstanceName(StringRef enumInstance) \{}
\DoxyCodeLine{10576                 \textcolor{comment}{// Find last occurence of "{}:"{}}}
\DoxyCodeLine{10577                 \textcolor{keywordtype}{size\_t} name\_start = enumInstance.size();}
\DoxyCodeLine{10578                 \textcolor{keywordflow}{while} (name\_start > 0 \&\& enumInstance[name\_start -\/ 1] != \textcolor{charliteral}{':'}) \{}
\DoxyCodeLine{10579                     -\/-\/name\_start;}
\DoxyCodeLine{10580                 \}}
\DoxyCodeLine{10581                 \textcolor{keywordflow}{return} enumInstance.substr(name\_start, enumInstance.size() -\/ name\_start);}
\DoxyCodeLine{10582             \}}
\DoxyCodeLine{10583         \}}
\DoxyCodeLine{10584 }
\DoxyCodeLine{10585         std::vector<StringRef> parseEnums( StringRef enums ) \{}
\DoxyCodeLine{10586             \textcolor{keyword}{auto} enumValues = splitStringRef( enums, \textcolor{charliteral}{','} );}
\DoxyCodeLine{10587             std::vector<StringRef> parsed;}
\DoxyCodeLine{10588             parsed.reserve( enumValues.size() );}
\DoxyCodeLine{10589             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& enumValue : enumValues ) \{}
\DoxyCodeLine{10590                 parsed.push\_back(trim(extractInstanceName(enumValue)));}
\DoxyCodeLine{10591             \}}
\DoxyCodeLine{10592             \textcolor{keywordflow}{return} parsed;}
\DoxyCodeLine{10593         \}}
\DoxyCodeLine{10594 }
\DoxyCodeLine{10595         EnumInfo::\string~EnumInfo() \{\}}
\DoxyCodeLine{10596 }
\DoxyCodeLine{10597         StringRef EnumInfo::lookup( \textcolor{keywordtype}{int} value )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10598             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& valueToName : m\_values ) \{}
\DoxyCodeLine{10599                 \textcolor{keywordflow}{if}( valueToName.first == value )}
\DoxyCodeLine{10600                     \textcolor{keywordflow}{return} valueToName.second;}
\DoxyCodeLine{10601             \}}
\DoxyCodeLine{10602             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}\{** unexpected enum value **\}"{}}\_sr;}
\DoxyCodeLine{10603         \}}
\DoxyCodeLine{10604 }
\DoxyCodeLine{10605         std::unique\_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> \textcolor{keyword}{const}\& values ) \{}
\DoxyCodeLine{10606             std::unique\_ptr<EnumInfo> enumInfo( \textcolor{keyword}{new} EnumInfo );}
\DoxyCodeLine{10607             enumInfo-\/>m\_name = enumName;}
\DoxyCodeLine{10608             enumInfo-\/>m\_values.reserve( values.size() );}
\DoxyCodeLine{10609 }
\DoxyCodeLine{10610             \textcolor{keyword}{const} \textcolor{keyword}{auto} valueNames = Catch::Detail::parseEnums( allValueNames );}
\DoxyCodeLine{10611             assert( valueNames.size() == values.size() );}
\DoxyCodeLine{10612             std::size\_t i = 0;}
\DoxyCodeLine{10613             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} value : values )}
\DoxyCodeLine{10614                 enumInfo-\/>m\_values.emplace\_back(value, valueNames[i++]);}
\DoxyCodeLine{10615 }
\DoxyCodeLine{10616             \textcolor{keywordflow}{return} enumInfo;}
\DoxyCodeLine{10617         \}}
\DoxyCodeLine{10618 }
\DoxyCodeLine{10619         EnumInfo \textcolor{keyword}{const}\& EnumValuesRegistry::registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> \textcolor{keyword}{const}\& values ) \{}
\DoxyCodeLine{10620             m\_enumInfos.push\_back(makeEnumInfo(enumName, allValueNames, values));}
\DoxyCodeLine{10621             \textcolor{keywordflow}{return} *m\_enumInfos.back();}
\DoxyCodeLine{10622         \}}
\DoxyCodeLine{10623 }
\DoxyCodeLine{10624     \} \textcolor{comment}{// Detail}}
\DoxyCodeLine{10625 \} \textcolor{comment}{// Catch}}
\DoxyCodeLine{10626 }
\DoxyCodeLine{10627 \textcolor{comment}{// end catch\_enum\_values\_registry.cpp}}
\DoxyCodeLine{10628 \textcolor{comment}{// start catch\_errno\_guard.cpp}}
\DoxyCodeLine{10629 }
\DoxyCodeLine{10630 \textcolor{preprocessor}{\#include <cerrno>}}
\DoxyCodeLine{10631 }
\DoxyCodeLine{10632 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10633         ErrnoGuard::ErrnoGuard():m\_oldErrno(errno)\{\}}
\DoxyCodeLine{10634         ErrnoGuard::\string~ErrnoGuard() \{ errno = m\_oldErrno; \}}
\DoxyCodeLine{10635 \}}
\DoxyCodeLine{10636 \textcolor{comment}{// end catch\_errno\_guard.cpp}}
\DoxyCodeLine{10637 \textcolor{comment}{// start catch\_exception\_translator\_registry.cpp}}
\DoxyCodeLine{10638 }
\DoxyCodeLine{10639 \textcolor{comment}{// start catch\_exception\_translator\_registry.h}}
\DoxyCodeLine{10640 }
\DoxyCodeLine{10641 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{10642 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{10643 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{10644 }
\DoxyCodeLine{10645 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10646 }
\DoxyCodeLine{10647     \textcolor{keyword}{class }ExceptionTranslatorRegistry : \textcolor{keyword}{public} IExceptionTranslatorRegistry \{}
\DoxyCodeLine{10648     \textcolor{keyword}{public}:}
\DoxyCodeLine{10649         \string~ExceptionTranslatorRegistry();}
\DoxyCodeLine{10650         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} IExceptionTranslator* translator );}
\DoxyCodeLine{10651         std::string translateActiveException() \textcolor{keyword}{const override};}
\DoxyCodeLine{10652         std::string tryTranslators() \textcolor{keyword}{const};}
\DoxyCodeLine{10653 }
\DoxyCodeLine{10654     \textcolor{keyword}{private}:}
\DoxyCodeLine{10655         std::vector<std::unique\_ptr<IExceptionTranslator const>> m\_translators;}
\DoxyCodeLine{10656     \};}
\DoxyCodeLine{10657 \}}
\DoxyCodeLine{10658 }
\DoxyCodeLine{10659 \textcolor{comment}{// end catch\_exception\_translator\_registry.h}}
\DoxyCodeLine{10660 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{10661 \textcolor{preprocessor}{\#import "{}Foundation/Foundation.h"{}}}
\DoxyCodeLine{10662 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10663 }
\DoxyCodeLine{10664 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10665 }
\DoxyCodeLine{10666     ExceptionTranslatorRegistry::\string~ExceptionTranslatorRegistry() \{}
\DoxyCodeLine{10667     \}}
\DoxyCodeLine{10668 }
\DoxyCodeLine{10669     \textcolor{keywordtype}{void} ExceptionTranslatorRegistry::registerTranslator( \textcolor{keyword}{const} IExceptionTranslator* translator ) \{}
\DoxyCodeLine{10670         m\_translators.push\_back( std::unique\_ptr<const IExceptionTranslator>( translator ) );}
\DoxyCodeLine{10671     \}}
\DoxyCodeLine{10672 }
\DoxyCodeLine{10673 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{10674     std::string ExceptionTranslatorRegistry::translateActiveException()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10675         \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{10676 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{10677             \textcolor{comment}{// In Objective-\/C try objective-\/c exceptions first}}
\DoxyCodeLine{10678             \textcolor{keywordflow}{@try} \{}
\DoxyCodeLine{10679                 \textcolor{keywordflow}{return} tryTranslators();}
\DoxyCodeLine{10680             \}}
\DoxyCodeLine{10681             \textcolor{keywordflow}{@catch} (NSException *exception) \{}
\DoxyCodeLine{10682                 \textcolor{keywordflow}{return} Catch::Detail::stringify( [exception description] );}
\DoxyCodeLine{10683             \}}
\DoxyCodeLine{10684 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10685             \textcolor{comment}{// Compiling a mixed mode project with MSVC means that CLR}}
\DoxyCodeLine{10686             \textcolor{comment}{// exceptions will be caught in (...) as well. However, these}}
\DoxyCodeLine{10687             \textcolor{comment}{// do not fill-\/in std::current\_exception and thus lead to crash}}
\DoxyCodeLine{10688             \textcolor{comment}{// when attempting rethrow.}}
\DoxyCodeLine{10689             \textcolor{comment}{// /EHa switch also causes structured exceptions to be caught}}
\DoxyCodeLine{10690             \textcolor{comment}{// here, but they fill-\/in current\_exception properly, so}}
\DoxyCodeLine{10691             \textcolor{comment}{// at worst the output should be a little weird, instead of}}
\DoxyCodeLine{10692             \textcolor{comment}{// causing a crash.}}
\DoxyCodeLine{10693             \textcolor{keywordflow}{if} (std::current\_exception() == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{10694                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Non C++ exception. Possibly a CLR exception."{}};}
\DoxyCodeLine{10695             \}}
\DoxyCodeLine{10696             \textcolor{keywordflow}{return} tryTranslators();}
\DoxyCodeLine{10697 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10698         \}}
\DoxyCodeLine{10699         \textcolor{keywordflow}{catch}( TestFailureException\& ) \{}
\DoxyCodeLine{10700             std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{10701         \}}
\DoxyCodeLine{10702         \textcolor{keywordflow}{catch}( std::exception\& ex ) \{}
\DoxyCodeLine{10703             \textcolor{keywordflow}{return} ex.what();}
\DoxyCodeLine{10704         \}}
\DoxyCodeLine{10705         \textcolor{keywordflow}{catch}( std::string\& msg ) \{}
\DoxyCodeLine{10706             \textcolor{keywordflow}{return} msg;}
\DoxyCodeLine{10707         \}}
\DoxyCodeLine{10708         \textcolor{keywordflow}{catch}( \textcolor{keyword}{const} \textcolor{keywordtype}{char}* msg ) \{}
\DoxyCodeLine{10709             \textcolor{keywordflow}{return} msg;}
\DoxyCodeLine{10710         \}}
\DoxyCodeLine{10711         \textcolor{keywordflow}{catch}(...) \{}
\DoxyCodeLine{10712             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Unknown exception"{}};}
\DoxyCodeLine{10713         \}}
\DoxyCodeLine{10714     \}}
\DoxyCodeLine{10715 }
\DoxyCodeLine{10716     std::string ExceptionTranslatorRegistry::tryTranslators()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10717         \textcolor{keywordflow}{if} (m\_translators.empty()) \{}
\DoxyCodeLine{10718             std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{10719         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{10720             \textcolor{keywordflow}{return} m\_translators[0]-\/>translate(m\_translators.begin() + 1, m\_translators.end());}
\DoxyCodeLine{10721         \}}
\DoxyCodeLine{10722     \}}
\DoxyCodeLine{10723 }
\DoxyCodeLine{10724 \textcolor{preprocessor}{\#else }\textcolor{comment}{// \string^\string^ Exceptions are enabled // Exceptions are disabled vv}}
\DoxyCodeLine{10725     std::string ExceptionTranslatorRegistry::translateActiveException()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10726         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Attempted to translate active exception under CATCH\_CONFIG\_DISABLE\_EXCEPTIONS!"{}});}
\DoxyCodeLine{10727     \}}
\DoxyCodeLine{10728 }
\DoxyCodeLine{10729     std::string ExceptionTranslatorRegistry::tryTranslators()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10730         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Attempted to use exception translators under CATCH\_CONFIG\_DISABLE\_EXCEPTIONS!"{}});}
\DoxyCodeLine{10731     \}}
\DoxyCodeLine{10732 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10733 }
\DoxyCodeLine{10734 \}}
\DoxyCodeLine{10735 \textcolor{comment}{// end catch\_exception\_translator\_registry.cpp}}
\DoxyCodeLine{10736 \textcolor{comment}{// start catch\_fatal\_condition.cpp}}
\DoxyCodeLine{10737 }
\DoxyCodeLine{10738 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_)}}
\DoxyCodeLine{10739 \textcolor{preprocessor}{\#    pragma GCC diagnostic push}}
\DoxyCodeLine{10740 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wmissing-\/field-\/initializers"{}}}
\DoxyCodeLine{10741 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10742 }
\DoxyCodeLine{10743 \textcolor{preprocessor}{\#if defined( CATCH\_CONFIG\_WINDOWS\_SEH ) || defined( CATCH\_CONFIG\_POSIX\_SIGNALS )}}
\DoxyCodeLine{10744 }
\DoxyCodeLine{10745 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10746     \textcolor{comment}{// Report the error condition}}
\DoxyCodeLine{10747     \textcolor{keywordtype}{void} reportFatal( \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} message ) \{}
\DoxyCodeLine{10748         Catch::getCurrentContext().getResultCapture()-\/>handleFatalErrorCondition( message );}
\DoxyCodeLine{10749     \}}
\DoxyCodeLine{10750 \}}
\DoxyCodeLine{10751 }
\DoxyCodeLine{10752 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// signals/SEH handling}}
\DoxyCodeLine{10753 }
\DoxyCodeLine{10754 \textcolor{preprocessor}{\#if defined( CATCH\_CONFIG\_WINDOWS\_SEH )}}
\DoxyCodeLine{10755 }
\DoxyCodeLine{10756 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10757     \textcolor{keyword}{struct }SignalDefs \{ DWORD id; \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name; \};}
\DoxyCodeLine{10758 }
\DoxyCodeLine{10759     \textcolor{comment}{// There is no 1-\/1 mapping between signals and windows exceptions.}}
\DoxyCodeLine{10760     \textcolor{comment}{// Windows can easily distinguish between SO and SigSegV,}}
\DoxyCodeLine{10761     \textcolor{comment}{// but SigInt, SigTerm, etc are handled differently.}}
\DoxyCodeLine{10762     \textcolor{keyword}{static} SignalDefs signalDefs[] = \{}
\DoxyCodeLine{10763         \{ \textcolor{keyword}{static\_cast<}DWORD\textcolor{keyword}{>}(EXCEPTION\_ILLEGAL\_INSTRUCTION),  \textcolor{stringliteral}{"{}SIGILL -\/ Illegal instruction signal"{}} \},}
\DoxyCodeLine{10764         \{ \textcolor{keyword}{static\_cast<}DWORD\textcolor{keyword}{>}(EXCEPTION\_STACK\_OVERFLOW), \textcolor{stringliteral}{"{}SIGSEGV -\/ Stack overflow"{}} \},}
\DoxyCodeLine{10765         \{ \textcolor{keyword}{static\_cast<}DWORD\textcolor{keyword}{>}(EXCEPTION\_ACCESS\_VIOLATION), \textcolor{stringliteral}{"{}SIGSEGV -\/ Segmentation violation signal"{}} \},}
\DoxyCodeLine{10766         \{ \textcolor{keyword}{static\_cast<}DWORD\textcolor{keyword}{>}(EXCEPTION\_INT\_DIVIDE\_BY\_ZERO), \textcolor{stringliteral}{"{}Divide by zero error"{}} \},}
\DoxyCodeLine{10767     \};}
\DoxyCodeLine{10768 }
\DoxyCodeLine{10769     LONG CALLBACK FatalConditionHandler::handleVectoredException(PEXCEPTION\_POINTERS ExceptionInfo) \{}
\DoxyCodeLine{10770         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& def : signalDefs) \{}
\DoxyCodeLine{10771             \textcolor{keywordflow}{if} (ExceptionInfo-\/>ExceptionRecord-\/>ExceptionCode == def.id) \{}
\DoxyCodeLine{10772                 reportFatal(def.name);}
\DoxyCodeLine{10773             \}}
\DoxyCodeLine{10774         \}}
\DoxyCodeLine{10775         \textcolor{comment}{// If its not an exception we care about, pass it along.}}
\DoxyCodeLine{10776         \textcolor{comment}{// This stops us from eating debugger breaks etc.}}
\DoxyCodeLine{10777         \textcolor{keywordflow}{return} EXCEPTION\_CONTINUE\_SEARCH;}
\DoxyCodeLine{10778     \}}
\DoxyCodeLine{10779 }
\DoxyCodeLine{10780     FatalConditionHandler::FatalConditionHandler() \{}
\DoxyCodeLine{10781         isSet = \textcolor{keyword}{true};}
\DoxyCodeLine{10782         \textcolor{comment}{// 32k seems enough for Catch to handle stack overflow,}}
\DoxyCodeLine{10783         \textcolor{comment}{// but the value was found experimentally, so there is no strong guarantee}}
\DoxyCodeLine{10784         guaranteeSize = 32 * 1024;}
\DoxyCodeLine{10785         exceptionHandlerHandle = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10786         \textcolor{comment}{// Register as first handler in current chain}}
\DoxyCodeLine{10787         exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);}
\DoxyCodeLine{10788         \textcolor{comment}{// Pass in guarantee size to be filled}}
\DoxyCodeLine{10789         SetThreadStackGuarantee(\&guaranteeSize);}
\DoxyCodeLine{10790     \}}
\DoxyCodeLine{10791 }
\DoxyCodeLine{10792     \textcolor{keywordtype}{void} FatalConditionHandler::reset() \{}
\DoxyCodeLine{10793         \textcolor{keywordflow}{if} (isSet) \{}
\DoxyCodeLine{10794             RemoveVectoredExceptionHandler(exceptionHandlerHandle);}
\DoxyCodeLine{10795             SetThreadStackGuarantee(\&guaranteeSize);}
\DoxyCodeLine{10796             exceptionHandlerHandle = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10797             isSet = \textcolor{keyword}{false};}
\DoxyCodeLine{10798         \}}
\DoxyCodeLine{10799     \}}
\DoxyCodeLine{10800 }
\DoxyCodeLine{10801     FatalConditionHandler::\string~FatalConditionHandler() \{}
\DoxyCodeLine{10802         reset();}
\DoxyCodeLine{10803     \}}
\DoxyCodeLine{10804 }
\DoxyCodeLine{10805 \textcolor{keywordtype}{bool} FatalConditionHandler::isSet = \textcolor{keyword}{false};}
\DoxyCodeLine{10806 ULONG FatalConditionHandler::guaranteeSize = 0;}
\DoxyCodeLine{10807 PVOID FatalConditionHandler::exceptionHandlerHandle = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10808 }
\DoxyCodeLine{10809 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10810 }
\DoxyCodeLine{10811 \textcolor{preprocessor}{\#elif defined( CATCH\_CONFIG\_POSIX\_SIGNALS )}}
\DoxyCodeLine{10812 }
\DoxyCodeLine{10813 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10814 }
\DoxyCodeLine{10815     \textcolor{keyword}{struct }SignalDefs \{}
\DoxyCodeLine{10816         \textcolor{keywordtype}{int} id;}
\DoxyCodeLine{10817         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name;}
\DoxyCodeLine{10818     \};}
\DoxyCodeLine{10819 }
\DoxyCodeLine{10820     \textcolor{comment}{// 32kb for the alternate stack seems to be sufficient. However, this value}}
\DoxyCodeLine{10821     \textcolor{comment}{// is experimentally determined, so that's not guaranteed.}}
\DoxyCodeLine{10822     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} std::size\_t sigStackSize = 32768 >= MINSIGSTKSZ ? 32768 : MINSIGSTKSZ;}
\DoxyCodeLine{10823 }
\DoxyCodeLine{10824     \textcolor{keyword}{static} SignalDefs signalDefs[] = \{}
\DoxyCodeLine{10825         \{ SIGINT,  \textcolor{stringliteral}{"{}SIGINT -\/ Terminal interrupt signal"{}} \},}
\DoxyCodeLine{10826         \{ SIGILL,  \textcolor{stringliteral}{"{}SIGILL -\/ Illegal instruction signal"{}} \},}
\DoxyCodeLine{10827         \{ SIGFPE,  \textcolor{stringliteral}{"{}SIGFPE -\/ Floating point error signal"{}} \},}
\DoxyCodeLine{10828         \{ SIGSEGV, \textcolor{stringliteral}{"{}SIGSEGV -\/ Segmentation violation signal"{}} \},}
\DoxyCodeLine{10829         \{ SIGTERM, \textcolor{stringliteral}{"{}SIGTERM -\/ Termination request signal"{}} \},}
\DoxyCodeLine{10830         \{ SIGABRT, \textcolor{stringliteral}{"{}SIGABRT -\/ Abort (abnormal termination) signal"{}} \}}
\DoxyCodeLine{10831     \};}
\DoxyCodeLine{10832 }
\DoxyCodeLine{10833     \textcolor{keywordtype}{void} FatalConditionHandler::handleSignal( \textcolor{keywordtype}{int} sig ) \{}
\DoxyCodeLine{10834         \textcolor{keywordtype}{char} \textcolor{keyword}{const} * name = \textcolor{stringliteral}{"{}<unknown signal>"{}};}
\DoxyCodeLine{10835         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& def : signalDefs) \{}
\DoxyCodeLine{10836             \textcolor{keywordflow}{if} (sig == def.id) \{}
\DoxyCodeLine{10837                 name = def.name;}
\DoxyCodeLine{10838                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{10839             \}}
\DoxyCodeLine{10840         \}}
\DoxyCodeLine{10841         reset();}
\DoxyCodeLine{10842         reportFatal(name);}
\DoxyCodeLine{10843         \textcolor{keyword}{raise}( sig );}
\DoxyCodeLine{10844     \}}
\DoxyCodeLine{10845 }
\DoxyCodeLine{10846     FatalConditionHandler::FatalConditionHandler() \{}
\DoxyCodeLine{10847         isSet = \textcolor{keyword}{true};}
\DoxyCodeLine{10848         stack\_t sigStack;}
\DoxyCodeLine{10849         sigStack.ss\_sp = altStackMem;}
\DoxyCodeLine{10850         sigStack.ss\_size = sigStackSize;}
\DoxyCodeLine{10851         sigStack.ss\_flags = 0;}
\DoxyCodeLine{10852         sigaltstack(\&sigStack, \&oldSigStack);}
\DoxyCodeLine{10853         \textcolor{keyword}{struct }sigaction sa = \{ \};}
\DoxyCodeLine{10854 }
\DoxyCodeLine{10855         sa.sa\_handler = handleSignal;}
\DoxyCodeLine{10856         sa.sa\_flags = SA\_ONSTACK;}
\DoxyCodeLine{10857         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < \textcolor{keyword}{sizeof}(signalDefs)/\textcolor{keyword}{sizeof}(SignalDefs); ++i) \{}
\DoxyCodeLine{10858             sigaction(signalDefs[i].\textcolor{keywordtype}{id}, \&sa, \&oldSigActions[i]);}
\DoxyCodeLine{10859         \}}
\DoxyCodeLine{10860     \}}
\DoxyCodeLine{10861 }
\DoxyCodeLine{10862     FatalConditionHandler::\string~FatalConditionHandler() \{}
\DoxyCodeLine{10863         reset();}
\DoxyCodeLine{10864     \}}
\DoxyCodeLine{10865 }
\DoxyCodeLine{10866     \textcolor{keywordtype}{void} FatalConditionHandler::reset() \{}
\DoxyCodeLine{10867         \textcolor{keywordflow}{if}( isSet ) \{}
\DoxyCodeLine{10868             \textcolor{comment}{// Set signals back to previous values -\/-\/ hopefully nobody overwrote them in the meantime}}
\DoxyCodeLine{10869             \textcolor{keywordflow}{for}( std::size\_t i = 0; i < \textcolor{keyword}{sizeof}(signalDefs)/\textcolor{keyword}{sizeof}(SignalDefs); ++i ) \{}
\DoxyCodeLine{10870                 sigaction(signalDefs[i].\textcolor{keywordtype}{id}, \&oldSigActions[i], \textcolor{keyword}{nullptr});}
\DoxyCodeLine{10871             \}}
\DoxyCodeLine{10872             \textcolor{comment}{// Return the old stack}}
\DoxyCodeLine{10873             sigaltstack(\&oldSigStack, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{10874             isSet = \textcolor{keyword}{false};}
\DoxyCodeLine{10875         \}}
\DoxyCodeLine{10876     \}}
\DoxyCodeLine{10877 }
\DoxyCodeLine{10878     \textcolor{keywordtype}{bool} FatalConditionHandler::isSet = \textcolor{keyword}{false};}
\DoxyCodeLine{10879     \textcolor{keyword}{struct }sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = \{\};}
\DoxyCodeLine{10880     stack\_t FatalConditionHandler::oldSigStack = \{\};}
\DoxyCodeLine{10881     \textcolor{keywordtype}{char} FatalConditionHandler::altStackMem[sigStackSize] = \{\};}
\DoxyCodeLine{10882 }
\DoxyCodeLine{10883 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10884 }
\DoxyCodeLine{10885 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10886 }
\DoxyCodeLine{10887 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10888     \textcolor{keywordtype}{void} FatalConditionHandler::reset() \{\}}
\DoxyCodeLine{10889 \}}
\DoxyCodeLine{10890 }
\DoxyCodeLine{10891 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// signals/SEH handling}}
\DoxyCodeLine{10892 }
\DoxyCodeLine{10893 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_)}}
\DoxyCodeLine{10894 \textcolor{preprocessor}{\#    pragma GCC diagnostic pop}}
\DoxyCodeLine{10895 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10896 \textcolor{comment}{// end catch\_fatal\_condition.cpp}}
\DoxyCodeLine{10897 \textcolor{comment}{// start catch\_generators.cpp}}
\DoxyCodeLine{10898 }
\DoxyCodeLine{10899 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{10900 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{10901 }
\DoxyCodeLine{10902 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10903 }
\DoxyCodeLine{10904 IGeneratorTracker::\string~IGeneratorTracker() \{\}}
\DoxyCodeLine{10905 }
\DoxyCodeLine{10906 \textcolor{keyword}{const} \textcolor{keywordtype}{char}* GeneratorException::what() const noexcept \{}
\DoxyCodeLine{10907     \textcolor{keywordflow}{return} m\_msg;}
\DoxyCodeLine{10908 \}}
\DoxyCodeLine{10909 }
\DoxyCodeLine{10910 \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{10911 }
\DoxyCodeLine{10912     GeneratorUntypedBase::\string~GeneratorUntypedBase() \{\}}
\DoxyCodeLine{10913 }
\DoxyCodeLine{10914     \textcolor{keyword}{auto} acquireGeneratorTracker( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -\/> IGeneratorTracker\& \{}
\DoxyCodeLine{10915         \textcolor{keywordflow}{return} getResultCapture().acquireGeneratorTracker( generatorName, lineInfo );}
\DoxyCodeLine{10916     \}}
\DoxyCodeLine{10917 }
\DoxyCodeLine{10918 \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{10919 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10920 \textcolor{comment}{// end catch\_generators.cpp}}
\DoxyCodeLine{10921 \textcolor{comment}{// start catch\_interfaces\_capture.cpp}}
\DoxyCodeLine{10922 }
\DoxyCodeLine{10923 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10924     IResultCapture::\string~IResultCapture() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10925 \}}
\DoxyCodeLine{10926 \textcolor{comment}{// end catch\_interfaces\_capture.cpp}}
\DoxyCodeLine{10927 \textcolor{comment}{// start catch\_interfaces\_config.cpp}}
\DoxyCodeLine{10928 }
\DoxyCodeLine{10929 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10930     IConfig::\string~IConfig() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10931 \}}
\DoxyCodeLine{10932 \textcolor{comment}{// end catch\_interfaces\_config.cpp}}
\DoxyCodeLine{10933 \textcolor{comment}{// start catch\_interfaces\_exception.cpp}}
\DoxyCodeLine{10934 }
\DoxyCodeLine{10935 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10936     IExceptionTranslator::\string~IExceptionTranslator() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10937     IExceptionTranslatorRegistry::\string~IExceptionTranslatorRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10938 \}}
\DoxyCodeLine{10939 \textcolor{comment}{// end catch\_interfaces\_exception.cpp}}
\DoxyCodeLine{10940 \textcolor{comment}{// start catch\_interfaces\_registry\_hub.cpp}}
\DoxyCodeLine{10941 }
\DoxyCodeLine{10942 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10943     IRegistryHub::\string~IRegistryHub() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10944     IMutableRegistryHub::\string~IMutableRegistryHub() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10945 \}}
\DoxyCodeLine{10946 \textcolor{comment}{// end catch\_interfaces\_registry\_hub.cpp}}
\DoxyCodeLine{10947 \textcolor{comment}{// start catch\_interfaces\_reporter.cpp}}
\DoxyCodeLine{10948 }
\DoxyCodeLine{10949 \textcolor{comment}{// start catch\_reporter\_listening.h}}
\DoxyCodeLine{10950 }
\DoxyCodeLine{10951 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10952 }
\DoxyCodeLine{10953     \textcolor{keyword}{class }ListeningReporter : \textcolor{keyword}{public} IStreamingReporter \{}
\DoxyCodeLine{10954         \textcolor{keyword}{using} Reporters = std::vector<IStreamingReporterPtr>;}
\DoxyCodeLine{10955         Reporters m\_listeners;}
\DoxyCodeLine{10956         IStreamingReporterPtr m\_reporter = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10957         ReporterPreferences m\_preferences;}
\DoxyCodeLine{10958 }
\DoxyCodeLine{10959     \textcolor{keyword}{public}:}
\DoxyCodeLine{10960         ListeningReporter();}
\DoxyCodeLine{10961 }
\DoxyCodeLine{10962         \textcolor{keywordtype}{void} addListener( IStreamingReporterPtr\&\& listener );}
\DoxyCodeLine{10963         \textcolor{keywordtype}{void} addReporter( IStreamingReporterPtr\&\& reporter );}
\DoxyCodeLine{10964 }
\DoxyCodeLine{10965     \textcolor{keyword}{public}: \textcolor{comment}{// IStreamingReporter}}
\DoxyCodeLine{10966 }
\DoxyCodeLine{10967         ReporterPreferences getPreferences() \textcolor{keyword}{const override};}
\DoxyCodeLine{10968 }
\DoxyCodeLine{10969         \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) \textcolor{keyword}{override};}
\DoxyCodeLine{10970 }
\DoxyCodeLine{10971         \textcolor{keywordtype}{void} reportInvalidArguments(std::string \textcolor{keyword}{const}\&arg) \textcolor{keyword}{override};}
\DoxyCodeLine{10972 }
\DoxyCodeLine{10973         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities();}
\DoxyCodeLine{10974 }
\DoxyCodeLine{10975 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{10976         \textcolor{keywordtype}{void} benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \textcolor{keyword}{override};}
\DoxyCodeLine{10977         \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& benchmarkInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{10978         \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& benchmarkStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{10979         \textcolor{keywordtype}{void} benchmarkFailed(std::string \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{10980 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{10981 }
\DoxyCodeLine{10982         \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testRunInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{10983         \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{10984         \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{10985         \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{10986         \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& assertionInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{10987 }
\DoxyCodeLine{10988         \textcolor{comment}{// The return value indicates if the messages buffer should be cleared:}}
\DoxyCodeLine{10989         \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{10990         \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{10991         \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{10992         \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{10993         \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{10994 }
\DoxyCodeLine{10995         \textcolor{keywordtype}{void} skipTest( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{10996         \textcolor{keywordtype}{bool} isMulti() \textcolor{keyword}{const override};}
\DoxyCodeLine{10997 }
\DoxyCodeLine{10998     \};}
\DoxyCodeLine{10999 }
\DoxyCodeLine{11000 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11001 }
\DoxyCodeLine{11002 \textcolor{comment}{// end catch\_reporter\_listening.h}}
\DoxyCodeLine{11003 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11004 }
\DoxyCodeLine{11005     ReporterConfig::ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig )}
\DoxyCodeLine{11006     :   m\_stream( \&\_fullConfig-\/>stream() ), m\_fullConfig( \_fullConfig ) \{\}}
\DoxyCodeLine{11007 }
\DoxyCodeLine{11008     ReporterConfig::ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig, std::ostream\& \_stream )}
\DoxyCodeLine{11009     :   m\_stream( \&\_stream ), m\_fullConfig( \_fullConfig ) \{\}}
\DoxyCodeLine{11010 }
\DoxyCodeLine{11011     std::ostream\& ReporterConfig::stream()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *m\_stream; \}}
\DoxyCodeLine{11012     IConfigPtr ReporterConfig::fullConfig()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_fullConfig; \}}
\DoxyCodeLine{11013 }
\DoxyCodeLine{11014     TestRunInfo::TestRunInfo( std::string \textcolor{keyword}{const}\& \_name ) : name( \_name ) \{\}}
\DoxyCodeLine{11015 }
\DoxyCodeLine{11016     GroupInfo::GroupInfo(  std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{11017                            std::size\_t \_groupIndex,}
\DoxyCodeLine{11018                            std::size\_t \_groupsCount )}
\DoxyCodeLine{11019     :   name( \_name ),}
\DoxyCodeLine{11020         groupIndex( \_groupIndex ),}
\DoxyCodeLine{11021         groupsCounts( \_groupsCount )}
\DoxyCodeLine{11022     \{\}}
\DoxyCodeLine{11023 }
\DoxyCodeLine{11024      AssertionStats::AssertionStats( AssertionResult \textcolor{keyword}{const}\& \_assertionResult,}
\DoxyCodeLine{11025                                      std::vector<MessageInfo> \textcolor{keyword}{const}\& \_infoMessages,}
\DoxyCodeLine{11026                                      Totals \textcolor{keyword}{const}\& \_totals )}
\DoxyCodeLine{11027     :   assertionResult( \_assertionResult ),}
\DoxyCodeLine{11028         infoMessages( \_infoMessages ),}
\DoxyCodeLine{11029         totals( \_totals )}
\DoxyCodeLine{11030     \{}
\DoxyCodeLine{11031         assertionResult.m\_resultData.lazyExpression.m\_transientExpression = \_assertionResult.m\_resultData.lazyExpression.m\_transientExpression;}
\DoxyCodeLine{11032 }
\DoxyCodeLine{11033         \textcolor{keywordflow}{if}( assertionResult.hasMessage() ) \{}
\DoxyCodeLine{11034             \textcolor{comment}{// Copy message into messages list.}}
\DoxyCodeLine{11035             \textcolor{comment}{// !TBD This should have been done earlier, somewhere}}
\DoxyCodeLine{11036             MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );}
\DoxyCodeLine{11037             builder << assertionResult.getMessage();}
\DoxyCodeLine{11038             builder.m\_info.message = builder.m\_stream.str();}
\DoxyCodeLine{11039 }
\DoxyCodeLine{11040             infoMessages.push\_back( builder.m\_info );}
\DoxyCodeLine{11041         \}}
\DoxyCodeLine{11042     \}}
\DoxyCodeLine{11043 }
\DoxyCodeLine{11044      AssertionStats::\string~AssertionStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11045 }
\DoxyCodeLine{11046     SectionStats::SectionStats(  SectionInfo \textcolor{keyword}{const}\& \_sectionInfo,}
\DoxyCodeLine{11047                                  Counts \textcolor{keyword}{const}\& \_assertions,}
\DoxyCodeLine{11048                                  \textcolor{keywordtype}{double} \_durationInSeconds,}
\DoxyCodeLine{11049                                  \textcolor{keywordtype}{bool} \_missingAssertions )}
\DoxyCodeLine{11050     :   sectionInfo( \_sectionInfo ),}
\DoxyCodeLine{11051         assertions( \_assertions ),}
\DoxyCodeLine{11052         durationInSeconds( \_durationInSeconds ),}
\DoxyCodeLine{11053         missingAssertions( \_missingAssertions )}
\DoxyCodeLine{11054     \{\}}
\DoxyCodeLine{11055 }
\DoxyCodeLine{11056     SectionStats::\string~SectionStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11057 }
\DoxyCodeLine{11058     TestCaseStats::TestCaseStats(  TestCaseInfo \textcolor{keyword}{const}\& \_testInfo,}
\DoxyCodeLine{11059                                    Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{11060                                    std::string \textcolor{keyword}{const}\& \_stdOut,}
\DoxyCodeLine{11061                                    std::string \textcolor{keyword}{const}\& \_stdErr,}
\DoxyCodeLine{11062                                    \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{11063     : testInfo( \_testInfo ),}
\DoxyCodeLine{11064         totals( \_totals ),}
\DoxyCodeLine{11065         stdOut( \_stdOut ),}
\DoxyCodeLine{11066         stdErr( \_stdErr ),}
\DoxyCodeLine{11067         aborting( \_aborting )}
\DoxyCodeLine{11068     \{\}}
\DoxyCodeLine{11069 }
\DoxyCodeLine{11070     TestCaseStats::\string~TestCaseStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11071 }
\DoxyCodeLine{11072     TestGroupStats::TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo,}
\DoxyCodeLine{11073                                     Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{11074                                     \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{11075     :   groupInfo( \_groupInfo ),}
\DoxyCodeLine{11076         totals( \_totals ),}
\DoxyCodeLine{11077         aborting( \_aborting )}
\DoxyCodeLine{11078     \{\}}
\DoxyCodeLine{11079 }
\DoxyCodeLine{11080     TestGroupStats::TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo )}
\DoxyCodeLine{11081     :   groupInfo( \_groupInfo ),}
\DoxyCodeLine{11082         aborting( false )}
\DoxyCodeLine{11083     \{\}}
\DoxyCodeLine{11084 }
\DoxyCodeLine{11085     TestGroupStats::\string~TestGroupStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11086 }
\DoxyCodeLine{11087     TestRunStats::TestRunStats(   TestRunInfo \textcolor{keyword}{const}\& \_runInfo,}
\DoxyCodeLine{11088                     Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{11089                     \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{11090     :   runInfo( \_runInfo ),}
\DoxyCodeLine{11091         totals( \_totals ),}
\DoxyCodeLine{11092         aborting( \_aborting )}
\DoxyCodeLine{11093     \{\}}
\DoxyCodeLine{11094 }
\DoxyCodeLine{11095     TestRunStats::\string~TestRunStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11096 }
\DoxyCodeLine{11097     \textcolor{keywordtype}{void} IStreamingReporter::fatalErrorEncountered( StringRef ) \{\}}
\DoxyCodeLine{11098     \textcolor{keywordtype}{bool} IStreamingReporter::isMulti()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{11099 }
\DoxyCodeLine{11100     IReporterFactory::\string~IReporterFactory() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11101     IReporterRegistry::\string~IReporterRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11102 }
\DoxyCodeLine{11103 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11104 \textcolor{comment}{// end catch\_interfaces\_reporter.cpp}}
\DoxyCodeLine{11105 \textcolor{comment}{// start catch\_interfaces\_runner.cpp}}
\DoxyCodeLine{11106 }
\DoxyCodeLine{11107 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11108     IRunner::\string~IRunner() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11109 \}}
\DoxyCodeLine{11110 \textcolor{comment}{// end catch\_interfaces\_runner.cpp}}
\DoxyCodeLine{11111 \textcolor{comment}{// start catch\_interfaces\_testcase.cpp}}
\DoxyCodeLine{11112 }
\DoxyCodeLine{11113 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11114     ITestInvoker::\string~ITestInvoker() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11115     ITestCaseRegistry::\string~ITestCaseRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11116 \}}
\DoxyCodeLine{11117 \textcolor{comment}{// end catch\_interfaces\_testcase.cpp}}
\DoxyCodeLine{11118 \textcolor{comment}{// start catch\_leak\_detector.cpp}}
\DoxyCodeLine{11119 }
\DoxyCodeLine{11120 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_WINDOWS\_CRTDBG}}
\DoxyCodeLine{11121 \textcolor{preprocessor}{\#include <crtdbg.h>}}
\DoxyCodeLine{11122 }
\DoxyCodeLine{11123 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11124 }
\DoxyCodeLine{11125     LeakDetector::LeakDetector() \{}
\DoxyCodeLine{11126         \textcolor{keywordtype}{int} flag = \_CrtSetDbgFlag(\_CRTDBG\_REPORT\_FLAG);}
\DoxyCodeLine{11127         flag |= \_CRTDBG\_LEAK\_CHECK\_DF;}
\DoxyCodeLine{11128         flag |= \_CRTDBG\_ALLOC\_MEM\_DF;}
\DoxyCodeLine{11129         \_CrtSetDbgFlag(flag);}
\DoxyCodeLine{11130         \_CrtSetReportMode(\_CRT\_WARN, \_CRTDBG\_MODE\_FILE | \_CRTDBG\_MODE\_DEBUG);}
\DoxyCodeLine{11131         \_CrtSetReportFile(\_CRT\_WARN, \_CRTDBG\_FILE\_STDERR);}
\DoxyCodeLine{11132         \textcolor{comment}{// Change this to leaking allocation's number to break there}}
\DoxyCodeLine{11133         \_CrtSetBreakAlloc(-\/1);}
\DoxyCodeLine{11134     \}}
\DoxyCodeLine{11135 \}}
\DoxyCodeLine{11136 }
\DoxyCodeLine{11137 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11138 }
\DoxyCodeLine{11139     Catch::LeakDetector::LeakDetector() \{\}}
\DoxyCodeLine{11140 }
\DoxyCodeLine{11141 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11142 }
\DoxyCodeLine{11143 Catch::LeakDetector::\string~LeakDetector() \{}
\DoxyCodeLine{11144     Catch::cleanUp();}
\DoxyCodeLine{11145 \}}
\DoxyCodeLine{11146 \textcolor{comment}{// end catch\_leak\_detector.cpp}}
\DoxyCodeLine{11147 \textcolor{comment}{// start catch\_list.cpp}}
\DoxyCodeLine{11148 }
\DoxyCodeLine{11149 \textcolor{comment}{// start catch\_list.h}}
\DoxyCodeLine{11150 }
\DoxyCodeLine{11151 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{11152 }
\DoxyCodeLine{11153 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11154 }
\DoxyCodeLine{11155     std::size\_t listTests( \mbox{\hyperlink{struct_config__}{Config}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{11156 }
\DoxyCodeLine{11157     std::size\_t listTestsNamesOnly( \mbox{\hyperlink{struct_config__}{Config}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{11158 }
\DoxyCodeLine{11159     \textcolor{keyword}{struct }TagInfo \{}
\DoxyCodeLine{11160         \textcolor{keywordtype}{void} add( std::string \textcolor{keyword}{const}\& spelling );}
\DoxyCodeLine{11161         std::string all() \textcolor{keyword}{const};}
\DoxyCodeLine{11162 }
\DoxyCodeLine{11163         std::set<std::string> spellings;}
\DoxyCodeLine{11164         std::size\_t count = 0;}
\DoxyCodeLine{11165     \};}
\DoxyCodeLine{11166 }
\DoxyCodeLine{11167     std::size\_t listTags( \mbox{\hyperlink{struct_config__}{Config}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{11168 }
\DoxyCodeLine{11169     std::size\_t listReporters();}
\DoxyCodeLine{11170 }
\DoxyCodeLine{11171     Option<std::size\_t> list( std::shared\_ptr<Config> \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{11172 }
\DoxyCodeLine{11173 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11174 }
\DoxyCodeLine{11175 \textcolor{comment}{// end catch\_list.h}}
\DoxyCodeLine{11176 \textcolor{comment}{// start catch\_text.h}}
\DoxyCodeLine{11177 }
\DoxyCodeLine{11178 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11179     \textcolor{keyword}{using namespace }clara::TextFlow;}
\DoxyCodeLine{11180 \}}
\DoxyCodeLine{11181 }
\DoxyCodeLine{11182 \textcolor{comment}{// end catch\_text.h}}
\DoxyCodeLine{11183 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{11184 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{11185 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{11186 }
\DoxyCodeLine{11187 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11188 }
\DoxyCodeLine{11189     std::size\_t listTests( \mbox{\hyperlink{struct_config__}{Config}} \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11190         TestSpec \textcolor{keyword}{const}\& testSpec = config.testSpec();}
\DoxyCodeLine{11191         \textcolor{keywordflow}{if}( config.hasTestFilters() )}
\DoxyCodeLine{11192             Catch::cout() << \textcolor{stringliteral}{"{}Matching test cases:\(\backslash\)n"{}};}
\DoxyCodeLine{11193         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11194             Catch::cout() << \textcolor{stringliteral}{"{}All available test cases:\(\backslash\)n"{}};}
\DoxyCodeLine{11195         \}}
\DoxyCodeLine{11196 }
\DoxyCodeLine{11197         \textcolor{keyword}{auto} matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{11198         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo : matchedTestCases ) \{}
\DoxyCodeLine{11199             Colour::Code colour = testCaseInfo.isHidden()}
\DoxyCodeLine{11200                 ? Colour::SecondaryText}
\DoxyCodeLine{11201                 : Colour::None;}
\DoxyCodeLine{11202             Colour colourGuard( colour );}
\DoxyCodeLine{11203 }
\DoxyCodeLine{11204             Catch::cout() << Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{11205             \textcolor{keywordflow}{if}( config.verbosity() >= Verbosity::High ) \{}
\DoxyCodeLine{11206                 Catch::cout() << Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) << std::endl;}
\DoxyCodeLine{11207                 std::string description = testCaseInfo.description;}
\DoxyCodeLine{11208                 \textcolor{keywordflow}{if}( description.empty() )}
\DoxyCodeLine{11209                     description = \textcolor{stringliteral}{"{}(NO DESCRIPTION)"{}};}
\DoxyCodeLine{11210                 Catch::cout() << Column( description ).indent(4) << std::endl;}
\DoxyCodeLine{11211             \}}
\DoxyCodeLine{11212             \textcolor{keywordflow}{if}( !testCaseInfo.tags.empty() )}
\DoxyCodeLine{11213                 Catch::cout() << Column( testCaseInfo.tagsAsString() ).indent( 6 ) << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{11214         \}}
\DoxyCodeLine{11215 }
\DoxyCodeLine{11216         \textcolor{keywordflow}{if}( !config.hasTestFilters() )}
\DoxyCodeLine{11217             Catch::cout() << pluralise( matchedTestCases.size(), \textcolor{stringliteral}{"{}test case"{}} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{11218         \textcolor{keywordflow}{else}}
\DoxyCodeLine{11219             Catch::cout() << pluralise( matchedTestCases.size(), \textcolor{stringliteral}{"{}matching test case"{}} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{11220         \textcolor{keywordflow}{return} matchedTestCases.size();}
\DoxyCodeLine{11221     \}}
\DoxyCodeLine{11222 }
\DoxyCodeLine{11223     std::size\_t listTestsNamesOnly( \mbox{\hyperlink{struct_config__}{Config}} \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11224         TestSpec \textcolor{keyword}{const}\& testSpec = config.testSpec();}
\DoxyCodeLine{11225         std::size\_t matchedTests = 0;}
\DoxyCodeLine{11226         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{11227         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo : matchedTestCases ) \{}
\DoxyCodeLine{11228             matchedTests++;}
\DoxyCodeLine{11229             \textcolor{keywordflow}{if}( startsWith( testCaseInfo.name, \textcolor{charliteral}{'\#'} ) )}
\DoxyCodeLine{11230                Catch::cout() << \textcolor{charliteral}{'"{}'} << testCaseInfo.name << \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{11231             \textcolor{keywordflow}{else}}
\DoxyCodeLine{11232                Catch::cout() << testCaseInfo.name;}
\DoxyCodeLine{11233             \textcolor{keywordflow}{if} ( config.verbosity() >= Verbosity::High )}
\DoxyCodeLine{11234                 Catch::cout() << \textcolor{stringliteral}{"{}\(\backslash\)t@"{}} << testCaseInfo.lineInfo;}
\DoxyCodeLine{11235             Catch::cout() << std::endl;}
\DoxyCodeLine{11236         \}}
\DoxyCodeLine{11237         \textcolor{keywordflow}{return} matchedTests;}
\DoxyCodeLine{11238     \}}
\DoxyCodeLine{11239 }
\DoxyCodeLine{11240     \textcolor{keywordtype}{void} TagInfo::add( std::string \textcolor{keyword}{const}\& spelling ) \{}
\DoxyCodeLine{11241         ++count;}
\DoxyCodeLine{11242         spellings.insert( spelling );}
\DoxyCodeLine{11243     \}}
\DoxyCodeLine{11244 }
\DoxyCodeLine{11245     std::string TagInfo::all()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11246         \textcolor{keywordtype}{size\_t} size = 0;}
\DoxyCodeLine{11247         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& spelling : spellings) \{}
\DoxyCodeLine{11248             \textcolor{comment}{// Add 2 for the brackes}}
\DoxyCodeLine{11249             size += spelling.size() + 2;}
\DoxyCodeLine{11250         \}}
\DoxyCodeLine{11251 }
\DoxyCodeLine{11252         std::string out; out.reserve(size);}
\DoxyCodeLine{11253         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& spelling : spellings) \{}
\DoxyCodeLine{11254             out += '[';}
\DoxyCodeLine{11255             out += spelling;}
\DoxyCodeLine{11256             out += ']';}
\DoxyCodeLine{11257         \}}
\DoxyCodeLine{11258         \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{11259     \}}
\DoxyCodeLine{11260 }
\DoxyCodeLine{11261     std::size\_t listTags( \mbox{\hyperlink{struct_config__}{Config}} \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11262         TestSpec \textcolor{keyword}{const}\& testSpec = config.testSpec();}
\DoxyCodeLine{11263         \textcolor{keywordflow}{if}( config.hasTestFilters() )}
\DoxyCodeLine{11264             Catch::cout() << \textcolor{stringliteral}{"{}Tags for matching test cases:\(\backslash\)n"{}};}
\DoxyCodeLine{11265         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11266             Catch::cout() << \textcolor{stringliteral}{"{}All available tags:\(\backslash\)n"{}};}
\DoxyCodeLine{11267         \}}
\DoxyCodeLine{11268 }
\DoxyCodeLine{11269         std::map<std::string, TagInfo> tagCounts;}
\DoxyCodeLine{11270 }
\DoxyCodeLine{11271         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{11272         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : matchedTestCases ) \{}
\DoxyCodeLine{11273             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& tagName : testCase.getTestCaseInfo().tags ) \{}
\DoxyCodeLine{11274                 std::string lcaseTagName = toLower( tagName );}
\DoxyCodeLine{11275                 \textcolor{keyword}{auto} countIt = tagCounts.find( lcaseTagName );}
\DoxyCodeLine{11276                 \textcolor{keywordflow}{if}( countIt == tagCounts.end() )}
\DoxyCodeLine{11277                     countIt = tagCounts.insert( std::make\_pair( lcaseTagName, TagInfo() ) ).first;}
\DoxyCodeLine{11278                 countIt-\/>second.add( tagName );}
\DoxyCodeLine{11279             \}}
\DoxyCodeLine{11280         \}}
\DoxyCodeLine{11281 }
\DoxyCodeLine{11282         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& tagCount : tagCounts ) \{}
\DoxyCodeLine{11283             ReusableStringStream rss;}
\DoxyCodeLine{11284             rss << \textcolor{stringliteral}{"{}  "{}} << std::setw(2) << tagCount.second.count << \textcolor{stringliteral}{"{}  "{}};}
\DoxyCodeLine{11285             \textcolor{keyword}{auto} str = rss.str();}
\DoxyCodeLine{11286             \textcolor{keyword}{auto} wrapper = Column( tagCount.second.all() )}
\DoxyCodeLine{11287                                                     .initialIndent( 0 )}
\DoxyCodeLine{11288                                                     .indent( str.size() )}
\DoxyCodeLine{11289                                                     .width( CATCH\_CONFIG\_CONSOLE\_WIDTH-\/10 );}
\DoxyCodeLine{11290             Catch::cout() << str << wrapper << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{11291         \}}
\DoxyCodeLine{11292         Catch::cout() << pluralise( tagCounts.size(), \textcolor{stringliteral}{"{}tag"{}} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{11293         \textcolor{keywordflow}{return} tagCounts.size();}
\DoxyCodeLine{11294     \}}
\DoxyCodeLine{11295 }
\DoxyCodeLine{11296     std::size\_t listReporters() \{}
\DoxyCodeLine{11297         Catch::cout() << \textcolor{stringliteral}{"{}Available reporters:\(\backslash\)n"{}};}
\DoxyCodeLine{11298         IReporterRegistry::FactoryMap \textcolor{keyword}{const}\& factories = getRegistryHub().getReporterRegistry().getFactories();}
\DoxyCodeLine{11299         std::size\_t maxNameLen = 0;}
\DoxyCodeLine{11300         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& factoryKvp : factories )}
\DoxyCodeLine{11301             maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );}
\DoxyCodeLine{11302 }
\DoxyCodeLine{11303         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& factoryKvp : factories ) \{}
\DoxyCodeLine{11304             Catch::cout()}
\DoxyCodeLine{11305                     << Column( factoryKvp.first + \textcolor{stringliteral}{"{}:"{}} )}
\DoxyCodeLine{11306                             .indent(2)}
\DoxyCodeLine{11307                             .width( 5+maxNameLen )}
\DoxyCodeLine{11308                     +  Column( factoryKvp.second-\/>getDescription() )}
\DoxyCodeLine{11309                             .initialIndent(0)}
\DoxyCodeLine{11310                             .indent(2)}
\DoxyCodeLine{11311                             .width( CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ maxNameLen-\/8 )}
\DoxyCodeLine{11312                     << "{}\(\backslash\)n"{};}
\DoxyCodeLine{11313         \}}
\DoxyCodeLine{11314         Catch::cout() << std::endl;}
\DoxyCodeLine{11315         \textcolor{keywordflow}{return} factories.size();}
\DoxyCodeLine{11316     \}}
\DoxyCodeLine{11317 }
\DoxyCodeLine{11318     Option<std::size\_t> list( std::shared\_ptr<Config> \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11319         Option<std::size\_t> listedCount;}
\DoxyCodeLine{11320         getCurrentMutableContext().setConfig( config );}
\DoxyCodeLine{11321         \textcolor{keywordflow}{if}( config-\/>listTests() )}
\DoxyCodeLine{11322             listedCount = listedCount.valueOr(0) + listTests( *config );}
\DoxyCodeLine{11323         \textcolor{keywordflow}{if}( config-\/>listTestNamesOnly() )}
\DoxyCodeLine{11324             listedCount = listedCount.valueOr(0) + listTestsNamesOnly( *config );}
\DoxyCodeLine{11325         \textcolor{keywordflow}{if}( config-\/>listTags() )}
\DoxyCodeLine{11326             listedCount = listedCount.valueOr(0) + listTags( *config );}
\DoxyCodeLine{11327         \textcolor{keywordflow}{if}( config-\/>listReporters() )}
\DoxyCodeLine{11328             listedCount = listedCount.valueOr(0) + listReporters();}
\DoxyCodeLine{11329         \textcolor{keywordflow}{return} listedCount;}
\DoxyCodeLine{11330     \}}
\DoxyCodeLine{11331 }
\DoxyCodeLine{11332 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11333 \textcolor{comment}{// end catch\_list.cpp}}
\DoxyCodeLine{11334 \textcolor{comment}{// start catch\_matchers.cpp}}
\DoxyCodeLine{11335 }
\DoxyCodeLine{11336 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11337 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{11338     \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{11339 }
\DoxyCodeLine{11340         std::string MatcherUntypedBase::toString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11341             \textcolor{keywordflow}{if}( m\_cachedToString.empty() )}
\DoxyCodeLine{11342                 m\_cachedToString = describe();}
\DoxyCodeLine{11343             \textcolor{keywordflow}{return} m\_cachedToString;}
\DoxyCodeLine{11344         \}}
\DoxyCodeLine{11345 }
\DoxyCodeLine{11346         MatcherUntypedBase::\string~MatcherUntypedBase() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11347 }
\DoxyCodeLine{11348     \} \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{11349 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{11350 }
\DoxyCodeLine{11351 \textcolor{keyword}{using namespace }Matchers;}
\DoxyCodeLine{11352 \textcolor{keyword}{using} Matchers::Impl::MatcherBase;}
\DoxyCodeLine{11353 }
\DoxyCodeLine{11354 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{11355 \textcolor{comment}{// end catch\_matchers.cpp}}
\DoxyCodeLine{11356 \textcolor{comment}{// start catch\_matchers\_exception.cpp}}
\DoxyCodeLine{11357 }
\DoxyCodeLine{11358 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11359 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{11360 \textcolor{keyword}{namespace }Exception \{}
\DoxyCodeLine{11361 }
\DoxyCodeLine{11362 \textcolor{keywordtype}{bool} ExceptionMessageMatcher::match(std::exception \textcolor{keyword}{const}\& ex)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11363     \textcolor{keywordflow}{return} ex.what() == m\_message;}
\DoxyCodeLine{11364 \}}
\DoxyCodeLine{11365 }
\DoxyCodeLine{11366 std::string ExceptionMessageMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11367     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}exception message matches \(\backslash\)"{}"{}} + m\_message + "{}\(\backslash\)"{}"{};}
\DoxyCodeLine{11368 \}}
\DoxyCodeLine{11369 }
\DoxyCodeLine{11370 \}}
\DoxyCodeLine{11371 Exception::ExceptionMessageMatcher Message(std::string \textcolor{keyword}{const}\& message) \{}
\DoxyCodeLine{11372     \textcolor{keywordflow}{return} Exception::ExceptionMessageMatcher(message);}
\DoxyCodeLine{11373 \}}
\DoxyCodeLine{11374 }
\DoxyCodeLine{11375 \textcolor{comment}{// namespace Exception}}
\DoxyCodeLine{11376 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{11377 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{11378 \textcolor{comment}{// end catch\_matchers\_exception.cpp}}
\DoxyCodeLine{11379 \textcolor{comment}{// start catch\_matchers\_floating.cpp}}
\DoxyCodeLine{11380 }
\DoxyCodeLine{11381 \textcolor{comment}{// start catch\_polyfills.hpp}}
\DoxyCodeLine{11382 }
\DoxyCodeLine{11383 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11384     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{float} f);}
\DoxyCodeLine{11385     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{double} d);}
\DoxyCodeLine{11386 \}}
\DoxyCodeLine{11387 }
\DoxyCodeLine{11388 \textcolor{comment}{// end catch\_polyfills.hpp}}
\DoxyCodeLine{11389 \textcolor{comment}{// start catch\_to\_string.hpp}}
\DoxyCodeLine{11390 }
\DoxyCodeLine{11391 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{11392 }
\DoxyCodeLine{11393 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11394     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{11395     std::string to\_string(T \textcolor{keyword}{const}\& t) \{}
\DoxyCodeLine{11396 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP11\_TO\_STRING)}}
\DoxyCodeLine{11397         \textcolor{keywordflow}{return} std::to\_string(t);}
\DoxyCodeLine{11398 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11399         ReusableStringStream rss;}
\DoxyCodeLine{11400         rss << t;}
\DoxyCodeLine{11401         \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{11402 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11403     \}}
\DoxyCodeLine{11404 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11405 }
\DoxyCodeLine{11406 \textcolor{comment}{// end catch\_to\_string.hpp}}
\DoxyCodeLine{11407 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{11408 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{11409 \textcolor{preprocessor}{\#include <cstdlib>}}
\DoxyCodeLine{11410 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{11411 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{11412 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{11413 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{11414 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{11415 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{11416 }
\DoxyCodeLine{11417 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11418 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{11419 }
\DoxyCodeLine{11420     int32\_t convert(\textcolor{keywordtype}{float} f) \{}
\DoxyCodeLine{11421         \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(float) == \textcolor{keyword}{sizeof}(int32\_t), \textcolor{stringliteral}{"{}Important ULP matcher assumption violated"{}});}
\DoxyCodeLine{11422         int32\_t i;}
\DoxyCodeLine{11423         std::memcpy(\&i, \&f, \textcolor{keyword}{sizeof}(f));}
\DoxyCodeLine{11424         \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{11425     \}}
\DoxyCodeLine{11426 }
\DoxyCodeLine{11427     int64\_t convert(\textcolor{keywordtype}{double} d) \{}
\DoxyCodeLine{11428         \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(double) == \textcolor{keyword}{sizeof}(int64\_t), \textcolor{stringliteral}{"{}Important ULP matcher assumption violated"{}});}
\DoxyCodeLine{11429         int64\_t i;}
\DoxyCodeLine{11430         std::memcpy(\&i, \&d, \textcolor{keyword}{sizeof}(d));}
\DoxyCodeLine{11431         \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{11432     \}}
\DoxyCodeLine{11433 }
\DoxyCodeLine{11434     \textcolor{keyword}{template} <\textcolor{keyword}{typename} FP>}
\DoxyCodeLine{11435     \textcolor{keywordtype}{bool} almostEqualUlps(FP lhs, FP rhs, uint64\_t maxUlpDiff) \{}
\DoxyCodeLine{11436         \textcolor{comment}{// Comparison with NaN should always be false.}}
\DoxyCodeLine{11437         \textcolor{comment}{// This way we can rule it out before getting into the ugly details}}
\DoxyCodeLine{11438         \textcolor{keywordflow}{if} (Catch::isnan(lhs) || Catch::isnan(rhs)) \{}
\DoxyCodeLine{11439             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11440         \}}
\DoxyCodeLine{11441 }
\DoxyCodeLine{11442         \textcolor{keyword}{auto} lc = convert(lhs);}
\DoxyCodeLine{11443         \textcolor{keyword}{auto} rc = convert(rhs);}
\DoxyCodeLine{11444 }
\DoxyCodeLine{11445         \textcolor{keywordflow}{if} ((lc < 0) != (rc < 0)) \{}
\DoxyCodeLine{11446             \textcolor{comment}{// Potentially we can have +0 and -\/0}}
\DoxyCodeLine{11447             \textcolor{keywordflow}{return} lhs == rhs;}
\DoxyCodeLine{11448         \}}
\DoxyCodeLine{11449 }
\DoxyCodeLine{11450         \textcolor{keyword}{auto} ulpDiff = std::abs(lc -\/ rc);}
\DoxyCodeLine{11451         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(ulpDiff) <= maxUlpDiff;}
\DoxyCodeLine{11452     \}}
\DoxyCodeLine{11453 }
\DoxyCodeLine{11454 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_GLOBAL\_NEXTAFTER)}}
\DoxyCodeLine{11455 }
\DoxyCodeLine{11456     \textcolor{keywordtype}{float} nextafter(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y) \{}
\DoxyCodeLine{11457         return ::nextafterf(x, y);}
\DoxyCodeLine{11458     \}}
\DoxyCodeLine{11459 }
\DoxyCodeLine{11460     \textcolor{keywordtype}{double} nextafter(\textcolor{keywordtype}{double} x, \textcolor{keywordtype}{double} y) \{}
\DoxyCodeLine{11461         return ::nextafter(x, y);}
\DoxyCodeLine{11462     \}}
\DoxyCodeLine{11463 }
\DoxyCodeLine{11464 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \string^\string^\string^ CATCH\_CONFIG\_GLOBAL\_NEXTAFTER \string^\string^\string^}}
\DoxyCodeLine{11465 }
\DoxyCodeLine{11466 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FP>}
\DoxyCodeLine{11467 FP step(FP start, FP direction, uint64\_t steps) \{}
\DoxyCodeLine{11468     \textcolor{keywordflow}{for} (uint64\_t i = 0; i < steps; ++i) \{}
\DoxyCodeLine{11469 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_GLOBAL\_NEXTAFTER)}}
\DoxyCodeLine{11470         start = Catch::nextafter(start, direction);}
\DoxyCodeLine{11471 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11472         start = std::nextafter(start, direction);}
\DoxyCodeLine{11473 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11474     \}}
\DoxyCodeLine{11475     \textcolor{keywordflow}{return} start;}
\DoxyCodeLine{11476 \}}
\DoxyCodeLine{11477 }
\DoxyCodeLine{11478 \textcolor{comment}{// Performs equivalent check of std::fabs(lhs -\/ rhs) <= margin}}
\DoxyCodeLine{11479 \textcolor{comment}{// But without the subtraction to allow for INFINITY in comparison}}
\DoxyCodeLine{11480 \textcolor{keywordtype}{bool} marginComparison(\textcolor{keywordtype}{double} lhs, \textcolor{keywordtype}{double} rhs, \textcolor{keywordtype}{double} margin) \{}
\DoxyCodeLine{11481     \textcolor{keywordflow}{return} (lhs + margin >= rhs) \&\& (rhs + margin >= lhs);}
\DoxyCodeLine{11482 \}}
\DoxyCodeLine{11483 }
\DoxyCodeLine{11484 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FloatingPo\textcolor{keywordtype}{int}>}
\DoxyCodeLine{11485 \textcolor{keywordtype}{void} write(std::ostream\& out, FloatingPoint num) \{}
\DoxyCodeLine{11486     out << std::scientific}
\DoxyCodeLine{11487         << std::setprecision(std::numeric\_limits<FloatingPoint>::max\_digits10 -\/ 1)}
\DoxyCodeLine{11488         << num;}
\DoxyCodeLine{11489 \}}
\DoxyCodeLine{11490 }
\DoxyCodeLine{11491 \} \textcolor{comment}{// end anonymous namespace}}
\DoxyCodeLine{11492 }
\DoxyCodeLine{11493 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{11494 \textcolor{keyword}{namespace }Floating \{}
\DoxyCodeLine{11495 }
\DoxyCodeLine{11496     \textcolor{keyword}{enum class} FloatingPointKind : uint8\_t \{}
\DoxyCodeLine{11497         Float,}
\DoxyCodeLine{11498         Double}
\DoxyCodeLine{11499     \};}
\DoxyCodeLine{11500 }
\DoxyCodeLine{11501     WithinAbsMatcher::WithinAbsMatcher(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} margin)}
\DoxyCodeLine{11502         :m\_target\{ target \}, m\_margin\{ margin \} \{}
\DoxyCodeLine{11503         CATCH\_ENFORCE(margin >= 0, \textcolor{stringliteral}{"{}Invalid margin: "{}} << margin << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{11504             << \textcolor{stringliteral}{"{} Margin has to be non-\/negative."{}});}
\DoxyCodeLine{11505     \}}
\DoxyCodeLine{11506 }
\DoxyCodeLine{11507     \textcolor{comment}{// Performs equivalent check of std::fabs(lhs -\/ rhs) <= margin}}
\DoxyCodeLine{11508     \textcolor{comment}{// But without the subtraction to allow for INFINITY in comparison}}
\DoxyCodeLine{11509     \textcolor{keywordtype}{bool} WithinAbsMatcher::match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11510         \textcolor{keywordflow}{return} (matchee + m\_margin >= m\_target) \&\& (m\_target + m\_margin >= matchee);}
\DoxyCodeLine{11511     \}}
\DoxyCodeLine{11512 }
\DoxyCodeLine{11513     std::string WithinAbsMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11514         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is within "{}} + ::Catch::Detail::stringify(m\_margin) + "{} of "{} + ::Catch::Detail::stringify(m\_target);}
\DoxyCodeLine{11515     \}}
\DoxyCodeLine{11516 }
\DoxyCodeLine{11517     WithinUlpsMatcher::WithinUlpsMatcher(\textcolor{keywordtype}{double} target, uint64\_t ulps, FloatingPointKind baseType)}
\DoxyCodeLine{11518         :m\_target\{ target \}, m\_ulps\{ ulps \}, m\_type\{ baseType \} \{}
\DoxyCodeLine{11519         CATCH\_ENFORCE(m\_type == FloatingPointKind::Double}
\DoxyCodeLine{11520                    || m\_ulps < (std::numeric\_limits<uint32\_t>::max)(),}
\DoxyCodeLine{11521             \textcolor{stringliteral}{"{}Provided ULP is impossibly large for a float comparison."{}});}
\DoxyCodeLine{11522     \}}
\DoxyCodeLine{11523 }
\DoxyCodeLine{11524 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{11525 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{11526 \textcolor{comment}{// Clang <3.5 reports on the default branch in the switch below}}
\DoxyCodeLine{11527 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wunreachable-\/code"{}}}
\DoxyCodeLine{11528 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11529 }
\DoxyCodeLine{11530     \textcolor{keywordtype}{bool} WithinUlpsMatcher::match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11531         \textcolor{keywordflow}{switch} (m\_type) \{}
\DoxyCodeLine{11532         \textcolor{keywordflow}{case} FloatingPointKind::Float:}
\DoxyCodeLine{11533             \textcolor{keywordflow}{return} almostEqualUlps<float>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(matchee), \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(m\_target), m\_ulps);}
\DoxyCodeLine{11534         \textcolor{keywordflow}{case} FloatingPointKind::Double:}
\DoxyCodeLine{11535             \textcolor{keywordflow}{return} almostEqualUlps<double>(matchee, m\_target, m\_ulps);}
\DoxyCodeLine{11536         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{11537             CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Unknown FloatingPointKind value"{}} );}
\DoxyCodeLine{11538         \}}
\DoxyCodeLine{11539     \}}
\DoxyCodeLine{11540 }
\DoxyCodeLine{11541 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{11542 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{11543 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11544 }
\DoxyCodeLine{11545     std::string WithinUlpsMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11546         std::stringstream ret;}
\DoxyCodeLine{11547 }
\DoxyCodeLine{11548         ret << \textcolor{stringliteral}{"{}is within "{}} << m\_ulps << \textcolor{stringliteral}{"{} ULPs of "{}};}
\DoxyCodeLine{11549 }
\DoxyCodeLine{11550         \textcolor{keywordflow}{if} (m\_type == FloatingPointKind::Float) \{}
\DoxyCodeLine{11551             write(ret, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(m\_target));}
\DoxyCodeLine{11552             ret << \textcolor{charliteral}{'f'};}
\DoxyCodeLine{11553         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11554             write(ret, m\_target);}
\DoxyCodeLine{11555         \}}
\DoxyCodeLine{11556 }
\DoxyCodeLine{11557         ret << \textcolor{stringliteral}{"{} (["{}};}
\DoxyCodeLine{11558         \textcolor{keywordflow}{if} (m\_type == FloatingPointKind::Double) \{}
\DoxyCodeLine{11559             write(ret, step(m\_target, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(-\/INFINITY), m\_ulps));}
\DoxyCodeLine{11560             ret << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{11561             write(ret, step(m\_target, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}( INFINITY), m\_ulps));}
\DoxyCodeLine{11562         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11563             \textcolor{comment}{// We have to cast INFINITY to float because of MinGW, see \#1782}}
\DoxyCodeLine{11564             write(ret, step(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(m\_target), \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(-\/INFINITY), m\_ulps));}
\DoxyCodeLine{11565             ret << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{11566             write(ret, step(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(m\_target), \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}( INFINITY), m\_ulps));}
\DoxyCodeLine{11567         \}}
\DoxyCodeLine{11568         ret << \textcolor{stringliteral}{"{}])"{}};}
\DoxyCodeLine{11569 }
\DoxyCodeLine{11570         \textcolor{keywordflow}{return} ret.str();}
\DoxyCodeLine{11571     \}}
\DoxyCodeLine{11572 }
\DoxyCodeLine{11573     WithinRelMatcher::WithinRelMatcher(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} epsilon):}
\DoxyCodeLine{11574         m\_target(target),}
\DoxyCodeLine{11575         m\_epsilon(epsilon)\{}
\DoxyCodeLine{11576         CATCH\_ENFORCE(m\_epsilon >= 0., \textcolor{stringliteral}{"{}Relative comparison with epsilon <  0 does not make sense."{}});}
\DoxyCodeLine{11577         CATCH\_ENFORCE(m\_epsilon  < 1., "{}Relative comparison with epsilon >= 1 does not make sense.\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{11578 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{11579 \textcolor{stringliteral}{}}
\DoxyCodeLine{11580 \textcolor{stringliteral}{    bool WithinRelMatcher::match(double const\& matchee) const \{}}
\DoxyCodeLine{11581 \textcolor{stringliteral}{        const auto relMargin = m\_epsilon * (std::max)(std::fabs(matchee), std::fabs(m\_target));}}
\DoxyCodeLine{11582 \textcolor{stringliteral}{        return marginComparison(matchee, m\_target,}}
\DoxyCodeLine{11583 \textcolor{stringliteral}{                                std::isinf(relMargin)? 0 : relMargin);}}
\DoxyCodeLine{11584 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{11585 \textcolor{stringliteral}{}}
\DoxyCodeLine{11586 \textcolor{stringliteral}{    std::string WithinRelMatcher::describe() const \{}}
\DoxyCodeLine{11587 \textcolor{stringliteral}{        Catch::ReusableStringStream sstr;}}
\DoxyCodeLine{11588 \textcolor{stringliteral}{        sstr << "{}}and \textcolor{stringliteral}{"{} << m\_target << "{}} are within \textcolor{stringliteral}{"{} << m\_epsilon * 100. << "{}}\% of each other\textcolor{stringliteral}{"{};}}
\DoxyCodeLine{11589 \textcolor{stringliteral}{        return sstr.str();}}
\DoxyCodeLine{11590 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{11591 \textcolor{stringliteral}{}}
\DoxyCodeLine{11592 \textcolor{stringliteral}{\}// namespace Floating}}
\DoxyCodeLine{11593 \textcolor{stringliteral}{}}
\DoxyCodeLine{11594 \textcolor{stringliteral}{Floating::WithinUlpsMatcher WithinULP(double target, uint64\_t maxUlpDiff) \{}}
\DoxyCodeLine{11595 \textcolor{stringliteral}{    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);}}
\DoxyCodeLine{11596 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11597 \textcolor{stringliteral}{}}
\DoxyCodeLine{11598 \textcolor{stringliteral}{Floating::WithinUlpsMatcher WithinULP(float target, uint64\_t maxUlpDiff) \{}}
\DoxyCodeLine{11599 \textcolor{stringliteral}{    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);}}
\DoxyCodeLine{11600 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11601 \textcolor{stringliteral}{}}
\DoxyCodeLine{11602 \textcolor{stringliteral}{Floating::WithinAbsMatcher WithinAbs(double target, double margin) \{}}
\DoxyCodeLine{11603 \textcolor{stringliteral}{    return Floating::WithinAbsMatcher(target, margin);}}
\DoxyCodeLine{11604 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11605 \textcolor{stringliteral}{}}
\DoxyCodeLine{11606 \textcolor{stringliteral}{Floating::WithinRelMatcher WithinRel(double target, double eps) \{}}
\DoxyCodeLine{11607 \textcolor{stringliteral}{    return Floating::WithinRelMatcher(target, eps);}}
\DoxyCodeLine{11608 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11609 \textcolor{stringliteral}{}}
\DoxyCodeLine{11610 \textcolor{stringliteral}{Floating::WithinRelMatcher WithinRel(double target) \{}}
\DoxyCodeLine{11611 \textcolor{stringliteral}{    return Floating::WithinRelMatcher(target, std::numeric\_limits<double>::epsilon() * 100);}}
\DoxyCodeLine{11612 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11613 \textcolor{stringliteral}{}}
\DoxyCodeLine{11614 \textcolor{stringliteral}{Floating::WithinRelMatcher WithinRel(float target, float eps) \{}}
\DoxyCodeLine{11615 \textcolor{stringliteral}{    return Floating::WithinRelMatcher(target, eps);}}
\DoxyCodeLine{11616 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11617 \textcolor{stringliteral}{}}
\DoxyCodeLine{11618 \textcolor{stringliteral}{Floating::WithinRelMatcher WithinRel(float target) \{}}
\DoxyCodeLine{11619 \textcolor{stringliteral}{    return Floating::WithinRelMatcher(target, std::numeric\_limits<float>::epsilon() * 100);}}
\DoxyCodeLine{11620 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11621 \textcolor{stringliteral}{}}
\DoxyCodeLine{11622 \textcolor{stringliteral}{\} // namespace Matchers}}
\DoxyCodeLine{11623 \textcolor{stringliteral}{\} // namespace Catch}}
\DoxyCodeLine{11624 \textcolor{stringliteral}{}}
\DoxyCodeLine{11625 \textcolor{stringliteral}{// end catch\_matchers\_floating.cpp}}
\DoxyCodeLine{11626 \textcolor{stringliteral}{// start catch\_matchers\_generic.cpp}}
\DoxyCodeLine{11627 \textcolor{stringliteral}{}}
\DoxyCodeLine{11628 \textcolor{stringliteral}{std::string Catch::Matchers::Generic::Detail::finalizeDescription(const std::string\& desc) \{}}
\DoxyCodeLine{11629 \textcolor{stringliteral}{    if (desc.empty()) \{}}
\DoxyCodeLine{11630 \textcolor{stringliteral}{        return "{}}matches undescribed predicate\textcolor{stringliteral}{"{};}}
\DoxyCodeLine{11631 \textcolor{stringliteral}{    \} else \{}}
\DoxyCodeLine{11632 \textcolor{stringliteral}{        return "{}}matches predicate: \(\backslash\)\textcolor{stringliteral}{"{}"{}} + desc + \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{11633     \}}
\DoxyCodeLine{11634 \}}
\DoxyCodeLine{11635 \textcolor{comment}{// end catch\_matchers\_generic.cpp}}
\DoxyCodeLine{11636 \textcolor{comment}{// start catch\_matchers\_string.cpp}}
\DoxyCodeLine{11637 }
\DoxyCodeLine{11638 \textcolor{preprocessor}{\#include <regex>}}
\DoxyCodeLine{11639 }
\DoxyCodeLine{11640 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11641 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{11642 }
\DoxyCodeLine{11643     \textcolor{keyword}{namespace }StdString \{}
\DoxyCodeLine{11644 }
\DoxyCodeLine{11645         CasedString::CasedString( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity )}
\DoxyCodeLine{11646         :   m\_caseSensitivity( caseSensitivity ),}
\DoxyCodeLine{11647             m\_str( adjustString( str ) )}
\DoxyCodeLine{11648         \{\}}
\DoxyCodeLine{11649         std::string CasedString::adjustString( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11650             \textcolor{keywordflow}{return} m\_caseSensitivity == CaseSensitive::No}
\DoxyCodeLine{11651                    ? toLower( str )}
\DoxyCodeLine{11652                    : str;}
\DoxyCodeLine{11653         \}}
\DoxyCodeLine{11654         std::string CasedString::caseSensitivitySuffix()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11655             \textcolor{keywordflow}{return} m\_caseSensitivity == CaseSensitive::No}
\DoxyCodeLine{11656                    ? \textcolor{stringliteral}{"{} (case insensitive)"{}}}
\DoxyCodeLine{11657                    : std::string();}
\DoxyCodeLine{11658         \}}
\DoxyCodeLine{11659 }
\DoxyCodeLine{11660         StringMatcherBase::StringMatcherBase( std::string \textcolor{keyword}{const}\& operation, CasedString \textcolor{keyword}{const}\& comparator )}
\DoxyCodeLine{11661         : m\_comparator( comparator ),}
\DoxyCodeLine{11662           m\_operation( operation ) \{}
\DoxyCodeLine{11663         \}}
\DoxyCodeLine{11664 }
\DoxyCodeLine{11665         std::string StringMatcherBase::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11666             std::string description;}
\DoxyCodeLine{11667             description.reserve(5 + m\_operation.size() + m\_comparator.m\_str.size() +}
\DoxyCodeLine{11668                                         m\_comparator.caseSensitivitySuffix().size());}
\DoxyCodeLine{11669             description += m\_operation;}
\DoxyCodeLine{11670             description += "{}: \(\backslash\)"{}"{};}
\DoxyCodeLine{11671             description += m\_comparator.m\_str;}
\DoxyCodeLine{11672             description += "{}\(\backslash\)"{}"{};}
\DoxyCodeLine{11673             description += m\_comparator.caseSensitivitySuffix();}
\DoxyCodeLine{11674             \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{11675         \}}
\DoxyCodeLine{11676 }
\DoxyCodeLine{11677         EqualsMatcher::EqualsMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}equals"{}}, comparator ) \{\}}
\DoxyCodeLine{11678 }
\DoxyCodeLine{11679         \textcolor{keywordtype}{bool} EqualsMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11680             \textcolor{keywordflow}{return} m\_comparator.adjustString( source ) == m\_comparator.m\_str;}
\DoxyCodeLine{11681         \}}
\DoxyCodeLine{11682 }
\DoxyCodeLine{11683         ContainsMatcher::ContainsMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}contains"{}}, comparator ) \{\}}
\DoxyCodeLine{11684 }
\DoxyCodeLine{11685         \textcolor{keywordtype}{bool} ContainsMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11686             \textcolor{keywordflow}{return} contains( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{11687         \}}
\DoxyCodeLine{11688 }
\DoxyCodeLine{11689         StartsWithMatcher::StartsWithMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}starts with"{}}, comparator ) \{\}}
\DoxyCodeLine{11690 }
\DoxyCodeLine{11691         \textcolor{keywordtype}{bool} StartsWithMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11692             \textcolor{keywordflow}{return} startsWith( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{11693         \}}
\DoxyCodeLine{11694 }
\DoxyCodeLine{11695         EndsWithMatcher::EndsWithMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}ends with"{}}, comparator ) \{\}}
\DoxyCodeLine{11696 }
\DoxyCodeLine{11697         \textcolor{keywordtype}{bool} EndsWithMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11698             \textcolor{keywordflow}{return} endsWith( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{11699         \}}
\DoxyCodeLine{11700 }
\DoxyCodeLine{11701         RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m\_regex(std::move(regex)), m\_caseSensitivity(caseSensitivity) \{\}}
\DoxyCodeLine{11702 }
\DoxyCodeLine{11703         \textcolor{keywordtype}{bool} RegexMatcher::match(std::string \textcolor{keyword}{const}\& matchee)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11704             \textcolor{keyword}{auto} flags = std::regex::ECMAScript; \textcolor{comment}{// ECMAScript is the default syntax option anyway}}
\DoxyCodeLine{11705             \textcolor{keywordflow}{if} (m\_caseSensitivity == CaseSensitive::Choice::No) \{}
\DoxyCodeLine{11706                 flags |= std::regex::icase;}
\DoxyCodeLine{11707             \}}
\DoxyCodeLine{11708             \textcolor{keyword}{auto} reg = std::regex(m\_regex, flags);}
\DoxyCodeLine{11709             \textcolor{keywordflow}{return} std::regex\_match(matchee, reg);}
\DoxyCodeLine{11710         \}}
\DoxyCodeLine{11711 }
\DoxyCodeLine{11712         std::string RegexMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11713             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}matches "{}} + ::Catch::Detail::stringify(m\_regex) + ((m\_caseSensitivity == CaseSensitive::Choice::Yes)? "{} case sensitively"{} : "{} case insensitively"{});}
\DoxyCodeLine{11714         \}}
\DoxyCodeLine{11715 }
\DoxyCodeLine{11716     \} \textcolor{comment}{// namespace StdString}}
\DoxyCodeLine{11717 }
\DoxyCodeLine{11718     StdString::EqualsMatcher Equals( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{11719         \textcolor{keywordflow}{return} StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{11720     \}}
\DoxyCodeLine{11721     StdString::ContainsMatcher Contains( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{11722         \textcolor{keywordflow}{return} StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{11723     \}}
\DoxyCodeLine{11724     StdString::EndsWithMatcher EndsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{11725         \textcolor{keywordflow}{return} StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{11726     \}}
\DoxyCodeLine{11727     StdString::StartsWithMatcher StartsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{11728         \textcolor{keywordflow}{return} StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{11729     \}}
\DoxyCodeLine{11730 }
\DoxyCodeLine{11731     StdString::RegexMatcher Matches(std::string \textcolor{keyword}{const}\& regex, CaseSensitive::Choice caseSensitivity) \{}
\DoxyCodeLine{11732         \textcolor{keywordflow}{return} StdString::RegexMatcher(regex, caseSensitivity);}
\DoxyCodeLine{11733     \}}
\DoxyCodeLine{11734 }
\DoxyCodeLine{11735 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{11736 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{11737 \textcolor{comment}{// end catch\_matchers\_string.cpp}}
\DoxyCodeLine{11738 \textcolor{comment}{// start catch\_message.cpp}}
\DoxyCodeLine{11739 }
\DoxyCodeLine{11740 \textcolor{comment}{// start catch\_uncaught\_exceptions.h}}
\DoxyCodeLine{11741 }
\DoxyCodeLine{11742 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11743     \textcolor{keywordtype}{bool} uncaught\_exceptions();}
\DoxyCodeLine{11744 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11745 }
\DoxyCodeLine{11746 \textcolor{comment}{// end catch\_uncaught\_exceptions.h}}
\DoxyCodeLine{11747 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{11748 \textcolor{preprocessor}{\#include <stack>}}
\DoxyCodeLine{11749 }
\DoxyCodeLine{11750 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11751 }
\DoxyCodeLine{11752     MessageInfo::MessageInfo(   StringRef \textcolor{keyword}{const}\& \_macroName,}
\DoxyCodeLine{11753                                 SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{11754                                 ResultWas::OfType \_type )}
\DoxyCodeLine{11755     :   macroName( \_macroName ),}
\DoxyCodeLine{11756         lineInfo( \_lineInfo ),}
\DoxyCodeLine{11757         type( \_type ),}
\DoxyCodeLine{11758         sequence( ++globalCount )}
\DoxyCodeLine{11759     \{\}}
\DoxyCodeLine{11760 }
\DoxyCodeLine{11761     \textcolor{keywordtype}{bool} MessageInfo::operator==( MessageInfo \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11762         \textcolor{keywordflow}{return} sequence == other.sequence;}
\DoxyCodeLine{11763     \}}
\DoxyCodeLine{11764 }
\DoxyCodeLine{11765     \textcolor{keywordtype}{bool} MessageInfo::operator<( MessageInfo \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11766         \textcolor{keywordflow}{return} sequence < other.sequence;}
\DoxyCodeLine{11767     \}}
\DoxyCodeLine{11768 }
\DoxyCodeLine{11769     \textcolor{comment}{// This may need protecting if threading support is added}}
\DoxyCodeLine{11770     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} MessageInfo::globalCount = 0;}
\DoxyCodeLine{11771 }
\DoxyCodeLine{11773 }
\DoxyCodeLine{11774     Catch::MessageBuilder::MessageBuilder( StringRef \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{11775                                            SourceLineInfo \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{11776                                            ResultWas::OfType type )}
\DoxyCodeLine{11777         :m\_info(macroName, lineInfo, type) \{\}}
\DoxyCodeLine{11778 }
\DoxyCodeLine{11780 }
\DoxyCodeLine{11781     ScopedMessage::ScopedMessage( MessageBuilder \textcolor{keyword}{const}\& builder )}
\DoxyCodeLine{11782     : m\_info( builder.m\_info ), m\_moved()}
\DoxyCodeLine{11783     \{}
\DoxyCodeLine{11784         m\_info.message = builder.m\_stream.str();}
\DoxyCodeLine{11785         getResultCapture().pushScopedMessage( m\_info );}
\DoxyCodeLine{11786     \}}
\DoxyCodeLine{11787 }
\DoxyCodeLine{11788     ScopedMessage::ScopedMessage( ScopedMessage\&\& old )}
\DoxyCodeLine{11789     : m\_info( old.m\_info ), m\_moved()}
\DoxyCodeLine{11790     \{}
\DoxyCodeLine{11791         old.m\_moved = \textcolor{keyword}{true};}
\DoxyCodeLine{11792     \}}
\DoxyCodeLine{11793 }
\DoxyCodeLine{11794     ScopedMessage::\string~ScopedMessage() \{}
\DoxyCodeLine{11795         \textcolor{keywordflow}{if} ( !uncaught\_exceptions() \&\& !m\_moved )\{}
\DoxyCodeLine{11796             getResultCapture().popScopedMessage(m\_info);}
\DoxyCodeLine{11797         \}}
\DoxyCodeLine{11798     \}}
\DoxyCodeLine{11799 }
\DoxyCodeLine{11800     Capturer::Capturer( StringRef macroName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo, ResultWas::OfType resultType, StringRef names ) \{}
\DoxyCodeLine{11801         \textcolor{keyword}{auto} trimmed = [\&] (\textcolor{keywordtype}{size\_t} start, \textcolor{keywordtype}{size\_t} end) \{}
\DoxyCodeLine{11802             \textcolor{keywordflow}{while} (names[start] == \textcolor{charliteral}{','} || isspace(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(names[start]))) \{}
\DoxyCodeLine{11803                 ++start;}
\DoxyCodeLine{11804             \}}
\DoxyCodeLine{11805             \textcolor{keywordflow}{while} (names[end] == \textcolor{charliteral}{','} || isspace(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(names[end]))) \{}
\DoxyCodeLine{11806                 -\/-\/end;}
\DoxyCodeLine{11807             \}}
\DoxyCodeLine{11808             \textcolor{keywordflow}{return} names.substr(start, end -\/ start + 1);}
\DoxyCodeLine{11809         \};}
\DoxyCodeLine{11810         \textcolor{keyword}{auto} skipq = [\&] (\textcolor{keywordtype}{size\_t} start, \textcolor{keywordtype}{char} quote) \{}
\DoxyCodeLine{11811             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = start + 1; i < names.size() ; ++i) \{}
\DoxyCodeLine{11812                 \textcolor{keywordflow}{if} (names[i] == quote)}
\DoxyCodeLine{11813                     \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{11814                 \textcolor{keywordflow}{if} (names[i] == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'})}
\DoxyCodeLine{11815                     ++i;}
\DoxyCodeLine{11816             \}}
\DoxyCodeLine{11817             CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}CAPTURE parsing encountered unmatched quote"{}});}
\DoxyCodeLine{11818         \};}
\DoxyCodeLine{11819 }
\DoxyCodeLine{11820         \textcolor{keywordtype}{size\_t} start = 0;}
\DoxyCodeLine{11821         std::stack<char> openings;}
\DoxyCodeLine{11822         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} pos = 0; pos < names.size(); ++pos) \{}
\DoxyCodeLine{11823             \textcolor{keywordtype}{char} c = names[pos];}
\DoxyCodeLine{11824             \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{11825             \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}:}
\DoxyCodeLine{11826             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\{'}:}
\DoxyCodeLine{11827             \textcolor{keywordflow}{case} \textcolor{charliteral}{'('}:}
\DoxyCodeLine{11828             \textcolor{comment}{// It is basically impossible to disambiguate between}}
\DoxyCodeLine{11829             \textcolor{comment}{// comparison and start of template args in this context}}
\DoxyCodeLine{11830 \textcolor{comment}{//            case '<':}}
\DoxyCodeLine{11831                 openings.push(c);}
\DoxyCodeLine{11832                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11833             \textcolor{keywordflow}{case} \textcolor{charliteral}{']'}:}
\DoxyCodeLine{11834             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\}'}:}
\DoxyCodeLine{11835             \textcolor{keywordflow}{case} \textcolor{charliteral}{')'}:}
\DoxyCodeLine{11836 \textcolor{comment}{//           case '>':}}
\DoxyCodeLine{11837                 openings.pop();}
\DoxyCodeLine{11838                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11839             \textcolor{keywordflow}{case} \textcolor{charliteral}{'"{}'}:}
\DoxyCodeLine{11840             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)''}:}
\DoxyCodeLine{11841                 pos = skipq(pos, c);}
\DoxyCodeLine{11842                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11843             \textcolor{keywordflow}{case} \textcolor{charliteral}{','}:}
\DoxyCodeLine{11844                 \textcolor{keywordflow}{if} (start != pos \&\& openings.empty()) \{}
\DoxyCodeLine{11845                     m\_messages.emplace\_back(macroName, lineInfo, resultType);}
\DoxyCodeLine{11846                     m\_messages.back().message = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(trimmed(start, pos));}
\DoxyCodeLine{11847                     m\_messages.back().message += "{} := "{};}
\DoxyCodeLine{11848                     start = pos;}
\DoxyCodeLine{11849                 \}}
\DoxyCodeLine{11850             \}}
\DoxyCodeLine{11851         \}}
\DoxyCodeLine{11852         assert(openings.empty() \&\& \textcolor{stringliteral}{"{}Mismatched openings"{}});}
\DoxyCodeLine{11853         m\_messages.emplace\_back(macroName, lineInfo, resultType);}
\DoxyCodeLine{11854         m\_messages.back().message = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(trimmed(start, names.size() -\/ 1));}
\DoxyCodeLine{11855         m\_messages.back().message += "{} := "{};}
\DoxyCodeLine{11856     \}}
\DoxyCodeLine{11857     Capturer::\string~Capturer() \{}
\DoxyCodeLine{11858         \textcolor{keywordflow}{if} ( !uncaught\_exceptions() )\{}
\DoxyCodeLine{11859             assert( m\_captured == m\_messages.size() );}
\DoxyCodeLine{11860             \textcolor{keywordflow}{for}( \textcolor{keywordtype}{size\_t} i = 0; i < m\_captured; ++i  )}
\DoxyCodeLine{11861                 m\_resultCapture.popScopedMessage( m\_messages[i] );}
\DoxyCodeLine{11862         \}}
\DoxyCodeLine{11863     \}}
\DoxyCodeLine{11864 }
\DoxyCodeLine{11865     \textcolor{keywordtype}{void} Capturer::captureValue( \textcolor{keywordtype}{size\_t} index, std::string \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{11866         assert( index < m\_messages.size() );}
\DoxyCodeLine{11867         m\_messages[index].message += value;}
\DoxyCodeLine{11868         m\_resultCapture.pushScopedMessage( m\_messages[index] );}
\DoxyCodeLine{11869         m\_captured++;}
\DoxyCodeLine{11870     \}}
\DoxyCodeLine{11871 }
\DoxyCodeLine{11872 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11873 \textcolor{comment}{// end catch\_message.cpp}}
\DoxyCodeLine{11874 \textcolor{comment}{// start catch\_output\_redirect.cpp}}
\DoxyCodeLine{11875 }
\DoxyCodeLine{11876 \textcolor{comment}{// start catch\_output\_redirect.h}}
\DoxyCodeLine{11877 \textcolor{preprocessor}{\#ifndef TWOBLUECUBES\_CATCH\_OUTPUT\_REDIRECT\_H}}
\DoxyCodeLine{11878 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_OUTPUT\_REDIRECT\_H}}
\DoxyCodeLine{11879 }
\DoxyCodeLine{11880 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{11881 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{11882 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{11883 }
\DoxyCodeLine{11884 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11885 }
\DoxyCodeLine{11886     \textcolor{keyword}{class }RedirectedStream \{}
\DoxyCodeLine{11887         std::ostream\& m\_originalStream;}
\DoxyCodeLine{11888         std::ostream\& m\_redirectionStream;}
\DoxyCodeLine{11889         std::streambuf* m\_prevBuf;}
\DoxyCodeLine{11890 }
\DoxyCodeLine{11891     \textcolor{keyword}{public}:}
\DoxyCodeLine{11892         RedirectedStream( std::ostream\& originalStream, std::ostream\& redirectionStream );}
\DoxyCodeLine{11893         \string~RedirectedStream();}
\DoxyCodeLine{11894     \};}
\DoxyCodeLine{11895 }
\DoxyCodeLine{11896     \textcolor{keyword}{class }RedirectedStdOut \{}
\DoxyCodeLine{11897         ReusableStringStream m\_rss;}
\DoxyCodeLine{11898         RedirectedStream m\_cout;}
\DoxyCodeLine{11899     \textcolor{keyword}{public}:}
\DoxyCodeLine{11900         RedirectedStdOut();}
\DoxyCodeLine{11901         \textcolor{keyword}{auto} str() const -\/> std::\textcolor{keywordtype}{string};}
\DoxyCodeLine{11902     \};}
\DoxyCodeLine{11903 }
\DoxyCodeLine{11904     \textcolor{comment}{// StdErr has two constituent streams in C++, std::cerr and std::clog}}
\DoxyCodeLine{11905     \textcolor{comment}{// This means that we need to redirect 2 streams into 1 to keep proper}}
\DoxyCodeLine{11906     \textcolor{comment}{// order of writes}}
\DoxyCodeLine{11907     class RedirectedStdErr \{}
\DoxyCodeLine{11908         ReusableStringStream m\_rss;}
\DoxyCodeLine{11909         RedirectedStream m\_cerr;}
\DoxyCodeLine{11910         RedirectedStream m\_clog;}
\DoxyCodeLine{11911     \textcolor{keyword}{public}:}
\DoxyCodeLine{11912         RedirectedStdErr();}
\DoxyCodeLine{11913         \textcolor{keyword}{auto} str() const -\/> std::\textcolor{keywordtype}{string};}
\DoxyCodeLine{11914     \};}
\DoxyCodeLine{11915 }
\DoxyCodeLine{11916     class RedirectedStreams \{}
\DoxyCodeLine{11917     \textcolor{keyword}{public}:}
\DoxyCodeLine{11918         RedirectedStreams(RedirectedStreams \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11919         RedirectedStreams\& operator=(RedirectedStreams \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11920         RedirectedStreams(RedirectedStreams\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11921         RedirectedStreams\& operator=(RedirectedStreams\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11922 }
\DoxyCodeLine{11923         RedirectedStreams(std::string\& redirectedCout, std::string\& redirectedCerr);}
\DoxyCodeLine{11924         \string~RedirectedStreams();}
\DoxyCodeLine{11925     \textcolor{keyword}{private}:}
\DoxyCodeLine{11926         std::string\& m\_redirectedCout;}
\DoxyCodeLine{11927         std::string\& m\_redirectedCerr;}
\DoxyCodeLine{11928         RedirectedStdOut m\_redirectedStdOut;}
\DoxyCodeLine{11929         RedirectedStdErr m\_redirectedStdErr;}
\DoxyCodeLine{11930     \};}
\DoxyCodeLine{11931 }
\DoxyCodeLine{11932 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{11933 }
\DoxyCodeLine{11934     \textcolor{comment}{// Windows's implementation of std::tmpfile is terrible (it tries}}
\DoxyCodeLine{11935     \textcolor{comment}{// to create a file inside system folder, thus requiring elevated}}
\DoxyCodeLine{11936     \textcolor{comment}{// privileges for the binary), so we have to use tmpnam(\_s) and}}
\DoxyCodeLine{11937     \textcolor{comment}{// create the file ourselves there.}}
\DoxyCodeLine{11938     \textcolor{keyword}{class }TempFile \{}
\DoxyCodeLine{11939     \textcolor{keyword}{public}:}
\DoxyCodeLine{11940         TempFile(TempFile \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11941         TempFile\& operator=(TempFile \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11942         TempFile(TempFile\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11943         TempFile\& operator=(TempFile\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11944 }
\DoxyCodeLine{11945         TempFile();}
\DoxyCodeLine{11946         \string~TempFile();}
\DoxyCodeLine{11947 }
\DoxyCodeLine{11948         std::FILE* getFile();}
\DoxyCodeLine{11949         std::string getContents();}
\DoxyCodeLine{11950 }
\DoxyCodeLine{11951     \textcolor{keyword}{private}:}
\DoxyCodeLine{11952         std::FILE* m\_file = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{11953 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{11954         \textcolor{keywordtype}{char} m\_buffer[L\_tmpnam] = \{ 0 \};}
\DoxyCodeLine{11955 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{11956     \};}
\DoxyCodeLine{11957 }
\DoxyCodeLine{11958     \textcolor{keyword}{class }OutputRedirect \{}
\DoxyCodeLine{11959     \textcolor{keyword}{public}:}
\DoxyCodeLine{11960         OutputRedirect(OutputRedirect \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11961         OutputRedirect\& operator=(OutputRedirect \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11962         OutputRedirect(OutputRedirect\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11963         OutputRedirect\& operator=(OutputRedirect\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11964 }
\DoxyCodeLine{11965         OutputRedirect(std::string\& stdout\_dest, std::string\& stderr\_dest);}
\DoxyCodeLine{11966         \string~OutputRedirect();}
\DoxyCodeLine{11967 }
\DoxyCodeLine{11968     \textcolor{keyword}{private}:}
\DoxyCodeLine{11969         \textcolor{keywordtype}{int} m\_originalStdout = -\/1;}
\DoxyCodeLine{11970         \textcolor{keywordtype}{int} m\_originalStderr = -\/1;}
\DoxyCodeLine{11971         TempFile m\_stdoutFile;}
\DoxyCodeLine{11972         TempFile m\_stderrFile;}
\DoxyCodeLine{11973         std::string\& m\_stdoutDest;}
\DoxyCodeLine{11974         std::string\& m\_stderrDest;}
\DoxyCodeLine{11975     \};}
\DoxyCodeLine{11976 }
\DoxyCodeLine{11977 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11978 }
\DoxyCodeLine{11979 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11980 }
\DoxyCodeLine{11981 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// TWOBLUECUBES\_CATCH\_OUTPUT\_REDIRECT\_H}}
\DoxyCodeLine{11982 \textcolor{comment}{// end catch\_output\_redirect.h}}
\DoxyCodeLine{11983 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{11984 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{11985 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{11986 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{11987 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{11988 }
\DoxyCodeLine{11989 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{11990 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{11991 \textcolor{preprocessor}{    \#include <io.h>}      \textcolor{comment}{//\_dup and \_dup2}}
\DoxyCodeLine{11992 \textcolor{preprocessor}{    \#define dup \_dup}}
\DoxyCodeLine{11993 \textcolor{preprocessor}{    \#define dup2 \_dup2}}
\DoxyCodeLine{11994 \textcolor{preprocessor}{    \#define fileno \_fileno}}
\DoxyCodeLine{11995 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{11996 \textcolor{preprocessor}{    \#include <unistd.h>}  \textcolor{comment}{// dup and dup2}}
\DoxyCodeLine{11997 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{11998 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11999 }
\DoxyCodeLine{12000 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12001 }
\DoxyCodeLine{12002     RedirectedStream::RedirectedStream( std::ostream\& originalStream, std::ostream\& redirectionStream )}
\DoxyCodeLine{12003     :   m\_originalStream( originalStream ),}
\DoxyCodeLine{12004         m\_redirectionStream( redirectionStream ),}
\DoxyCodeLine{12005         m\_prevBuf( m\_originalStream.rdbuf() )}
\DoxyCodeLine{12006     \{}
\DoxyCodeLine{12007         m\_originalStream.rdbuf( m\_redirectionStream.rdbuf() );}
\DoxyCodeLine{12008     \}}
\DoxyCodeLine{12009 }
\DoxyCodeLine{12010     RedirectedStream::\string~RedirectedStream() \{}
\DoxyCodeLine{12011         m\_originalStream.rdbuf( m\_prevBuf );}
\DoxyCodeLine{12012     \}}
\DoxyCodeLine{12013 }
\DoxyCodeLine{12014     RedirectedStdOut::RedirectedStdOut() : m\_cout( Catch::cout(), m\_rss.get() ) \{\}}
\DoxyCodeLine{12015     \textcolor{keyword}{auto} RedirectedStdOut::str() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_rss.str(); \}}
\DoxyCodeLine{12016 }
\DoxyCodeLine{12017     RedirectedStdErr::RedirectedStdErr()}
\DoxyCodeLine{12018     :   m\_cerr( Catch::cerr(), m\_rss.get() ),}
\DoxyCodeLine{12019         m\_clog( Catch::clog(), m\_rss.get() )}
\DoxyCodeLine{12020     \{\}}
\DoxyCodeLine{12021     \textcolor{keyword}{auto} RedirectedStdErr::str() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_rss.str(); \}}
\DoxyCodeLine{12022 }
\DoxyCodeLine{12023     RedirectedStreams::RedirectedStreams(std::string\& redirectedCout, std::string\& redirectedCerr)}
\DoxyCodeLine{12024     :   m\_redirectedCout(redirectedCout),}
\DoxyCodeLine{12025         m\_redirectedCerr(redirectedCerr)}
\DoxyCodeLine{12026     \{\}}
\DoxyCodeLine{12027 }
\DoxyCodeLine{12028     RedirectedStreams::\string~RedirectedStreams() \{}
\DoxyCodeLine{12029         m\_redirectedCout += m\_redirectedStdOut.str();}
\DoxyCodeLine{12030         m\_redirectedCerr += m\_redirectedStdErr.str();}
\DoxyCodeLine{12031     \}}
\DoxyCodeLine{12032 }
\DoxyCodeLine{12033 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{12034 }
\DoxyCodeLine{12035 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12036     TempFile::TempFile() \{}
\DoxyCodeLine{12037         \textcolor{keywordflow}{if} (tmpnam\_s(m\_buffer)) \{}
\DoxyCodeLine{12038             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not get a temp filename"{}});}
\DoxyCodeLine{12039         \}}
\DoxyCodeLine{12040         \textcolor{keywordflow}{if} (fopen\_s(\&m\_file, m\_buffer, \textcolor{stringliteral}{"{}w+"{}})) \{}
\DoxyCodeLine{12041             \textcolor{keywordtype}{char} buffer[100];}
\DoxyCodeLine{12042             \textcolor{keywordflow}{if} (strerror\_s(buffer, errno)) \{}
\DoxyCodeLine{12043                 CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not translate errno to a string"{}});}
\DoxyCodeLine{12044             \}}
\DoxyCodeLine{12045             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not open the temp file: '"{}} << m\_buffer << \textcolor{stringliteral}{"{}' because: "{}} << buffer);}
\DoxyCodeLine{12046         \}}
\DoxyCodeLine{12047     \}}
\DoxyCodeLine{12048 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12049     TempFile::TempFile() \{}
\DoxyCodeLine{12050         m\_file = std::tmpfile();}
\DoxyCodeLine{12051         \textcolor{keywordflow}{if} (!m\_file) \{}
\DoxyCodeLine{12052             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not create a temp file."{}});}
\DoxyCodeLine{12053         \}}
\DoxyCodeLine{12054     \}}
\DoxyCodeLine{12055 }
\DoxyCodeLine{12056 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12057 }
\DoxyCodeLine{12058     TempFile::\string~TempFile() \{}
\DoxyCodeLine{12059          \textcolor{comment}{// TBD: What to do about errors here?}}
\DoxyCodeLine{12060          std::fclose(m\_file);}
\DoxyCodeLine{12061          \textcolor{comment}{// We manually create the file on Windows only, on Linux}}
\DoxyCodeLine{12062          \textcolor{comment}{// it will be autodeleted}}
\DoxyCodeLine{12063 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12064          std::remove(m\_buffer);}
\DoxyCodeLine{12065 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12066     \}}
\DoxyCodeLine{12067 }
\DoxyCodeLine{12068     FILE* TempFile::getFile() \{}
\DoxyCodeLine{12069         \textcolor{keywordflow}{return} m\_file;}
\DoxyCodeLine{12070     \}}
\DoxyCodeLine{12071 }
\DoxyCodeLine{12072     std::string TempFile::getContents() \{}
\DoxyCodeLine{12073         std::stringstream sstr;}
\DoxyCodeLine{12074         \textcolor{keywordtype}{char} buffer[100] = \{\};}
\DoxyCodeLine{12075         std::rewind(m\_file);}
\DoxyCodeLine{12076         \textcolor{keywordflow}{while} (std::fgets(buffer, \textcolor{keyword}{sizeof}(buffer), m\_file)) \{}
\DoxyCodeLine{12077             sstr << buffer;}
\DoxyCodeLine{12078         \}}
\DoxyCodeLine{12079         \textcolor{keywordflow}{return} sstr.str();}
\DoxyCodeLine{12080     \}}
\DoxyCodeLine{12081 }
\DoxyCodeLine{12082     OutputRedirect::OutputRedirect(std::string\& stdout\_dest, std::string\& stderr\_dest) :}
\DoxyCodeLine{12083         m\_originalStdout(dup(1)),}
\DoxyCodeLine{12084         m\_originalStderr(dup(2)),}
\DoxyCodeLine{12085         m\_stdoutDest(stdout\_dest),}
\DoxyCodeLine{12086         m\_stderrDest(stderr\_dest) \{}
\DoxyCodeLine{12087         dup2(fileno(m\_stdoutFile.getFile()), 1);}
\DoxyCodeLine{12088         dup2(fileno(m\_stderrFile.getFile()), 2);}
\DoxyCodeLine{12089     \}}
\DoxyCodeLine{12090 }
\DoxyCodeLine{12091     OutputRedirect::\string~OutputRedirect() \{}
\DoxyCodeLine{12092         Catch::cout() << std::flush;}
\DoxyCodeLine{12093         fflush(stdout);}
\DoxyCodeLine{12094         \textcolor{comment}{// Since we support overriding these streams, we flush cerr}}
\DoxyCodeLine{12095         \textcolor{comment}{// even though std::cerr is unbuffered}}
\DoxyCodeLine{12096         Catch::cerr() << std::flush;}
\DoxyCodeLine{12097         Catch::clog() << std::flush;}
\DoxyCodeLine{12098         fflush(stderr);}
\DoxyCodeLine{12099 }
\DoxyCodeLine{12100         dup2(m\_originalStdout, 1);}
\DoxyCodeLine{12101         dup2(m\_originalStderr, 2);}
\DoxyCodeLine{12102 }
\DoxyCodeLine{12103         m\_stdoutDest += m\_stdoutFile.getContents();}
\DoxyCodeLine{12104         m\_stderrDest += m\_stderrFile.getContents();}
\DoxyCodeLine{12105     \}}
\DoxyCodeLine{12106 }
\DoxyCodeLine{12107 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_NEW\_CAPTURE}}
\DoxyCodeLine{12108 }
\DoxyCodeLine{12109 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{12110 }
\DoxyCodeLine{12111 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{12112 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12113 \textcolor{preprocessor}{    \#undef dup}}
\DoxyCodeLine{12114 \textcolor{preprocessor}{    \#undef dup2}}
\DoxyCodeLine{12115 \textcolor{preprocessor}{    \#undef fileno}}
\DoxyCodeLine{12116 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{12117 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12118 \textcolor{comment}{// end catch\_output\_redirect.cpp}}
\DoxyCodeLine{12119 \textcolor{comment}{// start catch\_polyfills.cpp}}
\DoxyCodeLine{12120 }
\DoxyCodeLine{12121 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{12122 }
\DoxyCodeLine{12123 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12124 }
\DoxyCodeLine{12125 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_POLYFILL\_ISNAN)}}
\DoxyCodeLine{12126     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{float} f) \{}
\DoxyCodeLine{12127         \textcolor{keywordflow}{return} std::isnan(f);}
\DoxyCodeLine{12128     \}}
\DoxyCodeLine{12129     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{double} d) \{}
\DoxyCodeLine{12130         \textcolor{keywordflow}{return} std::isnan(d);}
\DoxyCodeLine{12131     \}}
\DoxyCodeLine{12132 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12133     \textcolor{comment}{// For now we only use this for embarcadero}}
\DoxyCodeLine{12134     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{float} f) \{}
\DoxyCodeLine{12135         \textcolor{keywordflow}{return} std::\_isnan(f);}
\DoxyCodeLine{12136     \}}
\DoxyCodeLine{12137     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{double} d) \{}
\DoxyCodeLine{12138         \textcolor{keywordflow}{return} std::\_isnan(d);}
\DoxyCodeLine{12139     \}}
\DoxyCodeLine{12140 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12141 }
\DoxyCodeLine{12142 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12143 \textcolor{comment}{// end catch\_polyfills.cpp}}
\DoxyCodeLine{12144 \textcolor{comment}{// start catch\_random\_number\_generator.cpp}}
\DoxyCodeLine{12145 }
\DoxyCodeLine{12146 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12147 }
\DoxyCodeLine{12148 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{12149 }
\DoxyCodeLine{12150 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12151 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{12152 \textcolor{preprocessor}{\#pragma warning(disable:4146) }\textcolor{comment}{// we negate uint32 during the rotate}}
\DoxyCodeLine{12153 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12154         \textcolor{comment}{// Safe rotr implementation thanks to John Regehr}}
\DoxyCodeLine{12155         uint32\_t rotate\_right(uint32\_t val, uint32\_t count) \{}
\DoxyCodeLine{12156             \textcolor{keyword}{const} uint32\_t mask = 31;}
\DoxyCodeLine{12157             count \&= mask;}
\DoxyCodeLine{12158             \textcolor{keywordflow}{return} (val >> count) | (val << (-\/count \& mask));}
\DoxyCodeLine{12159         \}}
\DoxyCodeLine{12160 }
\DoxyCodeLine{12161 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12162 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{12163 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12164 }
\DoxyCodeLine{12165 \}}
\DoxyCodeLine{12166 }
\DoxyCodeLine{12167     SimplePcg32::SimplePcg32(result\_type seed\_) \{}
\DoxyCodeLine{12168         seed(seed\_);}
\DoxyCodeLine{12169     \}}
\DoxyCodeLine{12170 }
\DoxyCodeLine{12171     \textcolor{keywordtype}{void} SimplePcg32::seed(result\_type seed\_) \{}
\DoxyCodeLine{12172         m\_state = 0;}
\DoxyCodeLine{12173         (*this)();}
\DoxyCodeLine{12174         m\_state += seed\_;}
\DoxyCodeLine{12175         (*this)();}
\DoxyCodeLine{12176     \}}
\DoxyCodeLine{12177 }
\DoxyCodeLine{12178     \textcolor{keywordtype}{void} SimplePcg32::discard(uint64\_t skip) \{}
\DoxyCodeLine{12179         \textcolor{comment}{// We could implement this to run in O(log n) steps, but this}}
\DoxyCodeLine{12180         \textcolor{comment}{// should suffice for our use case.}}
\DoxyCodeLine{12181         \textcolor{keywordflow}{for} (uint64\_t s = 0; s < skip; ++s) \{}
\DoxyCodeLine{12182             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}((*this)());}
\DoxyCodeLine{12183         \}}
\DoxyCodeLine{12184     \}}
\DoxyCodeLine{12185 }
\DoxyCodeLine{12186     SimplePcg32::result\_type SimplePcg32::operator()() \{}
\DoxyCodeLine{12187         \textcolor{comment}{// prepare the output value}}
\DoxyCodeLine{12188         \textcolor{keyword}{const} uint32\_t xorshifted = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(((m\_state >> 18u) \string^ m\_state) >> 27u);}
\DoxyCodeLine{12189         \textcolor{keyword}{const} \textcolor{keyword}{auto} output = rotate\_right(xorshifted, m\_state >> 59u);}
\DoxyCodeLine{12190 }
\DoxyCodeLine{12191         \textcolor{comment}{// advance state}}
\DoxyCodeLine{12192         m\_state = m\_state * 6364136223846793005ULL + s\_inc;}
\DoxyCodeLine{12193 }
\DoxyCodeLine{12194         \textcolor{keywordflow}{return} output;}
\DoxyCodeLine{12195     \}}
\DoxyCodeLine{12196 }
\DoxyCodeLine{12197     \textcolor{keywordtype}{bool} operator==(SimplePcg32 \textcolor{keyword}{const}\& lhs, SimplePcg32 \textcolor{keyword}{const}\& rhs) \{}
\DoxyCodeLine{12198         \textcolor{keywordflow}{return} lhs.m\_state == rhs.m\_state;}
\DoxyCodeLine{12199     \}}
\DoxyCodeLine{12200 }
\DoxyCodeLine{12201     \textcolor{keywordtype}{bool} operator!=(SimplePcg32 \textcolor{keyword}{const}\& lhs, SimplePcg32 \textcolor{keyword}{const}\& rhs) \{}
\DoxyCodeLine{12202         \textcolor{keywordflow}{return} lhs.m\_state != rhs.m\_state;}
\DoxyCodeLine{12203     \}}
\DoxyCodeLine{12204 \}}
\DoxyCodeLine{12205 \textcolor{comment}{// end catch\_random\_number\_generator.cpp}}
\DoxyCodeLine{12206 \textcolor{comment}{// start catch\_registry\_hub.cpp}}
\DoxyCodeLine{12207 }
\DoxyCodeLine{12208 \textcolor{comment}{// start catch\_test\_case\_registry\_impl.h}}
\DoxyCodeLine{12209 }
\DoxyCodeLine{12210 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{12211 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{12212 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{12213 \textcolor{preprocessor}{\#include <ios>}}
\DoxyCodeLine{12214 }
\DoxyCodeLine{12215 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12216 }
\DoxyCodeLine{12217     \textcolor{keyword}{class }TestCase;}
\DoxyCodeLine{12218     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{12219 }
\DoxyCodeLine{12220     std::vector<TestCase> sortTests( IConfig \textcolor{keyword}{const}\& config, std::vector<TestCase> \textcolor{keyword}{const}\& unsortedTestCases );}
\DoxyCodeLine{12221 }
\DoxyCodeLine{12222     \textcolor{keywordtype}{bool} isThrowSafe( TestCase \textcolor{keyword}{const}\& testCase, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{12223     \textcolor{keywordtype}{bool} matchTest( TestCase \textcolor{keyword}{const}\& testCase, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{12224 }
\DoxyCodeLine{12225     \textcolor{keywordtype}{void} enforceNoDuplicateTestCases( std::vector<TestCase> \textcolor{keyword}{const}\& functions );}
\DoxyCodeLine{12226 }
\DoxyCodeLine{12227     std::vector<TestCase> filterTests( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{12228     std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestCasesSorted( IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{12229 }
\DoxyCodeLine{12230     \textcolor{keyword}{class }TestRegistry : \textcolor{keyword}{public} ITestCaseRegistry \{}
\DoxyCodeLine{12231     \textcolor{keyword}{public}:}
\DoxyCodeLine{12232         \textcolor{keyword}{virtual} \string~TestRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{12233 }
\DoxyCodeLine{12234         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTest( TestCase \textcolor{keyword}{const}\& testCase );}
\DoxyCodeLine{12235 }
\DoxyCodeLine{12236         std::vector<TestCase> \textcolor{keyword}{const}\& getAllTests() \textcolor{keyword}{const override};}
\DoxyCodeLine{12237         std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestsSorted( IConfig \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const override};}
\DoxyCodeLine{12238 }
\DoxyCodeLine{12239     \textcolor{keyword}{private}:}
\DoxyCodeLine{12240         std::vector<TestCase> m\_functions;}
\DoxyCodeLine{12241         \textcolor{keyword}{mutable} RunTests::InWhatOrder m\_currentSortOrder = RunTests::InDeclarationOrder;}
\DoxyCodeLine{12242         \textcolor{keyword}{mutable} std::vector<TestCase> m\_sortedFunctions;}
\DoxyCodeLine{12243         std::size\_t m\_unnamedCount = 0;}
\DoxyCodeLine{12244         std::ios\_base::Init m\_ostreamInit; \textcolor{comment}{// Forces cout/ cerr to be initialised}}
\DoxyCodeLine{12245     \};}
\DoxyCodeLine{12246 }
\DoxyCodeLine{12248 }
\DoxyCodeLine{12249     \textcolor{keyword}{class }TestInvokerAsFunction : \textcolor{keyword}{public} ITestInvoker \{}
\DoxyCodeLine{12250         void(*m\_testAsFunction)();}
\DoxyCodeLine{12251     \textcolor{keyword}{public}:}
\DoxyCodeLine{12252         TestInvokerAsFunction( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept;}
\DoxyCodeLine{12253 }
\DoxyCodeLine{12254         \textcolor{keywordtype}{void} invoke() const override;}
\DoxyCodeLine{12255     \};}
\DoxyCodeLine{12256 }
\DoxyCodeLine{12257     std::\textcolor{keywordtype}{string} extractClassName( StringRef const\& classOrQualifiedMethodName );}
\DoxyCodeLine{12258 }
\DoxyCodeLine{12260 }
\DoxyCodeLine{12261 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12262 }
\DoxyCodeLine{12263 \textcolor{comment}{// end catch\_test\_case\_registry\_impl.h}}
\DoxyCodeLine{12264 \textcolor{comment}{// start catch\_reporter\_registry.h}}
\DoxyCodeLine{12265 }
\DoxyCodeLine{12266 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{12267 }
\DoxyCodeLine{12268 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12269 }
\DoxyCodeLine{12270     \textcolor{keyword}{class }ReporterRegistry : \textcolor{keyword}{public} IReporterRegistry \{}
\DoxyCodeLine{12271 }
\DoxyCodeLine{12272     \textcolor{keyword}{public}:}
\DoxyCodeLine{12273 }
\DoxyCodeLine{12274         \string~ReporterRegistry() \textcolor{keyword}{override};}
\DoxyCodeLine{12275 }
\DoxyCodeLine{12276         IStreamingReporterPtr create( std::string \textcolor{keyword}{const}\& name, IConfigPtr \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const override};}
\DoxyCodeLine{12277 }
\DoxyCodeLine{12278         \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory );}
\DoxyCodeLine{12279         \textcolor{keywordtype}{void} registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory );}
\DoxyCodeLine{12280 }
\DoxyCodeLine{12281         FactoryMap \textcolor{keyword}{const}\& getFactories() \textcolor{keyword}{const override};}
\DoxyCodeLine{12282         Listeners \textcolor{keyword}{const}\& getListeners() \textcolor{keyword}{const override};}
\DoxyCodeLine{12283 }
\DoxyCodeLine{12284     \textcolor{keyword}{private}:}
\DoxyCodeLine{12285         FactoryMap m\_factories;}
\DoxyCodeLine{12286         Listeners m\_listeners;}
\DoxyCodeLine{12287     \};}
\DoxyCodeLine{12288 \}}
\DoxyCodeLine{12289 }
\DoxyCodeLine{12290 \textcolor{comment}{// end catch\_reporter\_registry.h}}
\DoxyCodeLine{12291 \textcolor{comment}{// start catch\_tag\_alias\_registry.h}}
\DoxyCodeLine{12292 }
\DoxyCodeLine{12293 \textcolor{comment}{// start catch\_tag\_alias.h}}
\DoxyCodeLine{12294 }
\DoxyCodeLine{12295 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{12296 }
\DoxyCodeLine{12297 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12298 }
\DoxyCodeLine{12299     \textcolor{keyword}{struct }TagAlias \{}
\DoxyCodeLine{12300         TagAlias(std::string \textcolor{keyword}{const}\& \_tag, SourceLineInfo \_lineInfo);}
\DoxyCodeLine{12301 }
\DoxyCodeLine{12302         std::string tag;}
\DoxyCodeLine{12303         SourceLineInfo lineInfo;}
\DoxyCodeLine{12304     \};}
\DoxyCodeLine{12305 }
\DoxyCodeLine{12306 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12307 }
\DoxyCodeLine{12308 \textcolor{comment}{// end catch\_tag\_alias.h}}
\DoxyCodeLine{12309 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{12310 }
\DoxyCodeLine{12311 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12312 }
\DoxyCodeLine{12313     \textcolor{keyword}{class }TagAliasRegistry : \textcolor{keyword}{public} ITagAliasRegistry \{}
\DoxyCodeLine{12314     \textcolor{keyword}{public}:}
\DoxyCodeLine{12315         \string~TagAliasRegistry() \textcolor{keyword}{override};}
\DoxyCodeLine{12316         TagAlias \textcolor{keyword}{const}* find( std::string \textcolor{keyword}{const}\& alias ) \textcolor{keyword}{const override};}
\DoxyCodeLine{12317         std::string expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec ) \textcolor{keyword}{const override};}
\DoxyCodeLine{12318         \textcolor{keywordtype}{void} add( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{12319 }
\DoxyCodeLine{12320     \textcolor{keyword}{private}:}
\DoxyCodeLine{12321         std::map<std::string, TagAlias> m\_registry;}
\DoxyCodeLine{12322     \};}
\DoxyCodeLine{12323 }
\DoxyCodeLine{12324 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12325 }
\DoxyCodeLine{12326 \textcolor{comment}{// end catch\_tag\_alias\_registry.h}}
\DoxyCodeLine{12327 \textcolor{comment}{// start catch\_startup\_exception\_registry.h}}
\DoxyCodeLine{12328 }
\DoxyCodeLine{12329 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{12330 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{12331 }
\DoxyCodeLine{12332 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12333 }
\DoxyCodeLine{12334     \textcolor{keyword}{class }StartupExceptionRegistry \{}
\DoxyCodeLine{12335 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{12336     \textcolor{keyword}{public}:}
\DoxyCodeLine{12337         \textcolor{keywordtype}{void} add(std::exception\_ptr \textcolor{keyword}{const}\& exception) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{12338         std::vector<std::exception\_ptr> \textcolor{keyword}{const}\& getExceptions() const noexcept;}
\DoxyCodeLine{12339     private:}
\DoxyCodeLine{12340         std::vector<std::exception\_ptr> m\_exceptions;}
\DoxyCodeLine{12341 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12342     \};}
\DoxyCodeLine{12343 }
\DoxyCodeLine{12344 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12345 }
\DoxyCodeLine{12346 \textcolor{comment}{// end catch\_startup\_exception\_registry.h}}
\DoxyCodeLine{12347 \textcolor{comment}{// start catch\_singletons.hpp}}
\DoxyCodeLine{12348 }
\DoxyCodeLine{12349 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12350 }
\DoxyCodeLine{12351     \textcolor{keyword}{struct }ISingleton \{}
\DoxyCodeLine{12352         \textcolor{keyword}{virtual} \string~ISingleton();}
\DoxyCodeLine{12353     \};}
\DoxyCodeLine{12354 }
\DoxyCodeLine{12355     \textcolor{keywordtype}{void} addSingleton( ISingleton* singleton );}
\DoxyCodeLine{12356     \textcolor{keywordtype}{void} cleanupSingletons();}
\DoxyCodeLine{12357 }
\DoxyCodeLine{12358     \textcolor{keyword}{template}<\textcolor{keyword}{typename} SingletonImplT, \textcolor{keyword}{typename} InterfaceT = SingletonImplT, \textcolor{keyword}{typename} MutableInterfaceT = InterfaceT>}
\DoxyCodeLine{12359     \textcolor{keyword}{class }Singleton : SingletonImplT, \textcolor{keyword}{public} ISingleton \{}
\DoxyCodeLine{12360 }
\DoxyCodeLine{12361         \textcolor{keyword}{static} \textcolor{keyword}{auto} getInternal() -\/> Singleton* \{}
\DoxyCodeLine{12362             \textcolor{keyword}{static} Singleton* s\_instance = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12363             \textcolor{keywordflow}{if}( !s\_instance ) \{}
\DoxyCodeLine{12364                 s\_instance = \textcolor{keyword}{new} Singleton;}
\DoxyCodeLine{12365                 addSingleton( s\_instance );}
\DoxyCodeLine{12366             \}}
\DoxyCodeLine{12367             \textcolor{keywordflow}{return} s\_instance;}
\DoxyCodeLine{12368         \}}
\DoxyCodeLine{12369 }
\DoxyCodeLine{12370     \textcolor{keyword}{public}:}
\DoxyCodeLine{12371         \textcolor{keyword}{static} \textcolor{keyword}{auto} get() -\/> InterfaceT \textcolor{keyword}{const}\& \{}
\DoxyCodeLine{12372             \textcolor{keywordflow}{return} *getInternal();}
\DoxyCodeLine{12373         \}}
\DoxyCodeLine{12374         \textcolor{keyword}{static} \textcolor{keyword}{auto} getMutable() -\/> MutableInterfaceT\& \{}
\DoxyCodeLine{12375             \textcolor{keywordflow}{return} *getInternal();}
\DoxyCodeLine{12376         \}}
\DoxyCodeLine{12377     \};}
\DoxyCodeLine{12378 }
\DoxyCodeLine{12379 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{12380 }
\DoxyCodeLine{12381 \textcolor{comment}{// end catch\_singletons.hpp}}
\DoxyCodeLine{12382 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12383 }
\DoxyCodeLine{12384     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{12385 }
\DoxyCodeLine{12386         \textcolor{keyword}{class }RegistryHub : \textcolor{keyword}{public} IRegistryHub, \textcolor{keyword}{public} IMutableRegistryHub,}
\DoxyCodeLine{12387                             \textcolor{keyword}{private} NonCopyable \{}
\DoxyCodeLine{12388 }
\DoxyCodeLine{12389         \textcolor{keyword}{public}: \textcolor{comment}{// IRegistryHub}}
\DoxyCodeLine{12390             RegistryHub() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{12391             IReporterRegistry \textcolor{keyword}{const}\& getReporterRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12392                 \textcolor{keywordflow}{return} m\_reporterRegistry;}
\DoxyCodeLine{12393             \}}
\DoxyCodeLine{12394             ITestCaseRegistry \textcolor{keyword}{const}\& getTestCaseRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12395                 \textcolor{keywordflow}{return} m\_testCaseRegistry;}
\DoxyCodeLine{12396             \}}
\DoxyCodeLine{12397             IExceptionTranslatorRegistry \textcolor{keyword}{const}\& getExceptionTranslatorRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12398                 \textcolor{keywordflow}{return} m\_exceptionTranslatorRegistry;}
\DoxyCodeLine{12399             \}}
\DoxyCodeLine{12400             ITagAliasRegistry \textcolor{keyword}{const}\& getTagAliasRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12401                 \textcolor{keywordflow}{return} m\_tagAliasRegistry;}
\DoxyCodeLine{12402             \}}
\DoxyCodeLine{12403             StartupExceptionRegistry \textcolor{keyword}{const}\& getStartupExceptionRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12404                 \textcolor{keywordflow}{return} m\_exceptionRegistry;}
\DoxyCodeLine{12405             \}}
\DoxyCodeLine{12406 }
\DoxyCodeLine{12407         \textcolor{keyword}{public}: \textcolor{comment}{// IMutableRegistryHub}}
\DoxyCodeLine{12408             \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12409                 m\_reporterRegistry.registerReporter( name, factory );}
\DoxyCodeLine{12410             \}}
\DoxyCodeLine{12411             \textcolor{keywordtype}{void} registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12412                 m\_reporterRegistry.registerListener( factory );}
\DoxyCodeLine{12413             \}}
\DoxyCodeLine{12414             \textcolor{keywordtype}{void} registerTest( TestCase \textcolor{keyword}{const}\& testInfo )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12415                 m\_testCaseRegistry.registerTest( testInfo );}
\DoxyCodeLine{12416             \}}
\DoxyCodeLine{12417             \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} IExceptionTranslator* translator )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12418                 m\_exceptionTranslatorRegistry.registerTranslator( translator );}
\DoxyCodeLine{12419             \}}
\DoxyCodeLine{12420             \textcolor{keywordtype}{void} registerTagAlias( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12421                 m\_tagAliasRegistry.add( alias, tag, lineInfo );}
\DoxyCodeLine{12422             \}}
\DoxyCodeLine{12423             \textcolor{keywordtype}{void} registerStartupException() noexcept\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12424 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{12425                 m\_exceptionRegistry.add(std::current\_exception());}
\DoxyCodeLine{12426 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12427                 CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Attempted to register active exception under CATCH\_CONFIG\_DISABLE\_EXCEPTIONS!"{}});}
\DoxyCodeLine{12428 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12429             \}}
\DoxyCodeLine{12430             IMutableEnumValuesRegistry\& getMutableEnumValuesRegistry()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12431                 \textcolor{keywordflow}{return} m\_enumValuesRegistry;}
\DoxyCodeLine{12432             \}}
\DoxyCodeLine{12433 }
\DoxyCodeLine{12434         \textcolor{keyword}{private}:}
\DoxyCodeLine{12435             TestRegistry m\_testCaseRegistry;}
\DoxyCodeLine{12436             ReporterRegistry m\_reporterRegistry;}
\DoxyCodeLine{12437             ExceptionTranslatorRegistry m\_exceptionTranslatorRegistry;}
\DoxyCodeLine{12438             TagAliasRegistry m\_tagAliasRegistry;}
\DoxyCodeLine{12439             StartupExceptionRegistry m\_exceptionRegistry;}
\DoxyCodeLine{12440             Detail::EnumValuesRegistry m\_enumValuesRegistry;}
\DoxyCodeLine{12441         \};}
\DoxyCodeLine{12442     \}}
\DoxyCodeLine{12443 }
\DoxyCodeLine{12444     \textcolor{keyword}{using} RegistryHubSingleton = Singleton<RegistryHub, IRegistryHub, IMutableRegistryHub>;}
\DoxyCodeLine{12445 }
\DoxyCodeLine{12446     IRegistryHub \textcolor{keyword}{const}\& getRegistryHub() \{}
\DoxyCodeLine{12447         \textcolor{keywordflow}{return} RegistryHubSingleton::get();}
\DoxyCodeLine{12448     \}}
\DoxyCodeLine{12449     IMutableRegistryHub\& getMutableRegistryHub() \{}
\DoxyCodeLine{12450         \textcolor{keywordflow}{return} RegistryHubSingleton::getMutable();}
\DoxyCodeLine{12451     \}}
\DoxyCodeLine{12452     \textcolor{keywordtype}{void} cleanUp() \{}
\DoxyCodeLine{12453         cleanupSingletons();}
\DoxyCodeLine{12454         cleanUpContext();}
\DoxyCodeLine{12455     \}}
\DoxyCodeLine{12456     std::string translateActiveException() \{}
\DoxyCodeLine{12457         \textcolor{keywordflow}{return} getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();}
\DoxyCodeLine{12458     \}}
\DoxyCodeLine{12459 }
\DoxyCodeLine{12460 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12461 \textcolor{comment}{// end catch\_registry\_hub.cpp}}
\DoxyCodeLine{12462 \textcolor{comment}{// start catch\_reporter\_registry.cpp}}
\DoxyCodeLine{12463 }
\DoxyCodeLine{12464 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12465 }
\DoxyCodeLine{12466     ReporterRegistry::\string~ReporterRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{12467 }
\DoxyCodeLine{12468     IStreamingReporterPtr ReporterRegistry::create( std::string \textcolor{keyword}{const}\& name, IConfigPtr \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12469         \textcolor{keyword}{auto} it =  m\_factories.find( name );}
\DoxyCodeLine{12470         \textcolor{keywordflow}{if}( it == m\_factories.end() )}
\DoxyCodeLine{12471             \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12472         \textcolor{keywordflow}{return} it-\/>second-\/>create( ReporterConfig( config ) );}
\DoxyCodeLine{12473     \}}
\DoxyCodeLine{12474 }
\DoxyCodeLine{12475     \textcolor{keywordtype}{void} ReporterRegistry::registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) \{}
\DoxyCodeLine{12476         m\_factories.emplace(name, factory);}
\DoxyCodeLine{12477     \}}
\DoxyCodeLine{12478     \textcolor{keywordtype}{void} ReporterRegistry::registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) \{}
\DoxyCodeLine{12479         m\_listeners.push\_back( factory );}
\DoxyCodeLine{12480     \}}
\DoxyCodeLine{12481 }
\DoxyCodeLine{12482     IReporterRegistry::FactoryMap \textcolor{keyword}{const}\& ReporterRegistry::getFactories()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12483         \textcolor{keywordflow}{return} m\_factories;}
\DoxyCodeLine{12484     \}}
\DoxyCodeLine{12485     IReporterRegistry::Listeners \textcolor{keyword}{const}\& ReporterRegistry::getListeners()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12486         \textcolor{keywordflow}{return} m\_listeners;}
\DoxyCodeLine{12487     \}}
\DoxyCodeLine{12488 }
\DoxyCodeLine{12489 \}}
\DoxyCodeLine{12490 \textcolor{comment}{// end catch\_reporter\_registry.cpp}}
\DoxyCodeLine{12491 \textcolor{comment}{// start catch\_result\_type.cpp}}
\DoxyCodeLine{12492 }
\DoxyCodeLine{12493 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12494 }
\DoxyCodeLine{12495     \textcolor{keywordtype}{bool} isOk( ResultWas::OfType resultType ) \{}
\DoxyCodeLine{12496         \textcolor{keywordflow}{return} ( resultType \& ResultWas::FailureBit ) == 0;}
\DoxyCodeLine{12497     \}}
\DoxyCodeLine{12498     \textcolor{keywordtype}{bool} isJustInfo( \textcolor{keywordtype}{int} flags ) \{}
\DoxyCodeLine{12499         \textcolor{keywordflow}{return} flags == ResultWas::Info;}
\DoxyCodeLine{12500     \}}
\DoxyCodeLine{12501 }
\DoxyCodeLine{12502     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) \{}
\DoxyCodeLine{12503         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}ResultDisposition::Flags\textcolor{keyword}{>}( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( lhs ) | \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( rhs ) );}
\DoxyCodeLine{12504     \}}
\DoxyCodeLine{12505 }
\DoxyCodeLine{12506     \textcolor{keywordtype}{bool} shouldContinueOnFailure( \textcolor{keywordtype}{int} flags )    \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::ContinueOnFailure ) != 0; \}}
\DoxyCodeLine{12507     \textcolor{keywordtype}{bool} shouldSuppressFailure( \textcolor{keywordtype}{int} flags )      \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::SuppressFail ) != 0; \}}
\DoxyCodeLine{12508 }
\DoxyCodeLine{12509 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12510 \textcolor{comment}{// end catch\_result\_type.cpp}}
\DoxyCodeLine{12511 \textcolor{comment}{// start catch\_run\_context.cpp}}
\DoxyCodeLine{12512 }
\DoxyCodeLine{12513 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{12514 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{12515 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{12516 }
\DoxyCodeLine{12517 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12518 }
\DoxyCodeLine{12519     \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{12520         \textcolor{keyword}{struct }GeneratorTracker : TestCaseTracking::TrackerBase, IGeneratorTracker \{}
\DoxyCodeLine{12521             GeneratorBasePtr m\_generator;}
\DoxyCodeLine{12522 }
\DoxyCodeLine{12523             GeneratorTracker( TestCaseTracking::NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent )}
\DoxyCodeLine{12524             :   TrackerBase( nameAndLocation, ctx, parent )}
\DoxyCodeLine{12525             \{\}}
\DoxyCodeLine{12526             \string~GeneratorTracker();}
\DoxyCodeLine{12527 }
\DoxyCodeLine{12528             \textcolor{keyword}{static} GeneratorTracker\& acquire( TrackerContext\& ctx, TestCaseTracking::NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \{}
\DoxyCodeLine{12529                 std::shared\_ptr<GeneratorTracker> tracker;}
\DoxyCodeLine{12530 }
\DoxyCodeLine{12531                 ITracker\& currentTracker = ctx.currentTracker();}
\DoxyCodeLine{12532                 \textcolor{comment}{// Under specific circumstances, the generator we want}}
\DoxyCodeLine{12533                 \textcolor{comment}{// to acquire is also the current tracker. If this is}}
\DoxyCodeLine{12534                 \textcolor{comment}{// the case, we have to avoid looking through current}}
\DoxyCodeLine{12535                 \textcolor{comment}{// tracker's children, and instead return the current}}
\DoxyCodeLine{12536                 \textcolor{comment}{// tracker.}}
\DoxyCodeLine{12537                 \textcolor{comment}{// A case where this check is important is e.g.}}
\DoxyCodeLine{12538                 \textcolor{comment}{//     for (int i = 0; i < 5; ++i) \{}}
\DoxyCodeLine{12539                 \textcolor{comment}{//         int n = GENERATE(1, 2);}}
\DoxyCodeLine{12540                 \textcolor{comment}{//     \}}}
\DoxyCodeLine{12541                 \textcolor{comment}{//}}
\DoxyCodeLine{12542                 \textcolor{comment}{// without it, the code above creates 5 nested generators.}}
\DoxyCodeLine{12543                 \textcolor{keywordflow}{if} (currentTracker.nameAndLocation() == nameAndLocation) \{}
\DoxyCodeLine{12544                     \textcolor{keyword}{auto} thisTracker = currentTracker.parent().findChild(nameAndLocation);}
\DoxyCodeLine{12545                     assert(thisTracker);}
\DoxyCodeLine{12546                     assert(thisTracker-\/>isGeneratorTracker());}
\DoxyCodeLine{12547                     tracker = std::static\_pointer\_cast<GeneratorTracker>(thisTracker);}
\DoxyCodeLine{12548                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( TestCaseTracking::ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) \{}
\DoxyCodeLine{12549                     assert( childTracker );}
\DoxyCodeLine{12550                     assert( childTracker-\/>isGeneratorTracker() );}
\DoxyCodeLine{12551                     tracker = std::static\_pointer\_cast<GeneratorTracker>( childTracker );}
\DoxyCodeLine{12552                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12553                     tracker = std::make\_shared<GeneratorTracker>( nameAndLocation, ctx, \&currentTracker );}
\DoxyCodeLine{12554                     currentTracker.addChild( tracker );}
\DoxyCodeLine{12555                 \}}
\DoxyCodeLine{12556 }
\DoxyCodeLine{12557                 \textcolor{keywordflow}{if}( !tracker-\/>isComplete() ) \{}
\DoxyCodeLine{12558                     tracker-\/>open();}
\DoxyCodeLine{12559                 \}}
\DoxyCodeLine{12560 }
\DoxyCodeLine{12561                 \textcolor{keywordflow}{return} *tracker;}
\DoxyCodeLine{12562             \}}
\DoxyCodeLine{12563 }
\DoxyCodeLine{12564             \textcolor{comment}{// TrackerBase interface}}
\DoxyCodeLine{12565             \textcolor{keywordtype}{bool} isGeneratorTracker()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{12566             \textcolor{keyword}{auto} hasGenerator() const -\/> \textcolor{keywordtype}{bool}\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12567                 \textcolor{keywordflow}{return} !!m\_generator;}
\DoxyCodeLine{12568             \}}
\DoxyCodeLine{12569             \textcolor{keywordtype}{void} close()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12570                 TrackerBase::close();}
\DoxyCodeLine{12571                 \textcolor{comment}{// If a generator has a child (it is followed by a section)}}
\DoxyCodeLine{12572                 \textcolor{comment}{// and none of its children have started, then we must wait}}
\DoxyCodeLine{12573                 \textcolor{comment}{// until later to start consuming its values.}}
\DoxyCodeLine{12574                 \textcolor{comment}{// This catches cases where `GENERATE` is placed between two}}
\DoxyCodeLine{12575                 \textcolor{comment}{// `SECTION`s.}}
\DoxyCodeLine{12576                 \textcolor{comment}{// **The check for m\_children.empty cannot be removed**.}}
\DoxyCodeLine{12577                 \textcolor{comment}{// doing so would break `GENERATE` \_not\_ followed by `SECTION`s.}}
\DoxyCodeLine{12578                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} should\_wait\_for\_child = [\&]() \{}
\DoxyCodeLine{12579                     \textcolor{comment}{// No children -\/> nobody to wait for}}
\DoxyCodeLine{12580                     \textcolor{keywordflow}{if} ( m\_children.empty() ) \{}
\DoxyCodeLine{12581                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12582                     \}}
\DoxyCodeLine{12583                     \textcolor{comment}{// If at least one child started executing, don't wait}}
\DoxyCodeLine{12584                     \textcolor{keywordflow}{if} ( std::find\_if(}
\DoxyCodeLine{12585                              m\_children.begin(),}
\DoxyCodeLine{12586                              m\_children.end(),}
\DoxyCodeLine{12587                              []( TestCaseTracking::ITrackerPtr tracker ) \{}
\DoxyCodeLine{12588                                  return tracker-\/>hasStarted();}
\DoxyCodeLine{12589                              \} ) != m\_children.end() ) \{}
\DoxyCodeLine{12590                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12591                     \}}
\DoxyCodeLine{12592 }
\DoxyCodeLine{12593                     \textcolor{comment}{// No children have started. We need to check if they \_can\_}}
\DoxyCodeLine{12594                     \textcolor{comment}{// start, and thus we should wait for them, or they cannot}}
\DoxyCodeLine{12595                     \textcolor{comment}{// start (due to filters), and we shouldn't wait for them}}
\DoxyCodeLine{12596                     \textcolor{keyword}{auto}* parent = m\_parent;}
\DoxyCodeLine{12597                     \textcolor{comment}{// This is safe: there is always at least one section}}
\DoxyCodeLine{12598                     \textcolor{comment}{// tracker in a test case tracking tree}}
\DoxyCodeLine{12599                     \textcolor{keywordflow}{while} ( !parent-\/>isSectionTracker() ) \{}
\DoxyCodeLine{12600                         parent = \&( parent-\/>parent() );}
\DoxyCodeLine{12601                     \}}
\DoxyCodeLine{12602                     assert( parent \&\&}
\DoxyCodeLine{12603                             \textcolor{stringliteral}{"{}Missing root (test case) level section"{}} );}
\DoxyCodeLine{12604 }
\DoxyCodeLine{12605                     \textcolor{keyword}{auto} \textcolor{keyword}{const}\& parentSection =}
\DoxyCodeLine{12606                         \textcolor{keyword}{static\_cast<}SectionTracker\&\textcolor{keyword}{>}( *parent );}
\DoxyCodeLine{12607                     \textcolor{keyword}{auto} \textcolor{keyword}{const}\& filters = parentSection.getFilters();}
\DoxyCodeLine{12608                     \textcolor{comment}{// No filters -\/> no restrictions on running sections}}
\DoxyCodeLine{12609                     \textcolor{keywordflow}{if} ( filters.empty() ) \{}
\DoxyCodeLine{12610                         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{12611                     \}}
\DoxyCodeLine{12612 }
\DoxyCodeLine{12613                     \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& child : m\_children ) \{}
\DoxyCodeLine{12614                         \textcolor{keywordflow}{if} ( child-\/>isSectionTracker() \&\&}
\DoxyCodeLine{12615                              std::find( filters.begin(),}
\DoxyCodeLine{12616                                         filters.end(),}
\DoxyCodeLine{12617                                         \textcolor{keyword}{static\_cast<}SectionTracker\&\textcolor{keyword}{>}( *child )}
\DoxyCodeLine{12618                                             .trimmedName() ) !=}
\DoxyCodeLine{12619                                  filters.end() ) \{}
\DoxyCodeLine{12620                             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{12621                         \}}
\DoxyCodeLine{12622                     \}}
\DoxyCodeLine{12623                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12624                 \}();}
\DoxyCodeLine{12625 }
\DoxyCodeLine{12626                 \textcolor{comment}{// This check is a bit tricky, because m\_generator-\/>next()}}
\DoxyCodeLine{12627                 \textcolor{comment}{// has a side-\/effect, where it consumes generator's current}}
\DoxyCodeLine{12628                 \textcolor{comment}{// value, but we do not want to invoke the side-\/effect if}}
\DoxyCodeLine{12629                 \textcolor{comment}{// this generator is still waiting for any child to start.}}
\DoxyCodeLine{12630                 \textcolor{keywordflow}{if} ( should\_wait\_for\_child ||}
\DoxyCodeLine{12631                      ( m\_runState == CompletedSuccessfully \&\&}
\DoxyCodeLine{12632                        m\_generator-\/>next() ) ) \{}
\DoxyCodeLine{12633                     m\_children.clear();}
\DoxyCodeLine{12634                     m\_runState = Executing;}
\DoxyCodeLine{12635                 \}}
\DoxyCodeLine{12636             \}}
\DoxyCodeLine{12637 }
\DoxyCodeLine{12638             \textcolor{comment}{// IGeneratorTracker interface}}
\DoxyCodeLine{12639             \textcolor{keyword}{auto} getGenerator() const -\/> GeneratorBasePtr const\&\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12640                 \textcolor{keywordflow}{return} m\_generator;}
\DoxyCodeLine{12641             \}}
\DoxyCodeLine{12642             \textcolor{keywordtype}{void} setGenerator( GeneratorBasePtr\&\& generator )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12643                 m\_generator = std::move( generator );}
\DoxyCodeLine{12644             \}}
\DoxyCodeLine{12645         \};}
\DoxyCodeLine{12646         GeneratorTracker::\string~GeneratorTracker() \{\}}
\DoxyCodeLine{12647     \}}
\DoxyCodeLine{12648 }
\DoxyCodeLine{12649     RunContext::RunContext(IConfigPtr \textcolor{keyword}{const}\& \_config, IStreamingReporterPtr\&\& reporter)}
\DoxyCodeLine{12650     :   m\_runInfo(\_config-\/>name()),}
\DoxyCodeLine{12651         m\_context(getCurrentMutableContext()),}
\DoxyCodeLine{12652         m\_config(\_config),}
\DoxyCodeLine{12653         m\_reporter(std::move(reporter)),}
\DoxyCodeLine{12654         m\_lastAssertionInfo\{ StringRef(), SourceLineInfo(\textcolor{stringliteral}{"{}"{}},0), StringRef(), ResultDisposition::Normal \},}
\DoxyCodeLine{12655         m\_includeSuccessfulResults( m\_config-\/>includeSuccessfulResults() || m\_reporter-\/>getPreferences().shouldReportAllAssertions )}
\DoxyCodeLine{12656     \{}
\DoxyCodeLine{12657         m\_context.setRunner(\textcolor{keyword}{this});}
\DoxyCodeLine{12658         m\_context.setConfig(m\_config);}
\DoxyCodeLine{12659         m\_context.setResultCapture(\textcolor{keyword}{this});}
\DoxyCodeLine{12660         m\_reporter-\/>testRunStarting(m\_runInfo);}
\DoxyCodeLine{12661     \}}
\DoxyCodeLine{12662 }
\DoxyCodeLine{12663     RunContext::\string~RunContext() \{}
\DoxyCodeLine{12664         m\_reporter-\/>testRunEnded(TestRunStats(m\_runInfo, m\_totals, aborting()));}
\DoxyCodeLine{12665     \}}
\DoxyCodeLine{12666 }
\DoxyCodeLine{12667     \textcolor{keywordtype}{void} RunContext::testGroupStarting(std::string \textcolor{keyword}{const}\& testSpec, std::size\_t groupIndex, std::size\_t groupsCount) \{}
\DoxyCodeLine{12668         m\_reporter-\/>testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));}
\DoxyCodeLine{12669     \}}
\DoxyCodeLine{12670 }
\DoxyCodeLine{12671     \textcolor{keywordtype}{void} RunContext::testGroupEnded(std::string \textcolor{keyword}{const}\& testSpec, Totals \textcolor{keyword}{const}\& totals, std::size\_t groupIndex, std::size\_t groupsCount) \{}
\DoxyCodeLine{12672         m\_reporter-\/>testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));}
\DoxyCodeLine{12673     \}}
\DoxyCodeLine{12674 }
\DoxyCodeLine{12675     Totals RunContext::runTest(TestCase \textcolor{keyword}{const}\& testCase) \{}
\DoxyCodeLine{12676         Totals prevTotals = m\_totals;}
\DoxyCodeLine{12677 }
\DoxyCodeLine{12678         std::string redirectedCout;}
\DoxyCodeLine{12679         std::string redirectedCerr;}
\DoxyCodeLine{12680 }
\DoxyCodeLine{12681         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testInfo = testCase.getTestCaseInfo();}
\DoxyCodeLine{12682 }
\DoxyCodeLine{12683         m\_reporter-\/>testCaseStarting(testInfo);}
\DoxyCodeLine{12684 }
\DoxyCodeLine{12685         m\_activeTestCase = \&testCase;}
\DoxyCodeLine{12686 }
\DoxyCodeLine{12687         ITracker\& rootTracker = m\_trackerContext.startRun();}
\DoxyCodeLine{12688         assert(rootTracker.isSectionTracker());}
\DoxyCodeLine{12689         \textcolor{keyword}{static\_cast<}SectionTracker\&\textcolor{keyword}{>}(rootTracker).addInitialFilters(m\_config-\/>getSectionsToRun());}
\DoxyCodeLine{12690         \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{12691             m\_trackerContext.startCycle();}
\DoxyCodeLine{12692             m\_testCaseTracker = \&SectionTracker::acquire(m\_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));}
\DoxyCodeLine{12693             runCurrentTest(redirectedCout, redirectedCerr);}
\DoxyCodeLine{12694         \} \textcolor{keywordflow}{while} (!m\_testCaseTracker-\/>isSuccessfullyCompleted() \&\& !aborting());}
\DoxyCodeLine{12695 }
\DoxyCodeLine{12696         Totals deltaTotals = m\_totals.delta(prevTotals);}
\DoxyCodeLine{12697         \textcolor{keywordflow}{if} (testInfo.expectedToFail() \&\& deltaTotals.testCases.passed > 0) \{}
\DoxyCodeLine{12698             deltaTotals.assertions.failed++;}
\DoxyCodeLine{12699             deltaTotals.testCases.passed-\/-\/;}
\DoxyCodeLine{12700             deltaTotals.testCases.failed++;}
\DoxyCodeLine{12701         \}}
\DoxyCodeLine{12702         m\_totals.testCases += deltaTotals.testCases;}
\DoxyCodeLine{12703         m\_reporter-\/>testCaseEnded(TestCaseStats(testInfo,}
\DoxyCodeLine{12704                                   deltaTotals,}
\DoxyCodeLine{12705                                   redirectedCout,}
\DoxyCodeLine{12706                                   redirectedCerr,}
\DoxyCodeLine{12707                                   aborting()));}
\DoxyCodeLine{12708 }
\DoxyCodeLine{12709         m\_activeTestCase = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12710         m\_testCaseTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12711 }
\DoxyCodeLine{12712         \textcolor{keywordflow}{return} deltaTotals;}
\DoxyCodeLine{12713     \}}
\DoxyCodeLine{12714 }
\DoxyCodeLine{12715     IConfigPtr RunContext::config()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12716         \textcolor{keywordflow}{return} m\_config;}
\DoxyCodeLine{12717     \}}
\DoxyCodeLine{12718 }
\DoxyCodeLine{12719     IStreamingReporter\& RunContext::reporter()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12720         \textcolor{keywordflow}{return} *m\_reporter;}
\DoxyCodeLine{12721     \}}
\DoxyCodeLine{12722 }
\DoxyCodeLine{12723     \textcolor{keywordtype}{void} RunContext::assertionEnded(AssertionResult \textcolor{keyword}{const} \& result) \{}
\DoxyCodeLine{12724         \textcolor{keywordflow}{if} (result.getResultType() == ResultWas::Ok) \{}
\DoxyCodeLine{12725             m\_totals.assertions.passed++;}
\DoxyCodeLine{12726             m\_lastAssertionPassed = \textcolor{keyword}{true};}
\DoxyCodeLine{12727         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!result.isOk()) \{}
\DoxyCodeLine{12728             m\_lastAssertionPassed = \textcolor{keyword}{false};}
\DoxyCodeLine{12729             \textcolor{keywordflow}{if}( m\_activeTestCase-\/>getTestCaseInfo().okToFail() )}
\DoxyCodeLine{12730                 m\_totals.assertions.failedButOk++;}
\DoxyCodeLine{12731             \textcolor{keywordflow}{else}}
\DoxyCodeLine{12732                 m\_totals.assertions.failed++;}
\DoxyCodeLine{12733         \}}
\DoxyCodeLine{12734         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12735             m\_lastAssertionPassed = \textcolor{keyword}{true};}
\DoxyCodeLine{12736         \}}
\DoxyCodeLine{12737 }
\DoxyCodeLine{12738         \textcolor{comment}{// We have no use for the return value (whether messages should be cleared), because messages were made scoped}}
\DoxyCodeLine{12739         \textcolor{comment}{// and should be let to clear themselves out.}}
\DoxyCodeLine{12740         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(m\_reporter-\/>assertionEnded(AssertionStats(result, m\_messages, m\_totals)));}
\DoxyCodeLine{12741 }
\DoxyCodeLine{12742         \textcolor{keywordflow}{if} (result.getResultType() != ResultWas::Warning)}
\DoxyCodeLine{12743             m\_messageScopes.clear();}
\DoxyCodeLine{12744 }
\DoxyCodeLine{12745         \textcolor{comment}{// Reset working state}}
\DoxyCodeLine{12746         resetAssertionInfo();}
\DoxyCodeLine{12747         m\_lastResult = result;}
\DoxyCodeLine{12748     \}}
\DoxyCodeLine{12749     \textcolor{keywordtype}{void} RunContext::resetAssertionInfo() \{}
\DoxyCodeLine{12750         m\_lastAssertionInfo.macroName = StringRef();}
\DoxyCodeLine{12751         m\_lastAssertionInfo.capturedExpression = \textcolor{stringliteral}{"{}\{Unknown expression after the reported line\}"{}}\_sr;}
\DoxyCodeLine{12752     \}}
\DoxyCodeLine{12753 }
\DoxyCodeLine{12754     \textcolor{keywordtype}{bool} RunContext::sectionStarted(SectionInfo \textcolor{keyword}{const} \& sectionInfo, Counts \& assertions) \{}
\DoxyCodeLine{12755         ITracker\& sectionTracker = SectionTracker::acquire(m\_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));}
\DoxyCodeLine{12756         \textcolor{keywordflow}{if} (!sectionTracker.isOpen())}
\DoxyCodeLine{12757             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12758         m\_activeSections.push\_back(\&sectionTracker);}
\DoxyCodeLine{12759 }
\DoxyCodeLine{12760         m\_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;}
\DoxyCodeLine{12761 }
\DoxyCodeLine{12762         m\_reporter-\/>sectionStarting(sectionInfo);}
\DoxyCodeLine{12763 }
\DoxyCodeLine{12764         assertions = m\_totals.assertions;}
\DoxyCodeLine{12765 }
\DoxyCodeLine{12766         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{12767     \}}
\DoxyCodeLine{12768     \textcolor{keyword}{auto} RunContext::acquireGeneratorTracker( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -\/> IGeneratorTracker\& \{}
\DoxyCodeLine{12769         \textcolor{keyword}{using namespace }Generators;}
\DoxyCodeLine{12770         GeneratorTracker\& tracker = GeneratorTracker::acquire(m\_trackerContext,}
\DoxyCodeLine{12771                                                               TestCaseTracking::NameAndLocation( \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(generatorName), lineInfo ) );}
\DoxyCodeLine{12772         m\_lastAssertionInfo.lineInfo = lineInfo;}
\DoxyCodeLine{12773         \textcolor{keywordflow}{return} tracker;}
\DoxyCodeLine{12774     \}}
\DoxyCodeLine{12775 }
\DoxyCodeLine{12776     \textcolor{keywordtype}{bool} RunContext::testForMissingAssertions(Counts\& assertions) \{}
\DoxyCodeLine{12777         \textcolor{keywordflow}{if} (assertions.total() != 0)}
\DoxyCodeLine{12778             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12779         \textcolor{keywordflow}{if} (!m\_config-\/>warnAboutMissingAssertions())}
\DoxyCodeLine{12780             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12781         \textcolor{keywordflow}{if} (m\_trackerContext.currentTracker().hasChildren())}
\DoxyCodeLine{12782             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12783         m\_totals.assertions.failed++;}
\DoxyCodeLine{12784         assertions.failed++;}
\DoxyCodeLine{12785         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{12786     \}}
\DoxyCodeLine{12787 }
\DoxyCodeLine{12788     \textcolor{keywordtype}{void} RunContext::sectionEnded(SectionEndInfo \textcolor{keyword}{const} \& endInfo) \{}
\DoxyCodeLine{12789         Counts assertions = m\_totals.assertions -\/ endInfo.prevAssertions;}
\DoxyCodeLine{12790         \textcolor{keywordtype}{bool} missingAssertions = testForMissingAssertions(assertions);}
\DoxyCodeLine{12791 }
\DoxyCodeLine{12792         \textcolor{keywordflow}{if} (!m\_activeSections.empty()) \{}
\DoxyCodeLine{12793             m\_activeSections.back()-\/>close();}
\DoxyCodeLine{12794             m\_activeSections.pop\_back();}
\DoxyCodeLine{12795         \}}
\DoxyCodeLine{12796 }
\DoxyCodeLine{12797         m\_reporter-\/>sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));}
\DoxyCodeLine{12798         m\_messages.clear();}
\DoxyCodeLine{12799         m\_messageScopes.clear();}
\DoxyCodeLine{12800     \}}
\DoxyCodeLine{12801 }
\DoxyCodeLine{12802     \textcolor{keywordtype}{void} RunContext::sectionEndedEarly(SectionEndInfo \textcolor{keyword}{const} \& endInfo) \{}
\DoxyCodeLine{12803         \textcolor{keywordflow}{if} (m\_unfinishedSections.empty())}
\DoxyCodeLine{12804             m\_activeSections.back()-\/>fail();}
\DoxyCodeLine{12805         \textcolor{keywordflow}{else}}
\DoxyCodeLine{12806             m\_activeSections.back()-\/>close();}
\DoxyCodeLine{12807         m\_activeSections.pop\_back();}
\DoxyCodeLine{12808 }
\DoxyCodeLine{12809         m\_unfinishedSections.push\_back(endInfo);}
\DoxyCodeLine{12810     \}}
\DoxyCodeLine{12811 }
\DoxyCodeLine{12812 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{12813     \textcolor{keywordtype}{void} RunContext::benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \{}
\DoxyCodeLine{12814         m\_reporter-\/>benchmarkPreparing(name);}
\DoxyCodeLine{12815     \}}
\DoxyCodeLine{12816     \textcolor{keywordtype}{void} RunContext::benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& info ) \{}
\DoxyCodeLine{12817         m\_reporter-\/>benchmarkStarting( info );}
\DoxyCodeLine{12818     \}}
\DoxyCodeLine{12819     \textcolor{keywordtype}{void} RunContext::benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& stats ) \{}
\DoxyCodeLine{12820         m\_reporter-\/>benchmarkEnded( stats );}
\DoxyCodeLine{12821     \}}
\DoxyCodeLine{12822     \textcolor{keywordtype}{void} RunContext::benchmarkFailed(std::string \textcolor{keyword}{const} \& error) \{}
\DoxyCodeLine{12823         m\_reporter-\/>benchmarkFailed(error);}
\DoxyCodeLine{12824     \}}
\DoxyCodeLine{12825 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{12826 }
\DoxyCodeLine{12827     \textcolor{keywordtype}{void} RunContext::pushScopedMessage(MessageInfo \textcolor{keyword}{const} \& message) \{}
\DoxyCodeLine{12828         m\_messages.push\_back(message);}
\DoxyCodeLine{12829     \}}
\DoxyCodeLine{12830 }
\DoxyCodeLine{12831     \textcolor{keywordtype}{void} RunContext::popScopedMessage(MessageInfo \textcolor{keyword}{const} \& message) \{}
\DoxyCodeLine{12832         m\_messages.erase(std::remove(m\_messages.begin(), m\_messages.end(), message), m\_messages.end());}
\DoxyCodeLine{12833     \}}
\DoxyCodeLine{12834 }
\DoxyCodeLine{12835     \textcolor{keywordtype}{void} RunContext::emplaceUnscopedMessage( MessageBuilder \textcolor{keyword}{const}\& builder ) \{}
\DoxyCodeLine{12836         m\_messageScopes.emplace\_back( builder );}
\DoxyCodeLine{12837     \}}
\DoxyCodeLine{12838 }
\DoxyCodeLine{12839     std::string RunContext::getCurrentTestName()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12840         \textcolor{keywordflow}{return} m\_activeTestCase}
\DoxyCodeLine{12841             ? m\_activeTestCase-\/>getTestCaseInfo().name}
\DoxyCodeLine{12842             : std::string();}
\DoxyCodeLine{12843     \}}
\DoxyCodeLine{12844 }
\DoxyCodeLine{12845     \textcolor{keyword}{const} AssertionResult * RunContext::getLastResult()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12846         \textcolor{keywordflow}{return} \&(*m\_lastResult);}
\DoxyCodeLine{12847     \}}
\DoxyCodeLine{12848 }
\DoxyCodeLine{12849     \textcolor{keywordtype}{void} RunContext::exceptionEarlyReported() \{}
\DoxyCodeLine{12850         m\_shouldReportUnexpected = \textcolor{keyword}{false};}
\DoxyCodeLine{12851     \}}
\DoxyCodeLine{12852 }
\DoxyCodeLine{12853     \textcolor{keywordtype}{void} RunContext::handleFatalErrorCondition( StringRef message ) \{}
\DoxyCodeLine{12854         \textcolor{comment}{// First notify reporter that bad things happened}}
\DoxyCodeLine{12855         m\_reporter-\/>fatalErrorEncountered(message);}
\DoxyCodeLine{12856 }
\DoxyCodeLine{12857         \textcolor{comment}{// Don't rebuild the result -\/-\/ the stringification itself can cause more fatal errors}}
\DoxyCodeLine{12858         \textcolor{comment}{// Instead, fake a result data.}}
\DoxyCodeLine{12859         AssertionResultData tempResult( ResultWas::FatalErrorCondition, \{ \textcolor{keyword}{false} \} );}
\DoxyCodeLine{12860         tempResult.message = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(message);}
\DoxyCodeLine{12861         AssertionResult result(m\_lastAssertionInfo, tempResult);}
\DoxyCodeLine{12862 }
\DoxyCodeLine{12863         assertionEnded(result);}
\DoxyCodeLine{12864 }
\DoxyCodeLine{12865         handleUnfinishedSections();}
\DoxyCodeLine{12866 }
\DoxyCodeLine{12867         \textcolor{comment}{// Recreate section for test case (as we will lose the one that was in scope)}}
\DoxyCodeLine{12868         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo = m\_activeTestCase-\/>getTestCaseInfo();}
\DoxyCodeLine{12869         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);}
\DoxyCodeLine{12870 }
\DoxyCodeLine{12871         Counts assertions;}
\DoxyCodeLine{12872         assertions.failed = 1;}
\DoxyCodeLine{12873         SectionStats testCaseSectionStats(testCaseSection, assertions, 0, \textcolor{keyword}{false});}
\DoxyCodeLine{12874         m\_reporter-\/>sectionEnded(testCaseSectionStats);}
\DoxyCodeLine{12875 }
\DoxyCodeLine{12876         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testInfo = m\_activeTestCase-\/>getTestCaseInfo();}
\DoxyCodeLine{12877 }
\DoxyCodeLine{12878         Totals deltaTotals;}
\DoxyCodeLine{12879         deltaTotals.testCases.failed = 1;}
\DoxyCodeLine{12880         deltaTotals.assertions.failed = 1;}
\DoxyCodeLine{12881         m\_reporter-\/>testCaseEnded(TestCaseStats(testInfo,}
\DoxyCodeLine{12882                                   deltaTotals,}
\DoxyCodeLine{12883                                   std::string(),}
\DoxyCodeLine{12884                                   std::string(),}
\DoxyCodeLine{12885                                   \textcolor{keyword}{false}));}
\DoxyCodeLine{12886         m\_totals.testCases.failed++;}
\DoxyCodeLine{12887         testGroupEnded(std::string(), m\_totals, 1, 1);}
\DoxyCodeLine{12888         m\_reporter-\/>testRunEnded(TestRunStats(m\_runInfo, m\_totals, \textcolor{keyword}{false}));}
\DoxyCodeLine{12889     \}}
\DoxyCodeLine{12890 }
\DoxyCodeLine{12891     \textcolor{keywordtype}{bool} RunContext::lastAssertionPassed() \{}
\DoxyCodeLine{12892          \textcolor{keywordflow}{return} m\_lastAssertionPassed;}
\DoxyCodeLine{12893     \}}
\DoxyCodeLine{12894 }
\DoxyCodeLine{12895     \textcolor{keywordtype}{void} RunContext::assertionPassed() \{}
\DoxyCodeLine{12896         m\_lastAssertionPassed = \textcolor{keyword}{true};}
\DoxyCodeLine{12897         ++m\_totals.assertions.passed;}
\DoxyCodeLine{12898         resetAssertionInfo();}
\DoxyCodeLine{12899         m\_messageScopes.clear();}
\DoxyCodeLine{12900     \}}
\DoxyCodeLine{12901 }
\DoxyCodeLine{12902     \textcolor{keywordtype}{bool} RunContext::aborting()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12903         \textcolor{keywordflow}{return} m\_totals.assertions.failed >= \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(m\_config-\/>abortAfter());}
\DoxyCodeLine{12904     \}}
\DoxyCodeLine{12905 }
\DoxyCodeLine{12906     \textcolor{keywordtype}{void} RunContext::runCurrentTest(std::string \& redirectedCout, std::string \& redirectedCerr) \{}
\DoxyCodeLine{12907         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo = m\_activeTestCase-\/>getTestCaseInfo();}
\DoxyCodeLine{12908         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);}
\DoxyCodeLine{12909         m\_reporter-\/>sectionStarting(testCaseSection);}
\DoxyCodeLine{12910         Counts prevAssertions = m\_totals.assertions;}
\DoxyCodeLine{12911         \textcolor{keywordtype}{double} duration = 0;}
\DoxyCodeLine{12912         m\_shouldReportUnexpected = \textcolor{keyword}{true};}
\DoxyCodeLine{12913         m\_lastAssertionInfo = \{ \textcolor{stringliteral}{"{}TEST\_CASE"{}}\_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal \};}
\DoxyCodeLine{12914 }
\DoxyCodeLine{12915         seedRng(*m\_config);}
\DoxyCodeLine{12916 }
\DoxyCodeLine{12917         Timer timer;}
\DoxyCodeLine{12918         CATCH\_TRY \{}
\DoxyCodeLine{12919             \textcolor{keywordflow}{if} (m\_reporter-\/>getPreferences().shouldRedirectStdOut) \{}
\DoxyCodeLine{12920 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_EXPERIMENTAL\_REDIRECT)}}
\DoxyCodeLine{12921                 RedirectedStreams redirectedStreams(redirectedCout, redirectedCerr);}
\DoxyCodeLine{12922 }
\DoxyCodeLine{12923                 timer.start();}
\DoxyCodeLine{12924                 invokeActiveTestCase();}
\DoxyCodeLine{12925 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12926                 OutputRedirect r(redirectedCout, redirectedCerr);}
\DoxyCodeLine{12927                 timer.start();}
\DoxyCodeLine{12928                 invokeActiveTestCase();}
\DoxyCodeLine{12929 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12930             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12931                 timer.start();}
\DoxyCodeLine{12932                 invokeActiveTestCase();}
\DoxyCodeLine{12933             \}}
\DoxyCodeLine{12934             duration = timer.getElapsedSeconds();}
\DoxyCodeLine{12935         \} CATCH\_CATCH\_ANON (TestFailureException\&) \{}
\DoxyCodeLine{12936             \textcolor{comment}{// This just means the test was aborted due to failure}}
\DoxyCodeLine{12937         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{12938             \textcolor{comment}{// Under CATCH\_CONFIG\_FAST\_COMPILE, unexpected exceptions under REQUIRE assertions}}
\DoxyCodeLine{12939             \textcolor{comment}{// are reported without translation at the point of origin.}}
\DoxyCodeLine{12940             \textcolor{keywordflow}{if}( m\_shouldReportUnexpected ) \{}
\DoxyCodeLine{12941                 AssertionReaction dummyReaction;}
\DoxyCodeLine{12942                 handleUnexpectedInflightException( m\_lastAssertionInfo, translateActiveException(), dummyReaction );}
\DoxyCodeLine{12943             \}}
\DoxyCodeLine{12944         \}}
\DoxyCodeLine{12945         Counts assertions = m\_totals.assertions -\/ prevAssertions;}
\DoxyCodeLine{12946         \textcolor{keywordtype}{bool} missingAssertions = testForMissingAssertions(assertions);}
\DoxyCodeLine{12947 }
\DoxyCodeLine{12948         m\_testCaseTracker-\/>close();}
\DoxyCodeLine{12949         handleUnfinishedSections();}
\DoxyCodeLine{12950         m\_messages.clear();}
\DoxyCodeLine{12951         m\_messageScopes.clear();}
\DoxyCodeLine{12952 }
\DoxyCodeLine{12953         SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);}
\DoxyCodeLine{12954         m\_reporter-\/>sectionEnded(testCaseSectionStats);}
\DoxyCodeLine{12955     \}}
\DoxyCodeLine{12956 }
\DoxyCodeLine{12957     \textcolor{keywordtype}{void} RunContext::invokeActiveTestCase() \{}
\DoxyCodeLine{12958         FatalConditionHandler fatalConditionHandler; \textcolor{comment}{// Handle signals}}
\DoxyCodeLine{12959         m\_activeTestCase-\/>invoke();}
\DoxyCodeLine{12960         fatalConditionHandler.reset();}
\DoxyCodeLine{12961     \}}
\DoxyCodeLine{12962 }
\DoxyCodeLine{12963     \textcolor{keywordtype}{void} RunContext::handleUnfinishedSections() \{}
\DoxyCodeLine{12964         \textcolor{comment}{// If sections ended prematurely due to an exception we stored their}}
\DoxyCodeLine{12965         \textcolor{comment}{// infos here so we can tear them down outside the unwind process.}}
\DoxyCodeLine{12966         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = m\_unfinishedSections.rbegin(),}
\DoxyCodeLine{12967              itEnd = m\_unfinishedSections.rend();}
\DoxyCodeLine{12968              it != itEnd;}
\DoxyCodeLine{12969              ++it)}
\DoxyCodeLine{12970             sectionEnded(*it);}
\DoxyCodeLine{12971         m\_unfinishedSections.clear();}
\DoxyCodeLine{12972     \}}
\DoxyCodeLine{12973 }
\DoxyCodeLine{12974     \textcolor{keywordtype}{void} RunContext::handleExpr(}
\DoxyCodeLine{12975         AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{12976         ITransientExpression \textcolor{keyword}{const}\& expr,}
\DoxyCodeLine{12977         AssertionReaction\& reaction}
\DoxyCodeLine{12978     ) \{}
\DoxyCodeLine{12979         m\_reporter-\/>assertionStarting( info );}
\DoxyCodeLine{12980 }
\DoxyCodeLine{12981         \textcolor{keywordtype}{bool} negated = isFalseTest( info.resultDisposition );}
\DoxyCodeLine{12982         \textcolor{keywordtype}{bool} result = expr.getResult() != negated;}
\DoxyCodeLine{12983 }
\DoxyCodeLine{12984         \textcolor{keywordflow}{if}( result ) \{}
\DoxyCodeLine{12985             \textcolor{keywordflow}{if} (!m\_includeSuccessfulResults) \{}
\DoxyCodeLine{12986                 assertionPassed();}
\DoxyCodeLine{12987             \}}
\DoxyCodeLine{12988             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12989                 reportExpr(info, ResultWas::Ok, \&expr, negated);}
\DoxyCodeLine{12990             \}}
\DoxyCodeLine{12991         \}}
\DoxyCodeLine{12992         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12993             reportExpr(info, ResultWas::ExpressionFailed, \&expr, negated );}
\DoxyCodeLine{12994             populateReaction( reaction );}
\DoxyCodeLine{12995         \}}
\DoxyCodeLine{12996     \}}
\DoxyCodeLine{12997     \textcolor{keywordtype}{void} RunContext::reportExpr(}
\DoxyCodeLine{12998             AssertionInfo \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{12999             ResultWas::OfType resultType,}
\DoxyCodeLine{13000             ITransientExpression \textcolor{keyword}{const} *expr,}
\DoxyCodeLine{13001             \textcolor{keywordtype}{bool} negated ) \{}
\DoxyCodeLine{13002 }
\DoxyCodeLine{13003         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13004         AssertionResultData data( resultType, LazyExpression( negated ) );}
\DoxyCodeLine{13005 }
\DoxyCodeLine{13006         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{13007         assertionResult.m\_resultData.lazyExpression.m\_transientExpression = expr;}
\DoxyCodeLine{13008 }
\DoxyCodeLine{13009         assertionEnded( assertionResult );}
\DoxyCodeLine{13010     \}}
\DoxyCodeLine{13011 }
\DoxyCodeLine{13012     \textcolor{keywordtype}{void} RunContext::handleMessage(}
\DoxyCodeLine{13013             AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{13014             ResultWas::OfType resultType,}
\DoxyCodeLine{13015             StringRef \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{13016             AssertionReaction\& reaction}
\DoxyCodeLine{13017     ) \{}
\DoxyCodeLine{13018         m\_reporter-\/>assertionStarting( info );}
\DoxyCodeLine{13019 }
\DoxyCodeLine{13020         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13021 }
\DoxyCodeLine{13022         AssertionResultData data( resultType, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{13023         data.message = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(message);}
\DoxyCodeLine{13024         AssertionResult assertionResult\{ m\_lastAssertionInfo, data \};}
\DoxyCodeLine{13025         assertionEnded( assertionResult );}
\DoxyCodeLine{13026         \textcolor{keywordflow}{if}( !assertionResult.isOk() )}
\DoxyCodeLine{13027             populateReaction( reaction );}
\DoxyCodeLine{13028     \}}
\DoxyCodeLine{13029     \textcolor{keywordtype}{void} RunContext::handleUnexpectedExceptionNotThrown(}
\DoxyCodeLine{13030             AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{13031             AssertionReaction\& reaction}
\DoxyCodeLine{13032     ) \{}
\DoxyCodeLine{13033         handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);}
\DoxyCodeLine{13034     \}}
\DoxyCodeLine{13035 }
\DoxyCodeLine{13036     \textcolor{keywordtype}{void} RunContext::handleUnexpectedInflightException(}
\DoxyCodeLine{13037             AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{13038             std::string \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{13039             AssertionReaction\& reaction}
\DoxyCodeLine{13040     ) \{}
\DoxyCodeLine{13041         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13042 }
\DoxyCodeLine{13043         AssertionResultData data( ResultWas::ThrewException, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{13044         data.message = message;}
\DoxyCodeLine{13045         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{13046         assertionEnded( assertionResult );}
\DoxyCodeLine{13047         populateReaction( reaction );}
\DoxyCodeLine{13048     \}}
\DoxyCodeLine{13049 }
\DoxyCodeLine{13050     \textcolor{keywordtype}{void} RunContext::populateReaction( AssertionReaction\& reaction ) \{}
\DoxyCodeLine{13051         reaction.shouldDebugBreak = m\_config-\/>shouldDebugBreak();}
\DoxyCodeLine{13052         reaction.shouldThrow = aborting() || (m\_lastAssertionInfo.resultDisposition \& ResultDisposition::Normal);}
\DoxyCodeLine{13053     \}}
\DoxyCodeLine{13054 }
\DoxyCodeLine{13055     \textcolor{keywordtype}{void} RunContext::handleIncomplete(}
\DoxyCodeLine{13056             AssertionInfo \textcolor{keyword}{const}\& info}
\DoxyCodeLine{13057     ) \{}
\DoxyCodeLine{13058         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13059 }
\DoxyCodeLine{13060         AssertionResultData data( ResultWas::ThrewException, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{13061         data.message = \textcolor{stringliteral}{"{}Exception translation was disabled by CATCH\_CONFIG\_FAST\_COMPILE"{}};}
\DoxyCodeLine{13062         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{13063         assertionEnded( assertionResult );}
\DoxyCodeLine{13064     \}}
\DoxyCodeLine{13065     \textcolor{keywordtype}{void} RunContext::handleNonExpr(}
\DoxyCodeLine{13066             AssertionInfo \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{13067             ResultWas::OfType resultType,}
\DoxyCodeLine{13068             AssertionReaction \&reaction}
\DoxyCodeLine{13069     ) \{}
\DoxyCodeLine{13070         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13071 }
\DoxyCodeLine{13072         AssertionResultData data( resultType, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{13073         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{13074         assertionEnded( assertionResult );}
\DoxyCodeLine{13075 }
\DoxyCodeLine{13076         \textcolor{keywordflow}{if}( !assertionResult.isOk() )}
\DoxyCodeLine{13077             populateReaction( reaction );}
\DoxyCodeLine{13078     \}}
\DoxyCodeLine{13079 }
\DoxyCodeLine{13080     IResultCapture\& getResultCapture() \{}
\DoxyCodeLine{13081         \textcolor{keywordflow}{if} (\textcolor{keyword}{auto}* capture = getCurrentContext().getResultCapture())}
\DoxyCodeLine{13082             \textcolor{keywordflow}{return} *capture;}
\DoxyCodeLine{13083         \textcolor{keywordflow}{else}}
\DoxyCodeLine{13084             CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}No result capture instance"{}});}
\DoxyCodeLine{13085     \}}
\DoxyCodeLine{13086 }
\DoxyCodeLine{13087     \textcolor{keywordtype}{void} seedRng(IConfig \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{13088         \textcolor{keywordflow}{if} (config.rngSeed() != 0) \{}
\DoxyCodeLine{13089             std::srand(config.rngSeed());}
\DoxyCodeLine{13090             rng().seed(config.rngSeed());}
\DoxyCodeLine{13091         \}}
\DoxyCodeLine{13092     \}}
\DoxyCodeLine{13093 }
\DoxyCodeLine{13094     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() \{}
\DoxyCodeLine{13095         \textcolor{keywordflow}{return} getCurrentContext().getConfig()-\/>rngSeed();}
\DoxyCodeLine{13096     \}}
\DoxyCodeLine{13097 }
\DoxyCodeLine{13098 \}}
\DoxyCodeLine{13099 \textcolor{comment}{// end catch\_run\_context.cpp}}
\DoxyCodeLine{13100 \textcolor{comment}{// start catch\_section.cpp}}
\DoxyCodeLine{13101 }
\DoxyCodeLine{13102 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13103 }
\DoxyCodeLine{13104     Section::Section( SectionInfo \textcolor{keyword}{const}\& info )}
\DoxyCodeLine{13105     :   m\_info( info ),}
\DoxyCodeLine{13106         m\_sectionIncluded( getResultCapture().sectionStarted( m\_info, m\_assertions ) )}
\DoxyCodeLine{13107     \{}
\DoxyCodeLine{13108         m\_timer.start();}
\DoxyCodeLine{13109     \}}
\DoxyCodeLine{13110 }
\DoxyCodeLine{13111     Section::\string~Section() \{}
\DoxyCodeLine{13112         \textcolor{keywordflow}{if}( m\_sectionIncluded ) \{}
\DoxyCodeLine{13113             SectionEndInfo endInfo\{ m\_info, m\_assertions, m\_timer.getElapsedSeconds() \};}
\DoxyCodeLine{13114             \textcolor{keywordflow}{if}( uncaught\_exceptions() )}
\DoxyCodeLine{13115                 getResultCapture().sectionEndedEarly( endInfo );}
\DoxyCodeLine{13116             \textcolor{keywordflow}{else}}
\DoxyCodeLine{13117                 getResultCapture().sectionEnded( endInfo );}
\DoxyCodeLine{13118         \}}
\DoxyCodeLine{13119     \}}
\DoxyCodeLine{13120 }
\DoxyCodeLine{13121     \textcolor{comment}{// This indicates whether the section should be executed or not}}
\DoxyCodeLine{13122     Section::operator bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13123         \textcolor{keywordflow}{return} m\_sectionIncluded;}
\DoxyCodeLine{13124     \}}
\DoxyCodeLine{13125 }
\DoxyCodeLine{13126 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13127 \textcolor{comment}{// end catch\_section.cpp}}
\DoxyCodeLine{13128 \textcolor{comment}{// start catch\_section\_info.cpp}}
\DoxyCodeLine{13129 }
\DoxyCodeLine{13130 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13131 }
\DoxyCodeLine{13132     SectionInfo::SectionInfo}
\DoxyCodeLine{13133         (   SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{13134             std::string \textcolor{keyword}{const}\& \_name )}
\DoxyCodeLine{13135     :   name( \_name ),}
\DoxyCodeLine{13136         lineInfo( \_lineInfo )}
\DoxyCodeLine{13137     \{\}}
\DoxyCodeLine{13138 }
\DoxyCodeLine{13139 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13140 \textcolor{comment}{// end catch\_section\_info.cpp}}
\DoxyCodeLine{13141 \textcolor{comment}{// start catch\_session.cpp}}
\DoxyCodeLine{13142 }
\DoxyCodeLine{13143 \textcolor{comment}{// start catch\_session.h}}
\DoxyCodeLine{13144 }
\DoxyCodeLine{13145 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{13146 }
\DoxyCodeLine{13147 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13148 }
\DoxyCodeLine{13149     \textcolor{keyword}{class }Session : NonCopyable \{}
\DoxyCodeLine{13150     \textcolor{keyword}{public}:}
\DoxyCodeLine{13151 }
\DoxyCodeLine{13152         Session();}
\DoxyCodeLine{13153         \string~Session() \textcolor{keyword}{override};}
\DoxyCodeLine{13154 }
\DoxyCodeLine{13155         \textcolor{keywordtype}{void} showHelp() \textcolor{keyword}{const};}
\DoxyCodeLine{13156         \textcolor{keywordtype}{void} libIdentify();}
\DoxyCodeLine{13157 }
\DoxyCodeLine{13158         \textcolor{keywordtype}{int} applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv );}
\DoxyCodeLine{13159 \textcolor{preprocessor}{    \#if defined(CATCH\_CONFIG\_WCHAR) \&\& defined(\_WIN32) \&\& defined(UNICODE)}}
\DoxyCodeLine{13160         \textcolor{keywordtype}{int} applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv );}
\DoxyCodeLine{13161 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{13162 }
\DoxyCodeLine{13163         \textcolor{keywordtype}{void} useConfigData( ConfigData \textcolor{keyword}{const}\& configData );}
\DoxyCodeLine{13164 }
\DoxyCodeLine{13165         \textcolor{keyword}{template}<\textcolor{keyword}{typename} CharT>}
\DoxyCodeLine{13166         \textcolor{keywordtype}{int} run(\textcolor{keywordtype}{int} argc, CharT \textcolor{keyword}{const} * \textcolor{keyword}{const} argv[]) \{}
\DoxyCodeLine{13167             \textcolor{keywordflow}{if} (m\_startupExceptions)}
\DoxyCodeLine{13168                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{13169             \textcolor{keywordtype}{int} returnCode = applyCommandLine(argc, argv);}
\DoxyCodeLine{13170             \textcolor{keywordflow}{if} (returnCode == 0)}
\DoxyCodeLine{13171                 returnCode = run();}
\DoxyCodeLine{13172             \textcolor{keywordflow}{return} returnCode;}
\DoxyCodeLine{13173         \}}
\DoxyCodeLine{13174 }
\DoxyCodeLine{13175         \textcolor{keywordtype}{int} run();}
\DoxyCodeLine{13176 }
\DoxyCodeLine{13177         \mbox{\hyperlink{structclara_1_1detail_1_1_parser}{clara::Parser}} \textcolor{keyword}{const}\& cli() \textcolor{keyword}{const};}
\DoxyCodeLine{13178         \textcolor{keywordtype}{void} cli( \mbox{\hyperlink{structclara_1_1detail_1_1_parser}{clara::Parser}} \textcolor{keyword}{const}\& newParser );}
\DoxyCodeLine{13179         ConfigData\& configData();}
\DoxyCodeLine{13180         \mbox{\hyperlink{struct_config__}{Config}}\& config();}
\DoxyCodeLine{13181     \textcolor{keyword}{private}:}
\DoxyCodeLine{13182         \textcolor{keywordtype}{int} runInternal();}
\DoxyCodeLine{13183 }
\DoxyCodeLine{13184         \mbox{\hyperlink{structclara_1_1detail_1_1_parser}{clara::Parser}} m\_cli;}
\DoxyCodeLine{13185         ConfigData m\_configData;}
\DoxyCodeLine{13186         std::shared\_ptr<Config> m\_config;}
\DoxyCodeLine{13187         \textcolor{keywordtype}{bool} m\_startupExceptions = \textcolor{keyword}{false};}
\DoxyCodeLine{13188     \};}
\DoxyCodeLine{13189 }
\DoxyCodeLine{13190 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13191 }
\DoxyCodeLine{13192 \textcolor{comment}{// end catch\_session.h}}
\DoxyCodeLine{13193 \textcolor{comment}{// start catch\_version.h}}
\DoxyCodeLine{13194 }
\DoxyCodeLine{13195 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{13196 }
\DoxyCodeLine{13197 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13198 }
\DoxyCodeLine{13199     \textcolor{comment}{// Versioning information}}
\DoxyCodeLine{13200     \textcolor{keyword}{struct }Version \{}
\DoxyCodeLine{13201         Version( Version \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{13202         Version\& operator=( Version \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{13203         Version(    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_majorVersion,}
\DoxyCodeLine{13204                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_minorVersion,}
\DoxyCodeLine{13205                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_patchNumber,}
\DoxyCodeLine{13206                     \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} \_branchName,}
\DoxyCodeLine{13207                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_buildNumber );}
\DoxyCodeLine{13208 }
\DoxyCodeLine{13209         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} majorVersion;}
\DoxyCodeLine{13210         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} minorVersion;}
\DoxyCodeLine{13211         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} patchNumber;}
\DoxyCodeLine{13212 }
\DoxyCodeLine{13213         \textcolor{comment}{// buildNumber is only used if branchName is not null}}
\DoxyCodeLine{13214         \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} branchName;}
\DoxyCodeLine{13215         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} buildNumber;}
\DoxyCodeLine{13216 }
\DoxyCodeLine{13217         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, Version \textcolor{keyword}{const}\& version );}
\DoxyCodeLine{13218     \};}
\DoxyCodeLine{13219 }
\DoxyCodeLine{13220     Version \textcolor{keyword}{const}\& libraryVersion();}
\DoxyCodeLine{13221 \}}
\DoxyCodeLine{13222 }
\DoxyCodeLine{13223 \textcolor{comment}{// end catch\_version.h}}
\DoxyCodeLine{13224 \textcolor{preprocessor}{\#include <cstdlib>}}
\DoxyCodeLine{13225 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{13226 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{13227 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{13228 }
\DoxyCodeLine{13229 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13230 }
\DoxyCodeLine{13231     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{13232         \textcolor{keyword}{const} \textcolor{keywordtype}{int} MaxExitCode = 255;}
\DoxyCodeLine{13233 }
\DoxyCodeLine{13234         IStreamingReporterPtr createReporter(std::string \textcolor{keyword}{const}\& reporterName, IConfigPtr \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{13235             \textcolor{keyword}{auto} reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);}
\DoxyCodeLine{13236             CATCH\_ENFORCE(reporter, \textcolor{stringliteral}{"{}No reporter registered with name: '"{}} << reporterName << \textcolor{stringliteral}{"{}'"{}});}
\DoxyCodeLine{13237 }
\DoxyCodeLine{13238             \textcolor{keywordflow}{return} reporter;}
\DoxyCodeLine{13239         \}}
\DoxyCodeLine{13240 }
\DoxyCodeLine{13241         IStreamingReporterPtr makeReporter(std::shared\_ptr<Config> \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{13242             \textcolor{keywordflow}{if} (Catch::getRegistryHub().getReporterRegistry().getListeners().empty()) \{}
\DoxyCodeLine{13243                 \textcolor{keywordflow}{return} createReporter(config-\/>getReporterName(), config);}
\DoxyCodeLine{13244             \}}
\DoxyCodeLine{13245 }
\DoxyCodeLine{13246             \textcolor{comment}{// On older platforms, returning std::unique\_ptr<ListeningReporter>}}
\DoxyCodeLine{13247             \textcolor{comment}{// when the return type is std::unique\_ptr<IStreamingReporter>}}
\DoxyCodeLine{13248             \textcolor{comment}{// doesn't compile without a std::move call. However, this causes}}
\DoxyCodeLine{13249             \textcolor{comment}{// a warning on newer platforms. Thus, we have to work around}}
\DoxyCodeLine{13250             \textcolor{comment}{// it a bit and downcast the pointer manually.}}
\DoxyCodeLine{13251             \textcolor{keyword}{auto} ret = std::unique\_ptr<IStreamingReporter>(\textcolor{keyword}{new} ListeningReporter);}
\DoxyCodeLine{13252             \textcolor{keyword}{auto}\& multi = \textcolor{keyword}{static\_cast<}ListeningReporter\&\textcolor{keyword}{>}(*ret);}
\DoxyCodeLine{13253             \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();}
\DoxyCodeLine{13254             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : listeners) \{}
\DoxyCodeLine{13255                 multi.addListener(listener-\/>create(Catch::ReporterConfig(config)));}
\DoxyCodeLine{13256             \}}
\DoxyCodeLine{13257             multi.addReporter(createReporter(config-\/>getReporterName(), config));}
\DoxyCodeLine{13258             \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{13259         \}}
\DoxyCodeLine{13260 }
\DoxyCodeLine{13261         \textcolor{keyword}{class }TestGroup \{}
\DoxyCodeLine{13262         \textcolor{keyword}{public}:}
\DoxyCodeLine{13263             \textcolor{keyword}{explicit} TestGroup(std::shared\_ptr<Config> \textcolor{keyword}{const}\& config)}
\DoxyCodeLine{13264             : m\_config\{config\}}
\DoxyCodeLine{13265             , m\_context\{config, makeReporter(config)\}}
\DoxyCodeLine{13266             \{}
\DoxyCodeLine{13267                 \textcolor{keyword}{auto} \textcolor{keyword}{const}\& allTestCases = getAllTestCasesSorted(*m\_config);}
\DoxyCodeLine{13268                 m\_matches = m\_config-\/>testSpec().matchesByFilter(allTestCases, *m\_config);}
\DoxyCodeLine{13269                 \textcolor{keyword}{auto} \textcolor{keyword}{const}\& invalidArgs = m\_config-\/>testSpec().getInvalidArgs();}
\DoxyCodeLine{13270 }
\DoxyCodeLine{13271                 \textcolor{keywordflow}{if} (m\_matches.empty() \&\& invalidArgs.empty()) \{}
\DoxyCodeLine{13272                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& test : allTestCases)}
\DoxyCodeLine{13273                         \textcolor{keywordflow}{if} (!test.isHidden())}
\DoxyCodeLine{13274                             m\_tests.emplace(\&test);}
\DoxyCodeLine{13275                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13276                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& match : m\_matches)}
\DoxyCodeLine{13277                         m\_tests.insert(match.tests.begin(), match.tests.end());}
\DoxyCodeLine{13278                 \}}
\DoxyCodeLine{13279             \}}
\DoxyCodeLine{13280 }
\DoxyCodeLine{13281             Totals execute() \{}
\DoxyCodeLine{13282                 \textcolor{keyword}{auto} \textcolor{keyword}{const}\& invalidArgs = m\_config-\/>testSpec().getInvalidArgs();}
\DoxyCodeLine{13283                 Totals totals;}
\DoxyCodeLine{13284                 m\_context.testGroupStarting(m\_config-\/>name(), 1, 1);}
\DoxyCodeLine{13285                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : m\_tests) \{}
\DoxyCodeLine{13286                     \textcolor{keywordflow}{if} (!m\_context.aborting())}
\DoxyCodeLine{13287                         totals += m\_context.runTest(*testCase);}
\DoxyCodeLine{13288                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13289                         m\_context.reporter().skipTest(*testCase);}
\DoxyCodeLine{13290                 \}}
\DoxyCodeLine{13291 }
\DoxyCodeLine{13292                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& match : m\_matches) \{}
\DoxyCodeLine{13293                     \textcolor{keywordflow}{if} (match.tests.empty()) \{}
\DoxyCodeLine{13294                         m\_context.reporter().noMatchingTestCases(match.name);}
\DoxyCodeLine{13295                         totals.error = -\/1;}
\DoxyCodeLine{13296                     \}}
\DoxyCodeLine{13297                 \}}
\DoxyCodeLine{13298 }
\DoxyCodeLine{13299                 \textcolor{keywordflow}{if} (!invalidArgs.empty()) \{}
\DoxyCodeLine{13300                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& invalidArg: invalidArgs)}
\DoxyCodeLine{13301                          m\_context.reporter().reportInvalidArguments(invalidArg);}
\DoxyCodeLine{13302                 \}}
\DoxyCodeLine{13303 }
\DoxyCodeLine{13304                 m\_context.testGroupEnded(m\_config-\/>name(), totals, 1, 1);}
\DoxyCodeLine{13305                 \textcolor{keywordflow}{return} totals;}
\DoxyCodeLine{13306             \}}
\DoxyCodeLine{13307 }
\DoxyCodeLine{13308         \textcolor{keyword}{private}:}
\DoxyCodeLine{13309             \textcolor{keyword}{using} Tests = std::set<TestCase const*>;}
\DoxyCodeLine{13310 }
\DoxyCodeLine{13311             std::shared\_ptr<Config> m\_config;}
\DoxyCodeLine{13312             RunContext m\_context;}
\DoxyCodeLine{13313             Tests m\_tests;}
\DoxyCodeLine{13314             TestSpec::Matches m\_matches;}
\DoxyCodeLine{13315         \};}
\DoxyCodeLine{13316 }
\DoxyCodeLine{13317         \textcolor{keywordtype}{void} applyFilenamesAsTags(\mbox{\hyperlink{struct_catch_1_1_i_config}{Catch::IConfig}} \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{13318             \textcolor{keyword}{auto}\& tests = \textcolor{keyword}{const\_cast<}std::vector<TestCase>\&\textcolor{keyword}{>}(getAllTestCasesSorted(config));}
\DoxyCodeLine{13319             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& testCase : tests) \{}
\DoxyCodeLine{13320                 \textcolor{keyword}{auto} tags = testCase.tags;}
\DoxyCodeLine{13321 }
\DoxyCodeLine{13322                 std::string filename = testCase.lineInfo.file;}
\DoxyCodeLine{13323                 \textcolor{keyword}{auto} lastSlash = filename.find\_last\_of(\textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)/"{}});}
\DoxyCodeLine{13324                 \textcolor{keywordflow}{if} (lastSlash != std::string::npos) \{}
\DoxyCodeLine{13325                     filename.erase(0, lastSlash);}
\DoxyCodeLine{13326                     filename[0] = \textcolor{charliteral}{'\#'};}
\DoxyCodeLine{13327                 \}}
\DoxyCodeLine{13328 }
\DoxyCodeLine{13329                 \textcolor{keyword}{auto} lastDot = filename.find\_last\_of(\textcolor{charliteral}{'.'});}
\DoxyCodeLine{13330                 \textcolor{keywordflow}{if} (lastDot != std::string::npos) \{}
\DoxyCodeLine{13331                     filename.erase(lastDot);}
\DoxyCodeLine{13332                 \}}
\DoxyCodeLine{13333 }
\DoxyCodeLine{13334                 tags.push\_back(std::move(filename));}
\DoxyCodeLine{13335                 setTags(testCase, tags);}
\DoxyCodeLine{13336             \}}
\DoxyCodeLine{13337         \}}
\DoxyCodeLine{13338 }
\DoxyCodeLine{13339     \} \textcolor{comment}{// anon namespace}}
\DoxyCodeLine{13340 }
\DoxyCodeLine{13341     Session::Session() \{}
\DoxyCodeLine{13342         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} alreadyInstantiated = \textcolor{keyword}{false};}
\DoxyCodeLine{13343         \textcolor{keywordflow}{if}( alreadyInstantiated ) \{}
\DoxyCodeLine{13344             CATCH\_TRY \{ CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Only one instance of Catch::Session can ever be used"{}} ); \}}
\DoxyCodeLine{13345             CATCH\_CATCH\_ALL \{ getMutableRegistryHub().registerStartupException(); \}}
\DoxyCodeLine{13346         \}}
\DoxyCodeLine{13347 }
\DoxyCodeLine{13348         \textcolor{comment}{// There cannot be exceptions at startup in no-\/exception mode.}}
\DoxyCodeLine{13349 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{13350         \textcolor{keyword}{const} \textcolor{keyword}{auto}\& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();}
\DoxyCodeLine{13351         \textcolor{keywordflow}{if} ( !exceptions.empty() ) \{}
\DoxyCodeLine{13352             config();}
\DoxyCodeLine{13353             getCurrentMutableContext().setConfig(m\_config);}
\DoxyCodeLine{13354 }
\DoxyCodeLine{13355             m\_startupExceptions = \textcolor{keyword}{true};}
\DoxyCodeLine{13356             Colour colourGuard( Colour::Red );}
\DoxyCodeLine{13357             Catch::cerr() << \textcolor{stringliteral}{"{}Errors occurred during startup!"{}} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13358             \textcolor{comment}{// iterate over all exceptions and notify user}}
\DoxyCodeLine{13359             \textcolor{keywordflow}{for} ( \textcolor{keyword}{const} \textcolor{keyword}{auto}\& ex\_ptr : exceptions ) \{}
\DoxyCodeLine{13360                 \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{13361                     std::rethrow\_exception(ex\_ptr);}
\DoxyCodeLine{13362                 \} \textcolor{keywordflow}{catch} ( std::exception \textcolor{keyword}{const}\& ex ) \{}
\DoxyCodeLine{13363                     Catch::cerr() << Column( ex.what() ).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13364                 \}}
\DoxyCodeLine{13365             \}}
\DoxyCodeLine{13366         \}}
\DoxyCodeLine{13367 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13368 }
\DoxyCodeLine{13369         alreadyInstantiated = \textcolor{keyword}{true};}
\DoxyCodeLine{13370         m\_cli = makeCommandLineParser( m\_configData );}
\DoxyCodeLine{13371     \}}
\DoxyCodeLine{13372     Session::\string~Session() \{}
\DoxyCodeLine{13373         Catch::cleanUp();}
\DoxyCodeLine{13374     \}}
\DoxyCodeLine{13375 }
\DoxyCodeLine{13376     \textcolor{keywordtype}{void} Session::showHelp()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13377         Catch::cout()}
\DoxyCodeLine{13378                 << \textcolor{stringliteral}{"{}\(\backslash\)nCatch v"{}} << libraryVersion() << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{13379                 << m\_cli << std::endl}
\DoxyCodeLine{13380                 << \textcolor{stringliteral}{"{}For more detailed usage please see the project docs\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{13381     \}}
\DoxyCodeLine{13382     \textcolor{keywordtype}{void} Session::libIdentify() \{}
\DoxyCodeLine{13383         Catch::cout()}
\DoxyCodeLine{13384                 << std::left << std::setw(16) << \textcolor{stringliteral}{"{}description: "{}} << \textcolor{stringliteral}{"{}A Catch2 test executable\(\backslash\)n"{}}}
\DoxyCodeLine{13385                 << std::left << std::setw(16) << \textcolor{stringliteral}{"{}category: "{}} << \textcolor{stringliteral}{"{}testframework\(\backslash\)n"{}}}
\DoxyCodeLine{13386                 << std::left << std::setw(16) << \textcolor{stringliteral}{"{}framework: "{}} << \textcolor{stringliteral}{"{}Catch Test\(\backslash\)n"{}}}
\DoxyCodeLine{13387                 << std::left << std::setw(16) << \textcolor{stringliteral}{"{}version: "{}} << libraryVersion() << std::endl;}
\DoxyCodeLine{13388     \}}
\DoxyCodeLine{13389 }
\DoxyCodeLine{13390     \textcolor{keywordtype}{int} Session::applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv ) \{}
\DoxyCodeLine{13391         \textcolor{keywordflow}{if}( m\_startupExceptions )}
\DoxyCodeLine{13392             \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{13393 }
\DoxyCodeLine{13394         \textcolor{keyword}{auto} result = m\_cli.parse( \mbox{\hyperlink{classclara_1_1detail_1_1_args}{clara::Args}}( argc, argv ) );}
\DoxyCodeLine{13395         \textcolor{keywordflow}{if}( !result ) \{}
\DoxyCodeLine{13396             config();}
\DoxyCodeLine{13397             getCurrentMutableContext().setConfig(m\_config);}
\DoxyCodeLine{13398             Catch::cerr()}
\DoxyCodeLine{13399                 << Colour( Colour::Red )}
\DoxyCodeLine{13400                 << \textcolor{stringliteral}{"{}\(\backslash\)nError(s) in input:\(\backslash\)n"{}}}
\DoxyCodeLine{13401                 << Column( result.errorMessage() ).indent( 2 )}
\DoxyCodeLine{13402                 << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{13403             Catch::cerr() << \textcolor{stringliteral}{"{}Run with -\/? for usage\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{13404             \textcolor{keywordflow}{return} MaxExitCode;}
\DoxyCodeLine{13405         \}}
\DoxyCodeLine{13406 }
\DoxyCodeLine{13407         \textcolor{keywordflow}{if}( m\_configData.showHelp )}
\DoxyCodeLine{13408             showHelp();}
\DoxyCodeLine{13409         \textcolor{keywordflow}{if}( m\_configData.libIdentify )}
\DoxyCodeLine{13410             libIdentify();}
\DoxyCodeLine{13411         m\_config.reset();}
\DoxyCodeLine{13412         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{13413     \}}
\DoxyCodeLine{13414 }
\DoxyCodeLine{13415 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_WCHAR) \&\& defined(\_WIN32) \&\& defined(UNICODE)}}
\DoxyCodeLine{13416     \textcolor{keywordtype}{int} Session::applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv ) \{}
\DoxyCodeLine{13417 }
\DoxyCodeLine{13418         \textcolor{keywordtype}{char} **utf8Argv = \textcolor{keyword}{new} \textcolor{keywordtype}{char} *[ argc ];}
\DoxyCodeLine{13419 }
\DoxyCodeLine{13420         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < argc; ++i ) \{}
\DoxyCodeLine{13421             \textcolor{keywordtype}{int} bufSize = WideCharToMultiByte( CP\_UTF8, 0, argv[i], -\/1, \textcolor{keyword}{nullptr}, 0, \textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr} );}
\DoxyCodeLine{13422 }
\DoxyCodeLine{13423             utf8Argv[ i ] = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[ bufSize ];}
\DoxyCodeLine{13424 }
\DoxyCodeLine{13425             WideCharToMultiByte( CP\_UTF8, 0, argv[i], -\/1, utf8Argv[i], bufSize, \textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr} );}
\DoxyCodeLine{13426         \}}
\DoxyCodeLine{13427 }
\DoxyCodeLine{13428         \textcolor{keywordtype}{int} returnCode = applyCommandLine( argc, utf8Argv );}
\DoxyCodeLine{13429 }
\DoxyCodeLine{13430         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < argc; ++i )}
\DoxyCodeLine{13431             delete [] utf8Argv[ i ];}
\DoxyCodeLine{13432 }
\DoxyCodeLine{13433         \textcolor{keyword}{delete} [] utf8Argv;}
\DoxyCodeLine{13434 }
\DoxyCodeLine{13435         \textcolor{keywordflow}{return} returnCode;}
\DoxyCodeLine{13436     \}}
\DoxyCodeLine{13437 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13438 }
\DoxyCodeLine{13439     \textcolor{keywordtype}{void} Session::useConfigData( ConfigData \textcolor{keyword}{const}\& configData ) \{}
\DoxyCodeLine{13440         m\_configData = configData;}
\DoxyCodeLine{13441         m\_config.reset();}
\DoxyCodeLine{13442     \}}
\DoxyCodeLine{13443 }
\DoxyCodeLine{13444     \textcolor{keywordtype}{int} Session::run() \{}
\DoxyCodeLine{13445         \textcolor{keywordflow}{if}( ( m\_configData.waitForKeypress \& WaitForKeypress::BeforeStart ) != 0 ) \{}
\DoxyCodeLine{13446             Catch::cout() << \textcolor{stringliteral}{"{}...waiting for enter/ return before starting"{}} << std::endl;}
\DoxyCodeLine{13447             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(std::getchar());}
\DoxyCodeLine{13448         \}}
\DoxyCodeLine{13449         \textcolor{keywordtype}{int} exitCode = runInternal();}
\DoxyCodeLine{13450         \textcolor{keywordflow}{if}( ( m\_configData.waitForKeypress \& WaitForKeypress::BeforeExit ) != 0 ) \{}
\DoxyCodeLine{13451             Catch::cout() << \textcolor{stringliteral}{"{}...waiting for enter/ return before exiting, with code: "{}} << exitCode << std::endl;}
\DoxyCodeLine{13452             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(std::getchar());}
\DoxyCodeLine{13453         \}}
\DoxyCodeLine{13454         \textcolor{keywordflow}{return} exitCode;}
\DoxyCodeLine{13455     \}}
\DoxyCodeLine{13456 }
\DoxyCodeLine{13457     \mbox{\hyperlink{structclara_1_1detail_1_1_parser}{clara::Parser}} \textcolor{keyword}{const}\& Session::cli()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13458         \textcolor{keywordflow}{return} m\_cli;}
\DoxyCodeLine{13459     \}}
\DoxyCodeLine{13460     \textcolor{keywordtype}{void} Session::cli( \mbox{\hyperlink{structclara_1_1detail_1_1_parser}{clara::Parser}} \textcolor{keyword}{const}\& newParser ) \{}
\DoxyCodeLine{13461         m\_cli = newParser;}
\DoxyCodeLine{13462     \}}
\DoxyCodeLine{13463     ConfigData\& Session::configData() \{}
\DoxyCodeLine{13464         \textcolor{keywordflow}{return} m\_configData;}
\DoxyCodeLine{13465     \}}
\DoxyCodeLine{13466     \mbox{\hyperlink{struct_config__}{Config}}\& Session::config() \{}
\DoxyCodeLine{13467         \textcolor{keywordflow}{if}( !m\_config )}
\DoxyCodeLine{13468             m\_config = std::make\_shared<Config>( m\_configData );}
\DoxyCodeLine{13469         \textcolor{keywordflow}{return} *m\_config;}
\DoxyCodeLine{13470     \}}
\DoxyCodeLine{13471 }
\DoxyCodeLine{13472     \textcolor{keywordtype}{int} Session::runInternal() \{}
\DoxyCodeLine{13473         \textcolor{keywordflow}{if}( m\_startupExceptions )}
\DoxyCodeLine{13474             \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{13475 }
\DoxyCodeLine{13476         \textcolor{keywordflow}{if} (m\_configData.showHelp || m\_configData.libIdentify) \{}
\DoxyCodeLine{13477             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{13478         \}}
\DoxyCodeLine{13479 }
\DoxyCodeLine{13480         CATCH\_TRY \{}
\DoxyCodeLine{13481             config(); \textcolor{comment}{// Force config to be constructed}}
\DoxyCodeLine{13482 }
\DoxyCodeLine{13483             seedRng( *m\_config );}
\DoxyCodeLine{13484 }
\DoxyCodeLine{13485             \textcolor{keywordflow}{if}( m\_configData.filenamesAsTags )}
\DoxyCodeLine{13486                 applyFilenamesAsTags( *m\_config );}
\DoxyCodeLine{13487 }
\DoxyCodeLine{13488             \textcolor{comment}{// Handle list request}}
\DoxyCodeLine{13489             \textcolor{keywordflow}{if}( Option<std::size\_t> listed = list( m\_config ) )}
\DoxyCodeLine{13490                 \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( *listed );}
\DoxyCodeLine{13491 }
\DoxyCodeLine{13492             TestGroup tests \{ m\_config \};}
\DoxyCodeLine{13493             \textcolor{keyword}{auto} \textcolor{keyword}{const} totals = tests.execute();}
\DoxyCodeLine{13494 }
\DoxyCodeLine{13495             \textcolor{keywordflow}{if}( m\_config-\/>warnAboutNoTests() \&\& totals.error == -\/1 )}
\DoxyCodeLine{13496                 \textcolor{keywordflow}{return} 2;}
\DoxyCodeLine{13497 }
\DoxyCodeLine{13498             \textcolor{comment}{// Note that on unices only the lower 8 bits are usually used, clamping}}
\DoxyCodeLine{13499             \textcolor{comment}{// the return value to 255 prevents false negative when some multiple}}
\DoxyCodeLine{13500             \textcolor{comment}{// of 256 tests has failed}}
\DoxyCodeLine{13501             \textcolor{keywordflow}{return} (std::min) (MaxExitCode, (std::max) (totals.error, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(totals.assertions.failed)));}
\DoxyCodeLine{13502         \}}
\DoxyCodeLine{13503 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{13504         \textcolor{keywordflow}{catch}( std::exception\& ex ) \{}
\DoxyCodeLine{13505             Catch::cerr() << ex.what() << std::endl;}
\DoxyCodeLine{13506             \textcolor{keywordflow}{return} MaxExitCode;}
\DoxyCodeLine{13507         \}}
\DoxyCodeLine{13508 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13509     \}}
\DoxyCodeLine{13510 }
\DoxyCodeLine{13511 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13512 \textcolor{comment}{// end catch\_session.cpp}}
\DoxyCodeLine{13513 \textcolor{comment}{// start catch\_singletons.cpp}}
\DoxyCodeLine{13514 }
\DoxyCodeLine{13515 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{13516 }
\DoxyCodeLine{13517 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13518 }
\DoxyCodeLine{13519     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{13520         \textcolor{keyword}{static} \textcolor{keyword}{auto} getSingletons() -\/> std::vector<ISingleton*>*\& \{}
\DoxyCodeLine{13521             \textcolor{keyword}{static} std::vector<ISingleton*>* g\_singletons = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{13522             \textcolor{keywordflow}{if}( !g\_singletons )}
\DoxyCodeLine{13523                 g\_singletons = \textcolor{keyword}{new} std::vector<ISingleton*>();}
\DoxyCodeLine{13524             \textcolor{keywordflow}{return} g\_singletons;}
\DoxyCodeLine{13525         \}}
\DoxyCodeLine{13526     \}}
\DoxyCodeLine{13527 }
\DoxyCodeLine{13528     ISingleton::\string~ISingleton() \{\}}
\DoxyCodeLine{13529 }
\DoxyCodeLine{13530     \textcolor{keywordtype}{void} addSingleton(ISingleton* singleton ) \{}
\DoxyCodeLine{13531         getSingletons()-\/>push\_back( singleton );}
\DoxyCodeLine{13532     \}}
\DoxyCodeLine{13533     \textcolor{keywordtype}{void} cleanupSingletons() \{}
\DoxyCodeLine{13534         \textcolor{keyword}{auto}\& singletons = getSingletons();}
\DoxyCodeLine{13535         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} singleton : *singletons )}
\DoxyCodeLine{13536             \textcolor{keyword}{delete} singleton;}
\DoxyCodeLine{13537         \textcolor{keyword}{delete} singletons;}
\DoxyCodeLine{13538         singletons = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{13539     \}}
\DoxyCodeLine{13540 }
\DoxyCodeLine{13541 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{13542 \textcolor{comment}{// end catch\_singletons.cpp}}
\DoxyCodeLine{13543 \textcolor{comment}{// start catch\_startup\_exception\_registry.cpp}}
\DoxyCodeLine{13544 }
\DoxyCodeLine{13545 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{13546 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13547 \textcolor{keywordtype}{void} StartupExceptionRegistry::add( std::exception\_ptr \textcolor{keyword}{const}\& exception ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{13548         CATCH\_TRY \{}
\DoxyCodeLine{13549             m\_exceptions.push\_back(exception);}
\DoxyCodeLine{13550         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{13551             \textcolor{comment}{// If we run out of memory during start-\/up there's really not a lot more we can do about it}}
\DoxyCodeLine{13552             std::terminate();}
\DoxyCodeLine{13553         \}}
\DoxyCodeLine{13554     \}}
\DoxyCodeLine{13555 }
\DoxyCodeLine{13556     std::vector<std::exception\_ptr> \textcolor{keyword}{const}\& StartupExceptionRegistry::getExceptions() const noexcept \{}
\DoxyCodeLine{13557         \textcolor{keywordflow}{return} m\_exceptions;}
\DoxyCodeLine{13558     \}}
\DoxyCodeLine{13559 }
\DoxyCodeLine{13560 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13561 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13562 \textcolor{comment}{// end catch\_startup\_exception\_registry.cpp}}
\DoxyCodeLine{13563 \textcolor{comment}{// start catch\_stream.cpp}}
\DoxyCodeLine{13564 }
\DoxyCodeLine{13565 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{13566 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{13567 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{13568 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{13569 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{13570 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{13571 }
\DoxyCodeLine{13572 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13573 }
\DoxyCodeLine{13574     Catch::IStream::\string~IStream() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{13575 }
\DoxyCodeLine{13576     \textcolor{keyword}{namespace }Detail \{ \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{13577         \textcolor{keyword}{template}<\textcolor{keyword}{typename} WriterF, std::\textcolor{keywordtype}{size\_t} bufferSize=256>}
\DoxyCodeLine{13578         \textcolor{keyword}{class }StreamBufImpl : \textcolor{keyword}{public} std::streambuf \{}
\DoxyCodeLine{13579             \textcolor{keywordtype}{char} data[bufferSize];}
\DoxyCodeLine{13580             WriterF m\_writer;}
\DoxyCodeLine{13581 }
\DoxyCodeLine{13582         \textcolor{keyword}{public}:}
\DoxyCodeLine{13583             StreamBufImpl() \{}
\DoxyCodeLine{13584                 setp( data, data + \textcolor{keyword}{sizeof}(data) );}
\DoxyCodeLine{13585             \}}
\DoxyCodeLine{13586 }
\DoxyCodeLine{13587             \string~StreamBufImpl() noexcept \{}
\DoxyCodeLine{13588                 StreamBufImpl::sync();}
\DoxyCodeLine{13589             \}}
\DoxyCodeLine{13590 }
\DoxyCodeLine{13591         \textcolor{keyword}{private}:}
\DoxyCodeLine{13592             \textcolor{keywordtype}{int} overflow( \textcolor{keywordtype}{int} c )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{13593                 sync();}
\DoxyCodeLine{13594 }
\DoxyCodeLine{13595                 \textcolor{keywordflow}{if}( c != EOF ) \{}
\DoxyCodeLine{13596                     \textcolor{keywordflow}{if}( pbase() == epptr() )}
\DoxyCodeLine{13597                         m\_writer( std::string( 1, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( c ) ) );}
\DoxyCodeLine{13598                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13599                         sputc( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( c ) );}
\DoxyCodeLine{13600                 \}}
\DoxyCodeLine{13601                 \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{13602             \}}
\DoxyCodeLine{13603 }
\DoxyCodeLine{13604             \textcolor{keywordtype}{int} sync()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{13605                 \textcolor{keywordflow}{if}( pbase() != pptr() ) \{}
\DoxyCodeLine{13606                     m\_writer( std::string( pbase(), \textcolor{keyword}{static\_cast<}std::string::size\_type\textcolor{keyword}{>}( pptr() -\/ pbase() ) ) );}
\DoxyCodeLine{13607                     setp( pbase(), epptr() );}
\DoxyCodeLine{13608                 \}}
\DoxyCodeLine{13609                 \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{13610             \}}
\DoxyCodeLine{13611         \};}
\DoxyCodeLine{13612 }
\DoxyCodeLine{13614 }
\DoxyCodeLine{13615         \textcolor{keyword}{struct }OutputDebugWriter \{}
\DoxyCodeLine{13616 }
\DoxyCodeLine{13617             \textcolor{keywordtype}{void} operator()( std::string \textcolor{keyword}{const}\&str ) \{}
\DoxyCodeLine{13618                 writeToDebugConsole( str );}
\DoxyCodeLine{13619             \}}
\DoxyCodeLine{13620         \};}
\DoxyCodeLine{13621 }
\DoxyCodeLine{13623 }
\DoxyCodeLine{13624         \textcolor{keyword}{class }FileStream : \textcolor{keyword}{public} IStream \{}
\DoxyCodeLine{13625             \textcolor{keyword}{mutable} std::ofstream m\_ofs;}
\DoxyCodeLine{13626         \textcolor{keyword}{public}:}
\DoxyCodeLine{13627             FileStream( StringRef filename ) \{}
\DoxyCodeLine{13628                 m\_ofs.open( filename.c\_str() );}
\DoxyCodeLine{13629                 CATCH\_ENFORCE( !m\_ofs.fail(), \textcolor{stringliteral}{"{}Unable to open file: '"{}} << filename << \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{13630             \}}
\DoxyCodeLine{13631             \string~FileStream() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{13632         \textcolor{keyword}{public}: \textcolor{comment}{// IStream}}
\DoxyCodeLine{13633             std::ostream\& stream()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{13634                 \textcolor{keywordflow}{return} m\_ofs;}
\DoxyCodeLine{13635             \}}
\DoxyCodeLine{13636         \};}
\DoxyCodeLine{13637 }
\DoxyCodeLine{13639 }
\DoxyCodeLine{13640         \textcolor{keyword}{class }CoutStream : \textcolor{keyword}{public} IStream \{}
\DoxyCodeLine{13641             \textcolor{keyword}{mutable} std::ostream m\_os;}
\DoxyCodeLine{13642         \textcolor{keyword}{public}:}
\DoxyCodeLine{13643             \textcolor{comment}{// Store the streambuf from cout up-\/front because}}
\DoxyCodeLine{13644             \textcolor{comment}{// cout may get redirected when running tests}}
\DoxyCodeLine{13645             CoutStream() : m\_os( Catch::cout().rdbuf() ) \{\}}
\DoxyCodeLine{13646             \string~CoutStream() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{13647 }
\DoxyCodeLine{13648         \textcolor{keyword}{public}: \textcolor{comment}{// IStream}}
\DoxyCodeLine{13649             std::ostream\& stream()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} m\_os; \}}
\DoxyCodeLine{13650         \};}
\DoxyCodeLine{13651 }
\DoxyCodeLine{13653 }
\DoxyCodeLine{13654         \textcolor{keyword}{class }DebugOutStream : \textcolor{keyword}{public} IStream \{}
\DoxyCodeLine{13655             std::unique\_ptr<StreamBufImpl<OutputDebugWriter>> m\_streamBuf;}
\DoxyCodeLine{13656             \textcolor{keyword}{mutable} std::ostream m\_os;}
\DoxyCodeLine{13657         \textcolor{keyword}{public}:}
\DoxyCodeLine{13658             DebugOutStream()}
\DoxyCodeLine{13659             :   m\_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),}
\DoxyCodeLine{13660                 m\_os( m\_streamBuf.get() )}
\DoxyCodeLine{13661             \{\}}
\DoxyCodeLine{13662 }
\DoxyCodeLine{13663             \string~DebugOutStream() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{13664 }
\DoxyCodeLine{13665         \textcolor{keyword}{public}: \textcolor{comment}{// IStream}}
\DoxyCodeLine{13666             std::ostream\& stream()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} m\_os; \}}
\DoxyCodeLine{13667         \};}
\DoxyCodeLine{13668 }
\DoxyCodeLine{13669     \}\} \textcolor{comment}{// namespace anon::detail}}
\DoxyCodeLine{13670 }
\DoxyCodeLine{13672 }
\DoxyCodeLine{13673     \textcolor{keyword}{auto} makeStream( StringRef \textcolor{keyword}{const} \&filename ) -\/> IStream \textcolor{keyword}{const}* \{}
\DoxyCodeLine{13674         \textcolor{keywordflow}{if}( filename.empty() )}
\DoxyCodeLine{13675             \textcolor{keywordflow}{return} \textcolor{keyword}{new} Detail::CoutStream();}
\DoxyCodeLine{13676         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( filename[0] == \textcolor{charliteral}{'\%'} ) \{}
\DoxyCodeLine{13677             \textcolor{keywordflow}{if}( filename == \textcolor{stringliteral}{"{}\%debug"{}} )}
\DoxyCodeLine{13678                 \textcolor{keywordflow}{return} \textcolor{keyword}{new} Detail::DebugOutStream();}
\DoxyCodeLine{13679             \textcolor{keywordflow}{else}}
\DoxyCodeLine{13680                 CATCH\_ERROR( \textcolor{stringliteral}{"{}Unrecognised stream: '"{}} << filename << \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{13681         \}}
\DoxyCodeLine{13682         \textcolor{keywordflow}{else}}
\DoxyCodeLine{13683             \textcolor{keywordflow}{return} \textcolor{keyword}{new} Detail::FileStream( filename );}
\DoxyCodeLine{13684     \}}
\DoxyCodeLine{13685 }
\DoxyCodeLine{13686     \textcolor{comment}{// This class encapsulates the idea of a pool of ostringstreams that can be reused.}}
\DoxyCodeLine{13687     \textcolor{keyword}{struct }StringStreams \{}
\DoxyCodeLine{13688         std::vector<std::unique\_ptr<std::ostringstream>> m\_streams;}
\DoxyCodeLine{13689         std::vector<std::size\_t> m\_unused;}
\DoxyCodeLine{13690         std::ostringstream m\_referenceStream; \textcolor{comment}{// Used for copy state/ flags from}}
\DoxyCodeLine{13691 }
\DoxyCodeLine{13692         \textcolor{keyword}{auto} add() -\/> std::size\_t \{}
\DoxyCodeLine{13693             \textcolor{keywordflow}{if}( m\_unused.empty() ) \{}
\DoxyCodeLine{13694                 m\_streams.push\_back( std::unique\_ptr<std::ostringstream>( \textcolor{keyword}{new} std::ostringstream ) );}
\DoxyCodeLine{13695                 \textcolor{keywordflow}{return} m\_streams.size()-\/1;}
\DoxyCodeLine{13696             \}}
\DoxyCodeLine{13697             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13698                 \textcolor{keyword}{auto} index = m\_unused.back();}
\DoxyCodeLine{13699                 m\_unused.pop\_back();}
\DoxyCodeLine{13700                 \textcolor{keywordflow}{return} index;}
\DoxyCodeLine{13701             \}}
\DoxyCodeLine{13702         \}}
\DoxyCodeLine{13703 }
\DoxyCodeLine{13704         \textcolor{keywordtype}{void} release( std::size\_t index ) \{}
\DoxyCodeLine{13705             m\_streams[index]-\/>copyfmt( m\_referenceStream ); \textcolor{comment}{// Restore initial flags and other state}}
\DoxyCodeLine{13706             m\_unused.push\_back(index);}
\DoxyCodeLine{13707         \}}
\DoxyCodeLine{13708     \};}
\DoxyCodeLine{13709 }
\DoxyCodeLine{13710     ReusableStringStream::ReusableStringStream()}
\DoxyCodeLine{13711     :   m\_index( Singleton<StringStreams>::getMutable().add() ),}
\DoxyCodeLine{13712         m\_oss( Singleton<StringStreams>::getMutable().m\_streams[m\_index].get() )}
\DoxyCodeLine{13713     \{\}}
\DoxyCodeLine{13714 }
\DoxyCodeLine{13715     ReusableStringStream::\string~ReusableStringStream() \{}
\DoxyCodeLine{13716         \textcolor{keyword}{static\_cast<}std::ostringstream*\textcolor{keyword}{>}( m\_oss )-\/>str(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{13717         m\_oss-\/>clear();}
\DoxyCodeLine{13718         Singleton<StringStreams>::getMutable().release( m\_index );}
\DoxyCodeLine{13719     \}}
\DoxyCodeLine{13720 }
\DoxyCodeLine{13721     \textcolor{keyword}{auto} ReusableStringStream::str() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{13722         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}std::ostringstream*\textcolor{keyword}{>}( m\_oss )-\/>str();}
\DoxyCodeLine{13723     \}}
\DoxyCodeLine{13724 }
\DoxyCodeLine{13726 }
\DoxyCodeLine{13727 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_NOSTDOUT }\textcolor{comment}{// If you \#define this you must implement these functions}}
\DoxyCodeLine{13728     std::ostream\& cout() \{ \textcolor{keywordflow}{return} std::cout; \}}
\DoxyCodeLine{13729     std::ostream\& cerr() \{ \textcolor{keywordflow}{return} std::cerr; \}}
\DoxyCodeLine{13730     std::ostream\& clog() \{ \textcolor{keywordflow}{return} std::clog; \}}
\DoxyCodeLine{13731 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13732 \}}
\DoxyCodeLine{13733 \textcolor{comment}{// end catch\_stream.cpp}}
\DoxyCodeLine{13734 \textcolor{comment}{// start catch\_string\_manip.cpp}}
\DoxyCodeLine{13735 }
\DoxyCodeLine{13736 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{13737 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{13738 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{13739 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{13740 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{13741 }
\DoxyCodeLine{13742 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13743 }
\DoxyCodeLine{13744     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{13745         \textcolor{keywordtype}{char} toLowerCh(\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{13746             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( std::tolower( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(c) ) );}
\DoxyCodeLine{13747         \}}
\DoxyCodeLine{13748     \}}
\DoxyCodeLine{13749 }
\DoxyCodeLine{13750     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& prefix ) \{}
\DoxyCodeLine{13751         \textcolor{keywordflow}{return} s.size() >= prefix.size() \&\& std::equal(prefix.begin(), prefix.end(), s.begin());}
\DoxyCodeLine{13752     \}}
\DoxyCodeLine{13753     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} prefix ) \{}
\DoxyCodeLine{13754         \textcolor{keywordflow}{return} !s.empty() \&\& s[0] == prefix;}
\DoxyCodeLine{13755     \}}
\DoxyCodeLine{13756     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& suffix ) \{}
\DoxyCodeLine{13757         \textcolor{keywordflow}{return} s.size() >= suffix.size() \&\& std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());}
\DoxyCodeLine{13758     \}}
\DoxyCodeLine{13759     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} suffix ) \{}
\DoxyCodeLine{13760         \textcolor{keywordflow}{return} !s.empty() \&\& s[s.size()-\/1] == suffix;}
\DoxyCodeLine{13761     \}}
\DoxyCodeLine{13762     \textcolor{keywordtype}{bool} contains( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& infix ) \{}
\DoxyCodeLine{13763         \textcolor{keywordflow}{return} s.find( infix ) != std::string::npos;}
\DoxyCodeLine{13764     \}}
\DoxyCodeLine{13765     \textcolor{keywordtype}{void} toLowerInPlace( std::string\& s ) \{}
\DoxyCodeLine{13766         std::transform( s.begin(), s.end(), s.begin(), toLowerCh );}
\DoxyCodeLine{13767     \}}
\DoxyCodeLine{13768     std::string toLower( std::string \textcolor{keyword}{const}\& s ) \{}
\DoxyCodeLine{13769         std::string lc = s;}
\DoxyCodeLine{13770         toLowerInPlace( lc );}
\DoxyCodeLine{13771         \textcolor{keywordflow}{return} lc;}
\DoxyCodeLine{13772     \}}
\DoxyCodeLine{13773     std::string trim( std::string \textcolor{keyword}{const}\& str ) \{}
\DoxyCodeLine{13774         \textcolor{keyword}{static} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* whitespaceChars = \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)r\(\backslash\)t "{}};}
\DoxyCodeLine{13775         std::string::size\_type start = str.find\_first\_not\_of( whitespaceChars );}
\DoxyCodeLine{13776         std::string::size\_type end = str.find\_last\_not\_of( whitespaceChars );}
\DoxyCodeLine{13777 }
\DoxyCodeLine{13778         \textcolor{keywordflow}{return} start != std::string::npos ? str.substr( start, 1+end-\/start ) : std::string();}
\DoxyCodeLine{13779     \}}
\DoxyCodeLine{13780 }
\DoxyCodeLine{13781     StringRef trim(StringRef ref) \{}
\DoxyCodeLine{13782         \textcolor{keyword}{const} \textcolor{keyword}{auto} is\_ws = [](\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{13783             \textcolor{keywordflow}{return} c == \textcolor{charliteral}{' '} || c == \textcolor{charliteral}{'\(\backslash\)t'} || c == \textcolor{charliteral}{'\(\backslash\)n'} || c == \textcolor{charliteral}{'\(\backslash\)r'};}
\DoxyCodeLine{13784         \};}
\DoxyCodeLine{13785         \textcolor{keywordtype}{size\_t} real\_begin = 0;}
\DoxyCodeLine{13786         \textcolor{keywordflow}{while} (real\_begin < ref.size() \&\& is\_ws(ref[real\_begin])) \{ ++real\_begin; \}}
\DoxyCodeLine{13787         \textcolor{keywordtype}{size\_t} real\_end = ref.size();}
\DoxyCodeLine{13788         \textcolor{keywordflow}{while} (real\_end > real\_begin \&\& is\_ws(ref[real\_end -\/ 1])) \{ -\/-\/real\_end; \}}
\DoxyCodeLine{13789 }
\DoxyCodeLine{13790         \textcolor{keywordflow}{return} ref.substr(real\_begin, real\_end -\/ real\_begin);}
\DoxyCodeLine{13791     \}}
\DoxyCodeLine{13792 }
\DoxyCodeLine{13793     \textcolor{keywordtype}{bool} replaceInPlace( std::string\& str, std::string \textcolor{keyword}{const}\& replaceThis, std::string \textcolor{keyword}{const}\& withThis ) \{}
\DoxyCodeLine{13794         \textcolor{keywordtype}{bool} replaced = \textcolor{keyword}{false};}
\DoxyCodeLine{13795         std::size\_t i = str.find( replaceThis );}
\DoxyCodeLine{13796         \textcolor{keywordflow}{while}( i != std::string::npos ) \{}
\DoxyCodeLine{13797             replaced = \textcolor{keyword}{true};}
\DoxyCodeLine{13798             str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );}
\DoxyCodeLine{13799             \textcolor{keywordflow}{if}( i < str.size()-\/withThis.size() )}
\DoxyCodeLine{13800                 i = str.find( replaceThis, i+withThis.size() );}
\DoxyCodeLine{13801             \textcolor{keywordflow}{else}}
\DoxyCodeLine{13802                 i = std::string::npos;}
\DoxyCodeLine{13803         \}}
\DoxyCodeLine{13804         \textcolor{keywordflow}{return} replaced;}
\DoxyCodeLine{13805     \}}
\DoxyCodeLine{13806 }
\DoxyCodeLine{13807     std::vector<StringRef> splitStringRef( StringRef str, \textcolor{keywordtype}{char} delimiter ) \{}
\DoxyCodeLine{13808         std::vector<StringRef> subStrings;}
\DoxyCodeLine{13809         std::size\_t start = 0;}
\DoxyCodeLine{13810         \textcolor{keywordflow}{for}(std::size\_t pos = 0; pos < str.size(); ++pos ) \{}
\DoxyCodeLine{13811             \textcolor{keywordflow}{if}( str[pos] == delimiter ) \{}
\DoxyCodeLine{13812                 \textcolor{keywordflow}{if}( pos -\/ start > 1 )}
\DoxyCodeLine{13813                     subStrings.push\_back( str.substr( start, pos-\/start ) );}
\DoxyCodeLine{13814                 start = pos+1;}
\DoxyCodeLine{13815             \}}
\DoxyCodeLine{13816         \}}
\DoxyCodeLine{13817         \textcolor{keywordflow}{if}( start < str.size() )}
\DoxyCodeLine{13818             subStrings.push\_back( str.substr( start, str.size()-\/start ) );}
\DoxyCodeLine{13819         \textcolor{keywordflow}{return} subStrings;}
\DoxyCodeLine{13820     \}}
\DoxyCodeLine{13821 }
\DoxyCodeLine{13822     pluralise::pluralise( std::size\_t count, std::string \textcolor{keyword}{const}\& label )}
\DoxyCodeLine{13823     :   m\_count( count ),}
\DoxyCodeLine{13824         m\_label( label )}
\DoxyCodeLine{13825     \{\}}
\DoxyCodeLine{13826 }
\DoxyCodeLine{13827     std::ostream\& operator << ( std::ostream\& os, pluralise \textcolor{keyword}{const}\& pluraliser ) \{}
\DoxyCodeLine{13828         os << pluraliser.m\_count << \textcolor{charliteral}{' '} << pluraliser.m\_label;}
\DoxyCodeLine{13829         \textcolor{keywordflow}{if}( pluraliser.m\_count != 1 )}
\DoxyCodeLine{13830             os << \textcolor{charliteral}{'s'};}
\DoxyCodeLine{13831         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{13832     \}}
\DoxyCodeLine{13833 }
\DoxyCodeLine{13834 \}}
\DoxyCodeLine{13835 \textcolor{comment}{// end catch\_string\_manip.cpp}}
\DoxyCodeLine{13836 \textcolor{comment}{// start catch\_stringref.cpp}}
\DoxyCodeLine{13837 }
\DoxyCodeLine{13838 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{13839 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{13840 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{13841 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{13842 }
\DoxyCodeLine{13843 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13844     StringRef::StringRef( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars ) noexcept}
\DoxyCodeLine{13845     : StringRef( rawChars, \textcolor{keyword}{static\_cast<}StringRef::size\_type\textcolor{keyword}{>}(std::strlen(rawChars) ) )}
\DoxyCodeLine{13846     \{\}}
\DoxyCodeLine{13847 }
\DoxyCodeLine{13848     \textcolor{keyword}{auto} StringRef::c\_str() const -\/> \textcolor{keywordtype}{char} const* \{}
\DoxyCodeLine{13849         CATCH\_ENFORCE(isNullTerminated(), \textcolor{stringliteral}{"{}Called StringRef::c\_str() on a non-\/null-\/terminated instance"{}});}
\DoxyCodeLine{13850         \textcolor{keywordflow}{return} m\_start;}
\DoxyCodeLine{13851     \}}
\DoxyCodeLine{13852     \textcolor{keyword}{auto} StringRef::data() const noexcept -\/> \textcolor{keywordtype}{char} const* \{}
\DoxyCodeLine{13853         \textcolor{keywordflow}{return} m\_start;}
\DoxyCodeLine{13854     \}}
\DoxyCodeLine{13855 }
\DoxyCodeLine{13856     \textcolor{keyword}{auto} StringRef::substr( size\_type start, size\_type size ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> StringRef \{}
\DoxyCodeLine{13857         \textcolor{keywordflow}{if} (start < m\_size) \{}
\DoxyCodeLine{13858             \textcolor{keywordflow}{return} StringRef(m\_start + start, (std::min)(m\_size -\/ start, size));}
\DoxyCodeLine{13859         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13860             \textcolor{keywordflow}{return} StringRef();}
\DoxyCodeLine{13861         \}}
\DoxyCodeLine{13862     \}}
\DoxyCodeLine{13863     \textcolor{keyword}{auto} StringRef::operator == ( StringRef \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{13864         \textcolor{keywordflow}{return} m\_size == other.m\_size}
\DoxyCodeLine{13865             \&\& (std::memcmp( m\_start, other.m\_start, m\_size ) == 0);}
\DoxyCodeLine{13866     \}}
\DoxyCodeLine{13867 }
\DoxyCodeLine{13868     \textcolor{keyword}{auto} operator << ( std::ostream\& os, StringRef \textcolor{keyword}{const}\& str ) -\/> std::ostream\& \{}
\DoxyCodeLine{13869         \textcolor{keywordflow}{return} os.write(str.data(), str.size());}
\DoxyCodeLine{13870     \}}
\DoxyCodeLine{13871 }
\DoxyCodeLine{13872     \textcolor{keyword}{auto} operator+=( std::string\& lhs, StringRef \textcolor{keyword}{const}\& rhs ) -\/> std::string\& \{}
\DoxyCodeLine{13873         lhs.append(rhs.data(), rhs.size());}
\DoxyCodeLine{13874         \textcolor{keywordflow}{return} lhs;}
\DoxyCodeLine{13875     \}}
\DoxyCodeLine{13876 }
\DoxyCodeLine{13877 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{13878 \textcolor{comment}{// end catch\_stringref.cpp}}
\DoxyCodeLine{13879 \textcolor{comment}{// start catch\_tag\_alias.cpp}}
\DoxyCodeLine{13880 }
\DoxyCodeLine{13881 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13882     TagAlias::TagAlias(std::string \textcolor{keyword}{const} \& \_tag, SourceLineInfo \_lineInfo): tag(\_tag), lineInfo(\_lineInfo) \{\}}
\DoxyCodeLine{13883 \}}
\DoxyCodeLine{13884 \textcolor{comment}{// end catch\_tag\_alias.cpp}}
\DoxyCodeLine{13885 \textcolor{comment}{// start catch\_tag\_alias\_autoregistrar.cpp}}
\DoxyCodeLine{13886 }
\DoxyCodeLine{13887 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13888 }
\DoxyCodeLine{13889     RegistrarForTagAliases::RegistrarForTagAliases(\textcolor{keywordtype}{char} \textcolor{keyword}{const}* alias, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo) \{}
\DoxyCodeLine{13890         CATCH\_TRY \{}
\DoxyCodeLine{13891             getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);}
\DoxyCodeLine{13892         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{13893             \textcolor{comment}{// Do not throw when constructing global objects, instead register the exception to be processed later}}
\DoxyCodeLine{13894             getMutableRegistryHub().registerStartupException();}
\DoxyCodeLine{13895         \}}
\DoxyCodeLine{13896     \}}
\DoxyCodeLine{13897 }
\DoxyCodeLine{13898 \}}
\DoxyCodeLine{13899 \textcolor{comment}{// end catch\_tag\_alias\_autoregistrar.cpp}}
\DoxyCodeLine{13900 \textcolor{comment}{// start catch\_tag\_alias\_registry.cpp}}
\DoxyCodeLine{13901 }
\DoxyCodeLine{13902 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{13903 }
\DoxyCodeLine{13904 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13905 }
\DoxyCodeLine{13906     TagAliasRegistry::\string~TagAliasRegistry() \{\}}
\DoxyCodeLine{13907 }
\DoxyCodeLine{13908     TagAlias \textcolor{keyword}{const}* TagAliasRegistry::find( std::string \textcolor{keyword}{const}\& alias )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13909         \textcolor{keyword}{auto} it = m\_registry.find( alias );}
\DoxyCodeLine{13910         \textcolor{keywordflow}{if}( it != m\_registry.end() )}
\DoxyCodeLine{13911             \textcolor{keywordflow}{return} \&(it-\/>second);}
\DoxyCodeLine{13912         \textcolor{keywordflow}{else}}
\DoxyCodeLine{13913             \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{13914     \}}
\DoxyCodeLine{13915 }
\DoxyCodeLine{13916     std::string TagAliasRegistry::expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13917         std::string expandedTestSpec = unexpandedTestSpec;}
\DoxyCodeLine{13918         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& registryKvp : m\_registry ) \{}
\DoxyCodeLine{13919             std::size\_t pos = expandedTestSpec.find( registryKvp.first );}
\DoxyCodeLine{13920             \textcolor{keywordflow}{if}( pos != std::string::npos ) \{}
\DoxyCodeLine{13921                 expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +}
\DoxyCodeLine{13922                                     registryKvp.second.tag +}
\DoxyCodeLine{13923                                     expandedTestSpec.substr( pos + registryKvp.first.size() );}
\DoxyCodeLine{13924             \}}
\DoxyCodeLine{13925         \}}
\DoxyCodeLine{13926         \textcolor{keywordflow}{return} expandedTestSpec;}
\DoxyCodeLine{13927     \}}
\DoxyCodeLine{13928 }
\DoxyCodeLine{13929     \textcolor{keywordtype}{void} TagAliasRegistry::add( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) \{}
\DoxyCodeLine{13930         CATCH\_ENFORCE( startsWith(alias, \textcolor{stringliteral}{"{}[@"{}}) \&\& endsWith(alias, \textcolor{charliteral}{']'}),}
\DoxyCodeLine{13931                       \textcolor{stringliteral}{"{}error: tag alias, '"{}} << alias << \textcolor{stringliteral}{"{}' is not of the form [@alias name].\(\backslash\)n"{}} << lineInfo );}
\DoxyCodeLine{13932 }
\DoxyCodeLine{13933         CATCH\_ENFORCE( m\_registry.insert(std::make\_pair(alias, TagAlias(tag, lineInfo))).second,}
\DoxyCodeLine{13934                       \textcolor{stringliteral}{"{}error: tag alias, '"{}} << alias << \textcolor{stringliteral}{"{}' already registered.\(\backslash\)n"{}}}
\DoxyCodeLine{13935                       << \textcolor{stringliteral}{"{}\(\backslash\)tFirst seen at: "{}} << find(alias)-\/>lineInfo << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{13936                       << \textcolor{stringliteral}{"{}\(\backslash\)tRedefined at: "{}} << lineInfo );}
\DoxyCodeLine{13937     \}}
\DoxyCodeLine{13938 }
\DoxyCodeLine{13939     ITagAliasRegistry::\string~ITagAliasRegistry() \{\}}
\DoxyCodeLine{13940 }
\DoxyCodeLine{13941     ITagAliasRegistry \textcolor{keyword}{const}\& ITagAliasRegistry::get() \{}
\DoxyCodeLine{13942         \textcolor{keywordflow}{return} getRegistryHub().getTagAliasRegistry();}
\DoxyCodeLine{13943     \}}
\DoxyCodeLine{13944 }
\DoxyCodeLine{13945 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13946 \textcolor{comment}{// end catch\_tag\_alias\_registry.cpp}}
\DoxyCodeLine{13947 \textcolor{comment}{// start catch\_test\_case\_info.cpp}}
\DoxyCodeLine{13948 }
\DoxyCodeLine{13949 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{13950 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{13951 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{13952 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{13953 }
\DoxyCodeLine{13954 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13955 }
\DoxyCodeLine{13956     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{13957         TestCaseInfo::SpecialProperties parseSpecialTag( std::string \textcolor{keyword}{const}\& tag ) \{}
\DoxyCodeLine{13958             \textcolor{keywordflow}{if}( startsWith( tag, \textcolor{charliteral}{'.'} ) ||}
\DoxyCodeLine{13959                 tag == \textcolor{stringliteral}{"{}!hide"{}} )}
\DoxyCodeLine{13960                 \textcolor{keywordflow}{return} TestCaseInfo::IsHidden;}
\DoxyCodeLine{13961             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!throws"{}} )}
\DoxyCodeLine{13962                 \textcolor{keywordflow}{return} TestCaseInfo::Throws;}
\DoxyCodeLine{13963             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!shouldfail"{}} )}
\DoxyCodeLine{13964                 \textcolor{keywordflow}{return} TestCaseInfo::ShouldFail;}
\DoxyCodeLine{13965             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!mayfail"{}} )}
\DoxyCodeLine{13966                 \textcolor{keywordflow}{return} TestCaseInfo::MayFail;}
\DoxyCodeLine{13967             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!nonportable"{}} )}
\DoxyCodeLine{13968                 \textcolor{keywordflow}{return} TestCaseInfo::NonPortable;}
\DoxyCodeLine{13969             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!benchmark"{}} )}
\DoxyCodeLine{13970                 \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}TestCaseInfo::SpecialProperties\textcolor{keyword}{>}( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );}
\DoxyCodeLine{13971             \textcolor{keywordflow}{else}}
\DoxyCodeLine{13972                 \textcolor{keywordflow}{return} TestCaseInfo::None;}
\DoxyCodeLine{13973         \}}
\DoxyCodeLine{13974         \textcolor{keywordtype}{bool} isReservedTag( std::string \textcolor{keyword}{const}\& tag ) \{}
\DoxyCodeLine{13975             \textcolor{keywordflow}{return} parseSpecialTag( tag ) == TestCaseInfo::None \&\& tag.size() > 0 \&\& !std::isalnum( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(tag[0]) );}
\DoxyCodeLine{13976         \}}
\DoxyCodeLine{13977         \textcolor{keywordtype}{void} enforceNotReservedTag( std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo ) \{}
\DoxyCodeLine{13978             CATCH\_ENFORCE( !isReservedTag(tag),}
\DoxyCodeLine{13979                           \textcolor{stringliteral}{"{}Tag name: ["{}} << tag << \textcolor{stringliteral}{"{}] is not allowed.\(\backslash\)n"{}}}
\DoxyCodeLine{13980                           << \textcolor{stringliteral}{"{}Tag names starting with non alphanumeric characters are reserved\(\backslash\)n"{}}}
\DoxyCodeLine{13981                           << \_lineInfo );}
\DoxyCodeLine{13982         \}}
\DoxyCodeLine{13983     \}}
\DoxyCodeLine{13984 }
\DoxyCodeLine{13985     TestCase makeTestCase(  ITestInvoker* \_testCase,}
\DoxyCodeLine{13986                             std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{13987                             NameAndTags \textcolor{keyword}{const}\& nameAndTags,}
\DoxyCodeLine{13988                             SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo )}
\DoxyCodeLine{13989     \{}
\DoxyCodeLine{13990         \textcolor{keywordtype}{bool} isHidden = \textcolor{keyword}{false};}
\DoxyCodeLine{13991 }
\DoxyCodeLine{13992         \textcolor{comment}{// Parse out tags}}
\DoxyCodeLine{13993         std::vector<std::string> tags;}
\DoxyCodeLine{13994         std::string desc, tag;}
\DoxyCodeLine{13995         \textcolor{keywordtype}{bool} inTag = \textcolor{keyword}{false};}
\DoxyCodeLine{13996         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{char} c : nameAndTags.tags) \{}
\DoxyCodeLine{13997             \textcolor{keywordflow}{if}( !inTag ) \{}
\DoxyCodeLine{13998                 \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{'['} )}
\DoxyCodeLine{13999                     inTag = \textcolor{keyword}{true};}
\DoxyCodeLine{14000                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{14001                     desc += c;}
\DoxyCodeLine{14002             \}}
\DoxyCodeLine{14003             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{14004                 \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{']'} ) \{}
\DoxyCodeLine{14005                     TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );}
\DoxyCodeLine{14006                     \textcolor{keywordflow}{if}( ( prop \& TestCaseInfo::IsHidden ) != 0 )}
\DoxyCodeLine{14007                         isHidden = \textcolor{keyword}{true};}
\DoxyCodeLine{14008                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( prop == TestCaseInfo::None )}
\DoxyCodeLine{14009                         enforceNotReservedTag( tag, \_lineInfo );}
\DoxyCodeLine{14010 }
\DoxyCodeLine{14011                     \textcolor{comment}{// Merged hide tags like `[.approvals]` should be added as}}
\DoxyCodeLine{14012                     \textcolor{comment}{// `[.][approvals]`. The `[.]` is added at later point, so}}
\DoxyCodeLine{14013                     \textcolor{comment}{// we only strip the prefix}}
\DoxyCodeLine{14014                     \textcolor{keywordflow}{if} (startsWith(tag, \textcolor{charliteral}{'.'}) \&\& tag.size() > 1) \{}
\DoxyCodeLine{14015                         tag.erase(0, 1);}
\DoxyCodeLine{14016                     \}}
\DoxyCodeLine{14017                     tags.push\_back( tag );}
\DoxyCodeLine{14018                     tag.clear();}
\DoxyCodeLine{14019                     inTag = \textcolor{keyword}{false};}
\DoxyCodeLine{14020                 \}}
\DoxyCodeLine{14021                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{14022                     tag += c;}
\DoxyCodeLine{14023             \}}
\DoxyCodeLine{14024         \}}
\DoxyCodeLine{14025         \textcolor{keywordflow}{if}( isHidden ) \{}
\DoxyCodeLine{14026             \textcolor{comment}{// Add all "{}hidden"{} tags to make them behave identically}}
\DoxyCodeLine{14027             tags.insert( tags.end(), \{ \textcolor{stringliteral}{"{}."{}}, \textcolor{stringliteral}{"{}!hide"{}} \} );}
\DoxyCodeLine{14028         \}}
\DoxyCodeLine{14029 }
\DoxyCodeLine{14030         TestCaseInfo info( \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(nameAndTags.name), \_className, desc, tags, \_lineInfo );}
\DoxyCodeLine{14031         \textcolor{keywordflow}{return} TestCase( \_testCase, std::move(info) );}
\DoxyCodeLine{14032     \}}
\DoxyCodeLine{14033 }
\DoxyCodeLine{14034     \textcolor{keywordtype}{void} setTags( TestCaseInfo\& testCaseInfo, std::vector<std::string> tags ) \{}
\DoxyCodeLine{14035         std::sort(begin(tags), end(tags));}
\DoxyCodeLine{14036         tags.erase(std::unique(begin(tags), end(tags)), end(tags));}
\DoxyCodeLine{14037         testCaseInfo.lcaseTags.clear();}
\DoxyCodeLine{14038 }
\DoxyCodeLine{14039         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& tag : tags ) \{}
\DoxyCodeLine{14040             std::string lcaseTag = toLower( tag );}
\DoxyCodeLine{14041             testCaseInfo.properties = \textcolor{keyword}{static\_cast<}TestCaseInfo::SpecialProperties\textcolor{keyword}{>}( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );}
\DoxyCodeLine{14042             testCaseInfo.lcaseTags.push\_back( lcaseTag );}
\DoxyCodeLine{14043         \}}
\DoxyCodeLine{14044         testCaseInfo.tags = std::move(tags);}
\DoxyCodeLine{14045     \}}
\DoxyCodeLine{14046 }
\DoxyCodeLine{14047     TestCaseInfo::TestCaseInfo( std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{14048                                 std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{14049                                 std::string \textcolor{keyword}{const}\& \_description,}
\DoxyCodeLine{14050                                 std::vector<std::string> \textcolor{keyword}{const}\& \_tags,}
\DoxyCodeLine{14051                                 SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo )}
\DoxyCodeLine{14052     :   name( \_name ),}
\DoxyCodeLine{14053         className( \_className ),}
\DoxyCodeLine{14054         description( \_description ),}
\DoxyCodeLine{14055         lineInfo( \_lineInfo ),}
\DoxyCodeLine{14056         properties( None )}
\DoxyCodeLine{14057     \{}
\DoxyCodeLine{14058         setTags( *\textcolor{keyword}{this}, \_tags );}
\DoxyCodeLine{14059     \}}
\DoxyCodeLine{14060 }
\DoxyCodeLine{14061     \textcolor{keywordtype}{bool} TestCaseInfo::isHidden()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14062         \textcolor{keywordflow}{return} ( properties \& IsHidden ) != 0;}
\DoxyCodeLine{14063     \}}
\DoxyCodeLine{14064     \textcolor{keywordtype}{bool} TestCaseInfo::throws()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14065         \textcolor{keywordflow}{return} ( properties \& Throws ) != 0;}
\DoxyCodeLine{14066     \}}
\DoxyCodeLine{14067     \textcolor{keywordtype}{bool} TestCaseInfo::okToFail()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14068         \textcolor{keywordflow}{return} ( properties \& (ShouldFail | MayFail ) ) != 0;}
\DoxyCodeLine{14069     \}}
\DoxyCodeLine{14070     \textcolor{keywordtype}{bool} TestCaseInfo::expectedToFail()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14071         \textcolor{keywordflow}{return} ( properties \& (ShouldFail ) ) != 0;}
\DoxyCodeLine{14072     \}}
\DoxyCodeLine{14073 }
\DoxyCodeLine{14074     std::string TestCaseInfo::tagsAsString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14075         std::string ret;}
\DoxyCodeLine{14076         \textcolor{comment}{// '[' and ']' per tag}}
\DoxyCodeLine{14077         std::size\_t full\_size = 2 * tags.size();}
\DoxyCodeLine{14078         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& tag : tags) \{}
\DoxyCodeLine{14079             full\_size += tag.size();}
\DoxyCodeLine{14080         \}}
\DoxyCodeLine{14081         ret.reserve(full\_size);}
\DoxyCodeLine{14082         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& tag : tags) \{}
\DoxyCodeLine{14083             ret.push\_back(\textcolor{charliteral}{'['});}
\DoxyCodeLine{14084             ret.append(tag);}
\DoxyCodeLine{14085             ret.push\_back(\textcolor{charliteral}{']'});}
\DoxyCodeLine{14086         \}}
\DoxyCodeLine{14087 }
\DoxyCodeLine{14088         \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{14089     \}}
\DoxyCodeLine{14090 }
\DoxyCodeLine{14091     TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo\&\& info ) : TestCaseInfo( std::move(info) ), test( testCase ) \{\}}
\DoxyCodeLine{14092 }
\DoxyCodeLine{14093     TestCase TestCase::withName( std::string \textcolor{keyword}{const}\& \_newName )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14094         TestCase other( *\textcolor{keyword}{this} );}
\DoxyCodeLine{14095         other.name = \_newName;}
\DoxyCodeLine{14096         \textcolor{keywordflow}{return} other;}
\DoxyCodeLine{14097     \}}
\DoxyCodeLine{14098 }
\DoxyCodeLine{14099     \textcolor{keywordtype}{void} TestCase::invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14100         test-\/>invoke();}
\DoxyCodeLine{14101     \}}
\DoxyCodeLine{14102 }
\DoxyCodeLine{14103     \textcolor{keywordtype}{bool} TestCase::operator == ( TestCase \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14104         \textcolor{keywordflow}{return}  test.get() == other.test.get() \&\&}
\DoxyCodeLine{14105                 name == other.name \&\&}
\DoxyCodeLine{14106                 className == other.className;}
\DoxyCodeLine{14107     \}}
\DoxyCodeLine{14108 }
\DoxyCodeLine{14109     \textcolor{keywordtype}{bool} TestCase::operator < ( TestCase \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14110         \textcolor{keywordflow}{return} name < other.name;}
\DoxyCodeLine{14111     \}}
\DoxyCodeLine{14112 }
\DoxyCodeLine{14113     TestCaseInfo \textcolor{keyword}{const}\& TestCase::getTestCaseInfo()\textcolor{keyword}{ const}}
\DoxyCodeLine{14114 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14115         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{14116     \}}
\DoxyCodeLine{14117 }
\DoxyCodeLine{14118 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{14119 \textcolor{comment}{// end catch\_test\_case\_info.cpp}}
\DoxyCodeLine{14120 \textcolor{comment}{// start catch\_test\_case\_registry\_impl.cpp}}
\DoxyCodeLine{14121 }
\DoxyCodeLine{14122 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{14123 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{14124 }
\DoxyCodeLine{14125 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14126 }
\DoxyCodeLine{14127     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{14128         \textcolor{keyword}{struct }TestHasher \{}
\DoxyCodeLine{14129             \textcolor{keyword}{using} hash\_t = uint64\_t;}
\DoxyCodeLine{14130 }
\DoxyCodeLine{14131             \textcolor{keyword}{explicit} TestHasher( hash\_t hashSuffix ):}
\DoxyCodeLine{14132                 m\_hashSuffix\{ hashSuffix \} \{\}}
\DoxyCodeLine{14133 }
\DoxyCodeLine{14134             uint32\_t operator()( TestCase \textcolor{keyword}{const}\& t )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14135                 \textcolor{comment}{// FNV-\/1a hash with multiplication fold.}}
\DoxyCodeLine{14136                 \textcolor{keyword}{const} hash\_t prime = 1099511628211u;}
\DoxyCodeLine{14137                 hash\_t hash = 14695981039346656037u;}
\DoxyCodeLine{14138                 \textcolor{keywordflow}{for} ( \textcolor{keyword}{const} \textcolor{keywordtype}{char} c : t.name ) \{}
\DoxyCodeLine{14139                     hash \string^= c;}
\DoxyCodeLine{14140                     hash *= prime;}
\DoxyCodeLine{14141                 \}}
\DoxyCodeLine{14142                 hash \string^= m\_hashSuffix;}
\DoxyCodeLine{14143                 hash *= prime;}
\DoxyCodeLine{14144                 \textcolor{keyword}{const} uint32\_t low\{ \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}( hash ) \};}
\DoxyCodeLine{14145                 \textcolor{keyword}{const} uint32\_t high\{ \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}( hash >> 32 ) \};}
\DoxyCodeLine{14146                 \textcolor{keywordflow}{return} low * high;}
\DoxyCodeLine{14147             \}}
\DoxyCodeLine{14148 }
\DoxyCodeLine{14149         \textcolor{keyword}{private}:}
\DoxyCodeLine{14150             hash\_t m\_hashSuffix;}
\DoxyCodeLine{14151         \};}
\DoxyCodeLine{14152     \} \textcolor{comment}{// end unnamed namespace}}
\DoxyCodeLine{14153 }
\DoxyCodeLine{14154     std::vector<TestCase> sortTests( IConfig \textcolor{keyword}{const}\& config, std::vector<TestCase> \textcolor{keyword}{const}\& unsortedTestCases ) \{}
\DoxyCodeLine{14155         \textcolor{keywordflow}{switch}( config.runOrder() ) \{}
\DoxyCodeLine{14156             \textcolor{keywordflow}{case} RunTests::InDeclarationOrder:}
\DoxyCodeLine{14157                 \textcolor{comment}{// already in declaration order}}
\DoxyCodeLine{14158                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14159 }
\DoxyCodeLine{14160             \textcolor{keywordflow}{case} RunTests::InLexicographicalOrder: \{}
\DoxyCodeLine{14161                 std::vector<TestCase> sorted = unsortedTestCases;}
\DoxyCodeLine{14162                 std::sort( sorted.begin(), sorted.end() );}
\DoxyCodeLine{14163                 \textcolor{keywordflow}{return} sorted;}
\DoxyCodeLine{14164             \}}
\DoxyCodeLine{14165 }
\DoxyCodeLine{14166             \textcolor{keywordflow}{case} RunTests::InRandomOrder: \{}
\DoxyCodeLine{14167                 seedRng( config );}
\DoxyCodeLine{14168                 TestHasher h\{ config.rngSeed() \};}
\DoxyCodeLine{14169 }
\DoxyCodeLine{14170                 \textcolor{keyword}{using} hashedTest = std::pair<TestHasher::hash\_t, TestCase const*>;}
\DoxyCodeLine{14171                 std::vector<hashedTest> indexed\_tests;}
\DoxyCodeLine{14172                 indexed\_tests.reserve( unsortedTestCases.size() );}
\DoxyCodeLine{14173 }
\DoxyCodeLine{14174                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : unsortedTestCases) \{}
\DoxyCodeLine{14175                     indexed\_tests.emplace\_back(h(testCase), \&testCase);}
\DoxyCodeLine{14176                 \}}
\DoxyCodeLine{14177 }
\DoxyCodeLine{14178                 std::sort(indexed\_tests.begin(), indexed\_tests.end(),}
\DoxyCodeLine{14179                           [](hashedTest \textcolor{keyword}{const}\& lhs, hashedTest \textcolor{keyword}{const}\& rhs) \{}
\DoxyCodeLine{14180                           if (lhs.first == rhs.first) \{}
\DoxyCodeLine{14181                               return lhs.second-\/>name < rhs.second-\/>name;}
\DoxyCodeLine{14182                           \}}
\DoxyCodeLine{14183                           \textcolor{keywordflow}{return} lhs.first < rhs.first;}
\DoxyCodeLine{14184                 \});}
\DoxyCodeLine{14185 }
\DoxyCodeLine{14186                 std::vector<TestCase> sorted;}
\DoxyCodeLine{14187                 sorted.reserve( indexed\_tests.size() );}
\DoxyCodeLine{14188 }
\DoxyCodeLine{14189                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& hashed : indexed\_tests) \{}
\DoxyCodeLine{14190                     sorted.emplace\_back(*hashed.second);}
\DoxyCodeLine{14191                 \}}
\DoxyCodeLine{14192 }
\DoxyCodeLine{14193                 \textcolor{keywordflow}{return} sorted;}
\DoxyCodeLine{14194             \}}
\DoxyCodeLine{14195         \}}
\DoxyCodeLine{14196         \textcolor{keywordflow}{return} unsortedTestCases;}
\DoxyCodeLine{14197     \}}
\DoxyCodeLine{14198 }
\DoxyCodeLine{14199     \textcolor{keywordtype}{bool} isThrowSafe( TestCase \textcolor{keyword}{const}\& testCase, IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{14200         \textcolor{keywordflow}{return} !testCase.throws() || config.allowThrows();}
\DoxyCodeLine{14201     \}}
\DoxyCodeLine{14202 }
\DoxyCodeLine{14203     \textcolor{keywordtype}{bool} matchTest( TestCase \textcolor{keyword}{const}\& testCase, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{14204         \textcolor{keywordflow}{return} testSpec.matches( testCase ) \&\& isThrowSafe( testCase, config );}
\DoxyCodeLine{14205     \}}
\DoxyCodeLine{14206 }
\DoxyCodeLine{14207     \textcolor{keywordtype}{void} enforceNoDuplicateTestCases( std::vector<TestCase> \textcolor{keyword}{const}\& functions ) \{}
\DoxyCodeLine{14208         std::set<TestCase> seenFunctions;}
\DoxyCodeLine{14209         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& \textcolor{keyword}{function} : functions ) \{}
\DoxyCodeLine{14210             \textcolor{keyword}{auto} prev = seenFunctions.insert( \textcolor{keyword}{function} );}
\DoxyCodeLine{14211             CATCH\_ENFORCE( prev.second,}
\DoxyCodeLine{14212                     \textcolor{stringliteral}{"{}error: TEST\_CASE( \(\backslash\)"{}"{}} << \textcolor{keyword}{function}.name << \textcolor{stringliteral}{"{}\(\backslash\)"{} ) already defined.\(\backslash\)n"{}}}
\DoxyCodeLine{14213                     << \textcolor{stringliteral}{"{}\(\backslash\)tFirst seen at "{}} << prev.first-\/>getTestCaseInfo().lineInfo << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{14214                     << \textcolor{stringliteral}{"{}\(\backslash\)tRedefined at "{}} << \textcolor{keyword}{function}.getTestCaseInfo().lineInfo );}
\DoxyCodeLine{14215         \}}
\DoxyCodeLine{14216     \}}
\DoxyCodeLine{14217 }
\DoxyCodeLine{14218     std::vector<TestCase> filterTests( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{14219         std::vector<TestCase> filtered;}
\DoxyCodeLine{14220         filtered.reserve( testCases.size() );}
\DoxyCodeLine{14221         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : testCases) \{}
\DoxyCodeLine{14222             \textcolor{keywordflow}{if} ((!testSpec.hasFilters() \&\& !testCase.isHidden()) ||}
\DoxyCodeLine{14223                 (testSpec.hasFilters() \&\& matchTest(testCase, testSpec, config))) \{}
\DoxyCodeLine{14224                 filtered.push\_back(testCase);}
\DoxyCodeLine{14225             \}}
\DoxyCodeLine{14226         \}}
\DoxyCodeLine{14227         \textcolor{keywordflow}{return} filtered;}
\DoxyCodeLine{14228     \}}
\DoxyCodeLine{14229     std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestCasesSorted( IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{14230         \textcolor{keywordflow}{return} getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );}
\DoxyCodeLine{14231     \}}
\DoxyCodeLine{14232 }
\DoxyCodeLine{14233     \textcolor{keywordtype}{void} TestRegistry::registerTest( TestCase \textcolor{keyword}{const}\& testCase ) \{}
\DoxyCodeLine{14234         std::string name = testCase.getTestCaseInfo().name;}
\DoxyCodeLine{14235         \textcolor{keywordflow}{if}( name.empty() ) \{}
\DoxyCodeLine{14236             ReusableStringStream rss;}
\DoxyCodeLine{14237             rss << \textcolor{stringliteral}{"{}Anonymous test case "{}} << ++m\_unnamedCount;}
\DoxyCodeLine{14238             \textcolor{keywordflow}{return} registerTest( testCase.withName( rss.str() ) );}
\DoxyCodeLine{14239         \}}
\DoxyCodeLine{14240         m\_functions.push\_back( testCase );}
\DoxyCodeLine{14241     \}}
\DoxyCodeLine{14242 }
\DoxyCodeLine{14243     std::vector<TestCase> \textcolor{keyword}{const}\& TestRegistry::getAllTests()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14244         \textcolor{keywordflow}{return} m\_functions;}
\DoxyCodeLine{14245     \}}
\DoxyCodeLine{14246     std::vector<TestCase> \textcolor{keyword}{const}\& TestRegistry::getAllTestsSorted( IConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14247         \textcolor{keywordflow}{if}( m\_sortedFunctions.empty() )}
\DoxyCodeLine{14248             enforceNoDuplicateTestCases( m\_functions );}
\DoxyCodeLine{14249 }
\DoxyCodeLine{14250         \textcolor{keywordflow}{if}(  m\_currentSortOrder != config.runOrder() || m\_sortedFunctions.empty() ) \{}
\DoxyCodeLine{14251             m\_sortedFunctions = sortTests( config, m\_functions );}
\DoxyCodeLine{14252             m\_currentSortOrder = config.runOrder();}
\DoxyCodeLine{14253         \}}
\DoxyCodeLine{14254         \textcolor{keywordflow}{return} m\_sortedFunctions;}
\DoxyCodeLine{14255     \}}
\DoxyCodeLine{14256 }
\DoxyCodeLine{14258     TestInvokerAsFunction::TestInvokerAsFunction( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept : m\_testAsFunction( testAsFunction ) \{\}}
\DoxyCodeLine{14259 }
\DoxyCodeLine{14260     \textcolor{keywordtype}{void} TestInvokerAsFunction::invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14261         m\_testAsFunction();}
\DoxyCodeLine{14262     \}}
\DoxyCodeLine{14263 }
\DoxyCodeLine{14264     std::string extractClassName( StringRef \textcolor{keyword}{const}\& classOrQualifiedMethodName ) \{}
\DoxyCodeLine{14265         std::string className(classOrQualifiedMethodName);}
\DoxyCodeLine{14266         \textcolor{keywordflow}{if}( startsWith( className, \textcolor{charliteral}{'\&'} ) )}
\DoxyCodeLine{14267         \{}
\DoxyCodeLine{14268             std::size\_t lastColons = className.rfind( \textcolor{stringliteral}{"{}::"{}} );}
\DoxyCodeLine{14269             std::size\_t penultimateColons = className.rfind( \textcolor{stringliteral}{"{}::"{}}, lastColons-\/1 );}
\DoxyCodeLine{14270             \textcolor{keywordflow}{if}( penultimateColons == std::string::npos )}
\DoxyCodeLine{14271                 penultimateColons = 1;}
\DoxyCodeLine{14272             className = className.substr( penultimateColons, lastColons-\/penultimateColons );}
\DoxyCodeLine{14273         \}}
\DoxyCodeLine{14274         \textcolor{keywordflow}{return} className;}
\DoxyCodeLine{14275     \}}
\DoxyCodeLine{14276 }
\DoxyCodeLine{14277 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{14278 \textcolor{comment}{// end catch\_test\_case\_registry\_impl.cpp}}
\DoxyCodeLine{14279 \textcolor{comment}{// start catch\_test\_case\_tracker.cpp}}
\DoxyCodeLine{14280 }
\DoxyCodeLine{14281 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{14282 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{14283 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{14284 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{14285 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{14286 }
\DoxyCodeLine{14287 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{14288 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{14289 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wexit-\/time-\/destructors"{}}}
\DoxyCodeLine{14290 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14291 }
\DoxyCodeLine{14292 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14293 \textcolor{keyword}{namespace }TestCaseTracking \{}
\DoxyCodeLine{14294 }
\DoxyCodeLine{14295     NameAndLocation::NameAndLocation( std::string \textcolor{keyword}{const}\& \_name, SourceLineInfo \textcolor{keyword}{const}\& \_location )}
\DoxyCodeLine{14296     :   name( \_name ),}
\DoxyCodeLine{14297         location( \_location )}
\DoxyCodeLine{14298     \{\}}
\DoxyCodeLine{14299 }
\DoxyCodeLine{14300     ITracker::\string~ITracker() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14301 }
\DoxyCodeLine{14302     ITracker\& TrackerContext::startRun() \{}
\DoxyCodeLine{14303         m\_rootTracker = std::make\_shared<SectionTracker>( NameAndLocation( \textcolor{stringliteral}{"{}\{root\}"{}}, CATCH\_INTERNAL\_LINEINFO ), *\textcolor{keyword}{this}, \textcolor{keyword}{nullptr} );}
\DoxyCodeLine{14304         m\_currentTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{14305         m\_runState = Executing;}
\DoxyCodeLine{14306         \textcolor{keywordflow}{return} *m\_rootTracker;}
\DoxyCodeLine{14307     \}}
\DoxyCodeLine{14308 }
\DoxyCodeLine{14309     \textcolor{keywordtype}{void} TrackerContext::endRun() \{}
\DoxyCodeLine{14310         m\_rootTracker.reset();}
\DoxyCodeLine{14311         m\_currentTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{14312         m\_runState = NotStarted;}
\DoxyCodeLine{14313     \}}
\DoxyCodeLine{14314 }
\DoxyCodeLine{14315     \textcolor{keywordtype}{void} TrackerContext::startCycle() \{}
\DoxyCodeLine{14316         m\_currentTracker = m\_rootTracker.get();}
\DoxyCodeLine{14317         m\_runState = Executing;}
\DoxyCodeLine{14318     \}}
\DoxyCodeLine{14319     \textcolor{keywordtype}{void} TrackerContext::completeCycle() \{}
\DoxyCodeLine{14320         m\_runState = CompletedCycle;}
\DoxyCodeLine{14321     \}}
\DoxyCodeLine{14322 }
\DoxyCodeLine{14323     \textcolor{keywordtype}{bool} TrackerContext::completedCycle()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14324         \textcolor{keywordflow}{return} m\_runState == CompletedCycle;}
\DoxyCodeLine{14325     \}}
\DoxyCodeLine{14326     ITracker\& TrackerContext::currentTracker() \{}
\DoxyCodeLine{14327         \textcolor{keywordflow}{return} *m\_currentTracker;}
\DoxyCodeLine{14328     \}}
\DoxyCodeLine{14329     \textcolor{keywordtype}{void} TrackerContext::setCurrentTracker( ITracker* tracker ) \{}
\DoxyCodeLine{14330         m\_currentTracker = tracker;}
\DoxyCodeLine{14331     \}}
\DoxyCodeLine{14332 }
\DoxyCodeLine{14333     TrackerBase::TrackerBase( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent ):}
\DoxyCodeLine{14334         ITracker(nameAndLocation),}
\DoxyCodeLine{14335         m\_ctx( ctx ),}
\DoxyCodeLine{14336         m\_parent( parent )}
\DoxyCodeLine{14337     \{\}}
\DoxyCodeLine{14338 }
\DoxyCodeLine{14339     \textcolor{keywordtype}{bool} TrackerBase::isComplete()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14340         \textcolor{keywordflow}{return} m\_runState == CompletedSuccessfully || m\_runState == Failed;}
\DoxyCodeLine{14341     \}}
\DoxyCodeLine{14342     \textcolor{keywordtype}{bool} TrackerBase::isSuccessfullyCompleted()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14343         \textcolor{keywordflow}{return} m\_runState == CompletedSuccessfully;}
\DoxyCodeLine{14344     \}}
\DoxyCodeLine{14345     \textcolor{keywordtype}{bool} TrackerBase::isOpen()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14346         \textcolor{keywordflow}{return} m\_runState != NotStarted \&\& !isComplete();}
\DoxyCodeLine{14347     \}}
\DoxyCodeLine{14348     \textcolor{keywordtype}{bool} TrackerBase::hasChildren()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14349         \textcolor{keywordflow}{return} !m\_children.empty();}
\DoxyCodeLine{14350     \}}
\DoxyCodeLine{14351 }
\DoxyCodeLine{14352     \textcolor{keywordtype}{void} TrackerBase::addChild( ITrackerPtr \textcolor{keyword}{const}\& child ) \{}
\DoxyCodeLine{14353         m\_children.push\_back( child );}
\DoxyCodeLine{14354     \}}
\DoxyCodeLine{14355 }
\DoxyCodeLine{14356     ITrackerPtr TrackerBase::findChild( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \{}
\DoxyCodeLine{14357         \textcolor{keyword}{auto} it = std::find\_if( m\_children.begin(), m\_children.end(),}
\DoxyCodeLine{14358             [\&nameAndLocation]( ITrackerPtr \textcolor{keyword}{const}\& tracker )\{}
\DoxyCodeLine{14359                 return}
\DoxyCodeLine{14360                     tracker-\/>nameAndLocation().location == nameAndLocation.location \&\&}
\DoxyCodeLine{14361                     tracker-\/>nameAndLocation().name == nameAndLocation.name;}
\DoxyCodeLine{14362             \} );}
\DoxyCodeLine{14363         \textcolor{keywordflow}{return}( it != m\_children.end() )}
\DoxyCodeLine{14364             ? *it}
\DoxyCodeLine{14365             : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{14366     \}}
\DoxyCodeLine{14367     ITracker\& TrackerBase::parent() \{}
\DoxyCodeLine{14368         assert( m\_parent ); \textcolor{comment}{// Should always be non-\/null except for root}}
\DoxyCodeLine{14369         \textcolor{keywordflow}{return} *m\_parent;}
\DoxyCodeLine{14370     \}}
\DoxyCodeLine{14371 }
\DoxyCodeLine{14372     \textcolor{keywordtype}{void} TrackerBase::openChild() \{}
\DoxyCodeLine{14373         \textcolor{keywordflow}{if}( m\_runState != ExecutingChildren ) \{}
\DoxyCodeLine{14374             m\_runState = ExecutingChildren;}
\DoxyCodeLine{14375             \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{14376                 m\_parent-\/>openChild();}
\DoxyCodeLine{14377         \}}
\DoxyCodeLine{14378     \}}
\DoxyCodeLine{14379 }
\DoxyCodeLine{14380     \textcolor{keywordtype}{bool} TrackerBase::isSectionTracker()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{14381     \textcolor{keywordtype}{bool} TrackerBase::isGeneratorTracker()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{14382 }
\DoxyCodeLine{14383     \textcolor{keywordtype}{void} TrackerBase::open() \{}
\DoxyCodeLine{14384         m\_runState = Executing;}
\DoxyCodeLine{14385         moveToThis();}
\DoxyCodeLine{14386         \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{14387             m\_parent-\/>openChild();}
\DoxyCodeLine{14388     \}}
\DoxyCodeLine{14389 }
\DoxyCodeLine{14390     \textcolor{keywordtype}{void} TrackerBase::close() \{}
\DoxyCodeLine{14391 }
\DoxyCodeLine{14392         \textcolor{comment}{// Close any still open children (e.g. generators)}}
\DoxyCodeLine{14393         \textcolor{keywordflow}{while}( \&m\_ctx.currentTracker() != \textcolor{keyword}{this} )}
\DoxyCodeLine{14394             m\_ctx.currentTracker().close();}
\DoxyCodeLine{14395 }
\DoxyCodeLine{14396         \textcolor{keywordflow}{switch}( m\_runState ) \{}
\DoxyCodeLine{14397             \textcolor{keywordflow}{case} NeedsAnotherRun:}
\DoxyCodeLine{14398                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14399 }
\DoxyCodeLine{14400             \textcolor{keywordflow}{case} Executing:}
\DoxyCodeLine{14401                 m\_runState = CompletedSuccessfully;}
\DoxyCodeLine{14402                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14403             \textcolor{keywordflow}{case} ExecutingChildren:}
\DoxyCodeLine{14404                 \textcolor{keywordflow}{if}( std::all\_of(m\_children.begin(), m\_children.end(), [](ITrackerPtr \textcolor{keyword}{const}\& t)\{ return t-\/>isComplete(); \}) )}
\DoxyCodeLine{14405                     m\_runState = CompletedSuccessfully;}
\DoxyCodeLine{14406                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14407 }
\DoxyCodeLine{14408             \textcolor{keywordflow}{case} NotStarted:}
\DoxyCodeLine{14409             \textcolor{keywordflow}{case} CompletedSuccessfully:}
\DoxyCodeLine{14410             \textcolor{keywordflow}{case} Failed:}
\DoxyCodeLine{14411                 CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Illogical state: "{}} << m\_runState );}
\DoxyCodeLine{14412 }
\DoxyCodeLine{14413             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14414                 CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Unknown state: "{}} << m\_runState );}
\DoxyCodeLine{14415         \}}
\DoxyCodeLine{14416         moveToParent();}
\DoxyCodeLine{14417         m\_ctx.completeCycle();}
\DoxyCodeLine{14418     \}}
\DoxyCodeLine{14419     \textcolor{keywordtype}{void} TrackerBase::fail() \{}
\DoxyCodeLine{14420         m\_runState = Failed;}
\DoxyCodeLine{14421         \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{14422             m\_parent-\/>markAsNeedingAnotherRun();}
\DoxyCodeLine{14423         moveToParent();}
\DoxyCodeLine{14424         m\_ctx.completeCycle();}
\DoxyCodeLine{14425     \}}
\DoxyCodeLine{14426     \textcolor{keywordtype}{void} TrackerBase::markAsNeedingAnotherRun() \{}
\DoxyCodeLine{14427         m\_runState = NeedsAnotherRun;}
\DoxyCodeLine{14428     \}}
\DoxyCodeLine{14429 }
\DoxyCodeLine{14430     \textcolor{keywordtype}{void} TrackerBase::moveToParent() \{}
\DoxyCodeLine{14431         assert( m\_parent );}
\DoxyCodeLine{14432         m\_ctx.setCurrentTracker( m\_parent );}
\DoxyCodeLine{14433     \}}
\DoxyCodeLine{14434     \textcolor{keywordtype}{void} TrackerBase::moveToThis() \{}
\DoxyCodeLine{14435         m\_ctx.setCurrentTracker( \textcolor{keyword}{this} );}
\DoxyCodeLine{14436     \}}
\DoxyCodeLine{14437 }
\DoxyCodeLine{14438     SectionTracker::SectionTracker( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent )}
\DoxyCodeLine{14439     :   TrackerBase( nameAndLocation, ctx, parent ),}
\DoxyCodeLine{14440         m\_trimmed\_name(trim(nameAndLocation.name))}
\DoxyCodeLine{14441     \{}
\DoxyCodeLine{14442         \textcolor{keywordflow}{if}( parent ) \{}
\DoxyCodeLine{14443             \textcolor{keywordflow}{while}( !parent-\/>isSectionTracker() )}
\DoxyCodeLine{14444                 parent = \&parent-\/>parent();}
\DoxyCodeLine{14445 }
\DoxyCodeLine{14446             SectionTracker\& parentSection = \textcolor{keyword}{static\_cast<}SectionTracker\&\textcolor{keyword}{>}( *parent );}
\DoxyCodeLine{14447             addNextFilters( parentSection.m\_filters );}
\DoxyCodeLine{14448         \}}
\DoxyCodeLine{14449     \}}
\DoxyCodeLine{14450 }
\DoxyCodeLine{14451     \textcolor{keywordtype}{bool} SectionTracker::isComplete()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14452         \textcolor{keywordtype}{bool} complete = \textcolor{keyword}{true};}
\DoxyCodeLine{14453 }
\DoxyCodeLine{14454         \textcolor{keywordflow}{if} (m\_filters.empty()}
\DoxyCodeLine{14455             || m\_filters[0] == \textcolor{stringliteral}{"{}"{}}}
\DoxyCodeLine{14456             || std::find(m\_filters.begin(), m\_filters.end(), m\_trimmed\_name) != m\_filters.end()) \{}
\DoxyCodeLine{14457             complete = TrackerBase::isComplete();}
\DoxyCodeLine{14458         \}}
\DoxyCodeLine{14459         \textcolor{keywordflow}{return} complete;}
\DoxyCodeLine{14460     \}}
\DoxyCodeLine{14461 }
\DoxyCodeLine{14462     \textcolor{keywordtype}{bool} SectionTracker::isSectionTracker()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{14463 }
\DoxyCodeLine{14464     SectionTracker\& SectionTracker::acquire( TrackerContext\& ctx, NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \{}
\DoxyCodeLine{14465         std::shared\_ptr<SectionTracker> section;}
\DoxyCodeLine{14466 }
\DoxyCodeLine{14467         ITracker\& currentTracker = ctx.currentTracker();}
\DoxyCodeLine{14468         \textcolor{keywordflow}{if}( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) \{}
\DoxyCodeLine{14469             assert( childTracker );}
\DoxyCodeLine{14470             assert( childTracker-\/>isSectionTracker() );}
\DoxyCodeLine{14471             section = std::static\_pointer\_cast<SectionTracker>( childTracker );}
\DoxyCodeLine{14472         \}}
\DoxyCodeLine{14473         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{14474             section = std::make\_shared<SectionTracker>( nameAndLocation, ctx, \&currentTracker );}
\DoxyCodeLine{14475             currentTracker.addChild( section );}
\DoxyCodeLine{14476         \}}
\DoxyCodeLine{14477         \textcolor{keywordflow}{if}( !ctx.completedCycle() )}
\DoxyCodeLine{14478             section-\/>tryOpen();}
\DoxyCodeLine{14479         \textcolor{keywordflow}{return} *section;}
\DoxyCodeLine{14480     \}}
\DoxyCodeLine{14481 }
\DoxyCodeLine{14482     \textcolor{keywordtype}{void} SectionTracker::tryOpen() \{}
\DoxyCodeLine{14483         \textcolor{keywordflow}{if}( !isComplete() )}
\DoxyCodeLine{14484             open();}
\DoxyCodeLine{14485     \}}
\DoxyCodeLine{14486 }
\DoxyCodeLine{14487     \textcolor{keywordtype}{void} SectionTracker::addInitialFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters ) \{}
\DoxyCodeLine{14488         \textcolor{keywordflow}{if}( !filters.empty() ) \{}
\DoxyCodeLine{14489             m\_filters.reserve( m\_filters.size() + filters.size() + 2 );}
\DoxyCodeLine{14490             m\_filters.emplace\_back(\textcolor{stringliteral}{"{}"{}}); \textcolor{comment}{// Root -\/ should never be consulted}}
\DoxyCodeLine{14491             m\_filters.emplace\_back(\textcolor{stringliteral}{"{}"{}}); \textcolor{comment}{// Test Case -\/ not a section filter}}
\DoxyCodeLine{14492             m\_filters.insert( m\_filters.end(), filters.begin(), filters.end() );}
\DoxyCodeLine{14493         \}}
\DoxyCodeLine{14494     \}}
\DoxyCodeLine{14495     \textcolor{keywordtype}{void} SectionTracker::addNextFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters ) \{}
\DoxyCodeLine{14496         \textcolor{keywordflow}{if}( filters.size() > 1 )}
\DoxyCodeLine{14497             m\_filters.insert( m\_filters.end(), filters.begin()+1, filters.end() );}
\DoxyCodeLine{14498     \}}
\DoxyCodeLine{14499 }
\DoxyCodeLine{14500     std::vector<std::string> \textcolor{keyword}{const}\& SectionTracker::getFilters()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14501         \textcolor{keywordflow}{return} m\_filters;}
\DoxyCodeLine{14502     \}}
\DoxyCodeLine{14503 }
\DoxyCodeLine{14504     std::string \textcolor{keyword}{const}\& SectionTracker::trimmedName()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14505         \textcolor{keywordflow}{return} m\_trimmed\_name;}
\DoxyCodeLine{14506     \}}
\DoxyCodeLine{14507 }
\DoxyCodeLine{14508 \} \textcolor{comment}{// namespace TestCaseTracking}}
\DoxyCodeLine{14509 }
\DoxyCodeLine{14510 \textcolor{keyword}{using} TestCaseTracking::ITracker;}
\DoxyCodeLine{14511 \textcolor{keyword}{using} TestCaseTracking::TrackerContext;}
\DoxyCodeLine{14512 \textcolor{keyword}{using} TestCaseTracking::SectionTracker;}
\DoxyCodeLine{14513 }
\DoxyCodeLine{14514 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{14515 }
\DoxyCodeLine{14516 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{14517 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{14518 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14519 \textcolor{comment}{// end catch\_test\_case\_tracker.cpp}}
\DoxyCodeLine{14520 \textcolor{comment}{// start catch\_test\_registry.cpp}}
\DoxyCodeLine{14521 }
\DoxyCodeLine{14522 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14523 }
\DoxyCodeLine{14524     \textcolor{keyword}{auto} makeTestInvoker( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept -\/> ITestInvoker* \{}
\DoxyCodeLine{14525         \textcolor{keywordflow}{return} \textcolor{keyword}{new}(std::nothrow) TestInvokerAsFunction( testAsFunction );}
\DoxyCodeLine{14526     \}}
\DoxyCodeLine{14527 }
\DoxyCodeLine{14528     NameAndTags::NameAndTags( StringRef \textcolor{keyword}{const}\& name\_ , StringRef \textcolor{keyword}{const}\& tags\_ ) noexcept : name( name\_ ), tags( tags\_ ) \{\}}
\DoxyCodeLine{14529 }
\DoxyCodeLine{14530     AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo \textcolor{keyword}{const}\& lineInfo, StringRef \textcolor{keyword}{const}\& classOrMethod, NameAndTags \textcolor{keyword}{const}\& nameAndTags ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{14531         CATCH\_TRY \{}
\DoxyCodeLine{14532             getMutableRegistryHub()}
\DoxyCodeLine{14533                     .registerTest(}
\DoxyCodeLine{14534                         makeTestCase(}
\DoxyCodeLine{14535                             invoker,}
\DoxyCodeLine{14536                             extractClassName( classOrMethod ),}
\DoxyCodeLine{14537                             nameAndTags,}
\DoxyCodeLine{14538                             lineInfo));}
\DoxyCodeLine{14539         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{14540             \textcolor{comment}{// Do not throw when constructing global objects, instead register the exception to be processed later}}
\DoxyCodeLine{14541             getMutableRegistryHub().registerStartupException();}
\DoxyCodeLine{14542         \}}
\DoxyCodeLine{14543     \}}
\DoxyCodeLine{14544 }
\DoxyCodeLine{14545     AutoReg::\string~AutoReg() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14546 \}}
\DoxyCodeLine{14547 \textcolor{comment}{// end catch\_test\_registry.cpp}}
\DoxyCodeLine{14548 \textcolor{comment}{// start catch\_test\_spec.cpp}}
\DoxyCodeLine{14549 }
\DoxyCodeLine{14550 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{14551 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{14552 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{14553 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{14554 }
\DoxyCodeLine{14555 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14556 }
\DoxyCodeLine{14557     TestSpec::Pattern::Pattern( std::string \textcolor{keyword}{const}\& name )}
\DoxyCodeLine{14558     : m\_name( name )}
\DoxyCodeLine{14559     \{\}}
\DoxyCodeLine{14560 }
\DoxyCodeLine{14561     TestSpec::Pattern::\string~Pattern() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14562 }
\DoxyCodeLine{14563     std::string \textcolor{keyword}{const}\& TestSpec::Pattern::name()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14564         \textcolor{keywordflow}{return} m\_name;}
\DoxyCodeLine{14565     \}}
\DoxyCodeLine{14566 }
\DoxyCodeLine{14567     TestSpec::NamePattern::NamePattern( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& filterString )}
\DoxyCodeLine{14568     : Pattern( filterString )}
\DoxyCodeLine{14569     , m\_wildcardPattern( toLower( name ), CaseSensitive::No )}
\DoxyCodeLine{14570     \{\}}
\DoxyCodeLine{14571 }
\DoxyCodeLine{14572     \textcolor{keywordtype}{bool} TestSpec::NamePattern::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14573         \textcolor{keywordflow}{return} m\_wildcardPattern.matches( testCase.name );}
\DoxyCodeLine{14574     \}}
\DoxyCodeLine{14575 }
\DoxyCodeLine{14576     TestSpec::TagPattern::TagPattern( std::string \textcolor{keyword}{const}\& tag, std::string \textcolor{keyword}{const}\& filterString )}
\DoxyCodeLine{14577     : Pattern( filterString )}
\DoxyCodeLine{14578     , m\_tag( toLower( tag ) )}
\DoxyCodeLine{14579     \{\}}
\DoxyCodeLine{14580 }
\DoxyCodeLine{14581     \textcolor{keywordtype}{bool} TestSpec::TagPattern::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14582         \textcolor{keywordflow}{return} std::find(begin(testCase.lcaseTags),}
\DoxyCodeLine{14583                          end(testCase.lcaseTags),}
\DoxyCodeLine{14584                          m\_tag) != end(testCase.lcaseTags);}
\DoxyCodeLine{14585     \}}
\DoxyCodeLine{14586 }
\DoxyCodeLine{14587     TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr \textcolor{keyword}{const}\& underlyingPattern )}
\DoxyCodeLine{14588     : Pattern( underlyingPattern-\/>name() )}
\DoxyCodeLine{14589     , m\_underlyingPattern( underlyingPattern )}
\DoxyCodeLine{14590     \{\}}
\DoxyCodeLine{14591 }
\DoxyCodeLine{14592     \textcolor{keywordtype}{bool} TestSpec::ExcludedPattern::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14593         \textcolor{keywordflow}{return} !m\_underlyingPattern-\/>matches( testCase );}
\DoxyCodeLine{14594     \}}
\DoxyCodeLine{14595 }
\DoxyCodeLine{14596     \textcolor{keywordtype}{bool} TestSpec::Filter::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14597         \textcolor{keywordflow}{return} std::all\_of( m\_patterns.begin(), m\_patterns.end(), [\&]( PatternPtr \textcolor{keyword}{const}\& p )\{ return p-\/>matches( testCase ); \} );}
\DoxyCodeLine{14598     \}}
\DoxyCodeLine{14599 }
\DoxyCodeLine{14600     std::string TestSpec::Filter::name()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14601         std::string name;}
\DoxyCodeLine{14602         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& p : m\_patterns )}
\DoxyCodeLine{14603             name += p-\/>name();}
\DoxyCodeLine{14604         \textcolor{keywordflow}{return} name;}
\DoxyCodeLine{14605     \}}
\DoxyCodeLine{14606 }
\DoxyCodeLine{14607     \textcolor{keywordtype}{bool} TestSpec::hasFilters()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14608         \textcolor{keywordflow}{return} !m\_filters.empty();}
\DoxyCodeLine{14609     \}}
\DoxyCodeLine{14610 }
\DoxyCodeLine{14611     \textcolor{keywordtype}{bool} TestSpec::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14612         \textcolor{keywordflow}{return} std::any\_of( m\_filters.begin(), m\_filters.end(), [\&]( Filter \textcolor{keyword}{const}\& f )\{ return f.matches( testCase ); \} );}
\DoxyCodeLine{14613     \}}
\DoxyCodeLine{14614 }
\DoxyCodeLine{14615     TestSpec::Matches TestSpec::matchesByFilter( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, IConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const}}
\DoxyCodeLine{14616 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14617         Matches matches( m\_filters.size() );}
\DoxyCodeLine{14618         std::transform( m\_filters.begin(), m\_filters.end(), matches.begin(), [\&]( Filter \textcolor{keyword}{const}\& filter )\{}
\DoxyCodeLine{14619             std::vector<TestCase const*> currentMatches;}
\DoxyCodeLine{14620             for( auto const\& test : testCases )}
\DoxyCodeLine{14621                 if( isThrowSafe( test, config ) \&\& filter.matches( test ) )}
\DoxyCodeLine{14622                     currentMatches.emplace\_back( \&test );}
\DoxyCodeLine{14623             return FilterMatch\{ filter.name(), currentMatches \};}
\DoxyCodeLine{14624         \} );}
\DoxyCodeLine{14625         \textcolor{keywordflow}{return} matches;}
\DoxyCodeLine{14626     \}}
\DoxyCodeLine{14627 }
\DoxyCodeLine{14628     \textcolor{keyword}{const} TestSpec::vectorStrings\& TestSpec::getInvalidArgs()\textcolor{keyword}{ const}\{}
\DoxyCodeLine{14629         \textcolor{keywordflow}{return}  (m\_invalidArgs);}
\DoxyCodeLine{14630     \}}
\DoxyCodeLine{14631 }
\DoxyCodeLine{14632 \}}
\DoxyCodeLine{14633 \textcolor{comment}{// end catch\_test\_spec.cpp}}
\DoxyCodeLine{14634 \textcolor{comment}{// start catch\_test\_spec\_parser.cpp}}
\DoxyCodeLine{14635 }
\DoxyCodeLine{14636 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14637 }
\DoxyCodeLine{14638     TestSpecParser::TestSpecParser( ITagAliasRegistry \textcolor{keyword}{const}\& tagAliases ) : m\_tagAliases( \&tagAliases ) \{\}}
\DoxyCodeLine{14639 }
\DoxyCodeLine{14640     TestSpecParser\& TestSpecParser::parse( std::string \textcolor{keyword}{const}\& arg ) \{}
\DoxyCodeLine{14641         m\_mode = None;}
\DoxyCodeLine{14642         m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{14643         m\_arg = m\_tagAliases-\/>expandAliases( arg );}
\DoxyCodeLine{14644         m\_escapeChars.clear();}
\DoxyCodeLine{14645         m\_substring.reserve(m\_arg.size());}
\DoxyCodeLine{14646         m\_patternName.reserve(m\_arg.size());}
\DoxyCodeLine{14647         m\_realPatternPos = 0;}
\DoxyCodeLine{14648 }
\DoxyCodeLine{14649         \textcolor{keywordflow}{for}( m\_pos = 0; m\_pos < m\_arg.size(); ++m\_pos )}
\DoxyCodeLine{14650           \textcolor{comment}{//if visitChar fails}}
\DoxyCodeLine{14651            if( !visitChar( m\_arg[m\_pos] ) )\{}
\DoxyCodeLine{14652                m\_testSpec.m\_invalidArgs.push\_back(arg);}
\DoxyCodeLine{14653                \textcolor{keywordflow}{break};}
\DoxyCodeLine{14654            \}}
\DoxyCodeLine{14655         endMode();}
\DoxyCodeLine{14656         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{14657     \}}
\DoxyCodeLine{14658     TestSpec TestSpecParser::testSpec() \{}
\DoxyCodeLine{14659         addFilter();}
\DoxyCodeLine{14660         \textcolor{keywordflow}{return} m\_testSpec;}
\DoxyCodeLine{14661     \}}
\DoxyCodeLine{14662     \textcolor{keywordtype}{bool} TestSpecParser::visitChar( \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{14663         \textcolor{keywordflow}{if}( (m\_mode != EscapedName) \&\& (c == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}) ) \{}
\DoxyCodeLine{14664             escape();}
\DoxyCodeLine{14665             addCharToPattern(c);}
\DoxyCodeLine{14666             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14667         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}((m\_mode != EscapedName) \&\& (c == \textcolor{charliteral}{','}) )  \{}
\DoxyCodeLine{14668             \textcolor{keywordflow}{return} separate();}
\DoxyCodeLine{14669         \}}
\DoxyCodeLine{14670 }
\DoxyCodeLine{14671         \textcolor{keywordflow}{switch}( m\_mode ) \{}
\DoxyCodeLine{14672         \textcolor{keywordflow}{case} None:}
\DoxyCodeLine{14673             \textcolor{keywordflow}{if}( processNoneChar( c ) )}
\DoxyCodeLine{14674                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14675             \textcolor{keywordflow}{break};}
\DoxyCodeLine{14676         \textcolor{keywordflow}{case} Name:}
\DoxyCodeLine{14677             processNameChar( c );}
\DoxyCodeLine{14678             \textcolor{keywordflow}{break};}
\DoxyCodeLine{14679         \textcolor{keywordflow}{case} EscapedName:}
\DoxyCodeLine{14680             endMode();}
\DoxyCodeLine{14681             addCharToPattern(c);}
\DoxyCodeLine{14682             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14683         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14684         \textcolor{keywordflow}{case} Tag:}
\DoxyCodeLine{14685         \textcolor{keywordflow}{case} QuotedName:}
\DoxyCodeLine{14686             \textcolor{keywordflow}{if}( processOtherChar( c ) )}
\DoxyCodeLine{14687                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14688             \textcolor{keywordflow}{break};}
\DoxyCodeLine{14689         \}}
\DoxyCodeLine{14690 }
\DoxyCodeLine{14691         m\_substring += c;}
\DoxyCodeLine{14692         \textcolor{keywordflow}{if}( !isControlChar( c ) ) \{}
\DoxyCodeLine{14693             m\_patternName += c;}
\DoxyCodeLine{14694             m\_realPatternPos++;}
\DoxyCodeLine{14695         \}}
\DoxyCodeLine{14696         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14697     \}}
\DoxyCodeLine{14698     \textcolor{comment}{// Two of the processing methods return true to signal the caller to return}}
\DoxyCodeLine{14699     \textcolor{comment}{// without adding the given character to the current pattern strings}}
\DoxyCodeLine{14700     \textcolor{keywordtype}{bool} TestSpecParser::processNoneChar( \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{14701         \textcolor{keywordflow}{switch}( c ) \{}
\DoxyCodeLine{14702         \textcolor{keywordflow}{case} \textcolor{charliteral}{' '}:}
\DoxyCodeLine{14703             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14704         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\string~'}:}
\DoxyCodeLine{14705             m\_exclusion = \textcolor{keyword}{true};}
\DoxyCodeLine{14706             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14707         \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}:}
\DoxyCodeLine{14708             startNewMode( Tag );}
\DoxyCodeLine{14709             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14710         \textcolor{keywordflow}{case} \textcolor{charliteral}{'"{}'}:}
\DoxyCodeLine{14711             startNewMode( QuotedName );}
\DoxyCodeLine{14712             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14713         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14714             startNewMode( Name );}
\DoxyCodeLine{14715             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14716         \}}
\DoxyCodeLine{14717     \}}
\DoxyCodeLine{14718     \textcolor{keywordtype}{void} TestSpecParser::processNameChar( \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{14719         \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{'['} ) \{}
\DoxyCodeLine{14720             \textcolor{keywordflow}{if}( m\_substring == \textcolor{stringliteral}{"{}exclude:"{}} )}
\DoxyCodeLine{14721                 m\_exclusion = \textcolor{keyword}{true};}
\DoxyCodeLine{14722             \textcolor{keywordflow}{else}}
\DoxyCodeLine{14723                 endMode();}
\DoxyCodeLine{14724             startNewMode( Tag );}
\DoxyCodeLine{14725         \}}
\DoxyCodeLine{14726     \}}
\DoxyCodeLine{14727     \textcolor{keywordtype}{bool} TestSpecParser::processOtherChar( \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{14728         \textcolor{keywordflow}{if}( !isControlChar( c ) )}
\DoxyCodeLine{14729             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14730         m\_substring += c;}
\DoxyCodeLine{14731         endMode();}
\DoxyCodeLine{14732         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14733     \}}
\DoxyCodeLine{14734     \textcolor{keywordtype}{void} TestSpecParser::startNewMode( Mode mode ) \{}
\DoxyCodeLine{14735         m\_mode = mode;}
\DoxyCodeLine{14736     \}}
\DoxyCodeLine{14737     \textcolor{keywordtype}{void} TestSpecParser::endMode() \{}
\DoxyCodeLine{14738         \textcolor{keywordflow}{switch}( m\_mode ) \{}
\DoxyCodeLine{14739         \textcolor{keywordflow}{case} Name:}
\DoxyCodeLine{14740         \textcolor{keywordflow}{case} QuotedName:}
\DoxyCodeLine{14741             \textcolor{keywordflow}{return} addNamePattern();}
\DoxyCodeLine{14742         \textcolor{keywordflow}{case} Tag:}
\DoxyCodeLine{14743             \textcolor{keywordflow}{return} addTagPattern();}
\DoxyCodeLine{14744         \textcolor{keywordflow}{case} EscapedName:}
\DoxyCodeLine{14745             revertBackToLastMode();}
\DoxyCodeLine{14746             \textcolor{keywordflow}{return};}
\DoxyCodeLine{14747         \textcolor{keywordflow}{case} None:}
\DoxyCodeLine{14748         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14749             \textcolor{keywordflow}{return} startNewMode( None );}
\DoxyCodeLine{14750         \}}
\DoxyCodeLine{14751     \}}
\DoxyCodeLine{14752     \textcolor{keywordtype}{void} TestSpecParser::escape() \{}
\DoxyCodeLine{14753         saveLastMode();}
\DoxyCodeLine{14754         m\_mode = EscapedName;}
\DoxyCodeLine{14755         m\_escapeChars.push\_back(m\_realPatternPos);}
\DoxyCodeLine{14756     \}}
\DoxyCodeLine{14757     \textcolor{keywordtype}{bool} TestSpecParser::isControlChar( \textcolor{keywordtype}{char} c )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14758         \textcolor{keywordflow}{switch}( m\_mode ) \{}
\DoxyCodeLine{14759             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14760                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14761             \textcolor{keywordflow}{case} None:}
\DoxyCodeLine{14762                 \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'\string~'};}
\DoxyCodeLine{14763             \textcolor{keywordflow}{case} Name:}
\DoxyCodeLine{14764                 \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'['};}
\DoxyCodeLine{14765             \textcolor{keywordflow}{case} EscapedName:}
\DoxyCodeLine{14766                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14767             \textcolor{keywordflow}{case} QuotedName:}
\DoxyCodeLine{14768                 \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{14769             \textcolor{keywordflow}{case} Tag:}
\DoxyCodeLine{14770                 \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'['} || c == \textcolor{charliteral}{']'};}
\DoxyCodeLine{14771         \}}
\DoxyCodeLine{14772     \}}
\DoxyCodeLine{14773 }
\DoxyCodeLine{14774     \textcolor{keywordtype}{void} TestSpecParser::addFilter() \{}
\DoxyCodeLine{14775         \textcolor{keywordflow}{if}( !m\_currentFilter.m\_patterns.empty() ) \{}
\DoxyCodeLine{14776             m\_testSpec.m\_filters.push\_back( m\_currentFilter );}
\DoxyCodeLine{14777             m\_currentFilter = TestSpec::Filter();}
\DoxyCodeLine{14778         \}}
\DoxyCodeLine{14779     \}}
\DoxyCodeLine{14780 }
\DoxyCodeLine{14781     \textcolor{keywordtype}{void} TestSpecParser::saveLastMode() \{}
\DoxyCodeLine{14782       lastMode = m\_mode;}
\DoxyCodeLine{14783     \}}
\DoxyCodeLine{14784 }
\DoxyCodeLine{14785     \textcolor{keywordtype}{void} TestSpecParser::revertBackToLastMode() \{}
\DoxyCodeLine{14786       m\_mode = lastMode;}
\DoxyCodeLine{14787     \}}
\DoxyCodeLine{14788 }
\DoxyCodeLine{14789     \textcolor{keywordtype}{bool} TestSpecParser::separate() \{}
\DoxyCodeLine{14790       \textcolor{keywordflow}{if}( (m\_mode==QuotedName) || (m\_mode==Tag) )\{}
\DoxyCodeLine{14791          \textcolor{comment}{//invalid argument, signal failure to previous scope.}}
\DoxyCodeLine{14792          m\_mode = None;}
\DoxyCodeLine{14793          m\_pos = m\_arg.size();}
\DoxyCodeLine{14794          m\_substring.clear();}
\DoxyCodeLine{14795          m\_patternName.clear();}
\DoxyCodeLine{14796          m\_realPatternPos = 0;}
\DoxyCodeLine{14797          \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14798       \}}
\DoxyCodeLine{14799       endMode();}
\DoxyCodeLine{14800       addFilter();}
\DoxyCodeLine{14801       \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \textcolor{comment}{//success}}
\DoxyCodeLine{14802     \}}
\DoxyCodeLine{14803 }
\DoxyCodeLine{14804     std::string TestSpecParser::preprocessPattern() \{}
\DoxyCodeLine{14805         std::string token = m\_patternName;}
\DoxyCodeLine{14806         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < m\_escapeChars.size(); ++i)}
\DoxyCodeLine{14807             token = token.substr(0, m\_escapeChars[i] -\/ i) + token.substr(m\_escapeChars[i] -\/ i + 1);}
\DoxyCodeLine{14808         m\_escapeChars.clear();}
\DoxyCodeLine{14809         \textcolor{keywordflow}{if} (startsWith(token, \textcolor{stringliteral}{"{}exclude:"{}})) \{}
\DoxyCodeLine{14810             m\_exclusion = \textcolor{keyword}{true};}
\DoxyCodeLine{14811             token = token.substr(8);}
\DoxyCodeLine{14812         \}}
\DoxyCodeLine{14813 }
\DoxyCodeLine{14814         m\_patternName.clear();}
\DoxyCodeLine{14815         m\_realPatternPos = 0;}
\DoxyCodeLine{14816 }
\DoxyCodeLine{14817         \textcolor{keywordflow}{return} token;}
\DoxyCodeLine{14818     \}}
\DoxyCodeLine{14819 }
\DoxyCodeLine{14820     \textcolor{keywordtype}{void} TestSpecParser::addNamePattern() \{}
\DoxyCodeLine{14821         \textcolor{keyword}{auto} token = preprocessPattern();}
\DoxyCodeLine{14822 }
\DoxyCodeLine{14823         \textcolor{keywordflow}{if} (!token.empty()) \{}
\DoxyCodeLine{14824             TestSpec::PatternPtr pattern = std::make\_shared<TestSpec::NamePattern>(token, m\_substring);}
\DoxyCodeLine{14825             \textcolor{keywordflow}{if} (m\_exclusion)}
\DoxyCodeLine{14826                 pattern = std::make\_shared<TestSpec::ExcludedPattern>(pattern);}
\DoxyCodeLine{14827             m\_currentFilter.m\_patterns.push\_back(pattern);}
\DoxyCodeLine{14828         \}}
\DoxyCodeLine{14829         m\_substring.clear();}
\DoxyCodeLine{14830         m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{14831         m\_mode = None;}
\DoxyCodeLine{14832     \}}
\DoxyCodeLine{14833 }
\DoxyCodeLine{14834     \textcolor{keywordtype}{void} TestSpecParser::addTagPattern() \{}
\DoxyCodeLine{14835         \textcolor{keyword}{auto} token = preprocessPattern();}
\DoxyCodeLine{14836 }
\DoxyCodeLine{14837         \textcolor{keywordflow}{if} (!token.empty()) \{}
\DoxyCodeLine{14838             \textcolor{comment}{// If the tag pattern is the "{}hide and tag"{} shorthand (e.g. [.foo])}}
\DoxyCodeLine{14839             \textcolor{comment}{// we have to create a separate hide tag and shorten the real one}}
\DoxyCodeLine{14840             \textcolor{keywordflow}{if} (token.size() > 1 \&\& token[0] == \textcolor{charliteral}{'.'}) \{}
\DoxyCodeLine{14841                 token.erase(token.begin());}
\DoxyCodeLine{14842                 TestSpec::PatternPtr pattern = std::make\_shared<TestSpec::TagPattern>(\textcolor{stringliteral}{"{}."{}}, m\_substring);}
\DoxyCodeLine{14843                 \textcolor{keywordflow}{if} (m\_exclusion) \{}
\DoxyCodeLine{14844                     pattern = std::make\_shared<TestSpec::ExcludedPattern>(pattern);}
\DoxyCodeLine{14845                 \}}
\DoxyCodeLine{14846                 m\_currentFilter.m\_patterns.push\_back(pattern);}
\DoxyCodeLine{14847             \}}
\DoxyCodeLine{14848 }
\DoxyCodeLine{14849             TestSpec::PatternPtr pattern = std::make\_shared<TestSpec::TagPattern>(token, m\_substring);}
\DoxyCodeLine{14850 }
\DoxyCodeLine{14851             \textcolor{keywordflow}{if} (m\_exclusion) \{}
\DoxyCodeLine{14852                 pattern = std::make\_shared<TestSpec::ExcludedPattern>(pattern);}
\DoxyCodeLine{14853             \}}
\DoxyCodeLine{14854             m\_currentFilter.m\_patterns.push\_back(pattern);}
\DoxyCodeLine{14855         \}}
\DoxyCodeLine{14856         m\_substring.clear();}
\DoxyCodeLine{14857         m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{14858         m\_mode = None;}
\DoxyCodeLine{14859     \}}
\DoxyCodeLine{14860 }
\DoxyCodeLine{14861     TestSpec parseTestSpec( std::string \textcolor{keyword}{const}\& arg ) \{}
\DoxyCodeLine{14862         \textcolor{keywordflow}{return} TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();}
\DoxyCodeLine{14863     \}}
\DoxyCodeLine{14864 }
\DoxyCodeLine{14865 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{14866 \textcolor{comment}{// end catch\_test\_spec\_parser.cpp}}
\DoxyCodeLine{14867 \textcolor{comment}{// start catch\_timer.cpp}}
\DoxyCodeLine{14868 }
\DoxyCodeLine{14869 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{14870 }
\DoxyCodeLine{14871 \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t nanosecondsInSecond = 1000000000;}
\DoxyCodeLine{14872 }
\DoxyCodeLine{14873 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14874 }
\DoxyCodeLine{14875     \textcolor{keyword}{auto} getCurrentNanosecondsSinceEpoch() -\/> uint64\_t \{}
\DoxyCodeLine{14876         \textcolor{keywordflow}{return} std::chrono::duration\_cast<std::chrono::nanoseconds>( std::chrono::high\_resolution\_clock::now().time\_since\_epoch() ).count();}
\DoxyCodeLine{14877     \}}
\DoxyCodeLine{14878 }
\DoxyCodeLine{14879     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{14880         \textcolor{keyword}{auto} estimateClockResolution() -\/> uint64\_t \{}
\DoxyCodeLine{14881             uint64\_t sum = 0;}
\DoxyCodeLine{14882             \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t iterations = 1000000;}
\DoxyCodeLine{14883 }
\DoxyCodeLine{14884             \textcolor{keyword}{auto} startTime = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{14885 }
\DoxyCodeLine{14886             \textcolor{keywordflow}{for}( std::size\_t i = 0; i < iterations; ++i ) \{}
\DoxyCodeLine{14887 }
\DoxyCodeLine{14888                 uint64\_t ticks;}
\DoxyCodeLine{14889                 uint64\_t baseTicks = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{14890                 \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{14891                     ticks = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{14892                 \} \textcolor{keywordflow}{while}( ticks == baseTicks );}
\DoxyCodeLine{14893 }
\DoxyCodeLine{14894                 \textcolor{keyword}{auto} delta = ticks -\/ baseTicks;}
\DoxyCodeLine{14895                 sum += delta;}
\DoxyCodeLine{14896 }
\DoxyCodeLine{14897                 \textcolor{comment}{// If we have been calibrating for over 3 seconds -\/-\/ the clock}}
\DoxyCodeLine{14898                 \textcolor{comment}{// is terrible and we should move on.}}
\DoxyCodeLine{14899                 \textcolor{comment}{// TBD: How to signal that the measured resolution is probably wrong?}}
\DoxyCodeLine{14900                 \textcolor{keywordflow}{if} (ticks > startTime + 3 * nanosecondsInSecond) \{}
\DoxyCodeLine{14901                     \textcolor{keywordflow}{return} sum / ( i + 1u );}
\DoxyCodeLine{14902                 \}}
\DoxyCodeLine{14903             \}}
\DoxyCodeLine{14904 }
\DoxyCodeLine{14905             \textcolor{comment}{// We're just taking the mean, here. To do better we could take the std. dev and exclude outliers}}
\DoxyCodeLine{14906             \textcolor{comment}{// -\/ and potentially do more iterations if there's a high variance.}}
\DoxyCodeLine{14907             \textcolor{keywordflow}{return} sum/iterations;}
\DoxyCodeLine{14908         \}}
\DoxyCodeLine{14909     \}}
\DoxyCodeLine{14910     \textcolor{keyword}{auto} getEstimatedClockResolution() -\/> uint64\_t \{}
\DoxyCodeLine{14911         \textcolor{keyword}{static} \textcolor{keyword}{auto} s\_resolution = estimateClockResolution();}
\DoxyCodeLine{14912         \textcolor{keywordflow}{return} s\_resolution;}
\DoxyCodeLine{14913     \}}
\DoxyCodeLine{14914 }
\DoxyCodeLine{14915     \textcolor{keywordtype}{void} Timer::start() \{}
\DoxyCodeLine{14916        m\_nanoseconds = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{14917     \}}
\DoxyCodeLine{14918     \textcolor{keyword}{auto} Timer::getElapsedNanoseconds() const -\/> uint64\_t \{}
\DoxyCodeLine{14919         \textcolor{keywordflow}{return} getCurrentNanosecondsSinceEpoch() -\/ m\_nanoseconds;}
\DoxyCodeLine{14920     \}}
\DoxyCodeLine{14921     \textcolor{keyword}{auto} Timer::getElapsedMicroseconds() const -\/> uint64\_t \{}
\DoxyCodeLine{14922         \textcolor{keywordflow}{return} getElapsedNanoseconds()/1000;}
\DoxyCodeLine{14923     \}}
\DoxyCodeLine{14924     \textcolor{keyword}{auto} Timer::getElapsedMilliseconds() const -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{14925         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(getElapsedMicroseconds()/1000);}
\DoxyCodeLine{14926     \}}
\DoxyCodeLine{14927     \textcolor{keyword}{auto} Timer::getElapsedSeconds() const -\/> \textcolor{keywordtype}{double} \{}
\DoxyCodeLine{14928         \textcolor{keywordflow}{return} getElapsedMicroseconds()/1000000.0;}
\DoxyCodeLine{14929     \}}
\DoxyCodeLine{14930 }
\DoxyCodeLine{14931 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{14932 \textcolor{comment}{// end catch\_timer.cpp}}
\DoxyCodeLine{14933 \textcolor{comment}{// start catch\_tostring.cpp}}
\DoxyCodeLine{14934 }
\DoxyCodeLine{14935 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{14936 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{14937 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wexit-\/time-\/destructors"{}}}
\DoxyCodeLine{14938 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wglobal-\/constructors"{}}}
\DoxyCodeLine{14939 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14940 }
\DoxyCodeLine{14941 \textcolor{comment}{// Enable specific decls locally}}
\DoxyCodeLine{14942 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER)}}
\DoxyCodeLine{14943 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{14944 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14945 }
\DoxyCodeLine{14946 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{14947 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{14948 }
\DoxyCodeLine{14949 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14950 }
\DoxyCodeLine{14951 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{14952 }
\DoxyCodeLine{14953     \textcolor{keyword}{const} std::string unprintableString = \textcolor{stringliteral}{"{}\{?\}"{}};}
\DoxyCodeLine{14954 }
\DoxyCodeLine{14955     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{14956         \textcolor{keyword}{const} \textcolor{keywordtype}{int} hexThreshold = 255;}
\DoxyCodeLine{14957 }
\DoxyCodeLine{14958         \textcolor{keyword}{struct }Endianness \{}
\DoxyCodeLine{14959             \textcolor{keyword}{enum} Arch \{ Big, Little \};}
\DoxyCodeLine{14960 }
\DoxyCodeLine{14961             \textcolor{keyword}{static} Arch which() \{}
\DoxyCodeLine{14962                 \textcolor{keywordtype}{int} one = 1;}
\DoxyCodeLine{14963                 \textcolor{comment}{// If the lowest byte we read is non-\/zero, we can assume}}
\DoxyCodeLine{14964                 \textcolor{comment}{// that little endian format is used.}}
\DoxyCodeLine{14965                 \textcolor{keyword}{auto} value = *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&one);}
\DoxyCodeLine{14966                 \textcolor{keywordflow}{return} value ? Little : Big;}
\DoxyCodeLine{14967             \}}
\DoxyCodeLine{14968         \};}
\DoxyCodeLine{14969     \}}
\DoxyCodeLine{14970 }
\DoxyCodeLine{14971     std::string rawMemoryToString( \textcolor{keyword}{const} \textcolor{keywordtype}{void} *\textcolor{keywordtype}{object}, std::size\_t size ) \{}
\DoxyCodeLine{14972         \textcolor{comment}{// Reverse order for little endian architectures}}
\DoxyCodeLine{14973         \textcolor{keywordtype}{int} i = 0, end = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( size ), inc = 1;}
\DoxyCodeLine{14974         \textcolor{keywordflow}{if}( Endianness::which() == Endianness::Little ) \{}
\DoxyCodeLine{14975             i = end-\/1;}
\DoxyCodeLine{14976             end = inc = -\/1;}
\DoxyCodeLine{14977         \}}
\DoxyCodeLine{14978 }
\DoxyCodeLine{14979         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \textcolor{keyword}{const} *bytes = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \textcolor{keyword}{const }*\textcolor{keyword}{>}(object);}
\DoxyCodeLine{14980         ReusableStringStream rss;}
\DoxyCodeLine{14981         rss << \textcolor{stringliteral}{"{}0x"{}} << std::setfill(\textcolor{charliteral}{'0'}) << std::hex;}
\DoxyCodeLine{14982         \textcolor{keywordflow}{for}( ; i != end; i += inc )}
\DoxyCodeLine{14983              rss << std::setw(2) << static\_cast<unsigned>(bytes[i]);}
\DoxyCodeLine{14984        \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{14985     \}}
\DoxyCodeLine{14986 \}}
\DoxyCodeLine{14987 }
\DoxyCodeLine{14988 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{14989 std::string fpToString( T value, \textcolor{keywordtype}{int} precision ) \{}
\DoxyCodeLine{14990     \textcolor{keywordflow}{if} (Catch::isnan(value)) \{}
\DoxyCodeLine{14991         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nan"{}};}
\DoxyCodeLine{14992     \}}
\DoxyCodeLine{14993 }
\DoxyCodeLine{14994     ReusableStringStream rss;}
\DoxyCodeLine{14995     rss << std::setprecision( precision )}
\DoxyCodeLine{14996         << std::fixed}
\DoxyCodeLine{14997         << value;}
\DoxyCodeLine{14998     std::string d = rss.str();}
\DoxyCodeLine{14999     std::size\_t i = d.find\_last\_not\_of( \textcolor{charliteral}{'0'} );}
\DoxyCodeLine{15000     \textcolor{keywordflow}{if}( i != std::string::npos \&\& i != d.size()-\/1 ) \{}
\DoxyCodeLine{15001         \textcolor{keywordflow}{if}( d[i] == \textcolor{charliteral}{'.'} )}
\DoxyCodeLine{15002             i++;}
\DoxyCodeLine{15003         d = d.substr( 0, i+1 );}
\DoxyCodeLine{15004     \}}
\DoxyCodeLine{15005     \textcolor{keywordflow}{return} d;}
\DoxyCodeLine{15006 \}}
\DoxyCodeLine{15007 }
\DoxyCodeLine{15009 \textcolor{comment}{//}}
\DoxyCodeLine{15010 \textcolor{comment}{//   Out-\/of-\/line defs for full specialization of StringMaker}}
\DoxyCodeLine{15011 \textcolor{comment}{//}}
\DoxyCodeLine{15013 \textcolor{comment}{}}
\DoxyCodeLine{15014 std::string StringMaker<std::string>::convert(\textcolor{keyword}{const} std::string\& str) \{}
\DoxyCodeLine{15015     \textcolor{keywordflow}{if} (!getCurrentContext().getConfig()-\/>showInvisibles()) \{}
\DoxyCodeLine{15016         \textcolor{keywordflow}{return} \textcolor{charliteral}{'"{}'} + str + '"{}';}
\DoxyCodeLine{15017     \}}
\DoxyCodeLine{15018 }
\DoxyCodeLine{15019     std::string s(\textcolor{stringliteral}{"{}\(\backslash\)"{}"{}});}
\DoxyCodeLine{15020     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{char} c : str) \{}
\DoxyCodeLine{15021         \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{15022         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)n'}:}
\DoxyCodeLine{15023             s.append(\textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)n"{}});}
\DoxyCodeLine{15024             \textcolor{keywordflow}{break};}
\DoxyCodeLine{15025         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)t'}:}
\DoxyCodeLine{15026             s.append(\textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)t"{}});}
\DoxyCodeLine{15027             \textcolor{keywordflow}{break};}
\DoxyCodeLine{15028         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{15029             s.push\_back(c);}
\DoxyCodeLine{15030             \textcolor{keywordflow}{break};}
\DoxyCodeLine{15031         \}}
\DoxyCodeLine{15032     \}}
\DoxyCodeLine{15033     s.append(\textcolor{stringliteral}{"{}\(\backslash\)"{}"{}});}
\DoxyCodeLine{15034     \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{15035 \}}
\DoxyCodeLine{15036 }
\DoxyCodeLine{15037 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{15038 std::string StringMaker<std::string\_view>::convert(std::string\_view str) \{}
\DoxyCodeLine{15039     return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{15040 \}}
\DoxyCodeLine{15041 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15042 }
\DoxyCodeLine{15043 std::string StringMaker<char const*>::convert(\textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{15044     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{15045         return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{15046     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15047         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"{}\{null string\}"{}} \};}
\DoxyCodeLine{15048     \}}
\DoxyCodeLine{15049 \}}
\DoxyCodeLine{15050 std::string StringMaker<char*>::convert(\textcolor{keywordtype}{char}* str) \{}
\DoxyCodeLine{15051     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{15052         return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{15053     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15054         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"{}\{null string\}"{}} \};}
\DoxyCodeLine{15055     \}}
\DoxyCodeLine{15056 \}}
\DoxyCodeLine{15057 }
\DoxyCodeLine{15058 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_WCHAR}}
\DoxyCodeLine{15059 std::string StringMaker<std::wstring>::convert(\textcolor{keyword}{const} std::wstring\& wstr) \{}
\DoxyCodeLine{15060     std::string s;}
\DoxyCodeLine{15061     s.reserve(wstr.size());}
\DoxyCodeLine{15062     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} c : wstr) \{}
\DoxyCodeLine{15063         s += (c <= 0xff) ? static\_cast<char>(c) : '?';}
\DoxyCodeLine{15064     \}}
\DoxyCodeLine{15065     return ::Catch::Detail::stringify(s);}
\DoxyCodeLine{15066 \}}
\DoxyCodeLine{15067 }
\DoxyCodeLine{15068 \textcolor{preprocessor}{\# ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{15069 std::string StringMaker<std::wstring\_view>::convert(std::wstring\_view str) \{}
\DoxyCodeLine{15070     \textcolor{keywordflow}{return} StringMaker<std::wstring>::convert(std::wstring(str));}
\DoxyCodeLine{15071 \}}
\DoxyCodeLine{15072 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{15073 }
\DoxyCodeLine{15074 std::string StringMaker<wchar\_t const*>::convert(\textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * str) \{}
\DoxyCodeLine{15075     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{15076         return ::Catch::Detail::stringify(std::wstring\{ str \});}
\DoxyCodeLine{15077     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15078         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"{}\{null string\}"{}} \};}
\DoxyCodeLine{15079     \}}
\DoxyCodeLine{15080 \}}
\DoxyCodeLine{15081 std::string StringMaker<wchar\_t *>::convert(\textcolor{keywordtype}{wchar\_t} * str) \{}
\DoxyCodeLine{15082     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{15083         return ::Catch::Detail::stringify(std::wstring\{ str \});}
\DoxyCodeLine{15084     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15085         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"{}\{null string\}"{}} \};}
\DoxyCodeLine{15086     \}}
\DoxyCodeLine{15087 \}}
\DoxyCodeLine{15088 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15089 }
\DoxyCodeLine{15090 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{15091 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{15092 std::string StringMaker<std::byte>::convert(std::byte value) \{}
\DoxyCodeLine{15093     return ::Catch::Detail::stringify(std::to\_integer<unsigned long long>(value));}
\DoxyCodeLine{15094 \}}
\DoxyCodeLine{15095 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{15096 }
\DoxyCodeLine{15097 std::string StringMaker<int>::convert(\textcolor{keywordtype}{int} value) \{}
\DoxyCodeLine{15098     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15099 \}}
\DoxyCodeLine{15100 std::string StringMaker<long>::convert(\textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{15101     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15102 \}}
\DoxyCodeLine{15103 std::string StringMaker<long long>::convert(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{15104     ReusableStringStream rss;}
\DoxyCodeLine{15105     rss << value;}
\DoxyCodeLine{15106     \textcolor{keywordflow}{if} (value > Detail::hexThreshold) \{}
\DoxyCodeLine{15107         rss << \textcolor{stringliteral}{"{} (0x"{}} << std::hex << value << \textcolor{charliteral}{')'};}
\DoxyCodeLine{15108     \}}
\DoxyCodeLine{15109     \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{15110 \}}
\DoxyCodeLine{15111 }
\DoxyCodeLine{15112 std::string StringMaker<unsigned int>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} value) \{}
\DoxyCodeLine{15113     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15114 \}}
\DoxyCodeLine{15115 std::string StringMaker<unsigned long>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{15116     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15117 \}}
\DoxyCodeLine{15118 std::string StringMaker<unsigned long long>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{15119     ReusableStringStream rss;}
\DoxyCodeLine{15120     rss << value;}
\DoxyCodeLine{15121     \textcolor{keywordflow}{if} (value > Detail::hexThreshold) \{}
\DoxyCodeLine{15122         rss << \textcolor{stringliteral}{"{} (0x"{}} << std::hex << value << \textcolor{charliteral}{')'};}
\DoxyCodeLine{15123     \}}
\DoxyCodeLine{15124     \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{15125 \}}
\DoxyCodeLine{15126 }
\DoxyCodeLine{15127 std::string StringMaker<bool>::convert(\textcolor{keywordtype}{bool} b) \{}
\DoxyCodeLine{15128     \textcolor{keywordflow}{return} b ? \textcolor{stringliteral}{"{}true"{}} : \textcolor{stringliteral}{"{}false"{}};}
\DoxyCodeLine{15129 \}}
\DoxyCodeLine{15130 }
\DoxyCodeLine{15131 std::string StringMaker<signed char>::convert(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} value) \{}
\DoxyCodeLine{15132     \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)r'}) \{}
\DoxyCodeLine{15133         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)r'"{}};}
\DoxyCodeLine{15134     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)f'}) \{}
\DoxyCodeLine{15135         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)f'"{}};}
\DoxyCodeLine{15136     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)n'}) \{}
\DoxyCodeLine{15137         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)n'"{}};}
\DoxyCodeLine{15138     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)t'}) \{}
\DoxyCodeLine{15139         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)t'"{}};}
\DoxyCodeLine{15140     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{charliteral}{'\(\backslash\)0'} <= value \&\& value < \textcolor{charliteral}{' '}) \{}
\DoxyCodeLine{15141         return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15142     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15143         \textcolor{keywordtype}{char} chstr[] = \textcolor{stringliteral}{"{}' '"{}};}
\DoxyCodeLine{15144         chstr[1] = value;}
\DoxyCodeLine{15145         \textcolor{keywordflow}{return} chstr;}
\DoxyCodeLine{15146     \}}
\DoxyCodeLine{15147 \}}
\DoxyCodeLine{15148 std::string StringMaker<char>::convert(\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15149     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(c));}
\DoxyCodeLine{15150 \}}
\DoxyCodeLine{15151 std::string StringMaker<unsigned char>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15152     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(c));}
\DoxyCodeLine{15153 \}}
\DoxyCodeLine{15154 }
\DoxyCodeLine{15155 std::string StringMaker<std::nullptr\_t>::convert(std::nullptr\_t) \{}
\DoxyCodeLine{15156     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nullptr"{}};}
\DoxyCodeLine{15157 \}}
\DoxyCodeLine{15158 }
\DoxyCodeLine{15159 \textcolor{keywordtype}{int} StringMaker<float>::precision = 5;}
\DoxyCodeLine{15160 }
\DoxyCodeLine{15161 std::string StringMaker<float>::convert(\textcolor{keywordtype}{float} value) \{}
\DoxyCodeLine{15162     \textcolor{keywordflow}{return} fpToString(value, precision) + 'f';}
\DoxyCodeLine{15163 \}}
\DoxyCodeLine{15164 }
\DoxyCodeLine{15165 \textcolor{keywordtype}{int} StringMaker<double>::precision = 10;}
\DoxyCodeLine{15166 }
\DoxyCodeLine{15167 std::string StringMaker<double>::convert(\textcolor{keywordtype}{double} value) \{}
\DoxyCodeLine{15168     \textcolor{keywordflow}{return} fpToString(value, precision);}
\DoxyCodeLine{15169 \}}
\DoxyCodeLine{15170 }
\DoxyCodeLine{15171 std::string ratio\_string<std::atto>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}a"{}}; \}}
\DoxyCodeLine{15172 std::string ratio\_string<std::femto>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}f"{}}; \}}
\DoxyCodeLine{15173 std::string ratio\_string<std::pico>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}p"{}}; \}}
\DoxyCodeLine{15174 std::string ratio\_string<std::nano>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}n"{}}; \}}
\DoxyCodeLine{15175 std::string ratio\_string<std::micro>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}u"{}}; \}}
\DoxyCodeLine{15176 std::string ratio\_string<std::milli>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}m"{}}; \}}
\DoxyCodeLine{15177 }
\DoxyCodeLine{15178 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{15179 }
\DoxyCodeLine{15180 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{15181 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{15182 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15183 }
\DoxyCodeLine{15184 \textcolor{comment}{// end catch\_tostring.cpp}}
\DoxyCodeLine{15185 \textcolor{comment}{// start catch\_totals.cpp}}
\DoxyCodeLine{15186 }
\DoxyCodeLine{15187 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15188 }
\DoxyCodeLine{15189     Counts Counts::operator -\/ ( Counts \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15190         Counts diff;}
\DoxyCodeLine{15191         diff.passed = passed -\/ other.passed;}
\DoxyCodeLine{15192         diff.failed = failed -\/ other.failed;}
\DoxyCodeLine{15193         diff.failedButOk = failedButOk -\/ other.failedButOk;}
\DoxyCodeLine{15194         \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{15195     \}}
\DoxyCodeLine{15196 }
\DoxyCodeLine{15197     Counts\& Counts::operator += ( Counts \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{15198         passed += other.passed;}
\DoxyCodeLine{15199         failed += other.failed;}
\DoxyCodeLine{15200         failedButOk += other.failedButOk;}
\DoxyCodeLine{15201         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15202     \}}
\DoxyCodeLine{15203 }
\DoxyCodeLine{15204     std::size\_t Counts::total()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15205         \textcolor{keywordflow}{return} passed + failed + failedButOk;}
\DoxyCodeLine{15206     \}}
\DoxyCodeLine{15207     \textcolor{keywordtype}{bool} Counts::allPassed()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15208         \textcolor{keywordflow}{return} failed == 0 \&\& failedButOk == 0;}
\DoxyCodeLine{15209     \}}
\DoxyCodeLine{15210     \textcolor{keywordtype}{bool} Counts::allOk()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15211         \textcolor{keywordflow}{return} failed == 0;}
\DoxyCodeLine{15212     \}}
\DoxyCodeLine{15213 }
\DoxyCodeLine{15214     Totals Totals::operator -\/ ( Totals \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15215         Totals diff;}
\DoxyCodeLine{15216         diff.assertions = assertions -\/ other.assertions;}
\DoxyCodeLine{15217         diff.testCases = testCases -\/ other.testCases;}
\DoxyCodeLine{15218         \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{15219     \}}
\DoxyCodeLine{15220 }
\DoxyCodeLine{15221     Totals\& Totals::operator += ( Totals \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{15222         assertions += other.assertions;}
\DoxyCodeLine{15223         testCases += other.testCases;}
\DoxyCodeLine{15224         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15225     \}}
\DoxyCodeLine{15226 }
\DoxyCodeLine{15227     Totals Totals::delta( Totals \textcolor{keyword}{const}\& prevTotals )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15228         Totals diff = *\textcolor{keyword}{this} -\/ prevTotals;}
\DoxyCodeLine{15229         \textcolor{keywordflow}{if}( diff.assertions.failed > 0 )}
\DoxyCodeLine{15230             ++diff.testCases.failed;}
\DoxyCodeLine{15231         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( diff.assertions.failedButOk > 0 )}
\DoxyCodeLine{15232             ++diff.testCases.failedButOk;}
\DoxyCodeLine{15233         \textcolor{keywordflow}{else}}
\DoxyCodeLine{15234             ++diff.testCases.passed;}
\DoxyCodeLine{15235         \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{15236     \}}
\DoxyCodeLine{15237 }
\DoxyCodeLine{15238 \}}
\DoxyCodeLine{15239 \textcolor{comment}{// end catch\_totals.cpp}}
\DoxyCodeLine{15240 \textcolor{comment}{// start catch\_uncaught\_exceptions.cpp}}
\DoxyCodeLine{15241 }
\DoxyCodeLine{15242 \textcolor{comment}{// start catch\_config\_uncaught\_exceptions.hpp}}
\DoxyCodeLine{15243 }
\DoxyCodeLine{15244 \textcolor{comment}{//              Copyright Catch2 Authors}}
\DoxyCodeLine{15245 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0.}}
\DoxyCodeLine{15246 \textcolor{comment}{//   (See accompanying file LICENSE\_1\_0.txt or copy at}}
\DoxyCodeLine{15247 \textcolor{comment}{//        https://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{15248 }
\DoxyCodeLine{15249 \textcolor{comment}{// SPDX-\/License-\/Identifier: BSL-\/1.0}}
\DoxyCodeLine{15250 }
\DoxyCodeLine{15251 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_UNCAUGHT\_EXCEPTIONS\_HPP}}
\DoxyCodeLine{15252 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_UNCAUGHT\_EXCEPTIONS\_HPP}}
\DoxyCodeLine{15253 }
\DoxyCodeLine{15254 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{15255 \textcolor{preprocessor}{\#  if \_MSC\_VER >= 1900 }\textcolor{comment}{// Visual Studio 2015 or newer}}
\DoxyCodeLine{15256 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS}}
\DoxyCodeLine{15257 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{15258 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15259 }
\DoxyCodeLine{15260 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{15261 }
\DoxyCodeLine{15262 \textcolor{preprocessor}{\#if defined(\_\_cpp\_lib\_uncaught\_exceptions) \(\backslash\)}}
\DoxyCodeLine{15263 \textcolor{preprocessor}{    \&\& !defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS)}}
\DoxyCodeLine{15264 }
\DoxyCodeLine{15265 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS}}
\DoxyCodeLine{15266 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_cpp\_lib\_uncaught\_exceptions}}
\DoxyCodeLine{15267 }
\DoxyCodeLine{15268 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS) \(\backslash\)}}
\DoxyCodeLine{15269 \textcolor{preprocessor}{    \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_UNCAUGHT\_EXCEPTIONS) \(\backslash\)}}
\DoxyCodeLine{15270 \textcolor{preprocessor}{    \&\& !defined(CATCH\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS)}}
\DoxyCodeLine{15271 }
\DoxyCodeLine{15272 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS}}
\DoxyCodeLine{15273 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15274 }
\DoxyCodeLine{15275 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_UNCAUGHT\_EXCEPTIONS\_HPP}}
\DoxyCodeLine{15276 \textcolor{comment}{// end catch\_config\_uncaught\_exceptions.hpp}}
\DoxyCodeLine{15277 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{15278 }
\DoxyCodeLine{15279 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15280     \textcolor{keywordtype}{bool} uncaught\_exceptions() \{}
\DoxyCodeLine{15281 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{15282         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{15283 \textcolor{preprocessor}{\#elif defined(CATCH\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS)}}
\DoxyCodeLine{15284         \textcolor{keywordflow}{return} std::uncaught\_exceptions() > 0;}
\DoxyCodeLine{15285 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{15286         \textcolor{keywordflow}{return} std::uncaught\_exception();}
\DoxyCodeLine{15287 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15288   \}}
\DoxyCodeLine{15289 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{15290 \textcolor{comment}{// end catch\_uncaught\_exceptions.cpp}}
\DoxyCodeLine{15291 \textcolor{comment}{// start catch\_version.cpp}}
\DoxyCodeLine{15292 }
\DoxyCodeLine{15293 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{15294 }
\DoxyCodeLine{15295 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15296 }
\DoxyCodeLine{15297     Version::Version}
\DoxyCodeLine{15298         (   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_majorVersion,}
\DoxyCodeLine{15299             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_minorVersion,}
\DoxyCodeLine{15300             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_patchNumber,}
\DoxyCodeLine{15301             \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} \_branchName,}
\DoxyCodeLine{15302             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_buildNumber )}
\DoxyCodeLine{15303     :   majorVersion( \_majorVersion ),}
\DoxyCodeLine{15304         minorVersion( \_minorVersion ),}
\DoxyCodeLine{15305         patchNumber( \_patchNumber ),}
\DoxyCodeLine{15306         branchName( \_branchName ),}
\DoxyCodeLine{15307         buildNumber( \_buildNumber )}
\DoxyCodeLine{15308     \{\}}
\DoxyCodeLine{15309 }
\DoxyCodeLine{15310     std::ostream\& operator << ( std::ostream\& os, Version \textcolor{keyword}{const}\& version ) \{}
\DoxyCodeLine{15311         os  << version.majorVersion << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{15312             << version.minorVersion << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{15313             << version.patchNumber;}
\DoxyCodeLine{15314         \textcolor{comment}{// branchName is never null -\/> 0th char is \(\backslash\)0 if it is empty}}
\DoxyCodeLine{15315         \textcolor{keywordflow}{if} (version.branchName[0]) \{}
\DoxyCodeLine{15316             os << \textcolor{charliteral}{'-\/'} << version.branchName}
\DoxyCodeLine{15317                << \textcolor{charliteral}{'.'} << version.buildNumber;}
\DoxyCodeLine{15318         \}}
\DoxyCodeLine{15319         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{15320     \}}
\DoxyCodeLine{15321 }
\DoxyCodeLine{15322     Version \textcolor{keyword}{const}\& libraryVersion() \{}
\DoxyCodeLine{15323         \textcolor{keyword}{static} Version version( 2, 13, 4, \textcolor{stringliteral}{"{}"{}}, 0 );}
\DoxyCodeLine{15324         \textcolor{keywordflow}{return} version;}
\DoxyCodeLine{15325     \}}
\DoxyCodeLine{15326 }
\DoxyCodeLine{15327 \}}
\DoxyCodeLine{15328 \textcolor{comment}{// end catch\_version.cpp}}
\DoxyCodeLine{15329 \textcolor{comment}{// start catch\_wildcard\_pattern.cpp}}
\DoxyCodeLine{15330 }
\DoxyCodeLine{15331 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15332 }
\DoxyCodeLine{15333     WildcardPattern::WildcardPattern( std::string \textcolor{keyword}{const}\& pattern,}
\DoxyCodeLine{15334                                       CaseSensitive::Choice caseSensitivity )}
\DoxyCodeLine{15335     :   m\_caseSensitivity( caseSensitivity ),}
\DoxyCodeLine{15336         m\_pattern( normaliseString( pattern ) )}
\DoxyCodeLine{15337     \{}
\DoxyCodeLine{15338         \textcolor{keywordflow}{if}( startsWith( m\_pattern, \textcolor{charliteral}{'*'} ) ) \{}
\DoxyCodeLine{15339             m\_pattern = m\_pattern.substr( 1 );}
\DoxyCodeLine{15340             m\_wildcard = WildcardAtStart;}
\DoxyCodeLine{15341         \}}
\DoxyCodeLine{15342         \textcolor{keywordflow}{if}( endsWith( m\_pattern, \textcolor{charliteral}{'*'} ) ) \{}
\DoxyCodeLine{15343             m\_pattern = m\_pattern.substr( 0, m\_pattern.size()-\/1 );}
\DoxyCodeLine{15344             m\_wildcard = \textcolor{keyword}{static\_cast<}WildcardPosition\textcolor{keyword}{>}( m\_wildcard | WildcardAtEnd );}
\DoxyCodeLine{15345         \}}
\DoxyCodeLine{15346     \}}
\DoxyCodeLine{15347 }
\DoxyCodeLine{15348     \textcolor{keywordtype}{bool} WildcardPattern::matches( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15349         \textcolor{keywordflow}{switch}( m\_wildcard ) \{}
\DoxyCodeLine{15350             \textcolor{keywordflow}{case} NoWildcard:}
\DoxyCodeLine{15351                 \textcolor{keywordflow}{return} m\_pattern == normaliseString( str );}
\DoxyCodeLine{15352             \textcolor{keywordflow}{case} WildcardAtStart:}
\DoxyCodeLine{15353                 \textcolor{keywordflow}{return} endsWith( normaliseString( str ), m\_pattern );}
\DoxyCodeLine{15354             \textcolor{keywordflow}{case} WildcardAtEnd:}
\DoxyCodeLine{15355                 \textcolor{keywordflow}{return} startsWith( normaliseString( str ), m\_pattern );}
\DoxyCodeLine{15356             \textcolor{keywordflow}{case} WildcardAtBothEnds:}
\DoxyCodeLine{15357                 \textcolor{keywordflow}{return} contains( normaliseString( str ), m\_pattern );}
\DoxyCodeLine{15358             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{15359                 CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Unknown enum"{}} );}
\DoxyCodeLine{15360         \}}
\DoxyCodeLine{15361     \}}
\DoxyCodeLine{15362 }
\DoxyCodeLine{15363     std::string WildcardPattern::normaliseString( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15364         \textcolor{keywordflow}{return} trim( m\_caseSensitivity == CaseSensitive::No ? toLower( str ) : str );}
\DoxyCodeLine{15365     \}}
\DoxyCodeLine{15366 \}}
\DoxyCodeLine{15367 \textcolor{comment}{// end catch\_wildcard\_pattern.cpp}}
\DoxyCodeLine{15368 \textcolor{comment}{// start catch\_xmlwriter.cpp}}
\DoxyCodeLine{15369 }
\DoxyCodeLine{15370 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{15371 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{15372 }
\DoxyCodeLine{15373 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15374 }
\DoxyCodeLine{15375 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{15376 }
\DoxyCodeLine{15377     \textcolor{keywordtype}{size\_t} trailingBytes(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15378         \textcolor{keywordflow}{if} ((c \& 0xE0) == 0xC0) \{}
\DoxyCodeLine{15379             \textcolor{keywordflow}{return} 2;}
\DoxyCodeLine{15380         \}}
\DoxyCodeLine{15381         \textcolor{keywordflow}{if} ((c \& 0xF0) == 0xE0) \{}
\DoxyCodeLine{15382             \textcolor{keywordflow}{return} 3;}
\DoxyCodeLine{15383         \}}
\DoxyCodeLine{15384         \textcolor{keywordflow}{if} ((c \& 0xF8) == 0xF0) \{}
\DoxyCodeLine{15385             \textcolor{keywordflow}{return} 4;}
\DoxyCodeLine{15386         \}}
\DoxyCodeLine{15387         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Invalid multibyte utf-\/8 start byte encountered"{}});}
\DoxyCodeLine{15388     \}}
\DoxyCodeLine{15389 }
\DoxyCodeLine{15390     uint32\_t headerValue(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15391         \textcolor{keywordflow}{if} ((c \& 0xE0) == 0xC0) \{}
\DoxyCodeLine{15392             \textcolor{keywordflow}{return} c \& 0x1F;}
\DoxyCodeLine{15393         \}}
\DoxyCodeLine{15394         \textcolor{keywordflow}{if} ((c \& 0xF0) == 0xE0) \{}
\DoxyCodeLine{15395             \textcolor{keywordflow}{return} c \& 0x0F;}
\DoxyCodeLine{15396         \}}
\DoxyCodeLine{15397         \textcolor{keywordflow}{if} ((c \& 0xF8) == 0xF0) \{}
\DoxyCodeLine{15398             \textcolor{keywordflow}{return} c \& 0x07;}
\DoxyCodeLine{15399         \}}
\DoxyCodeLine{15400         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Invalid multibyte utf-\/8 start byte encountered"{}});}
\DoxyCodeLine{15401     \}}
\DoxyCodeLine{15402 }
\DoxyCodeLine{15403     \textcolor{keywordtype}{void} hexEscapeChar(std::ostream\& os, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15404         std::ios\_base::fmtflags f(os.flags());}
\DoxyCodeLine{15405         os << \textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)x"{}}}
\DoxyCodeLine{15406             << std::uppercase << std::hex << std::setfill(\textcolor{charliteral}{'0'}) << std::setw(2)}
\DoxyCodeLine{15407             << \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(c);}
\DoxyCodeLine{15408         os.flags(f);}
\DoxyCodeLine{15409     \}}
\DoxyCodeLine{15410 }
\DoxyCodeLine{15411     \textcolor{keywordtype}{bool} shouldNewline(XmlFormatting fmt) \{}
\DoxyCodeLine{15412         \textcolor{keywordflow}{return} !!(\textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(fmt \& XmlFormatting::Newline));}
\DoxyCodeLine{15413     \}}
\DoxyCodeLine{15414 }
\DoxyCodeLine{15415     \textcolor{keywordtype}{bool} shouldIndent(XmlFormatting fmt) \{}
\DoxyCodeLine{15416         \textcolor{keywordflow}{return} !!(\textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(fmt \& XmlFormatting::Indent));}
\DoxyCodeLine{15417     \}}
\DoxyCodeLine{15418 }
\DoxyCodeLine{15419 \} \textcolor{comment}{// anonymous namespace}}
\DoxyCodeLine{15420 }
\DoxyCodeLine{15421     XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs) \{}
\DoxyCodeLine{15422         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}XmlFormatting\textcolor{keyword}{>}(}
\DoxyCodeLine{15423             \textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(lhs) |}
\DoxyCodeLine{15424             \textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(rhs)}
\DoxyCodeLine{15425         );}
\DoxyCodeLine{15426     \}}
\DoxyCodeLine{15427 }
\DoxyCodeLine{15428     XmlFormatting operator \& (XmlFormatting lhs, XmlFormatting rhs) \{}
\DoxyCodeLine{15429         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}XmlFormatting\textcolor{keyword}{>}(}
\DoxyCodeLine{15430             \textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(lhs) \&}
\DoxyCodeLine{15431             \textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(rhs)}
\DoxyCodeLine{15432         );}
\DoxyCodeLine{15433     \}}
\DoxyCodeLine{15434 }
\DoxyCodeLine{15435     XmlEncode::XmlEncode( std::string \textcolor{keyword}{const}\& str, ForWhat forWhat )}
\DoxyCodeLine{15436     :   m\_str( str ),}
\DoxyCodeLine{15437         m\_forWhat( forWhat )}
\DoxyCodeLine{15438     \{\}}
\DoxyCodeLine{15439 }
\DoxyCodeLine{15440     \textcolor{keywordtype}{void} XmlEncode::encodeTo( std::ostream\& os )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15441         \textcolor{comment}{// Apostrophe escaping not necessary if we always use "{} to write attributes}}
\DoxyCodeLine{15442         \textcolor{comment}{// (see: http://www.w3.org/TR/xml/\#syntax)}}
\DoxyCodeLine{15443 }
\DoxyCodeLine{15444         \textcolor{keywordflow}{for}( std::size\_t idx = 0; idx < m\_str.size(); ++ idx ) \{}
\DoxyCodeLine{15445             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c = m\_str[idx];}
\DoxyCodeLine{15446             \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{15447             \textcolor{keywordflow}{case} \textcolor{charliteral}{'<'}:   os << \textcolor{stringliteral}{"{}\&lt;"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{15448             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\&'}:   os << \textcolor{stringliteral}{"{}\&amp;"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{15449 }
\DoxyCodeLine{15450             \textcolor{keywordflow}{case} \textcolor{charliteral}{'>'}:}
\DoxyCodeLine{15451                 \textcolor{comment}{// See: http://www.w3.org/TR/xml/\#syntax}}
\DoxyCodeLine{15452                 \textcolor{keywordflow}{if} (idx > 2 \&\& m\_str[idx -\/ 1] == \textcolor{charliteral}{']'} \&\& m\_str[idx -\/ 2] == \textcolor{charliteral}{']'})}
\DoxyCodeLine{15453                     os << \textcolor{stringliteral}{"{}\&gt;"{}};}
\DoxyCodeLine{15454                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{15455                     os << c;}
\DoxyCodeLine{15456                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15457 }
\DoxyCodeLine{15458             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)"{}'}:}
\DoxyCodeLine{15459                 \textcolor{keywordflow}{if} (m\_forWhat == ForAttributes)}
\DoxyCodeLine{15460                     os << \textcolor{stringliteral}{"{}\&quot;"{}};}
\DoxyCodeLine{15461                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{15462                     os << c;}
\DoxyCodeLine{15463                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15464 }
\DoxyCodeLine{15465             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{15466                 \textcolor{comment}{// Check for control characters and invalid utf-\/8}}
\DoxyCodeLine{15467 }
\DoxyCodeLine{15468                 \textcolor{comment}{// Escape control characters in standard ascii}}
\DoxyCodeLine{15469                 \textcolor{comment}{// see http://stackoverflow.com/questions/404107/why-\/are-\/control-\/characters-\/illegal-\/in-\/xml-\/1-\/0}}
\DoxyCodeLine{15470                 \textcolor{keywordflow}{if} (c < 0x09 || (c > 0x0D \&\& c < 0x20) || c == 0x7F) \{}
\DoxyCodeLine{15471                     hexEscapeChar(os, c);}
\DoxyCodeLine{15472                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15473                 \}}
\DoxyCodeLine{15474 }
\DoxyCodeLine{15475                 \textcolor{comment}{// Plain ASCII: Write it to stream}}
\DoxyCodeLine{15476                 \textcolor{keywordflow}{if} (c < 0x7F) \{}
\DoxyCodeLine{15477                     os << c;}
\DoxyCodeLine{15478                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15479                 \}}
\DoxyCodeLine{15480 }
\DoxyCodeLine{15481                 \textcolor{comment}{// UTF-\/8 territory}}
\DoxyCodeLine{15482                 \textcolor{comment}{// Check if the encoding is valid and if it is not, hex escape bytes.}}
\DoxyCodeLine{15483                 \textcolor{comment}{// Important: We do not check the exact decoded values for validity, only the encoding format}}
\DoxyCodeLine{15484                 \textcolor{comment}{// First check that this bytes is a valid lead byte:}}
\DoxyCodeLine{15485                 \textcolor{comment}{// This means that it is not encoded as 1111 1XXX}}
\DoxyCodeLine{15486                 \textcolor{comment}{// Or as 10XX XXXX}}
\DoxyCodeLine{15487                 \textcolor{keywordflow}{if} (c <  0xC0 ||}
\DoxyCodeLine{15488                     c >= 0xF8) \{}
\DoxyCodeLine{15489                     hexEscapeChar(os, c);}
\DoxyCodeLine{15490                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15491                 \}}
\DoxyCodeLine{15492 }
\DoxyCodeLine{15493                 \textcolor{keyword}{auto} encBytes = trailingBytes(c);}
\DoxyCodeLine{15494                 \textcolor{comment}{// Are there enough bytes left to avoid accessing out-\/of-\/bounds memory?}}
\DoxyCodeLine{15495                 \textcolor{keywordflow}{if} (idx + encBytes -\/ 1 >= m\_str.size()) \{}
\DoxyCodeLine{15496                     hexEscapeChar(os, c);}
\DoxyCodeLine{15497                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15498                 \}}
\DoxyCodeLine{15499                 \textcolor{comment}{// The header is valid, check data}}
\DoxyCodeLine{15500                 \textcolor{comment}{// The next encBytes bytes must together be a valid utf-\/8}}
\DoxyCodeLine{15501                 \textcolor{comment}{// This means: bitpattern 10XX XXXX and the extracted value is sane (ish)}}
\DoxyCodeLine{15502                 \textcolor{keywordtype}{bool} valid = \textcolor{keyword}{true};}
\DoxyCodeLine{15503                 uint32\_t value = headerValue(c);}
\DoxyCodeLine{15504                 \textcolor{keywordflow}{for} (std::size\_t n = 1; n < encBytes; ++n) \{}
\DoxyCodeLine{15505                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} nc = m\_str[idx + n];}
\DoxyCodeLine{15506                     valid \&= ((nc \& 0xC0) == 0x80);}
\DoxyCodeLine{15507                     value = (value << 6) | (nc \& 0x3F);}
\DoxyCodeLine{15508                 \}}
\DoxyCodeLine{15509 }
\DoxyCodeLine{15510                 \textcolor{keywordflow}{if} (}
\DoxyCodeLine{15511                     \textcolor{comment}{// Wrong bit pattern of following bytes}}
\DoxyCodeLine{15512                     (!valid) ||}
\DoxyCodeLine{15513                     \textcolor{comment}{// Overlong encodings}}
\DoxyCodeLine{15514                     (value < 0x80) ||}
\DoxyCodeLine{15515                     (0x80 <= value \&\& value < 0x800   \&\& encBytes > 2) ||}
\DoxyCodeLine{15516                     (0x800 < value \&\& value < 0x10000 \&\& encBytes > 3) ||}
\DoxyCodeLine{15517                     \textcolor{comment}{// Encoded value out of range}}
\DoxyCodeLine{15518                     (value >= 0x110000)}
\DoxyCodeLine{15519                     ) \{}
\DoxyCodeLine{15520                     hexEscapeChar(os, c);}
\DoxyCodeLine{15521                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15522                 \}}
\DoxyCodeLine{15523 }
\DoxyCodeLine{15524                 \textcolor{comment}{// If we got here, this is in fact a valid(ish) utf-\/8 sequence}}
\DoxyCodeLine{15525                 \textcolor{keywordflow}{for} (std::size\_t n = 0; n < encBytes; ++n) \{}
\DoxyCodeLine{15526                     os << m\_str[idx + n];}
\DoxyCodeLine{15527                 \}}
\DoxyCodeLine{15528                 idx += encBytes -\/ 1;}
\DoxyCodeLine{15529                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15530             \}}
\DoxyCodeLine{15531         \}}
\DoxyCodeLine{15532     \}}
\DoxyCodeLine{15533 }
\DoxyCodeLine{15534     std::ostream\& operator << ( std::ostream\& os, XmlEncode \textcolor{keyword}{const}\& xmlEncode ) \{}
\DoxyCodeLine{15535         xmlEncode.encodeTo( os );}
\DoxyCodeLine{15536         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{15537     \}}
\DoxyCodeLine{15538 }
\DoxyCodeLine{15539     XmlWriter::ScopedElement::ScopedElement( XmlWriter* \mbox{\hyperlink{classbasic__writer}{writer}}, XmlFormatting fmt )}
\DoxyCodeLine{15540     :   m\_writer( \mbox{\hyperlink{classbasic__writer}{writer}} ),}
\DoxyCodeLine{15541         m\_fmt(fmt)}
\DoxyCodeLine{15542     \{\}}
\DoxyCodeLine{15543 }
\DoxyCodeLine{15544     XmlWriter::ScopedElement::ScopedElement( ScopedElement\&\& other ) noexcept}
\DoxyCodeLine{15545     :   m\_writer( other.m\_writer ),}
\DoxyCodeLine{15546         m\_fmt(other.m\_fmt)}
\DoxyCodeLine{15547     \{}
\DoxyCodeLine{15548         other.m\_writer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{15549         other.m\_fmt = XmlFormatting::None;}
\DoxyCodeLine{15550     \}}
\DoxyCodeLine{15551     XmlWriter::ScopedElement\& XmlWriter::ScopedElement::operator=( ScopedElement\&\& other ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{15552         \textcolor{keywordflow}{if} ( m\_writer ) \{}
\DoxyCodeLine{15553             m\_writer-\/>endElement();}
\DoxyCodeLine{15554         \}}
\DoxyCodeLine{15555         m\_writer = other.m\_writer;}
\DoxyCodeLine{15556         other.m\_writer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{15557         m\_fmt = other.m\_fmt;}
\DoxyCodeLine{15558         other.m\_fmt = XmlFormatting::None;}
\DoxyCodeLine{15559         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15560     \}}
\DoxyCodeLine{15561 }
\DoxyCodeLine{15562     XmlWriter::ScopedElement::\string~ScopedElement() \{}
\DoxyCodeLine{15563         \textcolor{keywordflow}{if} (m\_writer) \{}
\DoxyCodeLine{15564             m\_writer-\/>endElement(m\_fmt);}
\DoxyCodeLine{15565         \}}
\DoxyCodeLine{15566     \}}
\DoxyCodeLine{15567 }
\DoxyCodeLine{15568     XmlWriter::ScopedElement\& XmlWriter::ScopedElement::writeText( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt ) \{}
\DoxyCodeLine{15569         m\_writer-\/>writeText( text, fmt );}
\DoxyCodeLine{15570         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15571     \}}
\DoxyCodeLine{15572 }
\DoxyCodeLine{15573     XmlWriter::XmlWriter( std::ostream\& os ) : m\_os( os )}
\DoxyCodeLine{15574     \{}
\DoxyCodeLine{15575         writeDeclaration();}
\DoxyCodeLine{15576     \}}
\DoxyCodeLine{15577 }
\DoxyCodeLine{15578     XmlWriter::\string~XmlWriter() \{}
\DoxyCodeLine{15579         \textcolor{keywordflow}{while} (!m\_tags.empty()) \{}
\DoxyCodeLine{15580             endElement();}
\DoxyCodeLine{15581         \}}
\DoxyCodeLine{15582         newlineIfNecessary();}
\DoxyCodeLine{15583     \}}
\DoxyCodeLine{15584 }
\DoxyCodeLine{15585     XmlWriter\& XmlWriter::startElement( std::string \textcolor{keyword}{const}\& name, XmlFormatting fmt ) \{}
\DoxyCodeLine{15586         ensureTagClosed();}
\DoxyCodeLine{15587         newlineIfNecessary();}
\DoxyCodeLine{15588         \textcolor{keywordflow}{if} (shouldIndent(fmt)) \{}
\DoxyCodeLine{15589             m\_os << m\_indent;}
\DoxyCodeLine{15590             m\_indent += "{}  "{};}
\DoxyCodeLine{15591         \}}
\DoxyCodeLine{15592         m\_os << \textcolor{charliteral}{'<'} << name;}
\DoxyCodeLine{15593         m\_tags.push\_back( name );}
\DoxyCodeLine{15594         m\_tagIsOpen = \textcolor{keyword}{true};}
\DoxyCodeLine{15595         applyFormatting(fmt);}
\DoxyCodeLine{15596         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15597     \}}
\DoxyCodeLine{15598 }
\DoxyCodeLine{15599     XmlWriter::ScopedElement XmlWriter::scopedElement( std::string \textcolor{keyword}{const}\& name, XmlFormatting fmt ) \{}
\DoxyCodeLine{15600         ScopedElement scoped( \textcolor{keyword}{this}, fmt );}
\DoxyCodeLine{15601         startElement( name, fmt );}
\DoxyCodeLine{15602         \textcolor{keywordflow}{return} scoped;}
\DoxyCodeLine{15603     \}}
\DoxyCodeLine{15604 }
\DoxyCodeLine{15605     XmlWriter\& XmlWriter::endElement(XmlFormatting fmt) \{}
\DoxyCodeLine{15606         m\_indent = m\_indent.substr(0, m\_indent.size() -\/ 2);}
\DoxyCodeLine{15607 }
\DoxyCodeLine{15608         \textcolor{keywordflow}{if}( m\_tagIsOpen ) \{}
\DoxyCodeLine{15609             m\_os << \textcolor{stringliteral}{"{}/>"{}};}
\DoxyCodeLine{15610             m\_tagIsOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{15611         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15612             newlineIfNecessary();}
\DoxyCodeLine{15613             \textcolor{keywordflow}{if} (shouldIndent(fmt)) \{}
\DoxyCodeLine{15614                 m\_os << m\_indent;}
\DoxyCodeLine{15615             \}}
\DoxyCodeLine{15616             m\_os << \textcolor{stringliteral}{"{}</"{}} << m\_tags.back() << \textcolor{stringliteral}{"{}>"{}};}
\DoxyCodeLine{15617         \}}
\DoxyCodeLine{15618         m\_os << std::flush;}
\DoxyCodeLine{15619         applyFormatting(fmt);}
\DoxyCodeLine{15620         m\_tags.pop\_back();}
\DoxyCodeLine{15621         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15622     \}}
\DoxyCodeLine{15623 }
\DoxyCodeLine{15624     XmlWriter\& XmlWriter::writeAttribute( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{15625         \textcolor{keywordflow}{if}( !name.empty() \&\& !attribute.empty() )}
\DoxyCodeLine{15626             m\_os << \textcolor{charliteral}{' '} << name << \textcolor{stringliteral}{"{}=\(\backslash\)"{}"{}} << XmlEncode( attribute, XmlEncode::ForAttributes ) << \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{15627         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15628     \}}
\DoxyCodeLine{15629 }
\DoxyCodeLine{15630     XmlWriter\& XmlWriter::writeAttribute( std::string \textcolor{keyword}{const}\& name, \textcolor{keywordtype}{bool} attribute ) \{}
\DoxyCodeLine{15631         m\_os << \textcolor{charliteral}{' '} << name << \textcolor{stringliteral}{"{}=\(\backslash\)"{}"{}} << ( attribute ? \textcolor{stringliteral}{"{}true"{}} : \textcolor{stringliteral}{"{}false"{}} ) << \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{15632         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15633     \}}
\DoxyCodeLine{15634 }
\DoxyCodeLine{15635     XmlWriter\& XmlWriter::writeText( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt) \{}
\DoxyCodeLine{15636         \textcolor{keywordflow}{if}( !text.empty() )\{}
\DoxyCodeLine{15637             \textcolor{keywordtype}{bool} tagWasOpen = m\_tagIsOpen;}
\DoxyCodeLine{15638             ensureTagClosed();}
\DoxyCodeLine{15639             \textcolor{keywordflow}{if} (tagWasOpen \&\& shouldIndent(fmt)) \{}
\DoxyCodeLine{15640                 m\_os << m\_indent;}
\DoxyCodeLine{15641             \}}
\DoxyCodeLine{15642             m\_os << XmlEncode( text );}
\DoxyCodeLine{15643             applyFormatting(fmt);}
\DoxyCodeLine{15644         \}}
\DoxyCodeLine{15645         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15646     \}}
\DoxyCodeLine{15647 }
\DoxyCodeLine{15648     XmlWriter\& XmlWriter::writeComment( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt) \{}
\DoxyCodeLine{15649         ensureTagClosed();}
\DoxyCodeLine{15650         \textcolor{keywordflow}{if} (shouldIndent(fmt)) \{}
\DoxyCodeLine{15651             m\_os << m\_indent;}
\DoxyCodeLine{15652         \}}
\DoxyCodeLine{15653         m\_os << \textcolor{stringliteral}{"{}<!-\/-\/"{}} << text << \textcolor{stringliteral}{"{}-\/-\/>"{}};}
\DoxyCodeLine{15654         applyFormatting(fmt);}
\DoxyCodeLine{15655         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15656     \}}
\DoxyCodeLine{15657 }
\DoxyCodeLine{15658     \textcolor{keywordtype}{void} XmlWriter::writeStylesheetRef( std::string \textcolor{keyword}{const}\& url ) \{}
\DoxyCodeLine{15659         m\_os << \textcolor{stringliteral}{"{}<?xml-\/stylesheet type=\(\backslash\)"{}text/xsl\(\backslash\)"{} href=\(\backslash\)"{}"{}} << url << \textcolor{stringliteral}{"{}\(\backslash\)"{}?>\(\backslash\)n"{}};}
\DoxyCodeLine{15660     \}}
\DoxyCodeLine{15661 }
\DoxyCodeLine{15662     XmlWriter\& XmlWriter::writeBlankLine() \{}
\DoxyCodeLine{15663         ensureTagClosed();}
\DoxyCodeLine{15664         m\_os << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{15665         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15666     \}}
\DoxyCodeLine{15667 }
\DoxyCodeLine{15668     \textcolor{keywordtype}{void} XmlWriter::ensureTagClosed() \{}
\DoxyCodeLine{15669         \textcolor{keywordflow}{if}( m\_tagIsOpen ) \{}
\DoxyCodeLine{15670             m\_os << '>\textcolor{stringliteral}{' << std::flush;}}
\DoxyCodeLine{15671 \textcolor{stringliteral}{            newlineIfNecessary();}}
\DoxyCodeLine{15672 \textcolor{stringliteral}{            m\_tagIsOpen = false;}}
\DoxyCodeLine{15673 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15674 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15675 \textcolor{stringliteral}{}}
\DoxyCodeLine{15676 \textcolor{stringliteral}{    void XmlWriter::applyFormatting(XmlFormatting fmt) \{}}
\DoxyCodeLine{15677 \textcolor{stringliteral}{        m\_needsNewline = shouldNewline(fmt);}}
\DoxyCodeLine{15678 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15679 \textcolor{stringliteral}{}}
\DoxyCodeLine{15680 \textcolor{stringliteral}{    void XmlWriter::writeDeclaration() \{}}
\DoxyCodeLine{15681 \textcolor{stringliteral}{        m\_os << "{}<?xml version=\(\backslash\)"{}1.0\(\backslash\)"{} encoding=\(\backslash\)"{}UTF-\/8\(\backslash\)"{}?>\(\backslash\)n"{};}}
\DoxyCodeLine{15682 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15683 \textcolor{stringliteral}{}}
\DoxyCodeLine{15684 \textcolor{stringliteral}{    void XmlWriter::newlineIfNecessary() \{}}
\DoxyCodeLine{15685 \textcolor{stringliteral}{        if( m\_needsNewline ) \{}}
\DoxyCodeLine{15686 \textcolor{stringliteral}{            m\_os << std::endl;}}
\DoxyCodeLine{15687 \textcolor{stringliteral}{            m\_needsNewline = false;}}
\DoxyCodeLine{15688 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15689 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15690 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{15691 \textcolor{stringliteral}{// end catch\_xmlwriter.cpp}}
\DoxyCodeLine{15692 \textcolor{stringliteral}{// start catch\_reporter\_bases.cpp}}
\DoxyCodeLine{15693 \textcolor{stringliteral}{}}
\DoxyCodeLine{15694 \textcolor{stringliteral}{\#include <cstring>}}
\DoxyCodeLine{15695 \textcolor{stringliteral}{\#include <cfloat>}}
\DoxyCodeLine{15696 \textcolor{stringliteral}{\#include <cstdio>}}
\DoxyCodeLine{15697 \textcolor{stringliteral}{\#include <cassert>}}
\DoxyCodeLine{15698 \textcolor{stringliteral}{\#include <memory>}}
\DoxyCodeLine{15699 \textcolor{stringliteral}{}}
\DoxyCodeLine{15700 \textcolor{stringliteral}{namespace Catch \{}}
\DoxyCodeLine{15701 \textcolor{stringliteral}{    void prepareExpandedExpression(AssertionResult\& result) \{}}
\DoxyCodeLine{15702 \textcolor{stringliteral}{        result.getExpandedExpression();}}
\DoxyCodeLine{15703 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15704 \textcolor{stringliteral}{}}
\DoxyCodeLine{15705 \textcolor{stringliteral}{    // Because formatting using c++ streams is stateful, drop down to C is required}}
\DoxyCodeLine{15706 \textcolor{stringliteral}{    // Alternatively we could use stringstream, but its performance is... not good.}}
\DoxyCodeLine{15707 \textcolor{stringliteral}{    std::string getFormattedDuration( double duration ) \{}}
\DoxyCodeLine{15708 \textcolor{stringliteral}{        // Max exponent + 1 is required to represent the whole part}}
\DoxyCodeLine{15709 \textcolor{stringliteral}{        // + 1 for decimal point}}
\DoxyCodeLine{15710 \textcolor{stringliteral}{        // + 3 for the 3 decimal places}}
\DoxyCodeLine{15711 \textcolor{stringliteral}{        // + 1 for null terminator}}
\DoxyCodeLine{15712 \textcolor{stringliteral}{        const std::size\_t maxDoubleSize = DBL\_MAX\_10\_EXP + 1 + 1 + 3 + 1;}}
\DoxyCodeLine{15713 \textcolor{stringliteral}{        char buffer[maxDoubleSize];}}
\DoxyCodeLine{15714 \textcolor{stringliteral}{}}
\DoxyCodeLine{15715 \textcolor{stringliteral}{        // Save previous errno, to prevent sprintf from overwriting it}}
\DoxyCodeLine{15716 \textcolor{stringliteral}{        ErrnoGuard guard;}}
\DoxyCodeLine{15717 \textcolor{stringliteral}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{15718 \textcolor{stringliteral}{        sprintf\_s(buffer, "{}\%.3f"{}, duration);}}
\DoxyCodeLine{15719 \textcolor{stringliteral}{\#else}}
\DoxyCodeLine{15720 \textcolor{stringliteral}{        std::sprintf(buffer, "{}\%.3f"{}, duration);}}
\DoxyCodeLine{15721 \textcolor{stringliteral}{\#endif}}
\DoxyCodeLine{15722 \textcolor{stringliteral}{        return std::string(buffer);}}
\DoxyCodeLine{15723 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15724 \textcolor{stringliteral}{}}
\DoxyCodeLine{15725 \textcolor{stringliteral}{    bool shouldShowDuration( IConfig const\& config, double duration ) \{}}
\DoxyCodeLine{15726 \textcolor{stringliteral}{        if ( config.showDurations() == ShowDurations::Always ) \{}}
\DoxyCodeLine{15727 \textcolor{stringliteral}{            return true;}}
\DoxyCodeLine{15728 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15729 \textcolor{stringliteral}{        if ( config.showDurations() == ShowDurations::Never ) \{}}
\DoxyCodeLine{15730 \textcolor{stringliteral}{            return false;}}
\DoxyCodeLine{15731 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15732 \textcolor{stringliteral}{        const double min = config.minDuration();}}
\DoxyCodeLine{15733 \textcolor{stringliteral}{        return min >= 0 \&\& duration >= min;}}
\DoxyCodeLine{15734 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15735 \textcolor{stringliteral}{}}
\DoxyCodeLine{15736 \textcolor{stringliteral}{    std::string serializeFilters( std::vector<std::string> const\& container ) \{}}
\DoxyCodeLine{15737 \textcolor{stringliteral}{        ReusableStringStream oss;}}
\DoxyCodeLine{15738 \textcolor{stringliteral}{        bool first = true;}}
\DoxyCodeLine{15739 \textcolor{stringliteral}{        for (auto\&\& filter : container)}}
\DoxyCodeLine{15740 \textcolor{stringliteral}{        \{}}
\DoxyCodeLine{15741 \textcolor{stringliteral}{            if (!first)}}
\DoxyCodeLine{15742 \textcolor{stringliteral}{                oss << '} \textcolor{stringliteral}{';}}
\DoxyCodeLine{15743 \textcolor{stringliteral}{            else}}
\DoxyCodeLine{15744 \textcolor{stringliteral}{                first = false;}}
\DoxyCodeLine{15745 \textcolor{stringliteral}{}}
\DoxyCodeLine{15746 \textcolor{stringliteral}{            oss << filter;}}
\DoxyCodeLine{15747 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15748 \textcolor{stringliteral}{        return oss.str();}}
\DoxyCodeLine{15749 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15750 \textcolor{stringliteral}{}}
\DoxyCodeLine{15751 \textcolor{stringliteral}{    TestEventListenerBase::TestEventListenerBase(ReporterConfig const \& \_config)}}
\DoxyCodeLine{15752 \textcolor{stringliteral}{        :StreamingReporterBase(\_config) \{\}}}
\DoxyCodeLine{15753 \textcolor{stringliteral}{}}
\DoxyCodeLine{15754 \textcolor{stringliteral}{    std::set<Verbosity> TestEventListenerBase::getSupportedVerbosities() \{}}
\DoxyCodeLine{15755 \textcolor{stringliteral}{        return \{ Verbosity::Quiet, Verbosity::Normal, Verbosity::High \};}}
\DoxyCodeLine{15756 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15757 \textcolor{stringliteral}{}}
\DoxyCodeLine{15758 \textcolor{stringliteral}{    void TestEventListenerBase::assertionStarting(AssertionInfo const \&) \{\}}}
\DoxyCodeLine{15759 \textcolor{stringliteral}{}}
\DoxyCodeLine{15760 \textcolor{stringliteral}{    bool TestEventListenerBase::assertionEnded(AssertionStats const \&) \{}}
\DoxyCodeLine{15761 \textcolor{stringliteral}{        return false;}}
\DoxyCodeLine{15762 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15763 \textcolor{stringliteral}{}}
\DoxyCodeLine{15764 \textcolor{stringliteral}{\} // end namespace Catch}}
\DoxyCodeLine{15765 \textcolor{stringliteral}{// end catch\_reporter\_bases.cpp}}
\DoxyCodeLine{15766 \textcolor{stringliteral}{// start catch\_reporter\_compact.cpp}}
\DoxyCodeLine{15767 \textcolor{stringliteral}{}}
\DoxyCodeLine{15768 \textcolor{stringliteral}{namespace \{}}
\DoxyCodeLine{15769 \textcolor{stringliteral}{}}
\DoxyCodeLine{15770 \textcolor{stringliteral}{\#ifdef CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{15771 \textcolor{stringliteral}{    const char* failedString() \{ return "{}FAILED"{}; \}}}
\DoxyCodeLine{15772 \textcolor{stringliteral}{    const char* passedString() \{ return "{}PASSED"{}; \}}}
\DoxyCodeLine{15773 \textcolor{stringliteral}{\#else}}
\DoxyCodeLine{15774 \textcolor{stringliteral}{    const char* failedString() \{ return "{}failed"{}; \}}}
\DoxyCodeLine{15775 \textcolor{stringliteral}{    const char* passedString() \{ return "{}passed"{}; \}}}
\DoxyCodeLine{15776 \textcolor{stringliteral}{\#endif}}
\DoxyCodeLine{15777 \textcolor{stringliteral}{}}
\DoxyCodeLine{15778 \textcolor{stringliteral}{    // Colour::LightGrey}}
\DoxyCodeLine{15779 \textcolor{stringliteral}{    Catch::Colour::Code dimColour() \{ return Catch::Colour::FileName; \}}}
\DoxyCodeLine{15780 \textcolor{stringliteral}{}}
\DoxyCodeLine{15781 \textcolor{stringliteral}{    std::string bothOrAll( std::size\_t count ) \{}}
\DoxyCodeLine{15782 \textcolor{stringliteral}{        return count == 1 ? std::string() :}}
\DoxyCodeLine{15783 \textcolor{stringliteral}{               count == 2 ? "{}both "{} : "{}all "{} ;}}
\DoxyCodeLine{15784 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15785 \textcolor{stringliteral}{}}
\DoxyCodeLine{15786 \textcolor{stringliteral}{\} // anon namespace}}
\DoxyCodeLine{15787 \textcolor{stringliteral}{}}
\DoxyCodeLine{15788 \textcolor{stringliteral}{namespace Catch \{}}
\DoxyCodeLine{15789 \textcolor{stringliteral}{namespace \{}}
\DoxyCodeLine{15790 \textcolor{stringliteral}{// Colour, message variants:}}
\DoxyCodeLine{15791 \textcolor{stringliteral}{// -\/ white: No tests ran.}}
\DoxyCodeLine{15792 \textcolor{stringliteral}{// -\/   red: Failed [both/all] N test cases, failed [both/all] M assertions.}}
\DoxyCodeLine{15793 \textcolor{stringliteral}{// -\/ white: Passed [both/all] N test cases (no assertions).}}
\DoxyCodeLine{15794 \textcolor{stringliteral}{// -\/   red: Failed N tests cases, failed M assertions.}}
\DoxyCodeLine{15795 \textcolor{stringliteral}{// -\/ green: Passed [both/all] N tests cases with M assertions.}}
\DoxyCodeLine{15796 \textcolor{stringliteral}{void printTotals(std::ostream\& out, const Totals\& totals) \{}}
\DoxyCodeLine{15797 \textcolor{stringliteral}{    if (totals.testCases.total() == 0) \{}}
\DoxyCodeLine{15798 \textcolor{stringliteral}{        out << "{}No tests ran."{};}}
\DoxyCodeLine{15799 \textcolor{stringliteral}{    \} else if (totals.testCases.failed == totals.testCases.total()) \{}}
\DoxyCodeLine{15800 \textcolor{stringliteral}{        Colour colour(Colour::ResultError);}}
\DoxyCodeLine{15801 \textcolor{stringliteral}{        const std::string qualify\_assertions\_failed =}}
\DoxyCodeLine{15802 \textcolor{stringliteral}{            totals.assertions.failed == totals.assertions.total() ?}}
\DoxyCodeLine{15803 \textcolor{stringliteral}{            bothOrAll(totals.assertions.failed) : std::string();}}
\DoxyCodeLine{15804 \textcolor{stringliteral}{        out <<}}
\DoxyCodeLine{15805 \textcolor{stringliteral}{            "{}Failed "{} << bothOrAll(totals.testCases.failed)}}
\DoxyCodeLine{15806 \textcolor{stringliteral}{            << pluralise(totals.testCases.failed, "{}test case"{}) << "{}, "{}}}
\DoxyCodeLine{15807 \textcolor{stringliteral}{            "{}failed "{} << qualify\_assertions\_failed <<}}
\DoxyCodeLine{15808 \textcolor{stringliteral}{            pluralise(totals.assertions.failed, "{}assertion"{}) << '}.\textcolor{stringliteral}{';}}
\DoxyCodeLine{15809 \textcolor{stringliteral}{    \} else if (totals.assertions.total() == 0) \{}}
\DoxyCodeLine{15810 \textcolor{stringliteral}{        out <<}}
\DoxyCodeLine{15811 \textcolor{stringliteral}{            "{}Passed "{} << bothOrAll(totals.testCases.total())}}
\DoxyCodeLine{15812 \textcolor{stringliteral}{            << pluralise(totals.testCases.total(), "{}test case"{})}}
\DoxyCodeLine{15813 \textcolor{stringliteral}{            << "{} (no assertions)."{};}}
\DoxyCodeLine{15814 \textcolor{stringliteral}{    \} else if (totals.assertions.failed) \{}}
\DoxyCodeLine{15815 \textcolor{stringliteral}{        Colour colour(Colour::ResultError);}}
\DoxyCodeLine{15816 \textcolor{stringliteral}{        out <<}}
\DoxyCodeLine{15817 \textcolor{stringliteral}{            "{}Failed "{} << pluralise(totals.testCases.failed, "{}test case"{}) << "{}, "{}}}
\DoxyCodeLine{15818 \textcolor{stringliteral}{            "{}failed "{} << pluralise(totals.assertions.failed, "{}assertion"{}) << '}.\textcolor{stringliteral}{';}}
\DoxyCodeLine{15819 \textcolor{stringliteral}{    \} else \{}}
\DoxyCodeLine{15820 \textcolor{stringliteral}{        Colour colour(Colour::ResultSuccess);}}
\DoxyCodeLine{15821 \textcolor{stringliteral}{        out <<}}
\DoxyCodeLine{15822 \textcolor{stringliteral}{            "{}Passed "{} << bothOrAll(totals.testCases.passed)}}
\DoxyCodeLine{15823 \textcolor{stringliteral}{            << pluralise(totals.testCases.passed, "{}test case"{}) <<}}
\DoxyCodeLine{15824 \textcolor{stringliteral}{            "{} with "{} << pluralise(totals.assertions.passed, "{}assertion"{}) << '}.\textcolor{stringliteral}{';}}
\DoxyCodeLine{15825 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15826 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{15827 \textcolor{stringliteral}{}}
\DoxyCodeLine{15828 \textcolor{stringliteral}{// Implementation of CompactReporter formatting}}
\DoxyCodeLine{15829 \textcolor{stringliteral}{class AssertionPrinter \{}}
\DoxyCodeLine{15830 \textcolor{stringliteral}{public:}}
\DoxyCodeLine{15831 \textcolor{stringliteral}{    AssertionPrinter\& operator= (AssertionPrinter const\&) = delete;}}
\DoxyCodeLine{15832 \textcolor{stringliteral}{    AssertionPrinter(AssertionPrinter const\&) = delete;}}
\DoxyCodeLine{15833 \textcolor{stringliteral}{    AssertionPrinter(std::ostream\& \_stream, AssertionStats const\& \_stats, bool \_printInfoMessages)}}
\DoxyCodeLine{15834 \textcolor{stringliteral}{        : stream(\_stream)}}
\DoxyCodeLine{15835 \textcolor{stringliteral}{        , result(\_stats.assertionResult)}}
\DoxyCodeLine{15836 \textcolor{stringliteral}{        , messages(\_stats.infoMessages)}}
\DoxyCodeLine{15837 \textcolor{stringliteral}{        , itMessage(\_stats.infoMessages.begin())}}
\DoxyCodeLine{15838 \textcolor{stringliteral}{        , printInfoMessages(\_printInfoMessages) \{\}}}
\DoxyCodeLine{15839 \textcolor{stringliteral}{}}
\DoxyCodeLine{15840 \textcolor{stringliteral}{    void print() \{}}
\DoxyCodeLine{15841 \textcolor{stringliteral}{        printSourceInfo();}}
\DoxyCodeLine{15842 \textcolor{stringliteral}{}}
\DoxyCodeLine{15843 \textcolor{stringliteral}{        itMessage = messages.begin();}}
\DoxyCodeLine{15844 \textcolor{stringliteral}{}}
\DoxyCodeLine{15845 \textcolor{stringliteral}{        switch (result.getResultType()) \{}}
\DoxyCodeLine{15846 \textcolor{stringliteral}{        case ResultWas::Ok:}}
\DoxyCodeLine{15847 \textcolor{stringliteral}{            printResultType(Colour::ResultSuccess, passedString());}}
\DoxyCodeLine{15848 \textcolor{stringliteral}{            printOriginalExpression();}}
\DoxyCodeLine{15849 \textcolor{stringliteral}{            printReconstructedExpression();}}
\DoxyCodeLine{15850 \textcolor{stringliteral}{            if (!result.hasExpression())}}
\DoxyCodeLine{15851 \textcolor{stringliteral}{                printRemainingMessages(Colour::None);}}
\DoxyCodeLine{15852 \textcolor{stringliteral}{            else}}
\DoxyCodeLine{15853 \textcolor{stringliteral}{                printRemainingMessages();}}
\DoxyCodeLine{15854 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15855 \textcolor{stringliteral}{        case ResultWas::ExpressionFailed:}}
\DoxyCodeLine{15856 \textcolor{stringliteral}{            if (result.isOk())}}
\DoxyCodeLine{15857 \textcolor{stringliteral}{                printResultType(Colour::ResultSuccess, failedString() + std::string("{} -\/ but was ok"{}));}}
\DoxyCodeLine{15858 \textcolor{stringliteral}{            else}}
\DoxyCodeLine{15859 \textcolor{stringliteral}{                printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15860 \textcolor{stringliteral}{            printOriginalExpression();}}
\DoxyCodeLine{15861 \textcolor{stringliteral}{            printReconstructedExpression();}}
\DoxyCodeLine{15862 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15863 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15864 \textcolor{stringliteral}{        case ResultWas::ThrewException:}}
\DoxyCodeLine{15865 \textcolor{stringliteral}{            printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15866 \textcolor{stringliteral}{            printIssue("{}unexpected exception with message:"{});}}
\DoxyCodeLine{15867 \textcolor{stringliteral}{            printMessage();}}
\DoxyCodeLine{15868 \textcolor{stringliteral}{            printExpressionWas();}}
\DoxyCodeLine{15869 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15870 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15871 \textcolor{stringliteral}{        case ResultWas::FatalErrorCondition:}}
\DoxyCodeLine{15872 \textcolor{stringliteral}{            printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15873 \textcolor{stringliteral}{            printIssue("{}fatal error condition with message:"{});}}
\DoxyCodeLine{15874 \textcolor{stringliteral}{            printMessage();}}
\DoxyCodeLine{15875 \textcolor{stringliteral}{            printExpressionWas();}}
\DoxyCodeLine{15876 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15877 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15878 \textcolor{stringliteral}{        case ResultWas::DidntThrowException:}}
\DoxyCodeLine{15879 \textcolor{stringliteral}{            printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15880 \textcolor{stringliteral}{            printIssue("{}expected exception, got none"{});}}
\DoxyCodeLine{15881 \textcolor{stringliteral}{            printExpressionWas();}}
\DoxyCodeLine{15882 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15883 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15884 \textcolor{stringliteral}{        case ResultWas::Info:}}
\DoxyCodeLine{15885 \textcolor{stringliteral}{            printResultType(Colour::None, "{}info"{});}}
\DoxyCodeLine{15886 \textcolor{stringliteral}{            printMessage();}}
\DoxyCodeLine{15887 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15888 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15889 \textcolor{stringliteral}{        case ResultWas::Warning:}}
\DoxyCodeLine{15890 \textcolor{stringliteral}{            printResultType(Colour::None, "{}warning"{});}}
\DoxyCodeLine{15891 \textcolor{stringliteral}{            printMessage();}}
\DoxyCodeLine{15892 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15893 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15894 \textcolor{stringliteral}{        case ResultWas::ExplicitFailure:}}
\DoxyCodeLine{15895 \textcolor{stringliteral}{            printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15896 \textcolor{stringliteral}{            printIssue("{}explicitly"{});}}
\DoxyCodeLine{15897 \textcolor{stringliteral}{            printRemainingMessages(Colour::None);}}
\DoxyCodeLine{15898 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15899 \textcolor{stringliteral}{            // These cases are here to prevent compiler warnings}}
\DoxyCodeLine{15900 \textcolor{stringliteral}{        case ResultWas::Unknown:}}
\DoxyCodeLine{15901 \textcolor{stringliteral}{        case ResultWas::FailureBit:}}
\DoxyCodeLine{15902 \textcolor{stringliteral}{        case ResultWas::Exception:}}
\DoxyCodeLine{15903 \textcolor{stringliteral}{            printResultType(Colour::Error, "{}** internal error **"{});}}
\DoxyCodeLine{15904 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15905 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15906 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15907 \textcolor{stringliteral}{}}
\DoxyCodeLine{15908 \textcolor{stringliteral}{private:}}
\DoxyCodeLine{15909 \textcolor{stringliteral}{    void printSourceInfo() const \{}}
\DoxyCodeLine{15910 \textcolor{stringliteral}{        Colour colourGuard(Colour::FileName);}}
\DoxyCodeLine{15911 \textcolor{stringliteral}{        stream << result.getSourceInfo() << '}:\textcolor{stringliteral}{';}}
\DoxyCodeLine{15912 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15913 \textcolor{stringliteral}{}}
\DoxyCodeLine{15914 \textcolor{stringliteral}{    void printResultType(Colour::Code colour, std::string const\& passOrFail) const \{}}
\DoxyCodeLine{15915 \textcolor{stringliteral}{        if (!passOrFail.empty()) \{}}
\DoxyCodeLine{15916 \textcolor{stringliteral}{            \{}}
\DoxyCodeLine{15917 \textcolor{stringliteral}{                Colour colourGuard(colour);}}
\DoxyCodeLine{15918 \textcolor{stringliteral}{                stream << '} \textcolor{stringliteral}{' << passOrFail;}}
\DoxyCodeLine{15919 \textcolor{stringliteral}{            \}}}
\DoxyCodeLine{15920 \textcolor{stringliteral}{            stream << '}:\textcolor{stringliteral}{';}}
\DoxyCodeLine{15921 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15922 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15923 \textcolor{stringliteral}{}}
\DoxyCodeLine{15924 \textcolor{stringliteral}{    void printIssue(std::string const\& issue) const \{}}
\DoxyCodeLine{15925 \textcolor{stringliteral}{        stream << '} \textcolor{stringliteral}{' << issue;}}
\DoxyCodeLine{15926 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15927 \textcolor{stringliteral}{}}
\DoxyCodeLine{15928 \textcolor{stringliteral}{    void printExpressionWas() \{}}
\DoxyCodeLine{15929 \textcolor{stringliteral}{        if (result.hasExpression()) \{}}
\DoxyCodeLine{15930 \textcolor{stringliteral}{            stream << '};\textcolor{stringliteral}{';}}
\DoxyCodeLine{15931 \textcolor{stringliteral}{            \{}}
\DoxyCodeLine{15932 \textcolor{stringliteral}{                Colour colour(dimColour());}}
\DoxyCodeLine{15933 \textcolor{stringliteral}{                stream << "{} expression was:"{};}}
\DoxyCodeLine{15934 \textcolor{stringliteral}{            \}}}
\DoxyCodeLine{15935 \textcolor{stringliteral}{            printOriginalExpression();}}
\DoxyCodeLine{15936 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15937 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15938 \textcolor{stringliteral}{}}
\DoxyCodeLine{15939 \textcolor{stringliteral}{    void printOriginalExpression() const \{}}
\DoxyCodeLine{15940 \textcolor{stringliteral}{        if (result.hasExpression()) \{}}
\DoxyCodeLine{15941 \textcolor{stringliteral}{            stream << '} \textcolor{stringliteral}{' << result.getExpression();}}
\DoxyCodeLine{15942 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15943 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15944 \textcolor{stringliteral}{}}
\DoxyCodeLine{15945 \textcolor{stringliteral}{    void printReconstructedExpression() const \{}}
\DoxyCodeLine{15946 \textcolor{stringliteral}{        if (result.hasExpandedExpression()) \{}}
\DoxyCodeLine{15947 \textcolor{stringliteral}{            \{}}
\DoxyCodeLine{15948 \textcolor{stringliteral}{                Colour colour(dimColour());}}
\DoxyCodeLine{15949 \textcolor{stringliteral}{                stream << "{} for: "{};}}
\DoxyCodeLine{15950 \textcolor{stringliteral}{            \}}}
\DoxyCodeLine{15951 \textcolor{stringliteral}{            stream << result.getExpandedExpression();}}
\DoxyCodeLine{15952 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15953 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15954 \textcolor{stringliteral}{}}
\DoxyCodeLine{15955 \textcolor{stringliteral}{    void printMessage() \{}}
\DoxyCodeLine{15956 \textcolor{stringliteral}{        if (itMessage != messages.end()) \{}}
\DoxyCodeLine{15957 \textcolor{stringliteral}{            stream << "{} '}\textcolor{stringliteral}{"{} << itMessage-\/>message << '\(\backslash\)'';}}
\DoxyCodeLine{15958 \textcolor{stringliteral}{            ++itMessage;}}
\DoxyCodeLine{15959 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15960 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15961 \textcolor{stringliteral}{}}
\DoxyCodeLine{15962 \textcolor{stringliteral}{    void printRemainingMessages(Colour::Code colour = dimColour()) \{}}
\DoxyCodeLine{15963 \textcolor{stringliteral}{        if (itMessage == messages.end())}}
\DoxyCodeLine{15964 \textcolor{stringliteral}{            return;}}
\DoxyCodeLine{15965 \textcolor{stringliteral}{}}
\DoxyCodeLine{15966 \textcolor{stringliteral}{        const auto itEnd = messages.cend();}}
\DoxyCodeLine{15967 \textcolor{stringliteral}{        const auto N = static\_cast<std::size\_t>(std::distance(itMessage, itEnd));}}
\DoxyCodeLine{15968 \textcolor{stringliteral}{}}
\DoxyCodeLine{15969 \textcolor{stringliteral}{        \{}}
\DoxyCodeLine{15970 \textcolor{stringliteral}{            Colour colourGuard(colour);}}
\DoxyCodeLine{15971 \textcolor{stringliteral}{            stream << "{}} with \textcolor{stringliteral}{"{} << pluralise(N, "{}}message\textcolor{stringliteral}{"{}) << ':';}}
\DoxyCodeLine{15972 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15973 \textcolor{stringliteral}{}}
\DoxyCodeLine{15974 \textcolor{stringliteral}{        while (itMessage != itEnd) \{}}
\DoxyCodeLine{15975 \textcolor{stringliteral}{            // If this assertion is a warning ignore any INFO messages}}
\DoxyCodeLine{15976 \textcolor{stringliteral}{            if (printInfoMessages || itMessage-\/>type != ResultWas::Info) \{}}
\DoxyCodeLine{15977 \textcolor{stringliteral}{                printMessage();}}
\DoxyCodeLine{15978 \textcolor{stringliteral}{                if (itMessage != itEnd) \{}}
\DoxyCodeLine{15979 \textcolor{stringliteral}{                    Colour colourGuard(dimColour());}}
\DoxyCodeLine{15980 \textcolor{stringliteral}{                    stream << "{}} and\textcolor{stringliteral}{"{};}}
\DoxyCodeLine{15981 \textcolor{stringliteral}{                \}}}
\DoxyCodeLine{15982 \textcolor{stringliteral}{                continue;}}
\DoxyCodeLine{15983 \textcolor{stringliteral}{            \}}}
\DoxyCodeLine{15984 \textcolor{stringliteral}{            ++itMessage;}}
\DoxyCodeLine{15985 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15986 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15987 \textcolor{stringliteral}{}}
\DoxyCodeLine{15988 \textcolor{stringliteral}{private:}}
\DoxyCodeLine{15989 \textcolor{stringliteral}{    std::ostream\& stream;}}
\DoxyCodeLine{15990 \textcolor{stringliteral}{    AssertionResult const\& result;}}
\DoxyCodeLine{15991 \textcolor{stringliteral}{    std::vector<MessageInfo> messages;}}
\DoxyCodeLine{15992 \textcolor{stringliteral}{    std::vector<MessageInfo>::const\_iterator itMessage;}}
\DoxyCodeLine{15993 \textcolor{stringliteral}{    bool printInfoMessages;}}
\DoxyCodeLine{15994 \textcolor{stringliteral}{\};}}
\DoxyCodeLine{15995 \textcolor{stringliteral}{}}
\DoxyCodeLine{15996 \textcolor{stringliteral}{\} // anon namespace}}
\DoxyCodeLine{15997 \textcolor{stringliteral}{}}
\DoxyCodeLine{15998 \textcolor{stringliteral}{        std::string CompactReporter::getDescription() \{}}
\DoxyCodeLine{15999 \textcolor{stringliteral}{            return "{}}Reports test results on a single line, suitable \textcolor{keywordflow}{for} IDEs\textcolor{stringliteral}{"{};}}
\DoxyCodeLine{16000 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{16001 \textcolor{stringliteral}{}}
\DoxyCodeLine{16002 \textcolor{stringliteral}{        void CompactReporter::noMatchingTestCases( std::string const\& spec ) \{}}
\DoxyCodeLine{16003 \textcolor{stringliteral}{            stream << "{}}No test cases matched \textcolor{stringliteral}{'"{} << spec << '}\(\backslash\)\textcolor{stringliteral}{''} << std::endl;}
\DoxyCodeLine{16004         \}}
\DoxyCodeLine{16005 }
\DoxyCodeLine{16006         \textcolor{keywordtype}{void} CompactReporter::assertionStarting( AssertionInfo \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{16007 }
\DoxyCodeLine{16008         \textcolor{keywordtype}{bool} CompactReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& \_assertionStats ) \{}
\DoxyCodeLine{16009             AssertionResult \textcolor{keyword}{const}\& result = \_assertionStats.assertionResult;}
\DoxyCodeLine{16010 }
\DoxyCodeLine{16011             \textcolor{keywordtype}{bool} printInfoMessages = \textcolor{keyword}{true};}
\DoxyCodeLine{16012 }
\DoxyCodeLine{16013             \textcolor{comment}{// Drop out if result was successful and we're not printing those}}
\DoxyCodeLine{16014             \textcolor{keywordflow}{if}( !m\_config-\/>includeSuccessfulResults() \&\& result.isOk() ) \{}
\DoxyCodeLine{16015                 \textcolor{keywordflow}{if}( result.getResultType() != ResultWas::Warning )}
\DoxyCodeLine{16016                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{16017                 printInfoMessages = \textcolor{keyword}{false};}
\DoxyCodeLine{16018             \}}
\DoxyCodeLine{16019 }
\DoxyCodeLine{16020             AssertionPrinter printer( stream, \_assertionStats, printInfoMessages );}
\DoxyCodeLine{16021             printer.print();}
\DoxyCodeLine{16022 }
\DoxyCodeLine{16023             stream << std::endl;}
\DoxyCodeLine{16024             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{16025         \}}
\DoxyCodeLine{16026 }
\DoxyCodeLine{16027         \textcolor{keywordtype}{void} CompactReporter::sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \{}
\DoxyCodeLine{16028             \textcolor{keywordtype}{double} dur = \_sectionStats.durationInSeconds;}
\DoxyCodeLine{16029             \textcolor{keywordflow}{if} ( shouldShowDuration( *m\_config, dur ) ) \{}
\DoxyCodeLine{16030                 stream << getFormattedDuration( dur ) << \textcolor{stringliteral}{"{} s: "{}} << \_sectionStats.sectionInfo.name << std::endl;}
\DoxyCodeLine{16031             \}}
\DoxyCodeLine{16032         \}}
\DoxyCodeLine{16033 }
\DoxyCodeLine{16034         \textcolor{keywordtype}{void} CompactReporter::testRunEnded( TestRunStats \textcolor{keyword}{const}\& \_testRunStats ) \{}
\DoxyCodeLine{16035             printTotals( stream, \_testRunStats.totals );}
\DoxyCodeLine{16036             stream << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{16037             StreamingReporterBase::testRunEnded( \_testRunStats );}
\DoxyCodeLine{16038         \}}
\DoxyCodeLine{16039 }
\DoxyCodeLine{16040         CompactReporter::\string~CompactReporter() \{\}}
\DoxyCodeLine{16041 }
\DoxyCodeLine{16042     CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"{}compact"{}}, CompactReporter )}
\DoxyCodeLine{16043 }
\DoxyCodeLine{16044 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{16045 \textcolor{comment}{// end catch\_reporter\_compact.cpp}}
\DoxyCodeLine{16046 \textcolor{comment}{// start catch\_reporter\_console.cpp}}
\DoxyCodeLine{16047 }
\DoxyCodeLine{16048 \textcolor{preprocessor}{\#include <cfloat>}}
\DoxyCodeLine{16049 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{16050 }
\DoxyCodeLine{16051 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{16052 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{16053 \textcolor{preprocessor}{\#pragma warning(disable:4061) }\textcolor{comment}{// Not all labels are EXPLICITLY handled in switch}}
\DoxyCodeLine{16054  \textcolor{comment}{// Note that 4062 (not all labels are handled and default is missing) is enabled}}
\DoxyCodeLine{16055 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16056 }
\DoxyCodeLine{16057 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{16058 \textcolor{preprocessor}{\#  pragma clang diagnostic push}}
\DoxyCodeLine{16059 \textcolor{comment}{// For simplicity, benchmarking-\/only helpers are always enabled}}
\DoxyCodeLine{16060 \textcolor{preprocessor}{\#  pragma clang diagnostic ignored "{}-\/Wunused-\/function"{}}}
\DoxyCodeLine{16061 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16062 }
\DoxyCodeLine{16063 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{16064 }
\DoxyCodeLine{16065 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{16066 }
\DoxyCodeLine{16067 \textcolor{comment}{// Formatter impl for ConsoleReporter}}
\DoxyCodeLine{16068 \textcolor{keyword}{class }ConsoleAssertionPrinter \{}
\DoxyCodeLine{16069 \textcolor{keyword}{public}:}
\DoxyCodeLine{16070     ConsoleAssertionPrinter\& operator= (ConsoleAssertionPrinter \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{16071     ConsoleAssertionPrinter(ConsoleAssertionPrinter \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{16072     ConsoleAssertionPrinter(std::ostream\& \_stream, AssertionStats \textcolor{keyword}{const}\& \_stats, \textcolor{keywordtype}{bool} \_printInfoMessages)}
\DoxyCodeLine{16073         : stream(\_stream),}
\DoxyCodeLine{16074         stats(\_stats),}
\DoxyCodeLine{16075         result(\_stats.assertionResult),}
\DoxyCodeLine{16076         colour(Colour::None),}
\DoxyCodeLine{16077         message(result.getMessage()),}
\DoxyCodeLine{16078         messages(\_stats.infoMessages),}
\DoxyCodeLine{16079         printInfoMessages(\_printInfoMessages) \{}
\DoxyCodeLine{16080         \textcolor{keywordflow}{switch} (result.getResultType()) \{}
\DoxyCodeLine{16081         \textcolor{keywordflow}{case} ResultWas::Ok:}
\DoxyCodeLine{16082             colour = Colour::Success;}
\DoxyCodeLine{16083             passOrFail = \textcolor{stringliteral}{"{}PASSED"{}};}
\DoxyCodeLine{16084             \textcolor{comment}{//if( result.hasMessage() )}}
\DoxyCodeLine{16085             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{16086                 messageLabel = \textcolor{stringliteral}{"{}with message"{}};}
\DoxyCodeLine{16087             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{16088                 messageLabel = \textcolor{stringliteral}{"{}with messages"{}};}
\DoxyCodeLine{16089             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16090         \textcolor{keywordflow}{case} ResultWas::ExpressionFailed:}
\DoxyCodeLine{16091             \textcolor{keywordflow}{if} (result.isOk()) \{}
\DoxyCodeLine{16092                 colour = Colour::Success;}
\DoxyCodeLine{16093                 passOrFail = \textcolor{stringliteral}{"{}FAILED -\/ but was ok"{}};}
\DoxyCodeLine{16094             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16095                 colour = Colour::Error;}
\DoxyCodeLine{16096                 passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16097             \}}
\DoxyCodeLine{16098             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{16099                 messageLabel = \textcolor{stringliteral}{"{}with message"{}};}
\DoxyCodeLine{16100             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{16101                 messageLabel = \textcolor{stringliteral}{"{}with messages"{}};}
\DoxyCodeLine{16102             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16103         \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{16104             colour = Colour::Error;}
\DoxyCodeLine{16105             passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16106             messageLabel = \textcolor{stringliteral}{"{}due to unexpected exception with "{}};}
\DoxyCodeLine{16107             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{16108                 messageLabel += "{}message"{};}
\DoxyCodeLine{16109             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{16110                 messageLabel += "{}messages"{};}
\DoxyCodeLine{16111             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16112         \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{16113             colour = Colour::Error;}
\DoxyCodeLine{16114             passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16115             messageLabel = \textcolor{stringliteral}{"{}due to a fatal error condition"{}};}
\DoxyCodeLine{16116             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16117         \textcolor{keywordflow}{case} ResultWas::DidntThrowException:}
\DoxyCodeLine{16118             colour = Colour::Error;}
\DoxyCodeLine{16119             passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16120             messageLabel = \textcolor{stringliteral}{"{}because no exception was thrown where one was expected"{}};}
\DoxyCodeLine{16121             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16122         \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{16123             messageLabel = \textcolor{stringliteral}{"{}info"{}};}
\DoxyCodeLine{16124             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16125         \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{16126             messageLabel = \textcolor{stringliteral}{"{}warning"{}};}
\DoxyCodeLine{16127             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16128         \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{16129             passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16130             colour = Colour::Error;}
\DoxyCodeLine{16131             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{16132                 messageLabel = \textcolor{stringliteral}{"{}explicitly with message"{}};}
\DoxyCodeLine{16133             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{16134                 messageLabel = \textcolor{stringliteral}{"{}explicitly with messages"{}};}
\DoxyCodeLine{16135             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16136             \textcolor{comment}{// These cases are here to prevent compiler warnings}}
\DoxyCodeLine{16137         \textcolor{keywordflow}{case} ResultWas::Unknown:}
\DoxyCodeLine{16138         \textcolor{keywordflow}{case} ResultWas::FailureBit:}
\DoxyCodeLine{16139         \textcolor{keywordflow}{case} ResultWas::Exception:}
\DoxyCodeLine{16140             passOrFail = \textcolor{stringliteral}{"{}** internal error **"{}};}
\DoxyCodeLine{16141             colour = Colour::Error;}
\DoxyCodeLine{16142             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16143         \}}
\DoxyCodeLine{16144     \}}
\DoxyCodeLine{16145 }
\DoxyCodeLine{16146     \textcolor{keywordtype}{void} print()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16147         printSourceInfo();}
\DoxyCodeLine{16148         \textcolor{keywordflow}{if} (stats.totals.assertions.total() > 0) \{}
\DoxyCodeLine{16149             printResultType();}
\DoxyCodeLine{16150             printOriginalExpression();}
\DoxyCodeLine{16151             printReconstructedExpression();}
\DoxyCodeLine{16152         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16153             stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16154         \}}
\DoxyCodeLine{16155         printMessage();}
\DoxyCodeLine{16156     \}}
\DoxyCodeLine{16157 }
\DoxyCodeLine{16158 \textcolor{keyword}{private}:}
\DoxyCodeLine{16159     \textcolor{keywordtype}{void} printResultType()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16160         \textcolor{keywordflow}{if} (!passOrFail.empty()) \{}
\DoxyCodeLine{16161             Colour colourGuard(colour);}
\DoxyCodeLine{16162             stream << passOrFail << \textcolor{stringliteral}{"{}:\(\backslash\)n"{}};}
\DoxyCodeLine{16163         \}}
\DoxyCodeLine{16164     \}}
\DoxyCodeLine{16165     \textcolor{keywordtype}{void} printOriginalExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16166         \textcolor{keywordflow}{if} (result.hasExpression()) \{}
\DoxyCodeLine{16167             Colour colourGuard(Colour::OriginalExpression);}
\DoxyCodeLine{16168             stream << \textcolor{stringliteral}{"{}  "{}};}
\DoxyCodeLine{16169             stream << result.getExpressionInMacro();}
\DoxyCodeLine{16170             stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16171         \}}
\DoxyCodeLine{16172     \}}
\DoxyCodeLine{16173     \textcolor{keywordtype}{void} printReconstructedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16174         \textcolor{keywordflow}{if} (result.hasExpandedExpression()) \{}
\DoxyCodeLine{16175             stream << \textcolor{stringliteral}{"{}with expansion:\(\backslash\)n"{}};}
\DoxyCodeLine{16176             Colour colourGuard(Colour::ReconstructedExpression);}
\DoxyCodeLine{16177             stream << Column(result.getExpandedExpression()).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16178         \}}
\DoxyCodeLine{16179     \}}
\DoxyCodeLine{16180     \textcolor{keywordtype}{void} printMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16181         \textcolor{keywordflow}{if} (!messageLabel.empty())}
\DoxyCodeLine{16182             stream << messageLabel << \textcolor{charliteral}{':'} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16183         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& msg : messages) \{}
\DoxyCodeLine{16184             \textcolor{comment}{// If this assertion is a warning ignore any INFO messages}}
\DoxyCodeLine{16185             \textcolor{keywordflow}{if} (printInfoMessages || msg.type != ResultWas::Info)}
\DoxyCodeLine{16186                 stream << Column(msg.message).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16187         \}}
\DoxyCodeLine{16188     \}}
\DoxyCodeLine{16189     \textcolor{keywordtype}{void} printSourceInfo()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16190         Colour colourGuard(Colour::FileName);}
\DoxyCodeLine{16191         stream << result.getSourceInfo() << \textcolor{stringliteral}{"{}: "{}};}
\DoxyCodeLine{16192     \}}
\DoxyCodeLine{16193 }
\DoxyCodeLine{16194     std::ostream\& stream;}
\DoxyCodeLine{16195     AssertionStats \textcolor{keyword}{const}\& stats;}
\DoxyCodeLine{16196     AssertionResult \textcolor{keyword}{const}\& result;}
\DoxyCodeLine{16197     Colour::Code colour;}
\DoxyCodeLine{16198     std::string passOrFail;}
\DoxyCodeLine{16199     std::string messageLabel;}
\DoxyCodeLine{16200     std::string message;}
\DoxyCodeLine{16201     std::vector<MessageInfo> messages;}
\DoxyCodeLine{16202     \textcolor{keywordtype}{bool} printInfoMessages;}
\DoxyCodeLine{16203 \};}
\DoxyCodeLine{16204 }
\DoxyCodeLine{16205 std::size\_t makeRatio(std::size\_t number, std::size\_t total) \{}
\DoxyCodeLine{16206     std::size\_t ratio = total > 0 ? CATCH\_CONFIG\_CONSOLE\_WIDTH * number / total : 0;}
\DoxyCodeLine{16207     \textcolor{keywordflow}{return} (ratio == 0 \&\& number > 0) ? 1 : ratio;}
\DoxyCodeLine{16208 \}}
\DoxyCodeLine{16209 }
\DoxyCodeLine{16210 std::size\_t\& findMax(std::size\_t\& i, std::size\_t\& j, std::size\_t\& k) \{}
\DoxyCodeLine{16211     \textcolor{keywordflow}{if} (i > j \&\& i > k)}
\DoxyCodeLine{16212         \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{16213     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j > k)}
\DoxyCodeLine{16214         \textcolor{keywordflow}{return} j;}
\DoxyCodeLine{16215     \textcolor{keywordflow}{else}}
\DoxyCodeLine{16216         \textcolor{keywordflow}{return} k;}
\DoxyCodeLine{16217 \}}
\DoxyCodeLine{16218 }
\DoxyCodeLine{16219 \textcolor{keyword}{struct }ColumnInfo \{}
\DoxyCodeLine{16220     \textcolor{keyword}{enum} Justification \{ Left, Right \};}
\DoxyCodeLine{16221     std::string name;}
\DoxyCodeLine{16222     \textcolor{keywordtype}{int} width;}
\DoxyCodeLine{16223     Justification justification;}
\DoxyCodeLine{16224 \};}
\DoxyCodeLine{16225 \textcolor{keyword}{struct }ColumnBreak \{\};}
\DoxyCodeLine{16226 \textcolor{keyword}{struct }RowBreak \{\};}
\DoxyCodeLine{16227 }
\DoxyCodeLine{16228 \textcolor{keyword}{class }Duration \{}
\DoxyCodeLine{16229     \textcolor{keyword}{enum class} Unit \{}
\DoxyCodeLine{16230         Auto,}
\DoxyCodeLine{16231         Nanoseconds,}
\DoxyCodeLine{16232         Microseconds,}
\DoxyCodeLine{16233         Milliseconds,}
\DoxyCodeLine{16234         Seconds,}
\DoxyCodeLine{16235         Minutes}
\DoxyCodeLine{16236     \};}
\DoxyCodeLine{16237     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInAMicrosecond = 1000;}
\DoxyCodeLine{16238     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInAMillisecond = 1000 * s\_nanosecondsInAMicrosecond;}
\DoxyCodeLine{16239     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInASecond = 1000 * s\_nanosecondsInAMillisecond;}
\DoxyCodeLine{16240     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInAMinute = 60 * s\_nanosecondsInASecond;}
\DoxyCodeLine{16241 }
\DoxyCodeLine{16242     \textcolor{keywordtype}{double} m\_inNanoseconds;}
\DoxyCodeLine{16243     Unit m\_units;}
\DoxyCodeLine{16244 }
\DoxyCodeLine{16245 \textcolor{keyword}{public}:}
\DoxyCodeLine{16246     \textcolor{keyword}{explicit} Duration(\textcolor{keywordtype}{double} inNanoseconds, Unit units = Unit::Auto)}
\DoxyCodeLine{16247         : m\_inNanoseconds(inNanoseconds),}
\DoxyCodeLine{16248         m\_units(units) \{}
\DoxyCodeLine{16249         \textcolor{keywordflow}{if} (m\_units == Unit::Auto) \{}
\DoxyCodeLine{16250             \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInAMicrosecond)}
\DoxyCodeLine{16251                 m\_units = Unit::Nanoseconds;}
\DoxyCodeLine{16252             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInAMillisecond)}
\DoxyCodeLine{16253                 m\_units = Unit::Microseconds;}
\DoxyCodeLine{16254             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInASecond)}
\DoxyCodeLine{16255                 m\_units = Unit::Milliseconds;}
\DoxyCodeLine{16256             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInAMinute)}
\DoxyCodeLine{16257                 m\_units = Unit::Seconds;}
\DoxyCodeLine{16258             \textcolor{keywordflow}{else}}
\DoxyCodeLine{16259                 m\_units = Unit::Minutes;}
\DoxyCodeLine{16260         \}}
\DoxyCodeLine{16261 }
\DoxyCodeLine{16262     \}}
\DoxyCodeLine{16263 }
\DoxyCodeLine{16264     \textcolor{keyword}{auto} value() const -\/> \textcolor{keywordtype}{double} \{}
\DoxyCodeLine{16265         \textcolor{keywordflow}{switch} (m\_units) \{}
\DoxyCodeLine{16266         \textcolor{keywordflow}{case} Unit::Microseconds:}
\DoxyCodeLine{16267             \textcolor{keywordflow}{return} m\_inNanoseconds / \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(s\_nanosecondsInAMicrosecond);}
\DoxyCodeLine{16268         \textcolor{keywordflow}{case} Unit::Milliseconds:}
\DoxyCodeLine{16269             \textcolor{keywordflow}{return} m\_inNanoseconds / \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(s\_nanosecondsInAMillisecond);}
\DoxyCodeLine{16270         \textcolor{keywordflow}{case} Unit::Seconds:}
\DoxyCodeLine{16271             \textcolor{keywordflow}{return} m\_inNanoseconds / \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(s\_nanosecondsInASecond);}
\DoxyCodeLine{16272         \textcolor{keywordflow}{case} Unit::Minutes:}
\DoxyCodeLine{16273             \textcolor{keywordflow}{return} m\_inNanoseconds / \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(s\_nanosecondsInAMinute);}
\DoxyCodeLine{16274         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{16275             \textcolor{keywordflow}{return} m\_inNanoseconds;}
\DoxyCodeLine{16276         \}}
\DoxyCodeLine{16277     \}}
\DoxyCodeLine{16278     \textcolor{keyword}{auto} unitsAsString() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{16279         \textcolor{keywordflow}{switch} (m\_units) \{}
\DoxyCodeLine{16280         \textcolor{keywordflow}{case} Unit::Nanoseconds:}
\DoxyCodeLine{16281             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ns"{}};}
\DoxyCodeLine{16282         \textcolor{keywordflow}{case} Unit::Microseconds:}
\DoxyCodeLine{16283             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}us"{}};}
\DoxyCodeLine{16284         \textcolor{keywordflow}{case} Unit::Milliseconds:}
\DoxyCodeLine{16285             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ms"{}};}
\DoxyCodeLine{16286         \textcolor{keywordflow}{case} Unit::Seconds:}
\DoxyCodeLine{16287             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}s"{}};}
\DoxyCodeLine{16288         \textcolor{keywordflow}{case} Unit::Minutes:}
\DoxyCodeLine{16289             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}m"{}};}
\DoxyCodeLine{16290         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{16291             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}** internal error **"{}};}
\DoxyCodeLine{16292         \}}
\DoxyCodeLine{16293 }
\DoxyCodeLine{16294     \}}
\DoxyCodeLine{16295     \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator << (std::ostream\& os, Duration \textcolor{keyword}{const}\& duration) -\/> std::ostream\& \{}
\DoxyCodeLine{16296         \textcolor{keywordflow}{return} os << duration.value() << \textcolor{charliteral}{' '} << duration.unitsAsString();}
\DoxyCodeLine{16297     \}}
\DoxyCodeLine{16298 \};}
\DoxyCodeLine{16299 \} \textcolor{comment}{// end anon namespace}}
\DoxyCodeLine{16300 }
\DoxyCodeLine{16301 \textcolor{keyword}{class }TablePrinter \{}
\DoxyCodeLine{16302     std::ostream\& m\_os;}
\DoxyCodeLine{16303     std::vector<ColumnInfo> m\_columnInfos;}
\DoxyCodeLine{16304     std::ostringstream m\_oss;}
\DoxyCodeLine{16305     \textcolor{keywordtype}{int} m\_currentColumn = -\/1;}
\DoxyCodeLine{16306     \textcolor{keywordtype}{bool} m\_isOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{16307 }
\DoxyCodeLine{16308 \textcolor{keyword}{public}:}
\DoxyCodeLine{16309     TablePrinter( std::ostream\& os, std::vector<ColumnInfo> columnInfos )}
\DoxyCodeLine{16310     :   m\_os( os ),}
\DoxyCodeLine{16311         m\_columnInfos( std::move( columnInfos ) ) \{\}}
\DoxyCodeLine{16312 }
\DoxyCodeLine{16313     \textcolor{keyword}{auto} columnInfos() const -\/> std::vector<ColumnInfo> const\& \{}
\DoxyCodeLine{16314         \textcolor{keywordflow}{return} m\_columnInfos;}
\DoxyCodeLine{16315     \}}
\DoxyCodeLine{16316 }
\DoxyCodeLine{16317     \textcolor{keywordtype}{void} open() \{}
\DoxyCodeLine{16318         \textcolor{keywordflow}{if} (!m\_isOpen) \{}
\DoxyCodeLine{16319             m\_isOpen = \textcolor{keyword}{true};}
\DoxyCodeLine{16320             *\textcolor{keyword}{this} << RowBreak();}
\DoxyCodeLine{16321 }
\DoxyCodeLine{16322             Columns headerCols;}
\DoxyCodeLine{16323             Spacer spacer(2);}
\DoxyCodeLine{16324             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& info : m\_columnInfos) \{}
\DoxyCodeLine{16325                 headerCols += Column(info.name).width(static\_cast<std::size\_t>(info.width -\/ 2));}
\DoxyCodeLine{16326                 headerCols += spacer;}
\DoxyCodeLine{16327             \}}
\DoxyCodeLine{16328             m\_os << headerCols << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16329 }
\DoxyCodeLine{16330             m\_os << Catch::getLineOfChars<\textcolor{charliteral}{'-\/'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16331         \}}
\DoxyCodeLine{16332     \}}
\DoxyCodeLine{16333     \textcolor{keywordtype}{void} close() \{}
\DoxyCodeLine{16334         \textcolor{keywordflow}{if} (m\_isOpen) \{}
\DoxyCodeLine{16335             *\textcolor{keyword}{this} << RowBreak();}
\DoxyCodeLine{16336             m\_os << std::endl;}
\DoxyCodeLine{16337             m\_isOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{16338         \}}
\DoxyCodeLine{16339     \}}
\DoxyCodeLine{16340 }
\DoxyCodeLine{16341     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{16342     \textcolor{keyword}{friend} TablePrinter\& operator << (TablePrinter\& tp, T \textcolor{keyword}{const}\& value) \{}
\DoxyCodeLine{16343         tp.m\_oss << value;}
\DoxyCodeLine{16344         \textcolor{keywordflow}{return} tp;}
\DoxyCodeLine{16345     \}}
\DoxyCodeLine{16346 }
\DoxyCodeLine{16347     \textcolor{keyword}{friend} TablePrinter\& operator << (TablePrinter\& tp, ColumnBreak) \{}
\DoxyCodeLine{16348         \textcolor{keyword}{auto} colStr = tp.m\_oss.str();}
\DoxyCodeLine{16349         \textcolor{keyword}{const} \textcolor{keyword}{auto} strSize = colStr.size();}
\DoxyCodeLine{16350         tp.m\_oss.str(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{16351         tp.open();}
\DoxyCodeLine{16352         \textcolor{keywordflow}{if} (tp.m\_currentColumn == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(tp.m\_columnInfos.size() -\/ 1)) \{}
\DoxyCodeLine{16353             tp.m\_currentColumn = -\/1;}
\DoxyCodeLine{16354             tp.m\_os << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16355         \}}
\DoxyCodeLine{16356         tp.m\_currentColumn++;}
\DoxyCodeLine{16357 }
\DoxyCodeLine{16358         \textcolor{keyword}{auto} colInfo = tp.m\_columnInfos[tp.m\_currentColumn];}
\DoxyCodeLine{16359         \textcolor{keyword}{auto} padding = (strSize + 1 < static\_cast<std::size\_t>(colInfo.width))}
\DoxyCodeLine{16360             ? std::string(colInfo.width -\/ (strSize + 1), ' ')}
\DoxyCodeLine{16361             : std::string();}
\DoxyCodeLine{16362         \textcolor{keywordflow}{if} (colInfo.justification == ColumnInfo::Left)}
\DoxyCodeLine{16363             tp.m\_os << colStr << padding << \textcolor{charliteral}{' '};}
\DoxyCodeLine{16364         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16365             tp.m\_os << padding << colStr << \textcolor{charliteral}{' '};}
\DoxyCodeLine{16366         \textcolor{keywordflow}{return} tp;}
\DoxyCodeLine{16367     \}}
\DoxyCodeLine{16368 }
\DoxyCodeLine{16369     \textcolor{keyword}{friend} TablePrinter\& operator << (TablePrinter\& tp, RowBreak) \{}
\DoxyCodeLine{16370         \textcolor{keywordflow}{if} (tp.m\_currentColumn > 0) \{}
\DoxyCodeLine{16371             tp.m\_os << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16372             tp.m\_currentColumn = -\/1;}
\DoxyCodeLine{16373         \}}
\DoxyCodeLine{16374         \textcolor{keywordflow}{return} tp;}
\DoxyCodeLine{16375     \}}
\DoxyCodeLine{16376 \};}
\DoxyCodeLine{16377 }
\DoxyCodeLine{16378 ConsoleReporter::ConsoleReporter(ReporterConfig \textcolor{keyword}{const}\& config)}
\DoxyCodeLine{16379     : StreamingReporterBase(config),}
\DoxyCodeLine{16380     m\_tablePrinter(new TablePrinter(config.stream(),}
\DoxyCodeLine{16381         [\&config]() -\/> std::vector<ColumnInfo> \{}
\DoxyCodeLine{16382         \textcolor{keywordflow}{if} (config.fullConfig()-\/>benchmarkNoAnalysis())}
\DoxyCodeLine{16383         \{}
\DoxyCodeLine{16384             \textcolor{keywordflow}{return}\{}
\DoxyCodeLine{16385                 \{ \textcolor{stringliteral}{"{}benchmark name"{}}, CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 43, ColumnInfo::Left \},}
\DoxyCodeLine{16386                 \{ \textcolor{stringliteral}{"{}     samples"{}}, 14, ColumnInfo::Right \},}
\DoxyCodeLine{16387                 \{ \textcolor{stringliteral}{"{}  iterations"{}}, 14, ColumnInfo::Right \},}
\DoxyCodeLine{16388                 \{ \textcolor{stringliteral}{"{}        mean"{}}, 14, ColumnInfo::Right \}}
\DoxyCodeLine{16389             \};}
\DoxyCodeLine{16390         \}}
\DoxyCodeLine{16391         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16392         \{}
\DoxyCodeLine{16393             \textcolor{keywordflow}{return}\{}
\DoxyCodeLine{16394                 \{ \textcolor{stringliteral}{"{}benchmark name"{}}, CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 43, ColumnInfo::Left \},}
\DoxyCodeLine{16395                 \{ \textcolor{stringliteral}{"{}samples      mean       std dev"{}}, 14, ColumnInfo::Right \},}
\DoxyCodeLine{16396                 \{ \textcolor{stringliteral}{"{}iterations   low mean   low std dev"{}}, 14, ColumnInfo::Right \},}
\DoxyCodeLine{16397                 \{ \textcolor{stringliteral}{"{}estimated    high mean  high std dev"{}}, 14, ColumnInfo::Right \}}
\DoxyCodeLine{16398             \};}
\DoxyCodeLine{16399         \}}
\DoxyCodeLine{16400     \}())) \{\}}
\DoxyCodeLine{16401 ConsoleReporter::\string~ConsoleReporter() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{16402 }
\DoxyCodeLine{16403 std::string ConsoleReporter::getDescription() \{}
\DoxyCodeLine{16404     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Reports test results as plain lines of text"{}};}
\DoxyCodeLine{16405 \}}
\DoxyCodeLine{16406 }
\DoxyCodeLine{16407 \textcolor{keywordtype}{void} ConsoleReporter::noMatchingTestCases(std::string \textcolor{keyword}{const}\& spec) \{}
\DoxyCodeLine{16408     stream << \textcolor{stringliteral}{"{}No test cases matched '"{}} << spec << \textcolor{charliteral}{'\(\backslash\)''} << std::endl;}
\DoxyCodeLine{16409 \}}
\DoxyCodeLine{16410 }
\DoxyCodeLine{16411 \textcolor{keywordtype}{void} ConsoleReporter::reportInvalidArguments(std::string \textcolor{keyword}{const}\&arg)\{}
\DoxyCodeLine{16412     stream << \textcolor{stringliteral}{"{}Invalid Filter: "{}} << arg << std::endl;}
\DoxyCodeLine{16413 \}}
\DoxyCodeLine{16414 }
\DoxyCodeLine{16415 \textcolor{keywordtype}{void} ConsoleReporter::assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \{\}}
\DoxyCodeLine{16416 }
\DoxyCodeLine{16417 \textcolor{keywordtype}{bool} ConsoleReporter::assertionEnded(AssertionStats \textcolor{keyword}{const}\& \_assertionStats) \{}
\DoxyCodeLine{16418     AssertionResult \textcolor{keyword}{const}\& result = \_assertionStats.assertionResult;}
\DoxyCodeLine{16419 }
\DoxyCodeLine{16420     \textcolor{keywordtype}{bool} includeResults = m\_config-\/>includeSuccessfulResults() || !result.isOk();}
\DoxyCodeLine{16421 }
\DoxyCodeLine{16422     \textcolor{comment}{// Drop out if result was successful but we're not printing them.}}
\DoxyCodeLine{16423     \textcolor{keywordflow}{if} (!includeResults \&\& result.getResultType() != ResultWas::Warning)}
\DoxyCodeLine{16424         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{16425 }
\DoxyCodeLine{16426     lazyPrint();}
\DoxyCodeLine{16427 }
\DoxyCodeLine{16428     ConsoleAssertionPrinter printer(stream, \_assertionStats, includeResults);}
\DoxyCodeLine{16429     printer.print();}
\DoxyCodeLine{16430     stream << std::endl;}
\DoxyCodeLine{16431     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{16432 \}}
\DoxyCodeLine{16433 }
\DoxyCodeLine{16434 \textcolor{keywordtype}{void} ConsoleReporter::sectionStarting(SectionInfo \textcolor{keyword}{const}\& \_sectionInfo) \{}
\DoxyCodeLine{16435     m\_tablePrinter-\/>close();}
\DoxyCodeLine{16436     m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{16437     StreamingReporterBase::sectionStarting(\_sectionInfo);}
\DoxyCodeLine{16438 \}}
\DoxyCodeLine{16439 \textcolor{keywordtype}{void} ConsoleReporter::sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \{}
\DoxyCodeLine{16440     m\_tablePrinter-\/>close();}
\DoxyCodeLine{16441     \textcolor{keywordflow}{if} (\_sectionStats.missingAssertions) \{}
\DoxyCodeLine{16442         lazyPrint();}
\DoxyCodeLine{16443         Colour colour(Colour::ResultError);}
\DoxyCodeLine{16444         \textcolor{keywordflow}{if} (m\_sectionStack.size() > 1)}
\DoxyCodeLine{16445             stream << \textcolor{stringliteral}{"{}\(\backslash\)nNo assertions in section"{}};}
\DoxyCodeLine{16446         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16447             stream << \textcolor{stringliteral}{"{}\(\backslash\)nNo assertions in test case"{}};}
\DoxyCodeLine{16448         stream << \textcolor{stringliteral}{"{} '"{}} << \_sectionStats.sectionInfo.name << \textcolor{stringliteral}{"{}'\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{16449     \}}
\DoxyCodeLine{16450     \textcolor{keywordtype}{double} dur = \_sectionStats.durationInSeconds;}
\DoxyCodeLine{16451     \textcolor{keywordflow}{if} (shouldShowDuration(*m\_config, dur)) \{}
\DoxyCodeLine{16452         stream << getFormattedDuration(dur) << \textcolor{stringliteral}{"{} s: "{}} << \_sectionStats.sectionInfo.name << std::endl;}
\DoxyCodeLine{16453     \}}
\DoxyCodeLine{16454     \textcolor{keywordflow}{if} (m\_headerPrinted) \{}
\DoxyCodeLine{16455         m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{16456     \}}
\DoxyCodeLine{16457     StreamingReporterBase::sectionEnded(\_sectionStats);}
\DoxyCodeLine{16458 \}}
\DoxyCodeLine{16459 }
\DoxyCodeLine{16460 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{16461 \textcolor{keywordtype}{void} ConsoleReporter::benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \{}
\DoxyCodeLine{16462     lazyPrintWithoutClosingBenchmarkTable();}
\DoxyCodeLine{16463 }
\DoxyCodeLine{16464     \textcolor{keyword}{auto} nameCol = Column(name).width(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(m\_tablePrinter-\/>columnInfos()[0].width -\/ 2));}
\DoxyCodeLine{16465 }
\DoxyCodeLine{16466     \textcolor{keywordtype}{bool} firstLine = \textcolor{keyword}{true};}
\DoxyCodeLine{16467     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} line : nameCol) \{}
\DoxyCodeLine{16468         \textcolor{keywordflow}{if} (!firstLine)}
\DoxyCodeLine{16469             (*m\_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();}
\DoxyCodeLine{16470         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16471             firstLine = \textcolor{keyword}{false};}
\DoxyCodeLine{16472 }
\DoxyCodeLine{16473         (*m\_tablePrinter) << line << ColumnBreak();}
\DoxyCodeLine{16474     \}}
\DoxyCodeLine{16475 \}}
\DoxyCodeLine{16476 }
\DoxyCodeLine{16477 \textcolor{keywordtype}{void} ConsoleReporter::benchmarkStarting(BenchmarkInfo \textcolor{keyword}{const}\& info) \{}
\DoxyCodeLine{16478     (*m\_tablePrinter) << info.samples << ColumnBreak()}
\DoxyCodeLine{16479         << info.iterations << ColumnBreak();}
\DoxyCodeLine{16480     \textcolor{keywordflow}{if} (!m\_config-\/>benchmarkNoAnalysis())}
\DoxyCodeLine{16481         (*m\_tablePrinter) << Duration(info.estimatedDuration) << ColumnBreak();}
\DoxyCodeLine{16482 \}}
\DoxyCodeLine{16483 \textcolor{keywordtype}{void} ConsoleReporter::benchmarkEnded(BenchmarkStats<> \textcolor{keyword}{const}\& stats) \{}
\DoxyCodeLine{16484     \textcolor{keywordflow}{if} (m\_config-\/>benchmarkNoAnalysis())}
\DoxyCodeLine{16485     \{}
\DoxyCodeLine{16486         (*m\_tablePrinter) << Duration(stats.mean.point.count()) << ColumnBreak();}
\DoxyCodeLine{16487     \}}
\DoxyCodeLine{16488     \textcolor{keywordflow}{else}}
\DoxyCodeLine{16489     \{}
\DoxyCodeLine{16490         (*m\_tablePrinter) << ColumnBreak()}
\DoxyCodeLine{16491             << Duration(stats.mean.point.count()) << ColumnBreak()}
\DoxyCodeLine{16492             << Duration(stats.mean.lower\_bound.count()) << ColumnBreak()}
\DoxyCodeLine{16493             << Duration(stats.mean.upper\_bound.count()) << ColumnBreak() << ColumnBreak()}
\DoxyCodeLine{16494             << Duration(stats.standardDeviation.point.count()) << ColumnBreak()}
\DoxyCodeLine{16495             << Duration(stats.standardDeviation.lower\_bound.count()) << ColumnBreak()}
\DoxyCodeLine{16496             << Duration(stats.standardDeviation.upper\_bound.count()) << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak();}
\DoxyCodeLine{16497     \}}
\DoxyCodeLine{16498 \}}
\DoxyCodeLine{16499 }
\DoxyCodeLine{16500 \textcolor{keywordtype}{void} ConsoleReporter::benchmarkFailed(std::string \textcolor{keyword}{const}\& error) \{}
\DoxyCodeLine{16501     Colour colour(Colour::Red);}
\DoxyCodeLine{16502     (*m\_tablePrinter)}
\DoxyCodeLine{16503         << \textcolor{stringliteral}{"{}Benchmark failed ("{}} << error << \textcolor{charliteral}{')'}}
\DoxyCodeLine{16504         << ColumnBreak() << RowBreak();}
\DoxyCodeLine{16505 \}}
\DoxyCodeLine{16506 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{16507 }
\DoxyCodeLine{16508 \textcolor{keywordtype}{void} ConsoleReporter::testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& \_testCaseStats) \{}
\DoxyCodeLine{16509     m\_tablePrinter-\/>close();}
\DoxyCodeLine{16510     StreamingReporterBase::testCaseEnded(\_testCaseStats);}
\DoxyCodeLine{16511     m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{16512 \}}
\DoxyCodeLine{16513 \textcolor{keywordtype}{void} ConsoleReporter::testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& \_testGroupStats) \{}
\DoxyCodeLine{16514     \textcolor{keywordflow}{if} (currentGroupInfo.used) \{}
\DoxyCodeLine{16515         printSummaryDivider();}
\DoxyCodeLine{16516         stream << \textcolor{stringliteral}{"{}Summary for group '"{}} << \_testGroupStats.groupInfo.name << \textcolor{stringliteral}{"{}':\(\backslash\)n"{}};}
\DoxyCodeLine{16517         printTotals(\_testGroupStats.totals);}
\DoxyCodeLine{16518         stream << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{16519     \}}
\DoxyCodeLine{16520     StreamingReporterBase::testGroupEnded(\_testGroupStats);}
\DoxyCodeLine{16521 \}}
\DoxyCodeLine{16522 \textcolor{keywordtype}{void} ConsoleReporter::testRunEnded(TestRunStats \textcolor{keyword}{const}\& \_testRunStats) \{}
\DoxyCodeLine{16523     printTotalsDivider(\_testRunStats.totals);}
\DoxyCodeLine{16524     printTotals(\_testRunStats.totals);}
\DoxyCodeLine{16525     stream << std::endl;}
\DoxyCodeLine{16526     StreamingReporterBase::testRunEnded(\_testRunStats);}
\DoxyCodeLine{16527 \}}
\DoxyCodeLine{16528 \textcolor{keywordtype}{void} ConsoleReporter::testRunStarting(TestRunInfo \textcolor{keyword}{const}\& \_testInfo) \{}
\DoxyCodeLine{16529     StreamingReporterBase::testRunStarting(\_testInfo);}
\DoxyCodeLine{16530     printTestFilters();}
\DoxyCodeLine{16531 \}}
\DoxyCodeLine{16532 }
\DoxyCodeLine{16533 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrint() \{}
\DoxyCodeLine{16534 }
\DoxyCodeLine{16535     m\_tablePrinter-\/>close();}
\DoxyCodeLine{16536     lazyPrintWithoutClosingBenchmarkTable();}
\DoxyCodeLine{16537 \}}
\DoxyCodeLine{16538 }
\DoxyCodeLine{16539 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() \{}
\DoxyCodeLine{16540 }
\DoxyCodeLine{16541     \textcolor{keywordflow}{if} (!currentTestRunInfo.used)}
\DoxyCodeLine{16542         lazyPrintRunInfo();}
\DoxyCodeLine{16543     \textcolor{keywordflow}{if} (!currentGroupInfo.used)}
\DoxyCodeLine{16544         lazyPrintGroupInfo();}
\DoxyCodeLine{16545 }
\DoxyCodeLine{16546     \textcolor{keywordflow}{if} (!m\_headerPrinted) \{}
\DoxyCodeLine{16547         printTestCaseAndSectionHeader();}
\DoxyCodeLine{16548         m\_headerPrinted = \textcolor{keyword}{true};}
\DoxyCodeLine{16549     \}}
\DoxyCodeLine{16550 \}}
\DoxyCodeLine{16551 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrintRunInfo() \{}
\DoxyCodeLine{16552     stream << '\(\backslash\)n' << getLineOfChars<'\string~'>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16553     Colour colour(Colour::SecondaryText);}
\DoxyCodeLine{16554     stream << currentTestRunInfo-\/>name}
\DoxyCodeLine{16555         << \textcolor{stringliteral}{"{} is a Catch v"{}} << libraryVersion() << \textcolor{stringliteral}{"{} host application.\(\backslash\)n"{}}}
\DoxyCodeLine{16556         << \textcolor{stringliteral}{"{}Run with -\/? for options\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{16557 }
\DoxyCodeLine{16558     \textcolor{keywordflow}{if} (m\_config-\/>rngSeed() != 0)}
\DoxyCodeLine{16559         stream << \textcolor{stringliteral}{"{}Randomness seeded to: "{}} << m\_config-\/>rngSeed() << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{16560 }
\DoxyCodeLine{16561     currentTestRunInfo.used = \textcolor{keyword}{true};}
\DoxyCodeLine{16562 \}}
\DoxyCodeLine{16563 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrintGroupInfo() \{}
\DoxyCodeLine{16564     \textcolor{keywordflow}{if} (!currentGroupInfo-\/>name.empty() \&\& currentGroupInfo-\/>groupsCounts > 1) \{}
\DoxyCodeLine{16565         printClosedHeader(\textcolor{stringliteral}{"{}Group: "{}} + currentGroupInfo-\/>name);}
\DoxyCodeLine{16566         currentGroupInfo.used = \textcolor{keyword}{true};}
\DoxyCodeLine{16567     \}}
\DoxyCodeLine{16568 \}}
\DoxyCodeLine{16569 \textcolor{keywordtype}{void} ConsoleReporter::printTestCaseAndSectionHeader() \{}
\DoxyCodeLine{16570     assert(!m\_sectionStack.empty());}
\DoxyCodeLine{16571     printOpenHeader(currentTestCaseInfo-\/>name);}
\DoxyCodeLine{16572 }
\DoxyCodeLine{16573     \textcolor{keywordflow}{if} (m\_sectionStack.size() > 1) \{}
\DoxyCodeLine{16574         Colour colourGuard(Colour::Headers);}
\DoxyCodeLine{16575 }
\DoxyCodeLine{16576         \textcolor{keyword}{auto}}
\DoxyCodeLine{16577             it = m\_sectionStack.begin() + 1, \textcolor{comment}{// Skip first section (test case)}}
\DoxyCodeLine{16578             itEnd = m\_sectionStack.end();}
\DoxyCodeLine{16579         \textcolor{keywordflow}{for} (; it != itEnd; ++it)}
\DoxyCodeLine{16580             printHeaderString(it-\/>name, 2);}
\DoxyCodeLine{16581     \}}
\DoxyCodeLine{16582 }
\DoxyCodeLine{16583     SourceLineInfo lineInfo = m\_sectionStack.back().lineInfo;}
\DoxyCodeLine{16584 }
\DoxyCodeLine{16585     stream << getLineOfChars<\textcolor{charliteral}{'-\/'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16586     Colour colourGuard(Colour::FileName);}
\DoxyCodeLine{16587     stream << lineInfo << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16588     stream << getLineOfChars<\textcolor{charliteral}{'.'}>() << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{16589 \}}
\DoxyCodeLine{16590 }
\DoxyCodeLine{16591 \textcolor{keywordtype}{void} ConsoleReporter::printClosedHeader(std::string \textcolor{keyword}{const}\& \_name) \{}
\DoxyCodeLine{16592     printOpenHeader(\_name);}
\DoxyCodeLine{16593     stream << getLineOfChars<\textcolor{charliteral}{'.'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16594 \}}
\DoxyCodeLine{16595 \textcolor{keywordtype}{void} ConsoleReporter::printOpenHeader(std::string \textcolor{keyword}{const}\& \_name) \{}
\DoxyCodeLine{16596     stream << getLineOfChars<\textcolor{charliteral}{'-\/'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16597     \{}
\DoxyCodeLine{16598         Colour colourGuard(Colour::Headers);}
\DoxyCodeLine{16599         printHeaderString(\_name);}
\DoxyCodeLine{16600     \}}
\DoxyCodeLine{16601 \}}
\DoxyCodeLine{16602 }
\DoxyCodeLine{16603 \textcolor{comment}{// if string has a : in first line will set indent to follow it on}}
\DoxyCodeLine{16604 \textcolor{comment}{// subsequent lines}}
\DoxyCodeLine{16605 \textcolor{keywordtype}{void} ConsoleReporter::printHeaderString(std::string \textcolor{keyword}{const}\& \_string, std::size\_t indent) \{}
\DoxyCodeLine{16606     std::size\_t i = \_string.find(\textcolor{stringliteral}{"{}: "{}});}
\DoxyCodeLine{16607     \textcolor{keywordflow}{if} (i != std::string::npos)}
\DoxyCodeLine{16608         i += 2;}
\DoxyCodeLine{16609     \textcolor{keywordflow}{else}}
\DoxyCodeLine{16610         i = 0;}
\DoxyCodeLine{16611     stream << Column(\_string).indent(indent + i).initialIndent(indent) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16612 \}}
\DoxyCodeLine{16613 }
\DoxyCodeLine{16614 \textcolor{keyword}{struct }SummaryColumn \{}
\DoxyCodeLine{16615 }
\DoxyCodeLine{16616     SummaryColumn( std::string \_label, Colour::Code \_colour )}
\DoxyCodeLine{16617     :   label( std::move( \_label ) ),}
\DoxyCodeLine{16618         colour( \_colour ) \{\}}
\DoxyCodeLine{16619     SummaryColumn addRow( std::size\_t count ) \{}
\DoxyCodeLine{16620         ReusableStringStream rss;}
\DoxyCodeLine{16621         rss << count;}
\DoxyCodeLine{16622         std::string row = rss.str();}
\DoxyCodeLine{16623         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& oldRow : rows) \{}
\DoxyCodeLine{16624             \textcolor{keywordflow}{while} (oldRow.size() < row.size())}
\DoxyCodeLine{16625                 oldRow = \textcolor{charliteral}{' '} + oldRow;}
\DoxyCodeLine{16626             \textcolor{keywordflow}{while} (oldRow.size() > row.size())}
\DoxyCodeLine{16627                 row = \textcolor{charliteral}{' '} + row;}
\DoxyCodeLine{16628         \}}
\DoxyCodeLine{16629         rows.push\_back(row);}
\DoxyCodeLine{16630         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{16631     \}}
\DoxyCodeLine{16632 }
\DoxyCodeLine{16633     std::string label;}
\DoxyCodeLine{16634     Colour::Code colour;}
\DoxyCodeLine{16635     std::vector<std::string> rows;}
\DoxyCodeLine{16636 }
\DoxyCodeLine{16637 \};}
\DoxyCodeLine{16638 }
\DoxyCodeLine{16639 \textcolor{keywordtype}{void} ConsoleReporter::printTotals( Totals \textcolor{keyword}{const}\& totals ) \{}
\DoxyCodeLine{16640     \textcolor{keywordflow}{if} (totals.testCases.total() == 0) \{}
\DoxyCodeLine{16641         stream << Colour(Colour::Warning) << \textcolor{stringliteral}{"{}No tests ran\(\backslash\)n"{}};}
\DoxyCodeLine{16642     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (totals.assertions.total() > 0 \&\& totals.testCases.allPassed()) \{}
\DoxyCodeLine{16643         stream << Colour(Colour::ResultSuccess) << \textcolor{stringliteral}{"{}All tests passed"{}};}
\DoxyCodeLine{16644         stream << \textcolor{stringliteral}{"{} ("{}}}
\DoxyCodeLine{16645             << pluralise(totals.assertions.passed, \textcolor{stringliteral}{"{}assertion"{}}) << \textcolor{stringliteral}{"{} in "{}}}
\DoxyCodeLine{16646             << pluralise(totals.testCases.passed, \textcolor{stringliteral}{"{}test case"{}}) << \textcolor{charliteral}{')'}}
\DoxyCodeLine{16647             << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16648     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16649 }
\DoxyCodeLine{16650         std::vector<SummaryColumn> columns;}
\DoxyCodeLine{16651         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"{}"{}}, Colour::None)}
\DoxyCodeLine{16652                           .addRow(totals.testCases.total())}
\DoxyCodeLine{16653                           .addRow(totals.assertions.total()));}
\DoxyCodeLine{16654         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"{}passed"{}}, Colour::Success)}
\DoxyCodeLine{16655                           .addRow(totals.testCases.passed)}
\DoxyCodeLine{16656                           .addRow(totals.assertions.passed));}
\DoxyCodeLine{16657         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"{}failed"{}}, Colour::ResultError)}
\DoxyCodeLine{16658                           .addRow(totals.testCases.failed)}
\DoxyCodeLine{16659                           .addRow(totals.assertions.failed));}
\DoxyCodeLine{16660         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"{}failed as expected"{}}, Colour::ResultExpectedFailure)}
\DoxyCodeLine{16661                           .addRow(totals.testCases.failedButOk)}
\DoxyCodeLine{16662                           .addRow(totals.assertions.failedButOk));}
\DoxyCodeLine{16663 }
\DoxyCodeLine{16664         printSummaryRow(\textcolor{stringliteral}{"{}test cases"{}}, columns, 0);}
\DoxyCodeLine{16665         printSummaryRow(\textcolor{stringliteral}{"{}assertions"{}}, columns, 1);}
\DoxyCodeLine{16666     \}}
\DoxyCodeLine{16667 \}}
\DoxyCodeLine{16668 \textcolor{keywordtype}{void} ConsoleReporter::printSummaryRow(std::string \textcolor{keyword}{const}\& label, std::vector<SummaryColumn> \textcolor{keyword}{const}\& cols, std::size\_t row) \{}
\DoxyCodeLine{16669     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} col : cols) \{}
\DoxyCodeLine{16670         std::string value = col.rows[row];}
\DoxyCodeLine{16671         \textcolor{keywordflow}{if} (col.label.empty()) \{}
\DoxyCodeLine{16672             stream << label << \textcolor{stringliteral}{"{}: "{}};}
\DoxyCodeLine{16673             \textcolor{keywordflow}{if} (value != \textcolor{stringliteral}{"{}0"{}})}
\DoxyCodeLine{16674                 stream << value;}
\DoxyCodeLine{16675             \textcolor{keywordflow}{else}}
\DoxyCodeLine{16676                 stream << Colour(Colour::Warning) << \textcolor{stringliteral}{"{}-\/ none -\/"{}};}
\DoxyCodeLine{16677         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value != \textcolor{stringliteral}{"{}0"{}}) \{}
\DoxyCodeLine{16678             stream << Colour(Colour::LightGrey) << \textcolor{stringliteral}{"{} | "{}};}
\DoxyCodeLine{16679             stream << Colour(col.colour)}
\DoxyCodeLine{16680                 << value << \textcolor{charliteral}{' '} << col.label;}
\DoxyCodeLine{16681         \}}
\DoxyCodeLine{16682     \}}
\DoxyCodeLine{16683     stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16684 \}}
\DoxyCodeLine{16685 }
\DoxyCodeLine{16686 \textcolor{keywordtype}{void} ConsoleReporter::printTotalsDivider(Totals \textcolor{keyword}{const}\& totals) \{}
\DoxyCodeLine{16687     \textcolor{keywordflow}{if} (totals.testCases.total() > 0) \{}
\DoxyCodeLine{16688         std::size\_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());}
\DoxyCodeLine{16689         std::size\_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());}
\DoxyCodeLine{16690         std::size\_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());}
\DoxyCodeLine{16691         \textcolor{keywordflow}{while} (failedRatio + failedButOkRatio + passedRatio < CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 1)}
\DoxyCodeLine{16692             findMax(failedRatio, failedButOkRatio, passedRatio)++;}
\DoxyCodeLine{16693         \textcolor{keywordflow}{while} (failedRatio + failedButOkRatio + passedRatio > CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 1)}
\DoxyCodeLine{16694             findMax(failedRatio, failedButOkRatio, passedRatio)-\/-\/;}
\DoxyCodeLine{16695 }
\DoxyCodeLine{16696         stream << Colour(Colour::Error) << std::string(failedRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16697         stream << Colour(Colour::ResultExpectedFailure) << std::string(failedButOkRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16698         \textcolor{keywordflow}{if} (totals.testCases.allPassed())}
\DoxyCodeLine{16699             stream << Colour(Colour::ResultSuccess) << std::string(passedRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16700         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16701             stream << Colour(Colour::Success) << std::string(passedRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16702     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16703         stream << Colour(Colour::Warning) << std::string(CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 1, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16704     \}}
\DoxyCodeLine{16705     stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16706 \}}
\DoxyCodeLine{16707 \textcolor{keywordtype}{void} ConsoleReporter::printSummaryDivider() \{}
\DoxyCodeLine{16708     stream << getLineOfChars<\textcolor{charliteral}{'-\/'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16709 \}}
\DoxyCodeLine{16710 }
\DoxyCodeLine{16711 \textcolor{keywordtype}{void} ConsoleReporter::printTestFilters() \{}
\DoxyCodeLine{16712     \textcolor{keywordflow}{if} (m\_config-\/>testSpec().hasFilters()) \{}
\DoxyCodeLine{16713         Colour guard(Colour::BrightYellow);}
\DoxyCodeLine{16714         stream << \textcolor{stringliteral}{"{}Filters: "{}} << serializeFilters(m\_config-\/>getTestsOrTags()) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16715     \}}
\DoxyCodeLine{16716 \}}
\DoxyCodeLine{16717 }
\DoxyCodeLine{16718 CATCH\_REGISTER\_REPORTER(\textcolor{stringliteral}{"{}console"{}}, ConsoleReporter)}
\DoxyCodeLine{16719 }
\DoxyCodeLine{16720 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{16721 }
\DoxyCodeLine{16722 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{16723 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{16724 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16725 }
\DoxyCodeLine{16726 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{16727 \textcolor{preprocessor}{\#  pragma clang diagnostic pop}}
\DoxyCodeLine{16728 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16729 \textcolor{comment}{// end catch\_reporter\_console.cpp}}
\DoxyCodeLine{16730 \textcolor{comment}{// start catch\_reporter\_junit.cpp}}
\DoxyCodeLine{16731 }
\DoxyCodeLine{16732 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{16733 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{16734 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{16735 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{16736 }
\DoxyCodeLine{16737 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{16738 }
\DoxyCodeLine{16739     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{16740         std::string getCurrentTimestamp() \{}
\DoxyCodeLine{16741             \textcolor{comment}{// Beware, this is not reentrant because of backward compatibility issues}}
\DoxyCodeLine{16742             \textcolor{comment}{// Also, UTC only, again because of backward compatibility (\%z is C++11)}}
\DoxyCodeLine{16743             time\_t rawtime;}
\DoxyCodeLine{16744             std::time(\&rawtime);}
\DoxyCodeLine{16745             \textcolor{keyword}{auto} \textcolor{keyword}{const} timeStampSize = \textcolor{keyword}{sizeof}(\textcolor{stringliteral}{"{}2017-\/01-\/16T17:06:45Z"{}});}
\DoxyCodeLine{16746 }
\DoxyCodeLine{16747 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{16748             std::tm timeInfo = \{\};}
\DoxyCodeLine{16749             gmtime\_s(\&timeInfo, \&rawtime);}
\DoxyCodeLine{16750 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{16751             std::tm* timeInfo;}
\DoxyCodeLine{16752             timeInfo = std::gmtime(\&rawtime);}
\DoxyCodeLine{16753 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16754 }
\DoxyCodeLine{16755             \textcolor{keywordtype}{char} timeStamp[timeStampSize];}
\DoxyCodeLine{16756             \textcolor{keyword}{const} \textcolor{keywordtype}{char} * \textcolor{keyword}{const} fmt = \textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%dT\%H:\%M:\%SZ"{}};}
\DoxyCodeLine{16757 }
\DoxyCodeLine{16758 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{16759             std::strftime(timeStamp, timeStampSize, fmt, \&timeInfo);}
\DoxyCodeLine{16760 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{16761             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);}
\DoxyCodeLine{16762 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16763             \textcolor{keywordflow}{return} std::string(timeStamp);}
\DoxyCodeLine{16764         \}}
\DoxyCodeLine{16765 }
\DoxyCodeLine{16766         std::string fileNameTag(\textcolor{keyword}{const} std::vector<std::string> \&tags) \{}
\DoxyCodeLine{16767             \textcolor{keyword}{auto} it = std::find\_if(begin(tags),}
\DoxyCodeLine{16768                                    end(tags),}
\DoxyCodeLine{16769                                    [] (std::string \textcolor{keyword}{const}\& tag) \{\textcolor{keywordflow}{return} tag.front() == \textcolor{charliteral}{'\#'}; \});}
\DoxyCodeLine{16770             \textcolor{keywordflow}{if} (it != tags.end())}
\DoxyCodeLine{16771                 \textcolor{keywordflow}{return} it-\/>substr(1);}
\DoxyCodeLine{16772             \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{16773         \}}
\DoxyCodeLine{16774     \} \textcolor{comment}{// anonymous namespace}}
\DoxyCodeLine{16775 }
\DoxyCodeLine{16776     JunitReporter::JunitReporter( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{16777         :   CumulativeReporterBase( \_config ),}
\DoxyCodeLine{16778             xml( \_config.stream() )}
\DoxyCodeLine{16779         \{}
\DoxyCodeLine{16780             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{true};}
\DoxyCodeLine{16781             m\_reporterPrefs.shouldReportAllAssertions = \textcolor{keyword}{true};}
\DoxyCodeLine{16782         \}}
\DoxyCodeLine{16783 }
\DoxyCodeLine{16784     JunitReporter::\string~JunitReporter() \{\}}
\DoxyCodeLine{16785 }
\DoxyCodeLine{16786     std::string JunitReporter::getDescription() \{}
\DoxyCodeLine{16787         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Reports test results in an XML format that looks like Ant's junitreport target"{}};}
\DoxyCodeLine{16788     \}}
\DoxyCodeLine{16789 }
\DoxyCodeLine{16790     \textcolor{keywordtype}{void} JunitReporter::noMatchingTestCases( std::string \textcolor{keyword}{const}\& \textcolor{comment}{/*spec*/} ) \{\}}
\DoxyCodeLine{16791 }
\DoxyCodeLine{16792     \textcolor{keywordtype}{void} JunitReporter::testRunStarting( TestRunInfo \textcolor{keyword}{const}\& runInfo )  \{}
\DoxyCodeLine{16793         CumulativeReporterBase::testRunStarting( runInfo );}
\DoxyCodeLine{16794         xml.startElement( \textcolor{stringliteral}{"{}testsuites"{}} );}
\DoxyCodeLine{16795     \}}
\DoxyCodeLine{16796 }
\DoxyCodeLine{16797     \textcolor{keywordtype}{void} JunitReporter::testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \{}
\DoxyCodeLine{16798         suiteTimer.start();}
\DoxyCodeLine{16799         stdOutForSuite.clear();}
\DoxyCodeLine{16800         stdErrForSuite.clear();}
\DoxyCodeLine{16801         unexpectedExceptions = 0;}
\DoxyCodeLine{16802         CumulativeReporterBase::testGroupStarting( groupInfo );}
\DoxyCodeLine{16803     \}}
\DoxyCodeLine{16804 }
\DoxyCodeLine{16805     \textcolor{keywordtype}{void} JunitReporter::testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testCaseInfo ) \{}
\DoxyCodeLine{16806         m\_okToFail = testCaseInfo.okToFail();}
\DoxyCodeLine{16807     \}}
\DoxyCodeLine{16808 }
\DoxyCodeLine{16809     \textcolor{keywordtype}{bool} JunitReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \{}
\DoxyCodeLine{16810         \textcolor{keywordflow}{if}( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException \&\& !m\_okToFail )}
\DoxyCodeLine{16811             unexpectedExceptions++;}
\DoxyCodeLine{16812         \textcolor{keywordflow}{return} CumulativeReporterBase::assertionEnded( assertionStats );}
\DoxyCodeLine{16813     \}}
\DoxyCodeLine{16814 }
\DoxyCodeLine{16815     \textcolor{keywordtype}{void} JunitReporter::testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \{}
\DoxyCodeLine{16816         stdOutForSuite += testCaseStats.stdOut;}
\DoxyCodeLine{16817         stdErrForSuite += testCaseStats.stdErr;}
\DoxyCodeLine{16818         CumulativeReporterBase::testCaseEnded( testCaseStats );}
\DoxyCodeLine{16819     \}}
\DoxyCodeLine{16820 }
\DoxyCodeLine{16821     \textcolor{keywordtype}{void} JunitReporter::testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \{}
\DoxyCodeLine{16822         \textcolor{keywordtype}{double} suiteTime = suiteTimer.getElapsedSeconds();}
\DoxyCodeLine{16823         CumulativeReporterBase::testGroupEnded( testGroupStats );}
\DoxyCodeLine{16824         writeGroup( *m\_testGroups.back(), suiteTime );}
\DoxyCodeLine{16825     \}}
\DoxyCodeLine{16826 }
\DoxyCodeLine{16827     \textcolor{keywordtype}{void} JunitReporter::testRunEndedCumulative() \{}
\DoxyCodeLine{16828         xml.endElement();}
\DoxyCodeLine{16829     \}}
\DoxyCodeLine{16830 }
\DoxyCodeLine{16831     \textcolor{keywordtype}{void} JunitReporter::writeGroup( TestGroupNode \textcolor{keyword}{const}\& groupNode, \textcolor{keywordtype}{double} suiteTime ) \{}
\DoxyCodeLine{16832         XmlWriter::ScopedElement e = xml.scopedElement( \textcolor{stringliteral}{"{}testsuite"{}} );}
\DoxyCodeLine{16833 }
\DoxyCodeLine{16834         TestGroupStats \textcolor{keyword}{const}\& stats = groupNode.value;}
\DoxyCodeLine{16835         xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, stats.groupInfo.name );}
\DoxyCodeLine{16836         xml.writeAttribute( \textcolor{stringliteral}{"{}errors"{}}, unexpectedExceptions );}
\DoxyCodeLine{16837         xml.writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, stats.totals.assertions.failed-\/unexpectedExceptions );}
\DoxyCodeLine{16838         xml.writeAttribute( \textcolor{stringliteral}{"{}tests"{}}, stats.totals.assertions.total() );}
\DoxyCodeLine{16839         xml.writeAttribute( \textcolor{stringliteral}{"{}hostname"{}}, \textcolor{stringliteral}{"{}tbd"{}} ); \textcolor{comment}{// !TBD}}
\DoxyCodeLine{16840         \textcolor{keywordflow}{if}( m\_config-\/>showDurations() == ShowDurations::Never )}
\DoxyCodeLine{16841             xml.writeAttribute( \textcolor{stringliteral}{"{}time"{}}, \textcolor{stringliteral}{"{}"{}} );}
\DoxyCodeLine{16842         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16843             xml.writeAttribute( \textcolor{stringliteral}{"{}time"{}}, suiteTime );}
\DoxyCodeLine{16844         xml.writeAttribute( \textcolor{stringliteral}{"{}timestamp"{}}, getCurrentTimestamp() );}
\DoxyCodeLine{16845 }
\DoxyCodeLine{16846         \textcolor{comment}{// Write properties if there are any}}
\DoxyCodeLine{16847         \textcolor{keywordflow}{if} (m\_config-\/>hasTestFilters() || m\_config-\/>rngSeed() != 0) \{}
\DoxyCodeLine{16848             \textcolor{keyword}{auto} properties = xml.scopedElement(\textcolor{stringliteral}{"{}properties"{}});}
\DoxyCodeLine{16849             \textcolor{keywordflow}{if} (m\_config-\/>hasTestFilters()) \{}
\DoxyCodeLine{16850                 xml.scopedElement(\textcolor{stringliteral}{"{}property"{}})}
\DoxyCodeLine{16851                     .writeAttribute(\textcolor{stringliteral}{"{}name"{}}, \textcolor{stringliteral}{"{}filters"{}})}
\DoxyCodeLine{16852                     .writeAttribute(\textcolor{stringliteral}{"{}value"{}}, serializeFilters(m\_config-\/>getTestsOrTags()));}
\DoxyCodeLine{16853             \}}
\DoxyCodeLine{16854             \textcolor{keywordflow}{if} (m\_config-\/>rngSeed() != 0) \{}
\DoxyCodeLine{16855                 xml.scopedElement(\textcolor{stringliteral}{"{}property"{}})}
\DoxyCodeLine{16856                     .writeAttribute(\textcolor{stringliteral}{"{}name"{}}, \textcolor{stringliteral}{"{}random-\/seed"{}})}
\DoxyCodeLine{16857                     .writeAttribute(\textcolor{stringliteral}{"{}value"{}}, m\_config-\/>rngSeed());}
\DoxyCodeLine{16858             \}}
\DoxyCodeLine{16859         \}}
\DoxyCodeLine{16860 }
\DoxyCodeLine{16861         \textcolor{comment}{// Write test cases}}
\DoxyCodeLine{16862         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& child : groupNode.children )}
\DoxyCodeLine{16863             writeTestCase( *child );}
\DoxyCodeLine{16864 }
\DoxyCodeLine{16865         xml.scopedElement( \textcolor{stringliteral}{"{}system-\/out"{}} ).writeText( trim( stdOutForSuite ), XmlFormatting::Newline );}
\DoxyCodeLine{16866         xml.scopedElement( \textcolor{stringliteral}{"{}system-\/err"{}} ).writeText( trim( stdErrForSuite ), XmlFormatting::Newline );}
\DoxyCodeLine{16867     \}}
\DoxyCodeLine{16868 }
\DoxyCodeLine{16869     \textcolor{keywordtype}{void} JunitReporter::writeTestCase( TestCaseNode \textcolor{keyword}{const}\& testCaseNode ) \{}
\DoxyCodeLine{16870         TestCaseStats \textcolor{keyword}{const}\& stats = testCaseNode.value;}
\DoxyCodeLine{16871 }
\DoxyCodeLine{16872         \textcolor{comment}{// All test cases have exactly one section -\/ which represents the}}
\DoxyCodeLine{16873         \textcolor{comment}{// test case itself. That section may have 0-\/n nested sections}}
\DoxyCodeLine{16874         assert( testCaseNode.children.size() == 1 );}
\DoxyCodeLine{16875         SectionNode \textcolor{keyword}{const}\& rootSection = *testCaseNode.children.front();}
\DoxyCodeLine{16876 }
\DoxyCodeLine{16877         std::string className = stats.testInfo.className;}
\DoxyCodeLine{16878 }
\DoxyCodeLine{16879         \textcolor{keywordflow}{if}( className.empty() ) \{}
\DoxyCodeLine{16880             className = fileNameTag(stats.testInfo.tags);}
\DoxyCodeLine{16881             \textcolor{keywordflow}{if} ( className.empty() )}
\DoxyCodeLine{16882                 className = \textcolor{stringliteral}{"{}global"{}};}
\DoxyCodeLine{16883         \}}
\DoxyCodeLine{16884 }
\DoxyCodeLine{16885         \textcolor{keywordflow}{if} ( !m\_config-\/>name().empty() )}
\DoxyCodeLine{16886             className = m\_config-\/>name() + "{}."{} + className;}
\DoxyCodeLine{16887 }
\DoxyCodeLine{16888         writeSection( className, \textcolor{stringliteral}{"{}"{}}, rootSection );}
\DoxyCodeLine{16889     \}}
\DoxyCodeLine{16890 }
\DoxyCodeLine{16891     \textcolor{keywordtype}{void} JunitReporter::writeSection(  std::string \textcolor{keyword}{const}\& className,}
\DoxyCodeLine{16892                         std::string \textcolor{keyword}{const}\& rootName,}
\DoxyCodeLine{16893                         SectionNode \textcolor{keyword}{const}\& sectionNode ) \{}
\DoxyCodeLine{16894         std::string name = trim( sectionNode.stats.sectionInfo.name );}
\DoxyCodeLine{16895         \textcolor{keywordflow}{if}( !rootName.empty() )}
\DoxyCodeLine{16896             name = rootName + '/' + name;}
\DoxyCodeLine{16897 }
\DoxyCodeLine{16898         \textcolor{keywordflow}{if}( !sectionNode.assertions.empty() ||}
\DoxyCodeLine{16899             !sectionNode.stdOut.empty() ||}
\DoxyCodeLine{16900             !sectionNode.stdErr.empty() ) \{}
\DoxyCodeLine{16901             XmlWriter::ScopedElement e = xml.scopedElement( \textcolor{stringliteral}{"{}testcase"{}} );}
\DoxyCodeLine{16902             \textcolor{keywordflow}{if}( className.empty() ) \{}
\DoxyCodeLine{16903                 xml.writeAttribute( \textcolor{stringliteral}{"{}classname"{}}, name );}
\DoxyCodeLine{16904                 xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, \textcolor{stringliteral}{"{}root"{}} );}
\DoxyCodeLine{16905             \}}
\DoxyCodeLine{16906             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16907                 xml.writeAttribute( \textcolor{stringliteral}{"{}classname"{}}, className );}
\DoxyCodeLine{16908                 xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, name );}
\DoxyCodeLine{16909             \}}
\DoxyCodeLine{16910             xml.writeAttribute( \textcolor{stringliteral}{"{}time"{}}, ::Catch::Detail::stringify( sectionNode.stats.durationInSeconds ) );}
\DoxyCodeLine{16911             \textcolor{comment}{// This is not ideal, but it should be enough to mimic gtest's}}
\DoxyCodeLine{16912             \textcolor{comment}{// junit output.}}
\DoxyCodeLine{16913             \textcolor{comment}{// Ideally the JUnit reporter would also handle `skipTest`}}
\DoxyCodeLine{16914             \textcolor{comment}{// events and write those out appropriately.}}
\DoxyCodeLine{16915             xml.writeAttribute( \textcolor{stringliteral}{"{}status"{}}, \textcolor{stringliteral}{"{}run"{}} );}
\DoxyCodeLine{16916 }
\DoxyCodeLine{16917             writeAssertions( sectionNode );}
\DoxyCodeLine{16918 }
\DoxyCodeLine{16919             \textcolor{keywordflow}{if}( !sectionNode.stdOut.empty() )}
\DoxyCodeLine{16920                 xml.scopedElement( \textcolor{stringliteral}{"{}system-\/out"{}} ).writeText( trim( sectionNode.stdOut ), XmlFormatting::Newline );}
\DoxyCodeLine{16921             \textcolor{keywordflow}{if}( !sectionNode.stdErr.empty() )}
\DoxyCodeLine{16922                 xml.scopedElement( \textcolor{stringliteral}{"{}system-\/err"{}} ).writeText( trim( sectionNode.stdErr ), XmlFormatting::Newline );}
\DoxyCodeLine{16923         \}}
\DoxyCodeLine{16924         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& childNode : sectionNode.childSections )}
\DoxyCodeLine{16925             \textcolor{keywordflow}{if}( className.empty() )}
\DoxyCodeLine{16926                 writeSection( name, \textcolor{stringliteral}{"{}"{}}, *childNode );}
\DoxyCodeLine{16927             \textcolor{keywordflow}{else}}
\DoxyCodeLine{16928                 writeSection( className, name, *childNode );}
\DoxyCodeLine{16929     \}}
\DoxyCodeLine{16930 }
\DoxyCodeLine{16931     \textcolor{keywordtype}{void} JunitReporter::writeAssertions( SectionNode \textcolor{keyword}{const}\& sectionNode ) \{}
\DoxyCodeLine{16932         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& assertion : sectionNode.assertions )}
\DoxyCodeLine{16933             writeAssertion( assertion );}
\DoxyCodeLine{16934     \}}
\DoxyCodeLine{16935 }
\DoxyCodeLine{16936     \textcolor{keywordtype}{void} JunitReporter::writeAssertion( AssertionStats \textcolor{keyword}{const}\& stats ) \{}
\DoxyCodeLine{16937         AssertionResult \textcolor{keyword}{const}\& result = stats.assertionResult;}
\DoxyCodeLine{16938         \textcolor{keywordflow}{if}( !result.isOk() ) \{}
\DoxyCodeLine{16939             std::string elementName;}
\DoxyCodeLine{16940             \textcolor{keywordflow}{switch}( result.getResultType() ) \{}
\DoxyCodeLine{16941                 \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{16942                 \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{16943                     elementName = \textcolor{stringliteral}{"{}error"{}};}
\DoxyCodeLine{16944                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{16945                 \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{16946                 \textcolor{keywordflow}{case} ResultWas::ExpressionFailed:}
\DoxyCodeLine{16947                 \textcolor{keywordflow}{case} ResultWas::DidntThrowException:}
\DoxyCodeLine{16948                     elementName = \textcolor{stringliteral}{"{}failure"{}};}
\DoxyCodeLine{16949                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{16950 }
\DoxyCodeLine{16951                 \textcolor{comment}{// We should never see these here:}}
\DoxyCodeLine{16952                 \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{16953                 \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{16954                 \textcolor{keywordflow}{case} ResultWas::Ok:}
\DoxyCodeLine{16955                 \textcolor{keywordflow}{case} ResultWas::Unknown:}
\DoxyCodeLine{16956                 \textcolor{keywordflow}{case} ResultWas::FailureBit:}
\DoxyCodeLine{16957                 \textcolor{keywordflow}{case} ResultWas::Exception:}
\DoxyCodeLine{16958                     elementName = \textcolor{stringliteral}{"{}internalError"{}};}
\DoxyCodeLine{16959                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{16960             \}}
\DoxyCodeLine{16961 }
\DoxyCodeLine{16962             XmlWriter::ScopedElement e = xml.scopedElement( elementName );}
\DoxyCodeLine{16963 }
\DoxyCodeLine{16964             xml.writeAttribute( \textcolor{stringliteral}{"{}message"{}}, result.getExpression() );}
\DoxyCodeLine{16965             xml.writeAttribute( \textcolor{stringliteral}{"{}type"{}}, result.getTestMacroName() );}
\DoxyCodeLine{16966 }
\DoxyCodeLine{16967             ReusableStringStream rss;}
\DoxyCodeLine{16968             \textcolor{keywordflow}{if} (stats.totals.assertions.total() > 0) \{}
\DoxyCodeLine{16969                 rss << \textcolor{stringliteral}{"{}FAILED"{}} << \textcolor{stringliteral}{"{}:\(\backslash\)n"{}};}
\DoxyCodeLine{16970                 \textcolor{keywordflow}{if} (result.hasExpression()) \{}
\DoxyCodeLine{16971                     rss << \textcolor{stringliteral}{"{}  "{}};}
\DoxyCodeLine{16972                     rss << result.getExpressionInMacro();}
\DoxyCodeLine{16973                     rss << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16974                 \}}
\DoxyCodeLine{16975                 \textcolor{keywordflow}{if} (result.hasExpandedExpression()) \{}
\DoxyCodeLine{16976                     rss << \textcolor{stringliteral}{"{}with expansion:\(\backslash\)n"{}};}
\DoxyCodeLine{16977                     rss << Column(result.getExpandedExpression()).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16978                 \}}
\DoxyCodeLine{16979             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16980                 rss << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16981             \}}
\DoxyCodeLine{16982 }
\DoxyCodeLine{16983             \textcolor{keywordflow}{if}( !result.getMessage().empty() )}
\DoxyCodeLine{16984                 rss << result.getMessage() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16985             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& msg : stats.infoMessages )}
\DoxyCodeLine{16986                 \textcolor{keywordflow}{if}( msg.type == ResultWas::Info )}
\DoxyCodeLine{16987                     rss << msg.message << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16988 }
\DoxyCodeLine{16989             rss << \textcolor{stringliteral}{"{}at "{}} << result.getSourceInfo();}
\DoxyCodeLine{16990             xml.writeText( rss.str(), XmlFormatting::Newline );}
\DoxyCodeLine{16991         \}}
\DoxyCodeLine{16992     \}}
\DoxyCodeLine{16993 }
\DoxyCodeLine{16994     CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"{}junit"{}}, JunitReporter )}
\DoxyCodeLine{16995 }
\DoxyCodeLine{16996 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{16997 \textcolor{comment}{// end catch\_reporter\_junit.cpp}}
\DoxyCodeLine{16998 \textcolor{comment}{// start catch\_reporter\_listening.cpp}}
\DoxyCodeLine{16999 }
\DoxyCodeLine{17000 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{17001 }
\DoxyCodeLine{17002 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{17003 }
\DoxyCodeLine{17004     ListeningReporter::ListeningReporter() \{}
\DoxyCodeLine{17005         \textcolor{comment}{// We will assume that listeners will always want all assertions}}
\DoxyCodeLine{17006         m\_preferences.shouldReportAllAssertions = \textcolor{keyword}{true};}
\DoxyCodeLine{17007     \}}
\DoxyCodeLine{17008 }
\DoxyCodeLine{17009     \textcolor{keywordtype}{void} ListeningReporter::addListener( IStreamingReporterPtr\&\& listener ) \{}
\DoxyCodeLine{17010         m\_listeners.push\_back( std::move( listener ) );}
\DoxyCodeLine{17011     \}}
\DoxyCodeLine{17012 }
\DoxyCodeLine{17013     \textcolor{keywordtype}{void} ListeningReporter::addReporter(IStreamingReporterPtr\&\& reporter) \{}
\DoxyCodeLine{17014         assert(!m\_reporter \&\& \textcolor{stringliteral}{"{}Listening reporter can wrap only 1 real reporter"{}});}
\DoxyCodeLine{17015         m\_reporter = std::move( reporter );}
\DoxyCodeLine{17016         m\_preferences.shouldRedirectStdOut = m\_reporter-\/>getPreferences().shouldRedirectStdOut;}
\DoxyCodeLine{17017     \}}
\DoxyCodeLine{17018 }
\DoxyCodeLine{17019     ReporterPreferences ListeningReporter::getPreferences()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{17020         \textcolor{keywordflow}{return} m\_preferences;}
\DoxyCodeLine{17021     \}}
\DoxyCodeLine{17022 }
\DoxyCodeLine{17023     std::set<Verbosity> ListeningReporter::getSupportedVerbosities() \{}
\DoxyCodeLine{17024         \textcolor{keywordflow}{return} std::set<Verbosity>\{ \};}
\DoxyCodeLine{17025     \}}
\DoxyCodeLine{17026 }
\DoxyCodeLine{17027     \textcolor{keywordtype}{void} ListeningReporter::noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) \{}
\DoxyCodeLine{17028         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17029             listener-\/>noMatchingTestCases( spec );}
\DoxyCodeLine{17030         \}}
\DoxyCodeLine{17031         m\_reporter-\/>noMatchingTestCases( spec );}
\DoxyCodeLine{17032     \}}
\DoxyCodeLine{17033 }
\DoxyCodeLine{17034     \textcolor{keywordtype}{void} ListeningReporter::reportInvalidArguments(std::string \textcolor{keyword}{const}\&arg)\{}
\DoxyCodeLine{17035         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17036             listener-\/>reportInvalidArguments( arg );}
\DoxyCodeLine{17037         \}}
\DoxyCodeLine{17038         m\_reporter-\/>reportInvalidArguments( arg );}
\DoxyCodeLine{17039     \}}
\DoxyCodeLine{17040 }
\DoxyCodeLine{17041 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{17042     \textcolor{keywordtype}{void} ListeningReporter::benchmarkPreparing( std::string \textcolor{keyword}{const}\& name ) \{}
\DoxyCodeLine{17043         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners) \{}
\DoxyCodeLine{17044             listener-\/>benchmarkPreparing(name);}
\DoxyCodeLine{17045         \}}
\DoxyCodeLine{17046         m\_reporter-\/>benchmarkPreparing(name);}
\DoxyCodeLine{17047     \}}
\DoxyCodeLine{17048     \textcolor{keywordtype}{void} ListeningReporter::benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& benchmarkInfo ) \{}
\DoxyCodeLine{17049         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17050             listener-\/>benchmarkStarting( benchmarkInfo );}
\DoxyCodeLine{17051         \}}
\DoxyCodeLine{17052         m\_reporter-\/>benchmarkStarting( benchmarkInfo );}
\DoxyCodeLine{17053     \}}
\DoxyCodeLine{17054     \textcolor{keywordtype}{void} ListeningReporter::benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& benchmarkStats ) \{}
\DoxyCodeLine{17055         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17056             listener-\/>benchmarkEnded( benchmarkStats );}
\DoxyCodeLine{17057         \}}
\DoxyCodeLine{17058         m\_reporter-\/>benchmarkEnded( benchmarkStats );}
\DoxyCodeLine{17059     \}}
\DoxyCodeLine{17060 }
\DoxyCodeLine{17061     \textcolor{keywordtype}{void} ListeningReporter::benchmarkFailed( std::string \textcolor{keyword}{const}\& error ) \{}
\DoxyCodeLine{17062         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners) \{}
\DoxyCodeLine{17063             listener-\/>benchmarkFailed(error);}
\DoxyCodeLine{17064         \}}
\DoxyCodeLine{17065         m\_reporter-\/>benchmarkFailed(error);}
\DoxyCodeLine{17066     \}}
\DoxyCodeLine{17067 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{17068 }
\DoxyCodeLine{17069     \textcolor{keywordtype}{void} ListeningReporter::testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testRunInfo ) \{}
\DoxyCodeLine{17070         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17071             listener-\/>testRunStarting( testRunInfo );}
\DoxyCodeLine{17072         \}}
\DoxyCodeLine{17073         m\_reporter-\/>testRunStarting( testRunInfo );}
\DoxyCodeLine{17074     \}}
\DoxyCodeLine{17075 }
\DoxyCodeLine{17076     \textcolor{keywordtype}{void} ListeningReporter::testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \{}
\DoxyCodeLine{17077         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17078             listener-\/>testGroupStarting( groupInfo );}
\DoxyCodeLine{17079         \}}
\DoxyCodeLine{17080         m\_reporter-\/>testGroupStarting( groupInfo );}
\DoxyCodeLine{17081     \}}
\DoxyCodeLine{17082 }
\DoxyCodeLine{17083     \textcolor{keywordtype}{void} ListeningReporter::testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{17084         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17085             listener-\/>testCaseStarting( testInfo );}
\DoxyCodeLine{17086         \}}
\DoxyCodeLine{17087         m\_reporter-\/>testCaseStarting( testInfo );}
\DoxyCodeLine{17088     \}}
\DoxyCodeLine{17089 }
\DoxyCodeLine{17090     \textcolor{keywordtype}{void} ListeningReporter::sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) \{}
\DoxyCodeLine{17091         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17092             listener-\/>sectionStarting( sectionInfo );}
\DoxyCodeLine{17093         \}}
\DoxyCodeLine{17094         m\_reporter-\/>sectionStarting( sectionInfo );}
\DoxyCodeLine{17095     \}}
\DoxyCodeLine{17096 }
\DoxyCodeLine{17097     \textcolor{keywordtype}{void} ListeningReporter::assertionStarting( AssertionInfo \textcolor{keyword}{const}\& assertionInfo ) \{}
\DoxyCodeLine{17098         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17099             listener-\/>assertionStarting( assertionInfo );}
\DoxyCodeLine{17100         \}}
\DoxyCodeLine{17101         m\_reporter-\/>assertionStarting( assertionInfo );}
\DoxyCodeLine{17102     \}}
\DoxyCodeLine{17103 }
\DoxyCodeLine{17104     \textcolor{comment}{// The return value indicates if the messages buffer should be cleared:}}
\DoxyCodeLine{17105     \textcolor{keywordtype}{bool} ListeningReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \{}
\DoxyCodeLine{17106         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17107             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}( listener-\/>assertionEnded( assertionStats ) );}
\DoxyCodeLine{17108         \}}
\DoxyCodeLine{17109         \textcolor{keywordflow}{return} m\_reporter-\/>assertionEnded( assertionStats );}
\DoxyCodeLine{17110     \}}
\DoxyCodeLine{17111 }
\DoxyCodeLine{17112     \textcolor{keywordtype}{void} ListeningReporter::sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) \{}
\DoxyCodeLine{17113         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17114             listener-\/>sectionEnded( sectionStats );}
\DoxyCodeLine{17115         \}}
\DoxyCodeLine{17116         m\_reporter-\/>sectionEnded( sectionStats );}
\DoxyCodeLine{17117     \}}
\DoxyCodeLine{17118 }
\DoxyCodeLine{17119     \textcolor{keywordtype}{void} ListeningReporter::testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \{}
\DoxyCodeLine{17120         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17121             listener-\/>testCaseEnded( testCaseStats );}
\DoxyCodeLine{17122         \}}
\DoxyCodeLine{17123         m\_reporter-\/>testCaseEnded( testCaseStats );}
\DoxyCodeLine{17124     \}}
\DoxyCodeLine{17125 }
\DoxyCodeLine{17126     \textcolor{keywordtype}{void} ListeningReporter::testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \{}
\DoxyCodeLine{17127         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17128             listener-\/>testGroupEnded( testGroupStats );}
\DoxyCodeLine{17129         \}}
\DoxyCodeLine{17130         m\_reporter-\/>testGroupEnded( testGroupStats );}
\DoxyCodeLine{17131     \}}
\DoxyCodeLine{17132 }
\DoxyCodeLine{17133     \textcolor{keywordtype}{void} ListeningReporter::testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) \{}
\DoxyCodeLine{17134         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17135             listener-\/>testRunEnded( testRunStats );}
\DoxyCodeLine{17136         \}}
\DoxyCodeLine{17137         m\_reporter-\/>testRunEnded( testRunStats );}
\DoxyCodeLine{17138     \}}
\DoxyCodeLine{17139 }
\DoxyCodeLine{17140     \textcolor{keywordtype}{void} ListeningReporter::skipTest( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{17141         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17142             listener-\/>skipTest( testInfo );}
\DoxyCodeLine{17143         \}}
\DoxyCodeLine{17144         m\_reporter-\/>skipTest( testInfo );}
\DoxyCodeLine{17145     \}}
\DoxyCodeLine{17146 }
\DoxyCodeLine{17147     \textcolor{keywordtype}{bool} ListeningReporter::isMulti()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{17148         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{17149     \}}
\DoxyCodeLine{17150 }
\DoxyCodeLine{17151 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{17152 \textcolor{comment}{// end catch\_reporter\_listening.cpp}}
\DoxyCodeLine{17153 \textcolor{comment}{// start catch\_reporter\_xml.cpp}}
\DoxyCodeLine{17154 }
\DoxyCodeLine{17155 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{17156 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{17157 \textcolor{preprocessor}{\#pragma warning(disable:4061) }\textcolor{comment}{// Not all labels are EXPLICITLY handled in switch}}
\DoxyCodeLine{17158                               \textcolor{comment}{// Note that 4062 (not all labels are handled}}
\DoxyCodeLine{17159                               \textcolor{comment}{// and default is missing) is enabled}}
\DoxyCodeLine{17160 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17161 }
\DoxyCodeLine{17162 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{17163     XmlReporter::XmlReporter( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{17164     :   StreamingReporterBase( \_config ),}
\DoxyCodeLine{17165         m\_xml(\_config.stream())}
\DoxyCodeLine{17166     \{}
\DoxyCodeLine{17167         m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{true};}
\DoxyCodeLine{17168         m\_reporterPrefs.shouldReportAllAssertions = \textcolor{keyword}{true};}
\DoxyCodeLine{17169     \}}
\DoxyCodeLine{17170 }
\DoxyCodeLine{17171     XmlReporter::\string~XmlReporter() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{17172 }
\DoxyCodeLine{17173     std::string XmlReporter::getDescription() \{}
\DoxyCodeLine{17174         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Reports test results as an XML document"{}};}
\DoxyCodeLine{17175     \}}
\DoxyCodeLine{17176 }
\DoxyCodeLine{17177     std::string XmlReporter::getStylesheetRef()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{17178         \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{17179     \}}
\DoxyCodeLine{17180 }
\DoxyCodeLine{17181     \textcolor{keywordtype}{void} XmlReporter::writeSourceInfo( SourceLineInfo \textcolor{keyword}{const}\& sourceInfo ) \{}
\DoxyCodeLine{17182         m\_xml}
\DoxyCodeLine{17183             .writeAttribute( \textcolor{stringliteral}{"{}filename"{}}, sourceInfo.file )}
\DoxyCodeLine{17184             .writeAttribute( \textcolor{stringliteral}{"{}line"{}}, sourceInfo.line );}
\DoxyCodeLine{17185     \}}
\DoxyCodeLine{17186 }
\DoxyCodeLine{17187     \textcolor{keywordtype}{void} XmlReporter::noMatchingTestCases( std::string \textcolor{keyword}{const}\& s ) \{}
\DoxyCodeLine{17188         StreamingReporterBase::noMatchingTestCases( s );}
\DoxyCodeLine{17189     \}}
\DoxyCodeLine{17190 }
\DoxyCodeLine{17191     \textcolor{keywordtype}{void} XmlReporter::testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{17192         StreamingReporterBase::testRunStarting( testInfo );}
\DoxyCodeLine{17193         std::string stylesheetRef = getStylesheetRef();}
\DoxyCodeLine{17194         \textcolor{keywordflow}{if}( !stylesheetRef.empty() )}
\DoxyCodeLine{17195             m\_xml.writeStylesheetRef( stylesheetRef );}
\DoxyCodeLine{17196         m\_xml.startElement( \textcolor{stringliteral}{"{}Catch"{}} );}
\DoxyCodeLine{17197         \textcolor{keywordflow}{if}( !m\_config-\/>name().empty() )}
\DoxyCodeLine{17198             m\_xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, m\_config-\/>name() );}
\DoxyCodeLine{17199         \textcolor{keywordflow}{if} (m\_config-\/>testSpec().hasFilters())}
\DoxyCodeLine{17200             m\_xml.writeAttribute( \textcolor{stringliteral}{"{}filters"{}}, serializeFilters( m\_config-\/>getTestsOrTags() ) );}
\DoxyCodeLine{17201         \textcolor{keywordflow}{if}( m\_config-\/>rngSeed() != 0 )}
\DoxyCodeLine{17202             m\_xml.scopedElement( \textcolor{stringliteral}{"{}Randomness"{}} )}
\DoxyCodeLine{17203                 .writeAttribute( \textcolor{stringliteral}{"{}seed"{}}, m\_config-\/>rngSeed() );}
\DoxyCodeLine{17204     \}}
\DoxyCodeLine{17205 }
\DoxyCodeLine{17206     \textcolor{keywordtype}{void} XmlReporter::testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \{}
\DoxyCodeLine{17207         StreamingReporterBase::testGroupStarting( groupInfo );}
\DoxyCodeLine{17208         m\_xml.startElement( \textcolor{stringliteral}{"{}Group"{}} )}
\DoxyCodeLine{17209             .writeAttribute( \textcolor{stringliteral}{"{}name"{}}, groupInfo.name );}
\DoxyCodeLine{17210     \}}
\DoxyCodeLine{17211 }
\DoxyCodeLine{17212     \textcolor{keywordtype}{void} XmlReporter::testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{17213         StreamingReporterBase::testCaseStarting(testInfo);}
\DoxyCodeLine{17214         m\_xml.startElement( \textcolor{stringliteral}{"{}TestCase"{}} )}
\DoxyCodeLine{17215             .writeAttribute( \textcolor{stringliteral}{"{}name"{}}, trim( testInfo.name ) )}
\DoxyCodeLine{17216             .writeAttribute( \textcolor{stringliteral}{"{}description"{}}, testInfo.description )}
\DoxyCodeLine{17217             .writeAttribute( \textcolor{stringliteral}{"{}tags"{}}, testInfo.tagsAsString() );}
\DoxyCodeLine{17218 }
\DoxyCodeLine{17219         writeSourceInfo( testInfo.lineInfo );}
\DoxyCodeLine{17220 }
\DoxyCodeLine{17221         \textcolor{keywordflow}{if} ( m\_config-\/>showDurations() == ShowDurations::Always )}
\DoxyCodeLine{17222             m\_testCaseTimer.start();}
\DoxyCodeLine{17223         m\_xml.ensureTagClosed();}
\DoxyCodeLine{17224     \}}
\DoxyCodeLine{17225 }
\DoxyCodeLine{17226     \textcolor{keywordtype}{void} XmlReporter::sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) \{}
\DoxyCodeLine{17227         StreamingReporterBase::sectionStarting( sectionInfo );}
\DoxyCodeLine{17228         \textcolor{keywordflow}{if}( m\_sectionDepth++ > 0 ) \{}
\DoxyCodeLine{17229             m\_xml.startElement( \textcolor{stringliteral}{"{}Section"{}} )}
\DoxyCodeLine{17230                 .writeAttribute( \textcolor{stringliteral}{"{}name"{}}, trim( sectionInfo.name ) );}
\DoxyCodeLine{17231             writeSourceInfo( sectionInfo.lineInfo );}
\DoxyCodeLine{17232             m\_xml.ensureTagClosed();}
\DoxyCodeLine{17233         \}}
\DoxyCodeLine{17234     \}}
\DoxyCodeLine{17235 }
\DoxyCodeLine{17236     \textcolor{keywordtype}{void} XmlReporter::assertionStarting( AssertionInfo \textcolor{keyword}{const}\& ) \{ \}}
\DoxyCodeLine{17237 }
\DoxyCodeLine{17238     \textcolor{keywordtype}{bool} XmlReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \{}
\DoxyCodeLine{17239 }
\DoxyCodeLine{17240         AssertionResult \textcolor{keyword}{const}\& result = assertionStats.assertionResult;}
\DoxyCodeLine{17241 }
\DoxyCodeLine{17242         \textcolor{keywordtype}{bool} includeResults = m\_config-\/>includeSuccessfulResults() || !result.isOk();}
\DoxyCodeLine{17243 }
\DoxyCodeLine{17244         \textcolor{keywordflow}{if}( includeResults || result.getResultType() == ResultWas::Warning ) \{}
\DoxyCodeLine{17245             \textcolor{comment}{// Print any info messages in <Info> tags.}}
\DoxyCodeLine{17246             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& msg : assertionStats.infoMessages ) \{}
\DoxyCodeLine{17247                 \textcolor{keywordflow}{if}( msg.type == ResultWas::Info \&\& includeResults ) \{}
\DoxyCodeLine{17248                     m\_xml.scopedElement( \textcolor{stringliteral}{"{}Info"{}} )}
\DoxyCodeLine{17249                             .writeText( msg.message );}
\DoxyCodeLine{17250                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( msg.type == ResultWas::Warning ) \{}
\DoxyCodeLine{17251                     m\_xml.scopedElement( \textcolor{stringliteral}{"{}Warning"{}} )}
\DoxyCodeLine{17252                             .writeText( msg.message );}
\DoxyCodeLine{17253                 \}}
\DoxyCodeLine{17254             \}}
\DoxyCodeLine{17255         \}}
\DoxyCodeLine{17256 }
\DoxyCodeLine{17257         \textcolor{comment}{// Drop out if result was successful but we're not printing them.}}
\DoxyCodeLine{17258         \textcolor{keywordflow}{if}( !includeResults \&\& result.getResultType() != ResultWas::Warning )}
\DoxyCodeLine{17259             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{17260 }
\DoxyCodeLine{17261         \textcolor{comment}{// Print the expression if there is one.}}
\DoxyCodeLine{17262         \textcolor{keywordflow}{if}( result.hasExpression() ) \{}
\DoxyCodeLine{17263             m\_xml.startElement( \textcolor{stringliteral}{"{}Expression"{}} )}
\DoxyCodeLine{17264                 .writeAttribute( \textcolor{stringliteral}{"{}success"{}}, result.succeeded() )}
\DoxyCodeLine{17265                 .writeAttribute( \textcolor{stringliteral}{"{}type"{}}, result.getTestMacroName() );}
\DoxyCodeLine{17266 }
\DoxyCodeLine{17267             writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{17268 }
\DoxyCodeLine{17269             m\_xml.scopedElement( \textcolor{stringliteral}{"{}Original"{}} )}
\DoxyCodeLine{17270                 .writeText( result.getExpression() );}
\DoxyCodeLine{17271             m\_xml.scopedElement( \textcolor{stringliteral}{"{}Expanded"{}} )}
\DoxyCodeLine{17272                 .writeText( result.getExpandedExpression() );}
\DoxyCodeLine{17273         \}}
\DoxyCodeLine{17274 }
\DoxyCodeLine{17275         \textcolor{comment}{// And... Print a result applicable to each result type.}}
\DoxyCodeLine{17276         \textcolor{keywordflow}{switch}( result.getResultType() ) \{}
\DoxyCodeLine{17277             \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{17278                 m\_xml.startElement( \textcolor{stringliteral}{"{}Exception"{}} );}
\DoxyCodeLine{17279                 writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{17280                 m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{17281                 m\_xml.endElement();}
\DoxyCodeLine{17282                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17283             \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{17284                 m\_xml.startElement( \textcolor{stringliteral}{"{}FatalErrorCondition"{}} );}
\DoxyCodeLine{17285                 writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{17286                 m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{17287                 m\_xml.endElement();}
\DoxyCodeLine{17288                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17289             \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{17290                 m\_xml.scopedElement( \textcolor{stringliteral}{"{}Info"{}} )}
\DoxyCodeLine{17291                     .writeText( result.getMessage() );}
\DoxyCodeLine{17292                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17293             \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{17294                 \textcolor{comment}{// Warning will already have been written}}
\DoxyCodeLine{17295                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17296             \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{17297                 m\_xml.startElement( \textcolor{stringliteral}{"{}Failure"{}} );}
\DoxyCodeLine{17298                 writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{17299                 m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{17300                 m\_xml.endElement();}
\DoxyCodeLine{17301                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17302             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{17303                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17304         \}}
\DoxyCodeLine{17305 }
\DoxyCodeLine{17306         \textcolor{keywordflow}{if}( result.hasExpression() )}
\DoxyCodeLine{17307             m\_xml.endElement();}
\DoxyCodeLine{17308 }
\DoxyCodeLine{17309         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{17310     \}}
\DoxyCodeLine{17311 }
\DoxyCodeLine{17312     \textcolor{keywordtype}{void} XmlReporter::sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) \{}
\DoxyCodeLine{17313         StreamingReporterBase::sectionEnded( sectionStats );}
\DoxyCodeLine{17314         \textcolor{keywordflow}{if}( -\/-\/m\_sectionDepth > 0 ) \{}
\DoxyCodeLine{17315             XmlWriter::ScopedElement e = m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResults"{}} );}
\DoxyCodeLine{17316             e.writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, sectionStats.assertions.passed );}
\DoxyCodeLine{17317             e.writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, sectionStats.assertions.failed );}
\DoxyCodeLine{17318             e.writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, sectionStats.assertions.failedButOk );}
\DoxyCodeLine{17319 }
\DoxyCodeLine{17320             \textcolor{keywordflow}{if} ( m\_config-\/>showDurations() == ShowDurations::Always )}
\DoxyCodeLine{17321                 e.writeAttribute( \textcolor{stringliteral}{"{}durationInSeconds"{}}, sectionStats.durationInSeconds );}
\DoxyCodeLine{17322 }
\DoxyCodeLine{17323             m\_xml.endElement();}
\DoxyCodeLine{17324         \}}
\DoxyCodeLine{17325     \}}
\DoxyCodeLine{17326 }
\DoxyCodeLine{17327     \textcolor{keywordtype}{void} XmlReporter::testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \{}
\DoxyCodeLine{17328         StreamingReporterBase::testCaseEnded( testCaseStats );}
\DoxyCodeLine{17329         XmlWriter::ScopedElement e = m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResult"{}} );}
\DoxyCodeLine{17330         e.writeAttribute( \textcolor{stringliteral}{"{}success"{}}, testCaseStats.totals.assertions.allOk() );}
\DoxyCodeLine{17331 }
\DoxyCodeLine{17332         \textcolor{keywordflow}{if} ( m\_config-\/>showDurations() == ShowDurations::Always )}
\DoxyCodeLine{17333             e.writeAttribute( \textcolor{stringliteral}{"{}durationInSeconds"{}}, m\_testCaseTimer.getElapsedSeconds() );}
\DoxyCodeLine{17334 }
\DoxyCodeLine{17335         \textcolor{keywordflow}{if}( !testCaseStats.stdOut.empty() )}
\DoxyCodeLine{17336             m\_xml.scopedElement( \textcolor{stringliteral}{"{}StdOut"{}} ).writeText( trim( testCaseStats.stdOut ), XmlFormatting::Newline );}
\DoxyCodeLine{17337         \textcolor{keywordflow}{if}( !testCaseStats.stdErr.empty() )}
\DoxyCodeLine{17338             m\_xml.scopedElement( \textcolor{stringliteral}{"{}StdErr"{}} ).writeText( trim( testCaseStats.stdErr ), XmlFormatting::Newline );}
\DoxyCodeLine{17339 }
\DoxyCodeLine{17340         m\_xml.endElement();}
\DoxyCodeLine{17341     \}}
\DoxyCodeLine{17342 }
\DoxyCodeLine{17343     \textcolor{keywordtype}{void} XmlReporter::testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \{}
\DoxyCodeLine{17344         StreamingReporterBase::testGroupEnded( testGroupStats );}
\DoxyCodeLine{17345         \textcolor{comment}{// TODO: Check testGroupStats.aborting and act accordingly.}}
\DoxyCodeLine{17346         m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResults"{}} )}
\DoxyCodeLine{17347             .writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, testGroupStats.totals.assertions.passed )}
\DoxyCodeLine{17348             .writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, testGroupStats.totals.assertions.failed )}
\DoxyCodeLine{17349             .writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, testGroupStats.totals.assertions.failedButOk );}
\DoxyCodeLine{17350         m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResultsCases"{}})}
\DoxyCodeLine{17351             .writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, testGroupStats.totals.testCases.passed )}
\DoxyCodeLine{17352             .writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, testGroupStats.totals.testCases.failed )}
\DoxyCodeLine{17353             .writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, testGroupStats.totals.testCases.failedButOk );}
\DoxyCodeLine{17354         m\_xml.endElement();}
\DoxyCodeLine{17355     \}}
\DoxyCodeLine{17356 }
\DoxyCodeLine{17357     \textcolor{keywordtype}{void} XmlReporter::testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) \{}
\DoxyCodeLine{17358         StreamingReporterBase::testRunEnded( testRunStats );}
\DoxyCodeLine{17359         m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResults"{}} )}
\DoxyCodeLine{17360             .writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, testRunStats.totals.assertions.passed )}
\DoxyCodeLine{17361             .writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, testRunStats.totals.assertions.failed )}
\DoxyCodeLine{17362             .writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, testRunStats.totals.assertions.failedButOk );}
\DoxyCodeLine{17363         m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResultsCases"{}})}
\DoxyCodeLine{17364             .writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, testRunStats.totals.testCases.passed )}
\DoxyCodeLine{17365             .writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, testRunStats.totals.testCases.failed )}
\DoxyCodeLine{17366             .writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, testRunStats.totals.testCases.failedButOk );}
\DoxyCodeLine{17367         m\_xml.endElement();}
\DoxyCodeLine{17368     \}}
\DoxyCodeLine{17369 }
\DoxyCodeLine{17370 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{17371     \textcolor{keywordtype}{void} XmlReporter::benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \{}
\DoxyCodeLine{17372         m\_xml.startElement(\textcolor{stringliteral}{"{}BenchmarkResults"{}})}
\DoxyCodeLine{17373             .writeAttribute(\textcolor{stringliteral}{"{}name"{}}, name);}
\DoxyCodeLine{17374     \}}
\DoxyCodeLine{17375 }
\DoxyCodeLine{17376     \textcolor{keywordtype}{void} XmlReporter::benchmarkStarting(BenchmarkInfo \textcolor{keyword}{const} \&info) \{}
\DoxyCodeLine{17377         m\_xml.writeAttribute(\textcolor{stringliteral}{"{}samples"{}}, info.samples)}
\DoxyCodeLine{17378             .writeAttribute(\textcolor{stringliteral}{"{}resamples"{}}, info.resamples)}
\DoxyCodeLine{17379             .writeAttribute(\textcolor{stringliteral}{"{}iterations"{}}, info.iterations)}
\DoxyCodeLine{17380             .writeAttribute(\textcolor{stringliteral}{"{}clockResolution"{}}, info.clockResolution)}
\DoxyCodeLine{17381             .writeAttribute(\textcolor{stringliteral}{"{}estimatedDuration"{}}, info.estimatedDuration)}
\DoxyCodeLine{17382             .writeComment(\textcolor{stringliteral}{"{}All values in nano seconds"{}});}
\DoxyCodeLine{17383     \}}
\DoxyCodeLine{17384 }
\DoxyCodeLine{17385     \textcolor{keywordtype}{void} XmlReporter::benchmarkEnded(BenchmarkStats<> \textcolor{keyword}{const}\& benchmarkStats) \{}
\DoxyCodeLine{17386         m\_xml.startElement(\textcolor{stringliteral}{"{}mean"{}})}
\DoxyCodeLine{17387             .writeAttribute(\textcolor{stringliteral}{"{}value"{}}, benchmarkStats.mean.point.count())}
\DoxyCodeLine{17388             .writeAttribute(\textcolor{stringliteral}{"{}lowerBound"{}}, benchmarkStats.mean.lower\_bound.count())}
\DoxyCodeLine{17389             .writeAttribute(\textcolor{stringliteral}{"{}upperBound"{}}, benchmarkStats.mean.upper\_bound.count())}
\DoxyCodeLine{17390             .writeAttribute(\textcolor{stringliteral}{"{}ci"{}}, benchmarkStats.mean.confidence\_interval);}
\DoxyCodeLine{17391         m\_xml.endElement();}
\DoxyCodeLine{17392         m\_xml.startElement(\textcolor{stringliteral}{"{}standardDeviation"{}})}
\DoxyCodeLine{17393             .writeAttribute(\textcolor{stringliteral}{"{}value"{}}, benchmarkStats.standardDeviation.point.count())}
\DoxyCodeLine{17394             .writeAttribute(\textcolor{stringliteral}{"{}lowerBound"{}}, benchmarkStats.standardDeviation.lower\_bound.count())}
\DoxyCodeLine{17395             .writeAttribute(\textcolor{stringliteral}{"{}upperBound"{}}, benchmarkStats.standardDeviation.upper\_bound.count())}
\DoxyCodeLine{17396             .writeAttribute(\textcolor{stringliteral}{"{}ci"{}}, benchmarkStats.standardDeviation.confidence\_interval);}
\DoxyCodeLine{17397         m\_xml.endElement();}
\DoxyCodeLine{17398         m\_xml.startElement(\textcolor{stringliteral}{"{}outliers"{}})}
\DoxyCodeLine{17399             .writeAttribute(\textcolor{stringliteral}{"{}variance"{}}, benchmarkStats.outlierVariance)}
\DoxyCodeLine{17400             .writeAttribute(\textcolor{stringliteral}{"{}lowMild"{}}, benchmarkStats.outliers.low\_mild)}
\DoxyCodeLine{17401             .writeAttribute(\textcolor{stringliteral}{"{}lowSevere"{}}, benchmarkStats.outliers.low\_severe)}
\DoxyCodeLine{17402             .writeAttribute(\textcolor{stringliteral}{"{}highMild"{}}, benchmarkStats.outliers.high\_mild)}
\DoxyCodeLine{17403             .writeAttribute(\textcolor{stringliteral}{"{}highSevere"{}}, benchmarkStats.outliers.high\_severe);}
\DoxyCodeLine{17404         m\_xml.endElement();}
\DoxyCodeLine{17405         m\_xml.endElement();}
\DoxyCodeLine{17406     \}}
\DoxyCodeLine{17407 }
\DoxyCodeLine{17408     \textcolor{keywordtype}{void} XmlReporter::benchmarkFailed(std::string \textcolor{keyword}{const} \&error) \{}
\DoxyCodeLine{17409         m\_xml.scopedElement(\textcolor{stringliteral}{"{}failed"{}}).}
\DoxyCodeLine{17410             writeAttribute(\textcolor{stringliteral}{"{}message"{}}, error);}
\DoxyCodeLine{17411         m\_xml.endElement();}
\DoxyCodeLine{17412     \}}
\DoxyCodeLine{17413 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{17414 }
\DoxyCodeLine{17415     CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"{}xml"{}}, XmlReporter )}
\DoxyCodeLine{17416 }
\DoxyCodeLine{17417 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{17418 }
\DoxyCodeLine{17419 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{17420 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{17421 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17422 \textcolor{comment}{// end catch\_reporter\_xml.cpp}}
\DoxyCodeLine{17423 }
\DoxyCodeLine{17424 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{17425     LeakDetector leakDetector;}
\DoxyCodeLine{17426 \}}
\DoxyCodeLine{17427 }
\DoxyCodeLine{17428 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{17429 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{17430 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17431 }
\DoxyCodeLine{17432 \textcolor{comment}{// end catch\_impl.hpp}}
\DoxyCodeLine{17433 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17434 }
\DoxyCodeLine{17435 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_MAIN}}
\DoxyCodeLine{17436 \textcolor{comment}{// start catch\_default\_main.hpp}}
\DoxyCodeLine{17437 }
\DoxyCodeLine{17438 \textcolor{preprocessor}{\#ifndef \_\_OBJC\_\_}}
\DoxyCodeLine{17439 }
\DoxyCodeLine{17440 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_WCHAR) \&\& defined(CATCH\_PLATFORM\_WINDOWS) \&\& defined(\_UNICODE) \&\& !defined(DO\_NOT\_USE\_WMAIN)}}
\DoxyCodeLine{17441 \textcolor{comment}{// Standard C/C++ Win32 Unicode wmain entry point}}
\DoxyCodeLine{17442 \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \textcolor{keywordtype}{int} wmain (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} * argv[], \textcolor{keywordtype}{wchar\_t} * []) \{}
\DoxyCodeLine{17443 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17444 \textcolor{comment}{// Standard C/C++ main entry point}}
\DoxyCodeLine{17445 \textcolor{keywordtype}{int} main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} * argv[]) \{}
\DoxyCodeLine{17446 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17447 }
\DoxyCodeLine{17448     \textcolor{keywordflow}{return} Catch::Session().run( argc, argv );}
\DoxyCodeLine{17449 \}}
\DoxyCodeLine{17450 }
\DoxyCodeLine{17451 \textcolor{preprocessor}{\#else }\textcolor{comment}{// \_\_OBJC\_\_}}
\DoxyCodeLine{17452 }
\DoxyCodeLine{17453 \textcolor{comment}{// Objective-\/C entry point}}
\DoxyCodeLine{17454 \textcolor{keywordtype}{int} main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} * \textcolor{keyword}{const} argv[]) \{}
\DoxyCodeLine{17455 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{17456     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];}
\DoxyCodeLine{17457 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17458 }
\DoxyCodeLine{17459     Catch::registerTestMethods();}
\DoxyCodeLine{17460     \textcolor{keywordtype}{int} result = Catch::Session().run( argc, (\textcolor{keywordtype}{char}**)argv );}
\DoxyCodeLine{17461 }
\DoxyCodeLine{17462 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{17463     [pool drain];}
\DoxyCodeLine{17464 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17465 }
\DoxyCodeLine{17466     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{17467 \}}
\DoxyCodeLine{17468 }
\DoxyCodeLine{17469 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_OBJC\_\_}}
\DoxyCodeLine{17470 }
\DoxyCodeLine{17471 \textcolor{comment}{// end catch\_default\_main.hpp}}
\DoxyCodeLine{17472 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17473 }
\DoxyCodeLine{17474 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_IMPL\_ONLY)}}
\DoxyCodeLine{17475 }
\DoxyCodeLine{17476 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_MAIN\_NOT\_DEFINED}}
\DoxyCodeLine{17477 \textcolor{preprocessor}{\#  undef CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{17478 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17479 }
\DoxyCodeLine{17480 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{17482 \textcolor{comment}{// If this config identifier is defined then all CATCH macros are prefixed with CATCH\_}}
\DoxyCodeLine{17483 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_PREFIX\_ALL}}
\DoxyCodeLine{17484 }
\DoxyCodeLine{17485 \textcolor{preprocessor}{\#define CATCH\_REQUIRE( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_REQUIRE"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17486 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_REQUIRE\_FALSE"{}}, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17487 }
\DoxyCodeLine{17488 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS( ... ) INTERNAL\_CATCH\_THROWS( "{}CATCH\_REQUIRE\_THROWS"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17489 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}CATCH\_REQUIRE\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::Normal, expr )}
\DoxyCodeLine{17490 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "{}CATCH\_REQUIRE\_THROWS\_WITH"{}}, Catch::ResultDisposition::Normal, matcher, expr )}
\DoxyCodeLine{17491 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17492 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "{}CATCH\_REQUIRE\_THROWS\_MATCHES"{}}, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )}
\DoxyCodeLine{17493 \textcolor{preprocessor}{\#endif}\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17494 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "{}CATCH\_REQUIRE\_NOTHROW"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17495 }
\DoxyCodeLine{17496 \textcolor{preprocessor}{\#define CATCH\_CHECK( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_CHECK"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17497 \textcolor{preprocessor}{\#define CATCH\_CHECK\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_CHECK\_FALSE"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17498 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_IF( ... ) INTERNAL\_CATCH\_IF( "{}CATCH\_CHECKED\_IF"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17499 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_ELSE( ... ) INTERNAL\_CATCH\_ELSE( "{}CATCH\_CHECKED\_ELSE"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17500 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOFAIL( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_CHECK\_NOFAIL"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17501 }
\DoxyCodeLine{17502 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS( ... )  INTERNAL\_CATCH\_THROWS( "{}CATCH\_CHECK\_THROWS"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17503 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}CATCH\_CHECK\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{17504 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "{}CATCH\_CHECK\_THROWS\_WITH"{}}, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}
\DoxyCodeLine{17505 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17506 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "{}CATCH\_CHECK\_THROWS\_MATCHES"{}}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}
\DoxyCodeLine{17507 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17508 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "{}CATCH\_CHECK\_NOTHROW"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17509 }
\DoxyCodeLine{17510 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17511 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}CATCH\_CHECK\_THAT"{}}, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )}
\DoxyCodeLine{17512 }
\DoxyCodeLine{17513 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}CATCH\_REQUIRE\_THAT"{}}, matcher, Catch::ResultDisposition::Normal, arg )}
\DoxyCodeLine{17514 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17515 }
\DoxyCodeLine{17516 \textcolor{preprocessor}{\#define CATCH\_INFO( msg ) INTERNAL\_CATCH\_INFO( "{}CATCH\_INFO"{}}, msg )}
\DoxyCodeLine{17517 \textcolor{preprocessor}{\#define CATCH\_UNSCOPED\_INFO( msg ) INTERNAL\_CATCH\_UNSCOPED\_INFO( "{}CATCH\_UNSCOPED\_INFO"{}}, msg )}
\DoxyCodeLine{17518 \textcolor{preprocessor}{\#define CATCH\_WARN( msg ) INTERNAL\_CATCH\_MSG( "{}CATCH\_WARN"{}}, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )}
\DoxyCodeLine{17519 \textcolor{preprocessor}{\#define CATCH\_CAPTURE( ... ) INTERNAL\_CATCH\_CAPTURE( INTERNAL\_CATCH\_UNIQUE\_NAME(capturer), "{}CATCH\_CAPTURE"{}},\_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17520 }
\DoxyCodeLine{17521 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TESTCASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17522 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17523 \textcolor{preprocessor}{\#define CATCH\_METHOD\_AS\_TEST\_CASE( method, ... ) INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( method, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17524 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_TEST\_CASE( Function, ... ) INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17525 \textcolor{preprocessor}{\#define CATCH\_SECTION( ... ) INTERNAL\_CATCH\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17526 \textcolor{preprocessor}{\#define CATCH\_DYNAMIC\_SECTION( ... ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17527 \textcolor{preprocessor}{\#define CATCH\_FAIL( ... ) INTERNAL\_CATCH\_MSG( "{}CATCH\_FAIL"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17528 \textcolor{preprocessor}{\#define CATCH\_FAIL\_CHECK( ... ) INTERNAL\_CATCH\_MSG( "{}CATCH\_FAIL\_CHECK"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17529 \textcolor{preprocessor}{\#define CATCH\_SUCCEED( ... ) INTERNAL\_CATCH\_MSG( "{}CATCH\_SUCCEED"{}}, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17530 }
\DoxyCodeLine{17531 \textcolor{preprocessor}{\#define CATCH\_ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE()}}
\DoxyCodeLine{17532 }
\DoxyCodeLine{17533 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{17534 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17535 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17536 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17537 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17538 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17539 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17540 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17541 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17542 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17543 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17544 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17545 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17546 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17547 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17548 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17549 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17550 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17551 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17552 }
\DoxyCodeLine{17553 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_RUNTIME\_STATIC\_REQUIRE)}}
\DoxyCodeLine{17554 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE( ... )       static\_assert(   \_\_VA\_ARGS\_\_ ,      \#\_\_VA\_ARGS\_\_ );     CATCH\_SUCCEED( \#\_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17555 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE\_FALSE( ... ) static\_assert( !(\_\_VA\_ARGS\_\_), "{}!("{}} \#\_\_VA\_ARGS\_\_ "{})"{} ); CATCH\_SUCCEED( \#\_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17556 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17557 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE( ... )       CATCH\_REQUIRE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17558 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE\_FALSE( ... ) CATCH\_REQUIRE\_FALSE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17559 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17560 }
\DoxyCodeLine{17561 \textcolor{comment}{// "{}BDD-\/style"{} convenience wrappers}}
\DoxyCodeLine{17562 \textcolor{preprocessor}{\#define CATCH\_SCENARIO( ... ) CATCH\_TEST\_CASE( "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17563 \textcolor{preprocessor}{\#define CATCH\_SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17564 \textcolor{preprocessor}{\#define CATCH\_GIVEN( desc )     INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}    Given: "{}} << desc )}
\DoxyCodeLine{17565 \textcolor{preprocessor}{\#define CATCH\_AND\_GIVEN( desc ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}And given: "{}} << desc )}
\DoxyCodeLine{17566 \textcolor{preprocessor}{\#define CATCH\_WHEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}     When: "{}} << desc )}
\DoxyCodeLine{17567 \textcolor{preprocessor}{\#define CATCH\_AND\_WHEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{} And when: "{}} << desc )}
\DoxyCodeLine{17568 \textcolor{preprocessor}{\#define CATCH\_THEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}     Then: "{}} << desc )}
\DoxyCodeLine{17569 \textcolor{preprocessor}{\#define CATCH\_AND\_THEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}      And: "{}} << desc )}
\DoxyCodeLine{17570 }
\DoxyCodeLine{17571 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{17572 \textcolor{preprocessor}{\#define CATCH\_BENCHMARK(...) \(\backslash\)}}
\DoxyCodeLine{17573 \textcolor{preprocessor}{    INTERNAL\_CATCH\_BENCHMARK(INTERNAL\_CATCH\_UNIQUE\_NAME(\_\_\_\_C\_A\_T\_C\_H\_\_\_\_B\_E\_N\_C\_H\_\_\_\_), INTERNAL\_CATCH\_GET\_1\_ARG(\_\_VA\_ARGS\_\_,,), INTERNAL\_CATCH\_GET\_2\_ARG(\_\_VA\_ARGS\_\_,,))}}
\DoxyCodeLine{17574 \textcolor{preprocessor}{\#define CATCH\_BENCHMARK\_ADVANCED(name) \(\backslash\)}}
\DoxyCodeLine{17575 \textcolor{preprocessor}{    INTERNAL\_CATCH\_BENCHMARK\_ADVANCED(INTERNAL\_CATCH\_UNIQUE\_NAME(\_\_\_\_C\_A\_T\_C\_H\_\_\_\_B\_E\_N\_C\_H\_\_\_\_), name)}}
\DoxyCodeLine{17576 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{17577 }
\DoxyCodeLine{17578 \textcolor{comment}{// If CATCH\_CONFIG\_PREFIX\_ALL is not defined then the CATCH\_ prefix is not required}}
\DoxyCodeLine{17579 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17580 }
\DoxyCodeLine{17581 \textcolor{preprocessor}{\#define REQUIRE( ... ) INTERNAL\_CATCH\_TEST( "{}REQUIRE"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_  )}
\DoxyCodeLine{17582 \textcolor{preprocessor}{\#define REQUIRE\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "{}REQUIRE\_FALSE"{}}, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17583 }
\DoxyCodeLine{17584 \textcolor{preprocessor}{\#define REQUIRE\_THROWS( ... ) INTERNAL\_CATCH\_THROWS( "{}REQUIRE\_THROWS"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17585 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}REQUIRE\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::Normal, expr )}
\DoxyCodeLine{17586 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "{}REQUIRE\_THROWS\_WITH"{}}, Catch::ResultDisposition::Normal, matcher, expr )}
\DoxyCodeLine{17587 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17588 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "{}REQUIRE\_THROWS\_MATCHES"{}}, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )}
\DoxyCodeLine{17589 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17590 \textcolor{preprocessor}{\#define REQUIRE\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "{}REQUIRE\_NOTHROW"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17591 }
\DoxyCodeLine{17592 \textcolor{preprocessor}{\#define CHECK( ... ) INTERNAL\_CATCH\_TEST( "{}CHECK"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17593 \textcolor{preprocessor}{\#define CHECK\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "{}CHECK\_FALSE"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17594 \textcolor{preprocessor}{\#define CHECKED\_IF( ... ) INTERNAL\_CATCH\_IF( "{}CHECKED\_IF"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17595 \textcolor{preprocessor}{\#define CHECKED\_ELSE( ... ) INTERNAL\_CATCH\_ELSE( "{}CHECKED\_ELSE"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17596 \textcolor{preprocessor}{\#define CHECK\_NOFAIL( ... ) INTERNAL\_CATCH\_TEST( "{}CHECK\_NOFAIL"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17597 }
\DoxyCodeLine{17598 \textcolor{preprocessor}{\#define CHECK\_THROWS( ... )  INTERNAL\_CATCH\_THROWS( "{}CHECK\_THROWS"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17599 \textcolor{preprocessor}{\#define CHECK\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}CHECK\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{17600 \textcolor{preprocessor}{\#define CHECK\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "{}CHECK\_THROWS\_WITH"{}}, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}
\DoxyCodeLine{17601 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17602 \textcolor{preprocessor}{\#define CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "{}CHECK\_THROWS\_MATCHES"{}}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}
\DoxyCodeLine{17603 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17604 \textcolor{preprocessor}{\#define CHECK\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "{}CHECK\_NOTHROW"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17605 }
\DoxyCodeLine{17606 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17607 \textcolor{preprocessor}{\#define CHECK\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}CHECK\_THAT"{}}, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )}
\DoxyCodeLine{17608 }
\DoxyCodeLine{17609 \textcolor{preprocessor}{\#define REQUIRE\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}REQUIRE\_THAT"{}}, matcher, Catch::ResultDisposition::Normal, arg )}
\DoxyCodeLine{17610 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17611 }
\DoxyCodeLine{17612 \textcolor{preprocessor}{\#define INFO( msg ) INTERNAL\_CATCH\_INFO( "{}INFO"{}}, msg )}
\DoxyCodeLine{17613 \textcolor{preprocessor}{\#define UNSCOPED\_INFO( msg ) INTERNAL\_CATCH\_UNSCOPED\_INFO( "{}UNSCOPED\_INFO"{}}, msg )}
\DoxyCodeLine{17614 \textcolor{preprocessor}{\#define WARN( msg ) INTERNAL\_CATCH\_MSG( "{}WARN"{}}, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )}
\DoxyCodeLine{17615 \textcolor{preprocessor}{\#define CAPTURE( ... ) INTERNAL\_CATCH\_CAPTURE( INTERNAL\_CATCH\_UNIQUE\_NAME(capturer), "{}CAPTURE"{}},\_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17616 }
\DoxyCodeLine{17617 \textcolor{preprocessor}{\#define TEST\_CASE( ... ) INTERNAL\_CATCH\_TESTCASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17618 \textcolor{preprocessor}{\#define TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17619 \textcolor{preprocessor}{\#define METHOD\_AS\_TEST\_CASE( method, ... ) INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( method, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17620 \textcolor{preprocessor}{\#define REGISTER\_TEST\_CASE( Function, ... ) INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17621 \textcolor{preprocessor}{\#define SECTION( ... ) INTERNAL\_CATCH\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17622 \textcolor{preprocessor}{\#define DYNAMIC\_SECTION( ... ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17623 \textcolor{preprocessor}{\#define FAIL( ... ) INTERNAL\_CATCH\_MSG( "{}FAIL"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17624 \textcolor{preprocessor}{\#define FAIL\_CHECK( ... ) INTERNAL\_CATCH\_MSG( "{}FAIL\_CHECK"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17625 \textcolor{preprocessor}{\#define SUCCEED( ... ) INTERNAL\_CATCH\_MSG( "{}SUCCEED"{}}, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17626 \textcolor{preprocessor}{\#define ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE()}}
\DoxyCodeLine{17627 }
\DoxyCodeLine{17628 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{17629 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17630 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17631 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17632 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17633 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17634 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17635 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17636 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17637 \textcolor{preprocessor}{\#define TEMPLATE\_LIST\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17638 \textcolor{preprocessor}{\#define TEMPLATE\_LIST\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17639 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17640 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17641 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17642 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17643 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17644 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17645 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17646 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17647 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17648 \textcolor{preprocessor}{\#define TEMPLATE\_LIST\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17649 \textcolor{preprocessor}{\#define TEMPLATE\_LIST\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17650 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17651 }
\DoxyCodeLine{17652 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_RUNTIME\_STATIC\_REQUIRE)}}
\DoxyCodeLine{17653 \textcolor{preprocessor}{\#define STATIC\_REQUIRE( ... )       static\_assert(   \_\_VA\_ARGS\_\_,  \#\_\_VA\_ARGS\_\_ ); SUCCEED( \#\_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17654 \textcolor{preprocessor}{\#define STATIC\_REQUIRE\_FALSE( ... ) static\_assert( !(\_\_VA\_ARGS\_\_), "{}!("{}} \#\_\_VA\_ARGS\_\_ "{})"{} ); SUCCEED( "{}!("{} \#\_\_VA\_ARGS\_\_ "{})"{} )}
\DoxyCodeLine{17655 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17656 \textcolor{preprocessor}{\#define STATIC\_REQUIRE( ... )       REQUIRE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17657 \textcolor{preprocessor}{\#define STATIC\_REQUIRE\_FALSE( ... ) REQUIRE\_FALSE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17658 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17659 }
\DoxyCodeLine{17660 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17661 }
\DoxyCodeLine{17662 \textcolor{preprocessor}{\#define CATCH\_TRANSLATE\_EXCEPTION( signature ) INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION( signature )}}
\DoxyCodeLine{17663 }
\DoxyCodeLine{17664 \textcolor{comment}{// "{}BDD-\/style"{} convenience wrappers}}
\DoxyCodeLine{17665 \textcolor{preprocessor}{\#define SCENARIO( ... ) TEST\_CASE( "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17666 \textcolor{preprocessor}{\#define SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17667 }
\DoxyCodeLine{17668 \textcolor{preprocessor}{\#define GIVEN( desc )     INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}    Given: "{}} << desc )}
\DoxyCodeLine{17669 \textcolor{preprocessor}{\#define AND\_GIVEN( desc ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}And given: "{}} << desc )}
\DoxyCodeLine{17670 \textcolor{preprocessor}{\#define WHEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}     When: "{}} << desc )}
\DoxyCodeLine{17671 \textcolor{preprocessor}{\#define AND\_WHEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{} And when: "{}} << desc )}
\DoxyCodeLine{17672 \textcolor{preprocessor}{\#define THEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}     Then: "{}} << desc )}
\DoxyCodeLine{17673 \textcolor{preprocessor}{\#define AND\_THEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}      And: "{}} << desc )}
\DoxyCodeLine{17674 }
\DoxyCodeLine{17675 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{17676 \textcolor{preprocessor}{\#define BENCHMARK(...) \(\backslash\)}}
\DoxyCodeLine{17677 \textcolor{preprocessor}{    INTERNAL\_CATCH\_BENCHMARK(INTERNAL\_CATCH\_UNIQUE\_NAME(\_\_\_\_C\_A\_T\_C\_H\_\_\_\_B\_E\_N\_C\_H\_\_\_\_), INTERNAL\_CATCH\_GET\_1\_ARG(\_\_VA\_ARGS\_\_,,), INTERNAL\_CATCH\_GET\_2\_ARG(\_\_VA\_ARGS\_\_,,))}}
\DoxyCodeLine{17678 \textcolor{preprocessor}{\#define BENCHMARK\_ADVANCED(name) \(\backslash\)}}
\DoxyCodeLine{17679 \textcolor{preprocessor}{    INTERNAL\_CATCH\_BENCHMARK\_ADVANCED(INTERNAL\_CATCH\_UNIQUE\_NAME(\_\_\_\_C\_A\_T\_C\_H\_\_\_\_B\_E\_N\_C\_H\_\_\_\_), name)}}
\DoxyCodeLine{17680 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{17681 }
\DoxyCodeLine{17682 \textcolor{keyword}{using} \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Catch::Detail::Approx}};}
\DoxyCodeLine{17683 }
\DoxyCodeLine{17684 \textcolor{preprocessor}{\#else }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{17685 }
\DoxyCodeLine{17687 \textcolor{comment}{// If this config identifier is defined then all CATCH macros are prefixed with CATCH\_}}
\DoxyCodeLine{17688 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_PREFIX\_ALL}}
\DoxyCodeLine{17689 }
\DoxyCodeLine{17690 \textcolor{preprocessor}{\#define CATCH\_REQUIRE( ... )        (void)(0)}}
\DoxyCodeLine{17691 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_FALSE( ... )  (void)(0)}}
\DoxyCodeLine{17692 }
\DoxyCodeLine{17693 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS( ... ) (void)(0)}}
\DoxyCodeLine{17694 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{17695 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_WITH( expr, matcher )     (void)(0)}}
\DoxyCodeLine{17696 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17697 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{17698 \textcolor{preprocessor}{\#endif}\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17699 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{17700 }
\DoxyCodeLine{17701 \textcolor{preprocessor}{\#define CATCH\_CHECK( ... )         (void)(0)}}
\DoxyCodeLine{17702 \textcolor{preprocessor}{\#define CATCH\_CHECK\_FALSE( ... )   (void)(0)}}
\DoxyCodeLine{17703 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_IF( ... )    if (\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17704 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_ELSE( ... )  if (!(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{17705 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOFAIL( ... )  (void)(0)}}
\DoxyCodeLine{17706 }
\DoxyCodeLine{17707 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS( ... )  (void)(0)}}
\DoxyCodeLine{17708 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{17709 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_WITH( expr, matcher )     (void)(0)}}
\DoxyCodeLine{17710 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17711 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{17712 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17713 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{17714 }
\DoxyCodeLine{17715 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17716 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THAT( arg, matcher )   (void)(0)}}
\DoxyCodeLine{17717 }
\DoxyCodeLine{17718 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THAT( arg, matcher ) (void)(0)}}
\DoxyCodeLine{17719 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17720 }
\DoxyCodeLine{17721 \textcolor{preprocessor}{\#define CATCH\_INFO( msg )          (void)(0)}}
\DoxyCodeLine{17722 \textcolor{preprocessor}{\#define CATCH\_UNSCOPED\_INFO( msg ) (void)(0)}}
\DoxyCodeLine{17723 \textcolor{preprocessor}{\#define CATCH\_WARN( msg )          (void)(0)}}
\DoxyCodeLine{17724 \textcolor{preprocessor}{\#define CATCH\_CAPTURE( msg )       (void)(0)}}
\DoxyCodeLine{17725 }
\DoxyCodeLine{17726 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{17727 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{17728 \textcolor{preprocessor}{\#define CATCH\_METHOD\_AS\_TEST\_CASE( method, ... )}}
\DoxyCodeLine{17729 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_TEST\_CASE( Function, ... ) (void)(0)}}
\DoxyCodeLine{17730 \textcolor{preprocessor}{\#define CATCH\_SECTION( ... )}}
\DoxyCodeLine{17731 \textcolor{preprocessor}{\#define CATCH\_DYNAMIC\_SECTION( ... )}}
\DoxyCodeLine{17732 \textcolor{preprocessor}{\#define CATCH\_FAIL( ... ) (void)(0)}}
\DoxyCodeLine{17733 \textcolor{preprocessor}{\#define CATCH\_FAIL\_CHECK( ... ) (void)(0)}}
\DoxyCodeLine{17734 \textcolor{preprocessor}{\#define CATCH\_SUCCEED( ... ) (void)(0)}}
\DoxyCodeLine{17735 }
\DoxyCodeLine{17736 \textcolor{preprocessor}{\#define CATCH\_ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{17737 }
\DoxyCodeLine{17738 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{17739 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17740 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17741 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17742 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17743 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17744 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17745 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17746 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17747 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17748 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_) )}}
\DoxyCodeLine{17749 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_) )}}
\DoxyCodeLine{17750 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17751 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17752 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17753 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17754 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17755 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17756 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17757 }
\DoxyCodeLine{17758 \textcolor{comment}{// "{}BDD-\/style"{} convenience wrappers}}
\DoxyCodeLine{17759 \textcolor{preprocessor}{\#define CATCH\_SCENARIO( ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{17760 \textcolor{preprocessor}{\#define CATCH\_SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_METHOD\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), className )}}
\DoxyCodeLine{17761 \textcolor{preprocessor}{\#define CATCH\_GIVEN( desc )}}
\DoxyCodeLine{17762 \textcolor{preprocessor}{\#define CATCH\_AND\_GIVEN( desc )}}
\DoxyCodeLine{17763 \textcolor{preprocessor}{\#define CATCH\_WHEN( desc )}}
\DoxyCodeLine{17764 \textcolor{preprocessor}{\#define CATCH\_AND\_WHEN( desc )}}
\DoxyCodeLine{17765 \textcolor{preprocessor}{\#define CATCH\_THEN( desc )}}
\DoxyCodeLine{17766 \textcolor{preprocessor}{\#define CATCH\_AND\_THEN( desc )}}
\DoxyCodeLine{17767 }
\DoxyCodeLine{17768 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE( ... )       (void)(0)}}
\DoxyCodeLine{17769 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{17770 }
\DoxyCodeLine{17771 \textcolor{comment}{// If CATCH\_CONFIG\_PREFIX\_ALL is not defined then the CATCH\_ prefix is not required}}
\DoxyCodeLine{17772 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17773 }
\DoxyCodeLine{17774 \textcolor{preprocessor}{\#define REQUIRE( ... )       (void)(0)}}
\DoxyCodeLine{17775 \textcolor{preprocessor}{\#define REQUIRE\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{17776 }
\DoxyCodeLine{17777 \textcolor{preprocessor}{\#define REQUIRE\_THROWS( ... ) (void)(0)}}
\DoxyCodeLine{17778 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{17779 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_WITH( expr, matcher ) (void)(0)}}
\DoxyCodeLine{17780 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17781 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{17782 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17783 \textcolor{preprocessor}{\#define REQUIRE\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{17784 }
\DoxyCodeLine{17785 \textcolor{preprocessor}{\#define CHECK( ... ) (void)(0)}}
\DoxyCodeLine{17786 \textcolor{preprocessor}{\#define CHECK\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{17787 \textcolor{preprocessor}{\#define CHECKED\_IF( ... ) if (\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17788 \textcolor{preprocessor}{\#define CHECKED\_ELSE( ... ) if (!(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{17789 \textcolor{preprocessor}{\#define CHECK\_NOFAIL( ... ) (void)(0)}}
\DoxyCodeLine{17790 }
\DoxyCodeLine{17791 \textcolor{preprocessor}{\#define CHECK\_THROWS( ... )  (void)(0)}}
\DoxyCodeLine{17792 \textcolor{preprocessor}{\#define CHECK\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{17793 \textcolor{preprocessor}{\#define CHECK\_THROWS\_WITH( expr, matcher ) (void)(0)}}
\DoxyCodeLine{17794 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17795 \textcolor{preprocessor}{\#define CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{17796 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17797 \textcolor{preprocessor}{\#define CHECK\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{17798 }
\DoxyCodeLine{17799 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17800 \textcolor{preprocessor}{\#define CHECK\_THAT( arg, matcher ) (void)(0)}}
\DoxyCodeLine{17801 }
\DoxyCodeLine{17802 \textcolor{preprocessor}{\#define REQUIRE\_THAT( arg, matcher ) (void)(0)}}
\DoxyCodeLine{17803 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17804 }
\DoxyCodeLine{17805 \textcolor{preprocessor}{\#define INFO( msg ) (void)(0)}}
\DoxyCodeLine{17806 \textcolor{preprocessor}{\#define UNSCOPED\_INFO( msg ) (void)(0)}}
\DoxyCodeLine{17807 \textcolor{preprocessor}{\#define WARN( msg ) (void)(0)}}
\DoxyCodeLine{17808 \textcolor{preprocessor}{\#define CAPTURE( msg ) (void)(0)}}
\DoxyCodeLine{17809 }
\DoxyCodeLine{17810 \textcolor{preprocessor}{\#define TEST\_CASE( ... )  INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{17811 \textcolor{preprocessor}{\#define TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{17812 \textcolor{preprocessor}{\#define METHOD\_AS\_TEST\_CASE( method, ... )}}
\DoxyCodeLine{17813 \textcolor{preprocessor}{\#define REGISTER\_TEST\_CASE( Function, ... ) (void)(0)}}
\DoxyCodeLine{17814 \textcolor{preprocessor}{\#define SECTION( ... )}}
\DoxyCodeLine{17815 \textcolor{preprocessor}{\#define DYNAMIC\_SECTION( ... )}}
\DoxyCodeLine{17816 \textcolor{preprocessor}{\#define FAIL( ... ) (void)(0)}}
\DoxyCodeLine{17817 \textcolor{preprocessor}{\#define FAIL\_CHECK( ... ) (void)(0)}}
\DoxyCodeLine{17818 \textcolor{preprocessor}{\#define SUCCEED( ... ) (void)(0)}}
\DoxyCodeLine{17819 \textcolor{preprocessor}{\#define ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{17820 }
\DoxyCodeLine{17821 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{17822 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17823 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17824 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17825 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17826 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17827 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17828 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17829 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17830 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17831 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_) )}}
\DoxyCodeLine{17832 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_) )}}
\DoxyCodeLine{17833 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17834 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17835 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17836 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17837 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17838 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17839 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17840 }
\DoxyCodeLine{17841 \textcolor{preprocessor}{\#define STATIC\_REQUIRE( ... )       (void)(0)}}
\DoxyCodeLine{17842 \textcolor{preprocessor}{\#define STATIC\_REQUIRE\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{17843 }
\DoxyCodeLine{17844 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17845 }
\DoxyCodeLine{17846 \textcolor{preprocessor}{\#define CATCH\_TRANSLATE\_EXCEPTION( signature ) INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION\_NO\_REG( INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_ExceptionTranslator ), signature )}}
\DoxyCodeLine{17847 }
\DoxyCodeLine{17848 \textcolor{comment}{// "{}BDD-\/style"{} convenience wrappers}}
\DoxyCodeLine{17849 \textcolor{preprocessor}{\#define SCENARIO( ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ) )}}
\DoxyCodeLine{17850 \textcolor{preprocessor}{\#define SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_METHOD\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), className )}}
\DoxyCodeLine{17851 }
\DoxyCodeLine{17852 \textcolor{preprocessor}{\#define GIVEN( desc )}}
\DoxyCodeLine{17853 \textcolor{preprocessor}{\#define AND\_GIVEN( desc )}}
\DoxyCodeLine{17854 \textcolor{preprocessor}{\#define WHEN( desc )}}
\DoxyCodeLine{17855 \textcolor{preprocessor}{\#define AND\_WHEN( desc )}}
\DoxyCodeLine{17856 \textcolor{preprocessor}{\#define THEN( desc )}}
\DoxyCodeLine{17857 \textcolor{preprocessor}{\#define AND\_THEN( desc )}}
\DoxyCodeLine{17858 }
\DoxyCodeLine{17859 \textcolor{keyword}{using} \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Catch::Detail::Approx}};}
\DoxyCodeLine{17860 }
\DoxyCodeLine{17861 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17862 }
\DoxyCodeLine{17863 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// ! CATCH\_CONFIG\_IMPL\_ONLY}}
\DoxyCodeLine{17864 }
\DoxyCodeLine{17865 \textcolor{comment}{// start catch\_reenable\_warnings.h}}
\DoxyCodeLine{17866 }
\DoxyCodeLine{17867 }
\DoxyCodeLine{17868 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{17869 \textcolor{preprocessor}{\#    ifdef \_\_ICC }\textcolor{comment}{// icpc defines the \_\_clang\_\_ macro}}
\DoxyCodeLine{17870 \textcolor{preprocessor}{\#        pragma warning(pop)}}
\DoxyCodeLine{17871 \textcolor{preprocessor}{\#    else}}
\DoxyCodeLine{17872 \textcolor{preprocessor}{\#        pragma clang diagnostic pop}}
\DoxyCodeLine{17873 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{17874 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{17875 \textcolor{preprocessor}{\#    pragma GCC diagnostic pop}}
\DoxyCodeLine{17876 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17877 }
\DoxyCodeLine{17878 \textcolor{comment}{// end catch\_reenable\_warnings.h}}
\DoxyCodeLine{17879 \textcolor{comment}{// end catch.hpp}}
\DoxyCodeLine{17880 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{17881 }

\end{DoxyCode}
