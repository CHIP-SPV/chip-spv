\hypertarget{class_c_h_i_p_device}{}\doxysection{CHIPDevice Class Reference}
\label{class_c_h_i_p_device}\index{CHIPDevice@{CHIPDevice}}


Compute device class.  




{\ttfamily \#include $<$CHIPBackend.\+hh$>$}

Inheritance diagram for CHIPDevice\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_c_h_i_p_device}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_aedf034af76863e920fff061e1027e53b}\label{class_c_h_i_p_device_aedf034af76863e920fff061e1027e53b}} 
{\bfseries CHIPDevice} (\mbox{\hyperlink{class_c_h_i_p_context}{CHIPContext}} $\ast$ctx\+\_\+)
\begin{DoxyCompactList}\small\item\em Construct a new \mbox{\hyperlink{class_c_h_i_p_device}{CHIPDevice}} object. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a4922603bb72ecad2e9deeffd034b0993}\label{class_c_h_i_p_device_a4922603bb72ecad2e9deeffd034b0993}} 
{\bfseries CHIPDevice} ()
\begin{DoxyCompactList}\small\item\em Construct a new \mbox{\hyperlink{class_c_h_i_p_device}{CHIPDevice}} object. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a4994ef9c50511e2522d0397c69871d1a}\label{class_c_h_i_p_device_a4994ef9c50511e2522d0397c69871d1a}} 
{\bfseries $\sim$\+CHIPDevice} ()
\begin{DoxyCompactList}\small\item\em Destroy the \mbox{\hyperlink{class_c_h_i_p_device}{CHIPDevice}} object. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_c_h_i_p_kernel}{CHIPKernel}} $\ast$ $>$ \mbox{\hyperlink{class_c_h_i_p_device_aed8c7dfb1b40e78260cb4011cc0509dd}{get\+Kernels}} ()
\begin{DoxyCompactList}\small\item\em Get the Kernels object. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_c_h_i_p_module}{CHIPModule}} $\ast$ $>$ \& \mbox{\hyperlink{class_c_h_i_p_device_a0381200acd5010c1657c6c39c4c25632}{get\+Modules}} ()
\begin{DoxyCompactList}\small\item\em Get the Modules object. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a5194693b5813c5bc1551d293d48b3899}\label{class_c_h_i_p_device_a5194693b5813c5bc1551d293d48b3899}} 
void {\bfseries populate\+Device\+Properties} ()
\begin{DoxyCompactList}\small\item\em Use a backend to populate device properties such as memory available, frequencies, etc. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_c_h_i_p_device_aa7bfa85e318cda92cfe5c5cc394f6eca}{populate\+Device\+Properties\+\_\+}} ()=0
\begin{DoxyCompactList}\small\item\em Use a backend to populate device properties such as memory available, frequencies, etc. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_c_h_i_p_device_a375f7ce1038f3bfc9c3d98bc4ee18c6d}{copy\+Device\+Properties}} (hip\+Device\+Prop\+\_\+t $\ast$prop)
\begin{DoxyCompactList}\small\item\em Query the device for properties. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_h_i_p_kernel}{CHIPKernel}} $\ast$ \mbox{\hyperlink{class_c_h_i_p_device_a79ebc10bb0b3ee3f208a6bd4742d16ca}{find\+Kernel\+By\+Host\+Ptr}} (const void $\ast$host\+Ptr)
\begin{DoxyCompactList}\small\item\em Use the host function pointer to retrieve the kernel. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_h_i_p_context}{CHIPContext}} $\ast$ \mbox{\hyperlink{class_c_h_i_p_device_a967f4b9220725a2debcb6f66d22060fd}{get\+Context}} ()
\begin{DoxyCompactList}\small\item\em Get the context object. \end{DoxyCompactList}\item 
virtual \mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$ \mbox{\hyperlink{class_c_h_i_p_device_acd1d6b81696a43296a485647ec07f596}{add\+Queue}} (unsigned int flags, int priority)=0
\begin{DoxyCompactList}\small\item\em Construct an additional queue for this device. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_c_h_i_p_device_a343592eef975d362baac0006456e8337}{add\+Queue}} (\mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$chip\+\_\+queue\+\_\+)
\begin{DoxyCompactList}\small\item\em Add a queue to this device. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$ $>$ \mbox{\hyperlink{class_c_h_i_p_device_a13160a0a12a1e885faa15f20c88e3923}{get\+Queues}} ()
\begin{DoxyCompactList}\small\item\em Get the Queues object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$ \mbox{\hyperlink{class_c_h_i_p_device_aebb742c0c5df3f563d1a8f5c13c3b6d4}{get\+Active\+Queue}} ()
\begin{DoxyCompactList}\small\item\em HIP API allows for setting the active device, not the active queue so active device\textquotesingle{}s active queue is always it\textquotesingle{}s 0th/default/primary queue. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_c_h_i_p_device_ae49f9f351ba18e15a8baaa7c734ee679}{remove\+Queue}} (\mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$q)
\begin{DoxyCompactList}\small\item\em Remove a queue from this device\textquotesingle{}s queue vector. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_c_h_i_p_device_a0647eabfa0ae2fe14b1ea95666919090}{get\+Device\+Id}} ()
\begin{DoxyCompactList}\small\item\em Get the integer ID of this device as it appears in the Backend\textquotesingle{}s chip\+\_\+devices list. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{class_c_h_i_p_device_aca3d9af44bd816743e81eaf840066928}{get\+Name}} ()
\begin{DoxyCompactList}\small\item\em Get the device name. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_c_h_i_p_device_abd7d4be48339d070b09fcf5d6270caaa}{reset}} ()=0
\begin{DoxyCompactList}\small\item\em Destroy all allocations and reset all state on the current device in the current process. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_c_h_i_p_device_a11990aabcfa593917f152ed9614fb2fd}{get\+Attr}} (hip\+Device\+Attribute\+\_\+t attr)
\begin{DoxyCompactList}\small\item\em Query for a specific device attribute. Implementation copied from HIPAMD. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{class_c_h_i_p_device_a9ae23fb248d2338119fc81d52cdb8b91}{get\+Global\+Mem\+Size}} ()
\begin{DoxyCompactList}\small\item\em Get the total global memory available for this device. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_c_h_i_p_device_a65db2a50eb14046390e872911edde527}{set\+Cache\+Config}} (hip\+Func\+Cache\+\_\+t cfg)
\begin{DoxyCompactList}\small\item\em Set the Cache Config object. \end{DoxyCompactList}\item 
virtual hip\+Func\+Cache\+\_\+t \mbox{\hyperlink{class_c_h_i_p_device_a8d72d74a69af43d2c66eb6e28199e235}{get\+Cache\+Config}} ()
\begin{DoxyCompactList}\small\item\em Get the cache configuration for this device. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_c_h_i_p_device_a283a360f01661d90183ec293e2e51fdb}{set\+Shared\+Mem\+Config}} (hip\+Shared\+Mem\+Config config)
\begin{DoxyCompactList}\small\item\em Configure shared memory for this device. \end{DoxyCompactList}\item 
virtual hip\+Shared\+Mem\+Config \mbox{\hyperlink{class_c_h_i_p_device_a73e0e41a593edc15c7337183018cae5b}{get\+Shared\+Mem\+Config}} ()
\begin{DoxyCompactList}\small\item\em Get the shared memory configuration for this device. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_c_h_i_p_device_a444a7a27aea6312d84d5d02ee195ac30}{set\+Func\+Cache\+Config}} (const void $\ast$func, hip\+Func\+Cache\+\_\+t config)
\begin{DoxyCompactList}\small\item\em Setup the cache configuration for the device to use when executing this function. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_c_h_i_p_device_aebacdaea53d302b0ad0e5758f95c5cfd}{has\+PCIBus\+Id}} (int pci\+Domain\+ID, int pci\+Bus\+ID, int pci\+Device\+ID)
\begin{DoxyCompactList}\small\item\em Check if the current device has same PCI bus ID as the one given by input. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_c_h_i_p_device_aa293773bba48a9bf66b2fc02f0b7e7f8}{get\+Peer\+Access}} (\mbox{\hyperlink{class_c_h_i_p_device}{CHIPDevice}} $\ast$peer\+Device)
\begin{DoxyCompactList}\small\item\em Get peer-\/accesability between this and another device. \end{DoxyCompactList}\item 
hip\+Error\+\_\+t \mbox{\hyperlink{class_c_h_i_p_device_adf4b2dfdf3e022ff3f266ff4d96935ff}{set\+Peer\+Access}} (\mbox{\hyperlink{class_c_h_i_p_device}{CHIPDevice}} $\ast$peer, int flags, bool can\+Access\+Peer)
\begin{DoxyCompactList}\small\item\em Set access between this and another device. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{class_c_h_i_p_device_adfc125b715bd7bfa8d63d684ddf65433}{get\+Used\+Global\+Mem}} ()
\begin{DoxyCompactList}\small\item\em Get the total used global memory. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_h_i_p_device_var}{CHIPDevice\+Var}} $\ast$ \mbox{\hyperlink{class_c_h_i_p_device_a02c0e81ba452d2736a0803f381b36cfe}{get\+Dyn\+Global\+Var}} (const void $\ast$host\+\_\+var\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Get the global variable that came from a Fat\+Binary module. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_h_i_p_device_var}{CHIPDevice\+Var}} $\ast$ \mbox{\hyperlink{class_c_h_i_p_device_af0fb162a43b0afd71c8d36fb13890729}{get\+Stat\+Global\+Var}} (const void $\ast$host\+\_\+var\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Get the global variable that from from a module loaded at runtime. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_c_h_i_p_device_var}{CHIPDevice\+Var}} $\ast$ \mbox{\hyperlink{class_c_h_i_p_device_a97317260a798fc0d79d1c51c29d60f07}{get\+Global\+Var}} (const void $\ast$host\+\_\+var\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Get the global variable. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_c_h_i_p_device_aff26bc18398f030d01f92e0ef3d69244}{register\+Function\+As\+Kernel}} (std\+::string $\ast$module\+\_\+str, const void $\ast$host\+\_\+f\+\_\+ptr, const char $\ast$host\+\_\+f\+\_\+name)
\begin{DoxyCompactList}\small\item\em Take the module source, compile the kernels and associate the host function pointer with a kernel whose name matches host function name. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_h_i_p_device_addfa497b07b59a484fb17a37c3c424cd}\label{class_c_h_i_p_device_addfa497b07b59a484fb17a37c3c424cd}} 
virtual \mbox{\hyperlink{class_c_h_i_p_module}{CHIPModule}} $\ast$ {\bfseries add\+Module} (std\+::string $\ast$module\+\_\+str)=0
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_ab4d1b7774f410e21bbe305503a3b9d21}\label{class_c_h_i_p_device_ab4d1b7774f410e21bbe305503a3b9d21}} 
virtual \mbox{\hyperlink{class_c_h_i_p_texture}{CHIPTexture}} $\ast$ {\bfseries create\+Texture} (const hip\+Resource\+Desc $\ast$p\+Res\+Desc, const hip\+Texture\+Desc $\ast$p\+Tex\+Desc, const struct hip\+Resource\+View\+Desc $\ast$p\+Res\+View\+Desc)=0
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a2057969bf46da575da3f0a439e7f787a}\label{class_c_h_i_p_device_a2057969bf46da575da3f0a439e7f787a}} 
virtual void {\bfseries destroy\+Texture} (\mbox{\hyperlink{class_c_h_i_p_texture}{CHIPTexture}} $\ast$texture\+Object)=0
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a2afd57cc57c94db499b9be4449b73a97}\label{class_c_h_i_p_device_a2afd57cc57c94db499b9be4449b73a97}} 
std\+::vector$<$ std\+::string $\ast$ $>$ {\bfseries modules\+\_\+str}
\begin{DoxyCompactList}\small\item\em chip\+\_\+modules in binary representation \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a51ee6a67de68d89f75855c43a2c1bc74}\label{class_c_h_i_p_device_a51ee6a67de68d89f75855c43a2c1bc74}} 
std\+::vector$<$ \mbox{\hyperlink{class_c_h_i_p_module}{CHIPModule}} $\ast$ $>$ {\bfseries chip\+\_\+modules}
\begin{DoxyCompactList}\small\item\em chip\+\_\+modules in parsed representation \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a202318bfc413c9707ee1fb1ef2b76fed}\label{class_c_h_i_p_device_a202318bfc413c9707ee1fb1ef2b76fed}} 
std\+::unordered\+\_\+map$<$ const void $\ast$, std\+::string $\ast$ $>$ {\bfseries host\+\_\+f\+\_\+ptr\+\_\+to\+\_\+module\+\_\+str\+\_\+map}
\begin{DoxyCompactList}\small\item\em Map host pointer to module in binary representation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a88f651b661540d283294a9c7da333059}\label{class_c_h_i_p_device_a88f651b661540d283294a9c7da333059}} 
std\+::unordered\+\_\+map$<$ const void $\ast$, \mbox{\hyperlink{class_c_h_i_p_module}{CHIPModule}} $\ast$ $>$ {\bfseries host\+\_\+f\+\_\+ptr\+\_\+to\+\_\+chipmodule\+\_\+map}
\begin{DoxyCompactList}\small\item\em Map host pointer to module in parsed representation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_h_i_p_device_ae3b9aa2c990aef24ce42b3e3652ed274}\label{class_c_h_i_p_device_ae3b9aa2c990aef24ce42b3e3652ed274}} 
std\+::unordered\+\_\+map$<$ const void $\ast$, std\+::string $>$ {\bfseries host\+\_\+f\+\_\+ptr\+\_\+to\+\_\+host\+\_\+f\+\_\+name\+\_\+map}
\begin{DoxyCompactList}\small\item\em Map host pointer to a function name. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a10819a071232f19e24f851e821b4288e}\label{class_c_h_i_p_device_a10819a071232f19e24f851e821b4288e}} 
std\+::unordered\+\_\+map$<$ const void $\ast$, \mbox{\hyperlink{class_c_h_i_p_kernel}{CHIPKernel}} $\ast$ $>$ {\bfseries host\+\_\+ptr\+\_\+to\+\_\+chipkernel\+\_\+map}
\begin{DoxyCompactList}\small\item\em Map host pointer to \mbox{\hyperlink{class_c_h_i_p_kernel}{CHIPKernel}}. \end{DoxyCompactList}\item 
std\+::unordered\+\_\+map$<$ const void $\ast$, \mbox{\hyperlink{class_c_h_i_p_device_var}{CHIPDevice\+Var}} $\ast$ $>$ \mbox{\hyperlink{class_c_h_i_p_device_aac39e7bdde8added5691357cd31a3d27}{host\+\_\+var\+\_\+ptr\+\_\+to\+\_\+chipdevicevar\+\_\+stat}}
\item 
std\+::unordered\+\_\+map$<$ const void $\ast$, \mbox{\hyperlink{class_c_h_i_p_device_var}{CHIPDevice\+Var}} $\ast$ $>$ \mbox{\hyperlink{class_c_h_i_p_device_a6ea939f900db1167fddcaab422459092}{host\+\_\+var\+\_\+ptr\+\_\+to\+\_\+chipdevicevar\+\_\+dyn}}
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_ab03330d166b8621a745583df6786c03c}\label{class_c_h_i_p_device_ab03330d166b8621a745583df6786c03c}} 
int {\bfseries idx}
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a0f173c29ce72a9f699ef8765fe8efcc5}\label{class_c_h_i_p_device_a0f173c29ce72a9f699ef8765fe8efcc5}} 
\mbox{\hyperlink{class_c_h_i_p_allocation_tracker}{CHIPAllocation\+Tracker}} $\ast$ {\bfseries allocation\+\_\+tracker} = nullptr
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_acadc9022103fd54f87aadea5762bdaf5}\label{class_c_h_i_p_device_acadc9022103fd54f87aadea5762bdaf5}} 
std\+::string {\bfseries device\+\_\+name}
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_ac7cdfc001a8852c0e69888c256254506}\label{class_c_h_i_p_device_ac7cdfc001a8852c0e69888c256254506}} 
std\+::mutex {\bfseries mtx}
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a333873706d2a7d547871a45613ae5e38}\label{class_c_h_i_p_device_a333873706d2a7d547871a45613ae5e38}} 
\mbox{\hyperlink{class_c_h_i_p_context}{CHIPContext}} $\ast$ {\bfseries ctx}
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_aaa76ed4923954a52e914416c90845fab}\label{class_c_h_i_p_device_aaa76ed4923954a52e914416c90845fab}} 
std\+::vector$<$ \mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$ $>$ {\bfseries chip\+\_\+queues}
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a1fae7b58c18f748c8cab910ba6890e1e}\label{class_c_h_i_p_device_a1fae7b58c18f748c8cab910ba6890e1e}} 
int {\bfseries active\+\_\+queue\+\_\+id} = 0
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a1ae79160adaeaaa4fd68c58677346526}\label{class_c_h_i_p_device_a1ae79160adaeaaa4fd68c58677346526}} 
std\+::once\+\_\+flag {\bfseries props\+Populated}
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a63a5a19d95283d5e2527ecc935bac6cb}\label{class_c_h_i_p_device_a63a5a19d95283d5e2527ecc935bac6cb}} 
hip\+Device\+Attribute\+\_\+t {\bfseries attrs}
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a6aa417902885d6b15c26c6fc69aad547}\label{class_c_h_i_p_device_a6aa417902885d6b15c26c6fc69aad547}} 
hip\+Device\+Prop\+\_\+t {\bfseries hip\+\_\+device\+\_\+props}
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a0b1fe6033be1fc9717c30fcc20db0d7a}\label{class_c_h_i_p_device_a0b1fe6033be1fc9717c30fcc20db0d7a}} 
size\+\_\+t {\bfseries Total\+Used\+Mem}
\item 
\mbox{\Hypertarget{class_c_h_i_p_device_a797a22a51f4796fc8bd96e15b1ac28a0}\label{class_c_h_i_p_device_a797a22a51f4796fc8bd96e15b1ac28a0}} 
size\+\_\+t {\bfseries Max\+Used\+Mem}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Compute device class. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_c_h_i_p_device_a343592eef975d362baac0006456e8337}\label{class_c_h_i_p_device_a343592eef975d362baac0006456e8337}} 
\index{CHIPDevice@{CHIPDevice}!addQueue@{addQueue}}
\index{addQueue@{addQueue}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{addQueue()}{addQueue()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void CHIPDevice\+::add\+Queue (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$}]{chip\+\_\+queue\+\_\+ }\end{DoxyParamCaption})}



Add a queue to this device. 


\begin{DoxyParams}{Parameters}
{\em chip\+\_\+queue\+\_\+} & \mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} to be added \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_c_h_i_p_device_acd1d6b81696a43296a485647ec07f596}\label{class_c_h_i_p_device_acd1d6b81696a43296a485647ec07f596}} 
\index{CHIPDevice@{CHIPDevice}!addQueue@{addQueue}}
\index{addQueue@{addQueue}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{addQueue()}{addQueue()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$ CHIPDevice\+::add\+Queue (\begin{DoxyParamCaption}\item[{unsigned int}]{flags,  }\item[{int}]{priority }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Construct an additional queue for this device. 


\begin{DoxyParams}{Parameters}
{\em flags} & \\
\hline
{\em priority} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
CHIPQueue$\ast$ pointer to the newly created queue (can also be found in chip\+\_\+queues vector) 
\end{DoxyReturn}


Implemented in \mbox{\hyperlink{class_c_h_i_p_device_level0_aabd471a3cbb392716da624494de90f51}{CHIPDevice\+Level0}}, and \mbox{\hyperlink{class_c_h_i_p_device_open_c_l_acea38f2032eb4355363c1c939638c1df}{CHIPDevice\+Open\+CL}}.

\mbox{\Hypertarget{class_c_h_i_p_device_a375f7ce1038f3bfc9c3d98bc4ee18c6d}\label{class_c_h_i_p_device_a375f7ce1038f3bfc9c3d98bc4ee18c6d}} 
\index{CHIPDevice@{CHIPDevice}!copyDeviceProperties@{copyDeviceProperties}}
\index{copyDeviceProperties@{copyDeviceProperties}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{copyDeviceProperties()}{copyDeviceProperties()}}
{\footnotesize\ttfamily void CHIPDevice\+::copy\+Device\+Properties (\begin{DoxyParamCaption}\item[{hip\+Device\+Prop\+\_\+t $\ast$}]{prop }\end{DoxyParamCaption})}



Query the device for properties. 


\begin{DoxyParams}{Parameters}
{\em prop} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_c_h_i_p_device_a79ebc10bb0b3ee3f208a6bd4742d16ca}\label{class_c_h_i_p_device_a79ebc10bb0b3ee3f208a6bd4742d16ca}} 
\index{CHIPDevice@{CHIPDevice}!findKernelByHostPtr@{findKernelByHostPtr}}
\index{findKernelByHostPtr@{findKernelByHostPtr}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{findKernelByHostPtr()}{findKernelByHostPtr()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_c_h_i_p_kernel}{CHIPKernel}} $\ast$ CHIPDevice\+::find\+Kernel\+By\+Host\+Ptr (\begin{DoxyParamCaption}\item[{const void $\ast$}]{host\+Ptr }\end{DoxyParamCaption})}



Use the host function pointer to retrieve the kernel. 


\begin{DoxyParams}{Parameters}
{\em host\+Ptr} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
CHIPKernel$\ast$ \mbox{\hyperlink{class_c_h_i_p_kernel}{CHIPKernel}} associated with this host pointer 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_aebb742c0c5df3f563d1a8f5c13c3b6d4}\label{class_c_h_i_p_device_aebb742c0c5df3f563d1a8f5c13c3b6d4}} 
\index{CHIPDevice@{CHIPDevice}!getActiveQueue@{getActiveQueue}}
\index{getActiveQueue@{getActiveQueue}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getActiveQueue()}{getActiveQueue()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$ CHIPDevice\+::get\+Active\+Queue (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



HIP API allows for setting the active device, not the active queue so active device\textquotesingle{}s active queue is always it\textquotesingle{}s 0th/default/primary queue. 

\begin{DoxyReturn}{Returns}
CHIPQueue$\ast$ 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_a11990aabcfa593917f152ed9614fb2fd}\label{class_c_h_i_p_device_a11990aabcfa593917f152ed9614fb2fd}} 
\index{CHIPDevice@{CHIPDevice}!getAttr@{getAttr}}
\index{getAttr@{getAttr}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getAttr()}{getAttr()}}
{\footnotesize\ttfamily int CHIPDevice\+::get\+Attr (\begin{DoxyParamCaption}\item[{hip\+Device\+Attribute\+\_\+t}]{attr }\end{DoxyParamCaption})}



Query for a specific device attribute. Implementation copied from HIPAMD. 


\begin{DoxyParams}{Parameters}
{\em attr} & attribute to query \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int attribute value. In case invalid query returns -\/1; 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_a8d72d74a69af43d2c66eb6e28199e235}\label{class_c_h_i_p_device_a8d72d74a69af43d2c66eb6e28199e235}} 
\index{CHIPDevice@{CHIPDevice}!getCacheConfig@{getCacheConfig}}
\index{getCacheConfig@{getCacheConfig}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getCacheConfig()}{getCacheConfig()}}
{\footnotesize\ttfamily hip\+Func\+Cache\+\_\+t CHIPDevice\+::get\+Cache\+Config (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Get the cache configuration for this device. 

\begin{DoxyReturn}{Returns}
hip\+Func\+Cache\+\_\+t 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_a967f4b9220725a2debcb6f66d22060fd}\label{class_c_h_i_p_device_a967f4b9220725a2debcb6f66d22060fd}} 
\index{CHIPDevice@{CHIPDevice}!getContext@{getContext}}
\index{getContext@{getContext}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getContext()}{getContext()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_c_h_i_p_context}{CHIPContext}} $\ast$ CHIPDevice\+::get\+Context (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the context object. 

\begin{DoxyReturn}{Returns}
CHIPContext$\ast$ pointer to the \mbox{\hyperlink{class_c_h_i_p_context}{CHIPContext}} object this \mbox{\hyperlink{class_c_h_i_p_device}{CHIPDevice}} was created with 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_a0647eabfa0ae2fe14b1ea95666919090}\label{class_c_h_i_p_device_a0647eabfa0ae2fe14b1ea95666919090}} 
\index{CHIPDevice@{CHIPDevice}!getDeviceId@{getDeviceId}}
\index{getDeviceId@{getDeviceId}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getDeviceId()}{getDeviceId()}}
{\footnotesize\ttfamily int CHIPDevice\+::get\+Device\+Id (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the integer ID of this device as it appears in the Backend\textquotesingle{}s chip\+\_\+devices list. 

\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_a02c0e81ba452d2736a0803f381b36cfe}\label{class_c_h_i_p_device_a02c0e81ba452d2736a0803f381b36cfe}} 
\index{CHIPDevice@{CHIPDevice}!getDynGlobalVar@{getDynGlobalVar}}
\index{getDynGlobalVar@{getDynGlobalVar}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getDynGlobalVar()}{getDynGlobalVar()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_c_h_i_p_device_var}{CHIPDevice\+Var}} $\ast$ CHIPDevice\+::get\+Dyn\+Global\+Var (\begin{DoxyParamCaption}\item[{const void $\ast$}]{host\+\_\+var\+\_\+ptr }\end{DoxyParamCaption})}



Get the global variable that came from a Fat\+Binary module. 


\begin{DoxyParams}{Parameters}
{\em host\+\_\+var\+\_\+ptr} & host pointer to the variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
CHIPDevice\+Var$\ast$ 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_a9ae23fb248d2338119fc81d52cdb8b91}\label{class_c_h_i_p_device_a9ae23fb248d2338119fc81d52cdb8b91}} 
\index{CHIPDevice@{CHIPDevice}!getGlobalMemSize@{getGlobalMemSize}}
\index{getGlobalMemSize@{getGlobalMemSize}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getGlobalMemSize()}{getGlobalMemSize()}}
{\footnotesize\ttfamily size\+\_\+t CHIPDevice\+::get\+Global\+Mem\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the total global memory available for this device. 

\begin{DoxyReturn}{Returns}
size\+\_\+t 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_a97317260a798fc0d79d1c51c29d60f07}\label{class_c_h_i_p_device_a97317260a798fc0d79d1c51c29d60f07}} 
\index{CHIPDevice@{CHIPDevice}!getGlobalVar@{getGlobalVar}}
\index{getGlobalVar@{getGlobalVar}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getGlobalVar()}{getGlobalVar()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_c_h_i_p_device_var}{CHIPDevice\+Var}} $\ast$ CHIPDevice\+::get\+Global\+Var (\begin{DoxyParamCaption}\item[{const void $\ast$}]{host\+\_\+var\+\_\+ptr }\end{DoxyParamCaption})}



Get the global variable. 


\begin{DoxyParams}{Parameters}
{\em host\+\_\+var\+\_\+ptr} & host pointer to the variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
CHIPDevice\+Var$\ast$ if not found returns nullptr 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_aed8c7dfb1b40e78260cb4011cc0509dd}\label{class_c_h_i_p_device_aed8c7dfb1b40e78260cb4011cc0509dd}} 
\index{CHIPDevice@{CHIPDevice}!getKernels@{getKernels}}
\index{getKernels@{getKernels}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getKernels()}{getKernels()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_c_h_i_p_kernel}{CHIPKernel}} $\ast$ $>$ CHIPDevice\+::get\+Kernels (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the Kernels object. 

\begin{DoxyReturn}{Returns}
std\+::vector$<$\+CHIPKernel$\ast$$>$\& 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_a0381200acd5010c1657c6c39c4c25632}\label{class_c_h_i_p_device_a0381200acd5010c1657c6c39c4c25632}} 
\index{CHIPDevice@{CHIPDevice}!getModules@{getModules}}
\index{getModules@{getModules}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getModules()}{getModules()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_c_h_i_p_module}{CHIPModule}} $\ast$ $>$ \& CHIPDevice\+::get\+Modules (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the Modules object. 

\begin{DoxyReturn}{Returns}
std\+::vector$<$\+CHIPModule$\ast$$>$\& 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_aca3d9af44bd816743e81eaf840066928}\label{class_c_h_i_p_device_aca3d9af44bd816743e81eaf840066928}} 
\index{CHIPDevice@{CHIPDevice}!getName@{getName}}
\index{getName@{getName}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getName()}{getName()}}
{\footnotesize\ttfamily std\+::string CHIPDevice\+::get\+Name (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the device name. 

\begin{DoxyReturn}{Returns}
std\+::string 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_aa293773bba48a9bf66b2fc02f0b7e7f8}\label{class_c_h_i_p_device_aa293773bba48a9bf66b2fc02f0b7e7f8}} 
\index{CHIPDevice@{CHIPDevice}!getPeerAccess@{getPeerAccess}}
\index{getPeerAccess@{getPeerAccess}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getPeerAccess()}{getPeerAccess()}}
{\footnotesize\ttfamily int CHIPDevice\+::get\+Peer\+Access (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_c_h_i_p_device}{CHIPDevice}} $\ast$}]{peer\+Device }\end{DoxyParamCaption})}



Get peer-\/accesability between this and another device. 


\begin{DoxyParams}{Parameters}
{\em peer\+Device} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_a13160a0a12a1e885faa15f20c88e3923}\label{class_c_h_i_p_device_a13160a0a12a1e885faa15f20c88e3923}} 
\index{CHIPDevice@{CHIPDevice}!getQueues@{getQueues}}
\index{getQueues@{getQueues}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getQueues()}{getQueues()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$ $>$ CHIPDevice\+::get\+Queues (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the Queues object. 

\begin{DoxyReturn}{Returns}
std\+::vector$<$\+CHIPQueue$\ast$$>$ 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_a73e0e41a593edc15c7337183018cae5b}\label{class_c_h_i_p_device_a73e0e41a593edc15c7337183018cae5b}} 
\index{CHIPDevice@{CHIPDevice}!getSharedMemConfig@{getSharedMemConfig}}
\index{getSharedMemConfig@{getSharedMemConfig}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getSharedMemConfig()}{getSharedMemConfig()}}
{\footnotesize\ttfamily hip\+Shared\+Mem\+Config CHIPDevice\+::get\+Shared\+Mem\+Config (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Get the shared memory configuration for this device. 

\begin{DoxyReturn}{Returns}
hip\+Shared\+Mem\+Config 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_af0fb162a43b0afd71c8d36fb13890729}\label{class_c_h_i_p_device_af0fb162a43b0afd71c8d36fb13890729}} 
\index{CHIPDevice@{CHIPDevice}!getStatGlobalVar@{getStatGlobalVar}}
\index{getStatGlobalVar@{getStatGlobalVar}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getStatGlobalVar()}{getStatGlobalVar()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_c_h_i_p_device_var}{CHIPDevice\+Var}} $\ast$ CHIPDevice\+::get\+Stat\+Global\+Var (\begin{DoxyParamCaption}\item[{const void $\ast$}]{host\+\_\+var\+\_\+ptr }\end{DoxyParamCaption})}



Get the global variable that from from a module loaded at runtime. 


\begin{DoxyParams}{Parameters}
{\em host\+\_\+var\+\_\+ptr} & host pointer to the variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
CHIPDevice\+Var$\ast$ 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_adfc125b715bd7bfa8d63d684ddf65433}\label{class_c_h_i_p_device_adfc125b715bd7bfa8d63d684ddf65433}} 
\index{CHIPDevice@{CHIPDevice}!getUsedGlobalMem@{getUsedGlobalMem}}
\index{getUsedGlobalMem@{getUsedGlobalMem}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{getUsedGlobalMem()}{getUsedGlobalMem()}}
{\footnotesize\ttfamily size\+\_\+t CHIPDevice\+::get\+Used\+Global\+Mem (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the total used global memory. 

\begin{DoxyReturn}{Returns}
size\+\_\+t 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_aebacdaea53d302b0ad0e5758f95c5cfd}\label{class_c_h_i_p_device_aebacdaea53d302b0ad0e5758f95c5cfd}} 
\index{CHIPDevice@{CHIPDevice}!hasPCIBusId@{hasPCIBusId}}
\index{hasPCIBusId@{hasPCIBusId}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{hasPCIBusId()}{hasPCIBusId()}}
{\footnotesize\ttfamily bool CHIPDevice\+::has\+PCIBus\+Id (\begin{DoxyParamCaption}\item[{int}]{pci\+Domain\+ID,  }\item[{int}]{pci\+Bus\+ID,  }\item[{int}]{pci\+Device\+ID }\end{DoxyParamCaption})}



Check if the current device has same PCI bus ID as the one given by input. 


\begin{DoxyParams}{Parameters}
{\em pci\+Domain\+ID} & \\
\hline
{\em pci\+Bus\+ID} & \\
\hline
{\em pci\+Device\+ID} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true 

false 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_aa7bfa85e318cda92cfe5c5cc394f6eca}\label{class_c_h_i_p_device_aa7bfa85e318cda92cfe5c5cc394f6eca}} 
\index{CHIPDevice@{CHIPDevice}!populateDeviceProperties\_@{populateDeviceProperties\_}}
\index{populateDeviceProperties\_@{populateDeviceProperties\_}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{populateDeviceProperties\_()}{populateDeviceProperties\_()}}
{\footnotesize\ttfamily virtual void CHIPDevice\+::populate\+Device\+Properties\+\_\+ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Use a backend to populate device properties such as memory available, frequencies, etc. 



Implemented in \mbox{\hyperlink{class_c_h_i_p_device_level0_a76728b527fe3f8570a9f6402e1a0ee52}{CHIPDevice\+Level0}}, and \mbox{\hyperlink{class_c_h_i_p_device_open_c_l_a7baeebbfab0342cb95a0df689a6af50b}{CHIPDevice\+Open\+CL}}.

\mbox{\Hypertarget{class_c_h_i_p_device_aff26bc18398f030d01f92e0ef3d69244}\label{class_c_h_i_p_device_aff26bc18398f030d01f92e0ef3d69244}} 
\index{CHIPDevice@{CHIPDevice}!registerFunctionAsKernel@{registerFunctionAsKernel}}
\index{registerFunctionAsKernel@{registerFunctionAsKernel}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{registerFunctionAsKernel()}{registerFunctionAsKernel()}}
{\footnotesize\ttfamily void CHIPDevice\+::register\+Function\+As\+Kernel (\begin{DoxyParamCaption}\item[{std\+::string $\ast$}]{module\+\_\+str,  }\item[{const void $\ast$}]{host\+\_\+f\+\_\+ptr,  }\item[{const char $\ast$}]{host\+\_\+f\+\_\+name }\end{DoxyParamCaption})}



Take the module source, compile the kernels and associate the host function pointer with a kernel whose name matches host function name. 


\begin{DoxyParams}{Parameters}
{\em module\+\_\+str} & Binary representation of the SPIR-\/V module \\
\hline
{\em host\+\_\+f\+\_\+ptr} & host function pointer \\
\hline
{\em host\+\_\+f\+\_\+name} & host function name \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_c_h_i_p_device_ae49f9f351ba18e15a8baaa7c734ee679}\label{class_c_h_i_p_device_ae49f9f351ba18e15a8baaa7c734ee679}} 
\index{CHIPDevice@{CHIPDevice}!removeQueue@{removeQueue}}
\index{removeQueue@{removeQueue}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{removeQueue()}{removeQueue()}}
{\footnotesize\ttfamily bool CHIPDevice\+::remove\+Queue (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_c_h_i_p_queue}{CHIPQueue}} $\ast$}]{q }\end{DoxyParamCaption})}



Remove a queue from this device\textquotesingle{}s queue vector. 


\begin{DoxyParams}{Parameters}
{\em q} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true 

false 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_abd7d4be48339d070b09fcf5d6270caaa}\label{class_c_h_i_p_device_abd7d4be48339d070b09fcf5d6270caaa}} 
\index{CHIPDevice@{CHIPDevice}!reset@{reset}}
\index{reset@{reset}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}}
{\footnotesize\ttfamily virtual void CHIPDevice\+::reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Destroy all allocations and reset all state on the current device in the current process. 



Implemented in \mbox{\hyperlink{class_c_h_i_p_device_level0_a082d942aa4d6c26114f00537f5fb7230}{CHIPDevice\+Level0}}, and \mbox{\hyperlink{class_c_h_i_p_device_open_c_l_acaeee9322c45dbe16d711e30a99758b7}{CHIPDevice\+Open\+CL}}.

\mbox{\Hypertarget{class_c_h_i_p_device_a65db2a50eb14046390e872911edde527}\label{class_c_h_i_p_device_a65db2a50eb14046390e872911edde527}} 
\index{CHIPDevice@{CHIPDevice}!setCacheConfig@{setCacheConfig}}
\index{setCacheConfig@{setCacheConfig}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{setCacheConfig()}{setCacheConfig()}}
{\footnotesize\ttfamily void CHIPDevice\+::set\+Cache\+Config (\begin{DoxyParamCaption}\item[{hip\+Func\+Cache\+\_\+t}]{cfg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Set the Cache Config object. 


\begin{DoxyParams}{Parameters}
{\em cfg} & configuration \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_c_h_i_p_device_a444a7a27aea6312d84d5d02ee195ac30}\label{class_c_h_i_p_device_a444a7a27aea6312d84d5d02ee195ac30}} 
\index{CHIPDevice@{CHIPDevice}!setFuncCacheConfig@{setFuncCacheConfig}}
\index{setFuncCacheConfig@{setFuncCacheConfig}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{setFuncCacheConfig()}{setFuncCacheConfig()}}
{\footnotesize\ttfamily void CHIPDevice\+::set\+Func\+Cache\+Config (\begin{DoxyParamCaption}\item[{const void $\ast$}]{func,  }\item[{hip\+Func\+Cache\+\_\+t}]{config }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Setup the cache configuration for the device to use when executing this function. 


\begin{DoxyParams}{Parameters}
{\em func} & \\
\hline
{\em config} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_c_h_i_p_device_adf4b2dfdf3e022ff3f266ff4d96935ff}\label{class_c_h_i_p_device_adf4b2dfdf3e022ff3f266ff4d96935ff}} 
\index{CHIPDevice@{CHIPDevice}!setPeerAccess@{setPeerAccess}}
\index{setPeerAccess@{setPeerAccess}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{setPeerAccess()}{setPeerAccess()}}
{\footnotesize\ttfamily hip\+Error\+\_\+t CHIPDevice\+::set\+Peer\+Access (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_c_h_i_p_device}{CHIPDevice}} $\ast$}]{peer,  }\item[{int}]{flags,  }\item[{bool}]{can\+Access\+Peer }\end{DoxyParamCaption})}



Set access between this and another device. 


\begin{DoxyParams}{Parameters}
{\em peer} & \\
\hline
{\em flags} & \\
\hline
{\em can\+Access\+Peer} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
hip\+Error\+\_\+t 
\end{DoxyReturn}
\mbox{\Hypertarget{class_c_h_i_p_device_a283a360f01661d90183ec293e2e51fdb}\label{class_c_h_i_p_device_a283a360f01661d90183ec293e2e51fdb}} 
\index{CHIPDevice@{CHIPDevice}!setSharedMemConfig@{setSharedMemConfig}}
\index{setSharedMemConfig@{setSharedMemConfig}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{setSharedMemConfig()}{setSharedMemConfig()}}
{\footnotesize\ttfamily void CHIPDevice\+::set\+Shared\+Mem\+Config (\begin{DoxyParamCaption}\item[{hip\+Shared\+Mem\+Config}]{config }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Configure shared memory for this device. 


\begin{DoxyParams}{Parameters}
{\em config} & \\
\hline
\end{DoxyParams}


\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{class_c_h_i_p_device_a6ea939f900db1167fddcaab422459092}\label{class_c_h_i_p_device_a6ea939f900db1167fddcaab422459092}} 
\index{CHIPDevice@{CHIPDevice}!host\_var\_ptr\_to\_chipdevicevar\_dyn@{host\_var\_ptr\_to\_chipdevicevar\_dyn}}
\index{host\_var\_ptr\_to\_chipdevicevar\_dyn@{host\_var\_ptr\_to\_chipdevicevar\_dyn}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{host\_var\_ptr\_to\_chipdevicevar\_dyn}{host\_var\_ptr\_to\_chipdevicevar\_dyn}}
{\footnotesize\ttfamily std\+::unordered\+\_\+map$<$const void$\ast$, \mbox{\hyperlink{class_c_h_i_p_device_var}{CHIPDevice\+Var}}$\ast$$>$ CHIPDevice\+::host\+\_\+var\+\_\+ptr\+\_\+to\+\_\+chipdevicevar\+\_\+dyn}

Map host variable address to device pointer and size for dynamically loaded global vars \mbox{\Hypertarget{class_c_h_i_p_device_aac39e7bdde8added5691357cd31a3d27}\label{class_c_h_i_p_device_aac39e7bdde8added5691357cd31a3d27}} 
\index{CHIPDevice@{CHIPDevice}!host\_var\_ptr\_to\_chipdevicevar\_stat@{host\_var\_ptr\_to\_chipdevicevar\_stat}}
\index{host\_var\_ptr\_to\_chipdevicevar\_stat@{host\_var\_ptr\_to\_chipdevicevar\_stat}!CHIPDevice@{CHIPDevice}}
\doxysubsubsection{\texorpdfstring{host\_var\_ptr\_to\_chipdevicevar\_stat}{host\_var\_ptr\_to\_chipdevicevar\_stat}}
{\footnotesize\ttfamily std\+::unordered\+\_\+map$<$const void$\ast$, \mbox{\hyperlink{class_c_h_i_p_device_var}{CHIPDevice\+Var}}$\ast$$>$ CHIPDevice\+::host\+\_\+var\+\_\+ptr\+\_\+to\+\_\+chipdevicevar\+\_\+stat}

Map host variable address to device pointer and size for statically loaded global vars 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/\+Users/pvelesko/local/\+CHIP-\/\+SPV/src/\mbox{\hyperlink{_c_h_i_p_backend_8hh}{CHIPBackend.\+hh}}\item 
/\+Users/pvelesko/local/\+CHIP-\/\+SPV/src/CHIPBackend.\+cc\end{DoxyCompactItemize}
