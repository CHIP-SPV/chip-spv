\hypertarget{core_8h_source}{}\doxysection{core.\+h}
\label{core_8h_source}\index{/Users/pvelesko/local/CHIP-\/SPV/spdlog/fmt/bundled/core.h@{/Users/pvelesko/local/CHIP-\/SPV/spdlog/fmt/bundled/core.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Formatting library for C++ -\/ the core API}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{// Copyright (c) 2012 -\/ present, Victor Zverovich}}
\DoxyCodeLine{4 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// For the license information refer to format.h.}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 \textcolor{preprocessor}{\#ifndef FMT\_CORE\_H\_}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#define FMT\_CORE\_H\_}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <cstdio>}  \textcolor{comment}{// std::FILE}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{17 }
\DoxyCodeLine{18 \textcolor{comment}{// The fmt library version in the form major * 10000 + minor * 100 + patch.}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#define FMT\_VERSION 50201}}
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{preprocessor}{\#ifdef \_\_has\_feature}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\# define FMT\_HAS\_FEATURE(x) \_\_has\_feature(x)}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\# define FMT\_HAS\_FEATURE(x) 0}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 \textcolor{preprocessor}{\#if defined(\_\_has\_include) \&\& !defined(\_\_INTELLISENSE\_\_) \&\& \(\backslash\)}}
\DoxyCodeLine{28 \textcolor{preprocessor}{    (!defined(\_\_INTEL\_COMPILER) || \_\_INTEL\_COMPILER >= 1600)}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\# define FMT\_HAS\_INCLUDE(x) \_\_has\_include(x)}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\# define FMT\_HAS\_INCLUDE(x) 0}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{33 }
\DoxyCodeLine{34 \textcolor{preprocessor}{\#ifdef \_\_has\_cpp\_attribute}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\# define FMT\_HAS\_CPP\_ATTRIBUTE(x) \_\_has\_cpp\_attribute(x)}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\# define FMT\_HAS\_CPP\_ATTRIBUTE(x) 0}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{39 }
\DoxyCodeLine{40 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) \&\& !defined(\_\_clang\_\_)}}
\DoxyCodeLine{41 \textcolor{preprocessor}{\# define FMT\_GCC\_VERSION (\_\_GNUC\_\_ * 100 + \_\_GNUC\_MINOR\_\_)}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{43 \textcolor{preprocessor}{\# define FMT\_GCC\_VERSION 0}}
\DoxyCodeLine{44 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{45 }
\DoxyCodeLine{46 \textcolor{preprocessor}{\#if \_\_cplusplus >= 201103L || defined(\_\_GXX\_EXPERIMENTAL\_CXX0X\_\_)}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\# define FMT\_HAS\_GXX\_CXX11 FMT\_GCC\_VERSION}}
\DoxyCodeLine{48 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{49 \textcolor{preprocessor}{\# define FMT\_HAS\_GXX\_CXX11 0}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{51 }
\DoxyCodeLine{52 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{53 \textcolor{preprocessor}{\# define FMT\_MSC\_VER \_MSC\_VER}}
\DoxyCodeLine{54 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{55 \textcolor{preprocessor}{\# define FMT\_MSC\_VER 0}}
\DoxyCodeLine{56 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{57 }
\DoxyCodeLine{58 \textcolor{comment}{// Check if relaxed C++14 constexpr is supported.}}
\DoxyCodeLine{59 \textcolor{comment}{// GCC doesn't allow throw in constexpr until version 6 (bug 67371).}}
\DoxyCodeLine{60 \textcolor{preprocessor}{\#ifndef FMT\_USE\_CONSTEXPR}}
\DoxyCodeLine{61 \textcolor{preprocessor}{\# define FMT\_USE\_CONSTEXPR \(\backslash\)}}
\DoxyCodeLine{62 \textcolor{preprocessor}{  (FMT\_HAS\_FEATURE(cxx\_relaxed\_constexpr) || FMT\_MSC\_VER >= 1910 || \(\backslash\)}}
\DoxyCodeLine{63 \textcolor{preprocessor}{   (FMT\_GCC\_VERSION >= 600 \&\& \_\_cplusplus >= 201402L))}}
\DoxyCodeLine{64 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{65 \textcolor{preprocessor}{\#if FMT\_USE\_CONSTEXPR}}
\DoxyCodeLine{66 \textcolor{preprocessor}{\# define FMT\_CONSTEXPR constexpr}}
\DoxyCodeLine{67 \textcolor{preprocessor}{\# define FMT\_CONSTEXPR\_DECL constexpr}}
\DoxyCodeLine{68 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{69 \textcolor{preprocessor}{\# define FMT\_CONSTEXPR inline}}
\DoxyCodeLine{70 \textcolor{preprocessor}{\# define FMT\_CONSTEXPR\_DECL}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{72 }
\DoxyCodeLine{73 \textcolor{preprocessor}{\#ifndef FMT\_USE\_CONSTEXPR11}}
\DoxyCodeLine{74 \textcolor{preprocessor}{\# define FMT\_USE\_CONSTEXPR11 \(\backslash\)}}
\DoxyCodeLine{75 \textcolor{preprocessor}{    (FMT\_MSC\_VER >= 1900 || FMT\_GCC\_VERSION >= 406 || FMT\_USE\_CONSTEXPR)}}
\DoxyCodeLine{76 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{77 \textcolor{preprocessor}{\#if FMT\_USE\_CONSTEXPR11}}
\DoxyCodeLine{78 \textcolor{preprocessor}{\# define FMT\_CONSTEXPR11 constexpr}}
\DoxyCodeLine{79 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{80 \textcolor{preprocessor}{\# define FMT\_CONSTEXPR11}}
\DoxyCodeLine{81 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{82 }
\DoxyCodeLine{83 \textcolor{preprocessor}{\#ifndef FMT\_OVERRIDE}}
\DoxyCodeLine{84 \textcolor{preprocessor}{\# if FMT\_HAS\_FEATURE(cxx\_override) || \(\backslash\)}}
\DoxyCodeLine{85 \textcolor{preprocessor}{     (FMT\_GCC\_VERSION >= 408 \&\& FMT\_HAS\_GXX\_CXX11) || FMT\_MSC\_VER >= 1900}}
\DoxyCodeLine{86 \textcolor{preprocessor}{\#  define FMT\_OVERRIDE override}}
\DoxyCodeLine{87 \textcolor{preprocessor}{\# else}}
\DoxyCodeLine{88 \textcolor{preprocessor}{\#  define FMT\_OVERRIDE}}
\DoxyCodeLine{89 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{90 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{91 }
\DoxyCodeLine{92 \textcolor{preprocessor}{\#if FMT\_HAS\_FEATURE(cxx\_explicit\_conversions) || FMT\_MSC\_VER >= 1800}}
\DoxyCodeLine{93 \textcolor{preprocessor}{\# define FMT\_EXPLICIT explicit}}
\DoxyCodeLine{94 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{95 \textcolor{preprocessor}{\# define FMT\_EXPLICIT}}
\DoxyCodeLine{96 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{97 }
\DoxyCodeLine{98 \textcolor{preprocessor}{\#ifndef FMT\_NULL}}
\DoxyCodeLine{99 \textcolor{preprocessor}{\# if FMT\_HAS\_FEATURE(cxx\_nullptr) || \(\backslash\)}}
\DoxyCodeLine{100 \textcolor{preprocessor}{   (FMT\_GCC\_VERSION >= 408 \&\& FMT\_HAS\_GXX\_CXX11) || FMT\_MSC\_VER >= 1600}}
\DoxyCodeLine{101 \textcolor{preprocessor}{\#  define FMT\_NULL nullptr}}
\DoxyCodeLine{102 \textcolor{preprocessor}{\#  define FMT\_USE\_NULLPTR 1}}
\DoxyCodeLine{103 \textcolor{preprocessor}{\# else}}
\DoxyCodeLine{104 \textcolor{preprocessor}{\#  define FMT\_NULL NULL}}
\DoxyCodeLine{105 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{106 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{107 }
\DoxyCodeLine{108 \textcolor{preprocessor}{\#ifndef FMT\_USE\_NULLPTR}}
\DoxyCodeLine{109 \textcolor{preprocessor}{\# define FMT\_USE\_NULLPTR 0}}
\DoxyCodeLine{110 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{111 }
\DoxyCodeLine{112 \textcolor{preprocessor}{\#if FMT\_HAS\_CPP\_ATTRIBUTE(noreturn)}}
\DoxyCodeLine{113 \textcolor{preprocessor}{\# define FMT\_NORETURN [[noreturn]]}}
\DoxyCodeLine{114 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{115 \textcolor{preprocessor}{\# define FMT\_NORETURN}}
\DoxyCodeLine{116 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{117 }
\DoxyCodeLine{118 \textcolor{comment}{// Check if exceptions are disabled.}}
\DoxyCodeLine{119 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) \&\& !defined(\_\_EXCEPTIONS)}}
\DoxyCodeLine{120 \textcolor{preprocessor}{\# define FMT\_EXCEPTIONS 0}}
\DoxyCodeLine{121 \textcolor{preprocessor}{\#elif FMT\_MSC\_VER \&\& !\_HAS\_EXCEPTIONS}}
\DoxyCodeLine{122 \textcolor{preprocessor}{\# define FMT\_EXCEPTIONS 0}}
\DoxyCodeLine{123 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{124 \textcolor{preprocessor}{\#ifndef FMT\_EXCEPTIONS}}
\DoxyCodeLine{125 \textcolor{preprocessor}{\# define FMT\_EXCEPTIONS 1}}
\DoxyCodeLine{126 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{127 }
\DoxyCodeLine{128 \textcolor{comment}{// Define FMT\_USE\_NOEXCEPT to make fmt use noexcept (C++11 feature).}}
\DoxyCodeLine{129 \textcolor{preprocessor}{\#ifndef FMT\_USE\_NOEXCEPT}}
\DoxyCodeLine{130 \textcolor{preprocessor}{\# define FMT\_USE\_NOEXCEPT 0}}
\DoxyCodeLine{131 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{132 }
\DoxyCodeLine{133 \textcolor{preprocessor}{\#if FMT\_USE\_NOEXCEPT || FMT\_HAS\_FEATURE(cxx\_noexcept) || \(\backslash\)}}
\DoxyCodeLine{134 \textcolor{preprocessor}{    (FMT\_GCC\_VERSION >= 408 \&\& FMT\_HAS\_GXX\_CXX11) || FMT\_MSC\_VER >= 1900}}
\DoxyCodeLine{135 \textcolor{preprocessor}{\# define FMT\_DETECTED\_NOEXCEPT noexcept}}
\DoxyCodeLine{136 \textcolor{preprocessor}{\# define FMT\_HAS\_CXX11\_NOEXCEPT 1}}
\DoxyCodeLine{137 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{138 \textcolor{preprocessor}{\# define FMT\_DETECTED\_NOEXCEPT throw()}}
\DoxyCodeLine{139 \textcolor{preprocessor}{\# define FMT\_HAS\_CXX11\_NOEXCEPT 0}}
\DoxyCodeLine{140 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{141 }
\DoxyCodeLine{142 \textcolor{preprocessor}{\#ifndef FMT\_NOEXCEPT}}
\DoxyCodeLine{143 \textcolor{preprocessor}{\# if FMT\_EXCEPTIONS || FMT\_HAS\_CXX11\_NOEXCEPT}}
\DoxyCodeLine{144 \textcolor{preprocessor}{\#  define FMT\_NOEXCEPT FMT\_DETECTED\_NOEXCEPT}}
\DoxyCodeLine{145 \textcolor{preprocessor}{\# else}}
\DoxyCodeLine{146 \textcolor{preprocessor}{\#  define FMT\_NOEXCEPT}}
\DoxyCodeLine{147 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{148 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{149 }
\DoxyCodeLine{150 \textcolor{comment}{// This is needed because GCC still uses throw() in its headers when exceptions}}
\DoxyCodeLine{151 \textcolor{comment}{// are disabled.}}
\DoxyCodeLine{152 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION}}
\DoxyCodeLine{153 \textcolor{preprocessor}{\# define FMT\_DTOR\_NOEXCEPT FMT\_DETECTED\_NOEXCEPT}}
\DoxyCodeLine{154 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{155 \textcolor{preprocessor}{\# define FMT\_DTOR\_NOEXCEPT FMT\_NOEXCEPT}}
\DoxyCodeLine{156 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{157 }
\DoxyCodeLine{158 \textcolor{preprocessor}{\#ifndef FMT\_BEGIN\_NAMESPACE}}
\DoxyCodeLine{159 \textcolor{preprocessor}{\# if FMT\_HAS\_FEATURE(cxx\_inline\_namespaces) || FMT\_GCC\_VERSION >= 404 || \(\backslash\)}}
\DoxyCodeLine{160 \textcolor{preprocessor}{     FMT\_MSC\_VER >= 1900}}
\DoxyCodeLine{161 \textcolor{preprocessor}{\#  define FMT\_INLINE\_NAMESPACE inline namespace}}
\DoxyCodeLine{162 \textcolor{preprocessor}{\#  define FMT\_END\_NAMESPACE \}\}}}
\DoxyCodeLine{163 \textcolor{preprocessor}{\# else}}
\DoxyCodeLine{164 \textcolor{preprocessor}{\#  define FMT\_INLINE\_NAMESPACE namespace}}
\DoxyCodeLine{165 \textcolor{preprocessor}{\#  define FMT\_END\_NAMESPACE \} using namespace v5; \}}}
\DoxyCodeLine{166 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{167 \textcolor{preprocessor}{\# define FMT\_BEGIN\_NAMESPACE namespace fmt \{ FMT\_INLINE\_NAMESPACE v5 \{}}
\DoxyCodeLine{168 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{169 }
\DoxyCodeLine{170 \textcolor{preprocessor}{\#if !defined(FMT\_HEADER\_ONLY) \&\& defined(\_WIN32)}}
\DoxyCodeLine{171 \textcolor{preprocessor}{\# ifdef FMT\_EXPORT}}
\DoxyCodeLine{172 \textcolor{preprocessor}{\#  define FMT\_API \_\_declspec(dllexport)}}
\DoxyCodeLine{173 \textcolor{preprocessor}{\# elif defined(FMT\_SHARED)}}
\DoxyCodeLine{174 \textcolor{preprocessor}{\#  define FMT\_API \_\_declspec(dllimport)}}
\DoxyCodeLine{175 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{176 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{177 \textcolor{preprocessor}{\#ifndef FMT\_API}}
\DoxyCodeLine{178 \textcolor{preprocessor}{\# define FMT\_API}}
\DoxyCodeLine{179 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 \textcolor{preprocessor}{\#ifndef FMT\_ASSERT}}
\DoxyCodeLine{182 \textcolor{preprocessor}{\# define FMT\_ASSERT(condition, message) assert((condition) \&\& message)}}
\DoxyCodeLine{183 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{184 }
\DoxyCodeLine{185 \textcolor{comment}{// libc++ supports string\_view in pre-\/c++17.}}
\DoxyCodeLine{186 \textcolor{preprocessor}{\#if (FMT\_HAS\_INCLUDE(<string\_view>) \&\& \(\backslash\)}}
\DoxyCodeLine{187 \textcolor{preprocessor}{      (\_\_cplusplus > 201402L || defined(\_LIBCPP\_VERSION))) || \(\backslash\)}}
\DoxyCodeLine{188 \textcolor{preprocessor}{    (defined(\_MSVC\_LANG) \&\& \_MSVC\_LANG > 201402L \&\& \_MSC\_VER >= 1910)}}
\DoxyCodeLine{189 \textcolor{preprocessor}{\# include <string\_view>}}
\DoxyCodeLine{190 \textcolor{preprocessor}{\# define FMT\_USE\_STD\_STRING\_VIEW}}
\DoxyCodeLine{191 \textcolor{preprocessor}{\#elif (FMT\_HAS\_INCLUDE(<experimental/string\_view>) \&\& \(\backslash\)}}
\DoxyCodeLine{192 \textcolor{preprocessor}{       \_\_cplusplus >= 201402L)}}
\DoxyCodeLine{193 \textcolor{preprocessor}{\# include <experimental/string\_view>}}
\DoxyCodeLine{194 \textcolor{preprocessor}{\# define FMT\_USE\_EXPERIMENTAL\_STRING\_VIEW}}
\DoxyCodeLine{195 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{196 }
\DoxyCodeLine{197 \textcolor{comment}{// std::result\_of is defined in <functional> in gcc 4.4.}}
\DoxyCodeLine{198 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION <= 404}}
\DoxyCodeLine{199 \textcolor{preprocessor}{\# include <functional>}}
\DoxyCodeLine{200 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{201 }
\DoxyCodeLine{202 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{203 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{204 }
\DoxyCodeLine{205 \textcolor{comment}{// An implementation of declval for pre-\/C++11 compilers such as gcc 4.}}
\DoxyCodeLine{206 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{207 \textcolor{keyword}{typename} std::add\_rvalue\_reference<T>::type declval() FMT\_NOEXCEPT;}
\DoxyCodeLine{208 }
\DoxyCodeLine{209 template <typename>}
\DoxyCodeLine{210 struct \mbox{\hyperlink{structinternal_1_1result__of}{result\_of}};}
\DoxyCodeLine{211 }
\DoxyCodeLine{212 template <typename F, typename... Args>}
\DoxyCodeLine{213 struct \mbox{\hyperlink{structinternal_1_1result__of}{result\_of}}<F(Args...)> \{}
\DoxyCodeLine{214   \textcolor{comment}{// A workaround for gcc 4.4 that doesn't allow F to be a reference.}}
\DoxyCodeLine{215   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::result\_of<}
\DoxyCodeLine{216     \textcolor{keyword}{typename} std::remove\_reference<F>::type(Args...)>::type type;}
\DoxyCodeLine{217 \};}
\DoxyCodeLine{218 }
\DoxyCodeLine{219 \textcolor{comment}{// Casts nonnegative integer to unsigned.}}
\DoxyCodeLine{220 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Int>}
\DoxyCodeLine{221 FMT\_CONSTEXPR \textcolor{keyword}{typename} std::make\_unsigned<Int>::type to\_unsigned(Int \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{222   FMT\_ASSERT(\mbox{\hyperlink{classinternal_1_1value}{value}} >= 0, \textcolor{stringliteral}{"{}negative value"{}});}
\DoxyCodeLine{223   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}typename std::make\_unsigned<Int>::type\textcolor{keyword}{>}(\mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{224 \}}
\DoxyCodeLine{225 }
\DoxyCodeLine{226 \textcolor{comment}{// A constexpr std::char\_traits::length replacement for pre-\/C++17.}}
\DoxyCodeLine{227 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{228 FMT\_CONSTEXPR \textcolor{keywordtype}{size\_t} length(\textcolor{keyword}{const} Char *s) \{}
\DoxyCodeLine{229   \textcolor{keyword}{const} Char *start = s;}
\DoxyCodeLine{230   \textcolor{keywordflow}{while} (*s) ++s;}
\DoxyCodeLine{231   \textcolor{keywordflow}{return} s -\/ start;}
\DoxyCodeLine{232 \}}
\DoxyCodeLine{233 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION}}
\DoxyCodeLine{234 FMT\_CONSTEXPR \textcolor{keywordtype}{size\_t} length(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *s) \{ \textcolor{keywordflow}{return} std::strlen(s); \}}
\DoxyCodeLine{235 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{236 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{237 }
\DoxyCodeLine{245 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{246 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} \{}
\DoxyCodeLine{247  \textcolor{keyword}{private}:}
\DoxyCodeLine{248   \textcolor{keyword}{const} Char *data\_;}
\DoxyCodeLine{249   \textcolor{keywordtype}{size\_t} size\_;}
\DoxyCodeLine{250 }
\DoxyCodeLine{251  \textcolor{keyword}{public}:}
\DoxyCodeLine{252   \textcolor{keyword}{typedef} Char char\_type;}
\DoxyCodeLine{253   \textcolor{keyword}{typedef} \textcolor{keyword}{const} Char *iterator;}
\DoxyCodeLine{254 }
\DoxyCodeLine{255   \textcolor{comment}{// Standard basic\_string\_view type.}}
\DoxyCodeLine{256 \textcolor{preprocessor}{\#if defined(FMT\_USE\_STD\_STRING\_VIEW)}}
\DoxyCodeLine{257   \textcolor{keyword}{typedef} std::basic\_string\_view<Char> \mbox{\hyperlink{structbasic__string__view_1_1type}{type}};}
\DoxyCodeLine{258 \textcolor{preprocessor}{\#elif defined(FMT\_USE\_EXPERIMENTAL\_STRING\_VIEW)}}
\DoxyCodeLine{259   \textcolor{keyword}{typedef} std::experimental::basic\_string\_view<Char> \mbox{\hyperlink{structbasic__string__view_1_1type}{type}};}
\DoxyCodeLine{260 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{261   \textcolor{keyword}{struct }\mbox{\hyperlink{structbasic__string__view_1_1type}{type}} \{}
\DoxyCodeLine{262     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *data()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} FMT\_NULL; \}}
\DoxyCodeLine{263     \textcolor{keywordtype}{size\_t} size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{264   \};}
\DoxyCodeLine{265 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{266 }
\DoxyCodeLine{267   FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}}() FMT\_NOEXCEPT : data\_(FMT\_NULL), size\_(0) \{\}}
\DoxyCodeLine{268 }
\DoxyCodeLine{270   FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__string__view_a30be409cd941f8fa06e5e7b27496e3dc}{basic\_string\_view}}(\textcolor{keyword}{const} Char *s, \textcolor{keywordtype}{size\_t} count) FMT\_NOEXCEPT}
\DoxyCodeLine{271     : data\_(s), size\_(count) \{\}}
\DoxyCodeLine{272 }
\DoxyCodeLine{279   FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__string__view_a039a92fee947263a6c75dc6afd879719}{basic\_string\_view}}(\textcolor{keyword}{const} Char *s)}
\DoxyCodeLine{280     : data\_(s), size\_(internal::length(s)) \{\}}
\DoxyCodeLine{281 }
\DoxyCodeLine{283   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Alloc>}
\DoxyCodeLine{284   FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__string__view_a26380481d5c1675f0f56333f764c496b}{basic\_string\_view}}(}
\DoxyCodeLine{285       \textcolor{keyword}{const} std::basic\_string<Char, Alloc> \&s) FMT\_NOEXCEPT}
\DoxyCodeLine{286   : data\_(s.data()), size\_(s.size()) \{\}}
\DoxyCodeLine{287 }
\DoxyCodeLine{288   FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}}(type s) FMT\_NOEXCEPT}
\DoxyCodeLine{289   : data\_(s.data()), size\_(s.size()) \{\}}
\DoxyCodeLine{290 }
\DoxyCodeLine{292   FMT\_CONSTEXPR \textcolor{keyword}{const} Char *\mbox{\hyperlink{classbasic__string__view_ae88f246f09d5ee5610e979d074ea74e1}{data}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} data\_; \}}
\DoxyCodeLine{293 }
\DoxyCodeLine{295   FMT\_CONSTEXPR \textcolor{keywordtype}{size\_t} \mbox{\hyperlink{classbasic__string__view_a7fd9f4dcac1782259b0cd217af69d737}{size}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} size\_; \}}
\DoxyCodeLine{296 }
\DoxyCodeLine{297   FMT\_CONSTEXPR iterator begin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} data\_; \}}
\DoxyCodeLine{298   FMT\_CONSTEXPR iterator end()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} data\_ + size\_; \}}
\DoxyCodeLine{299 }
\DoxyCodeLine{300   FMT\_CONSTEXPR \textcolor{keywordtype}{void} remove\_prefix(\textcolor{keywordtype}{size\_t} n) \{}
\DoxyCodeLine{301     data\_ += n;}
\DoxyCodeLine{302     size\_ -\/= n;}
\DoxyCodeLine{303   \}}
\DoxyCodeLine{304 }
\DoxyCodeLine{305   \textcolor{comment}{// Lexicographically compare this string reference to other.}}
\DoxyCodeLine{306   \textcolor{keywordtype}{int} \mbox{\hyperlink{classcompare}{compare}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{307     \textcolor{keywordtype}{size\_t} str\_size = size\_ < other.size\_ ? size\_ : other.size\_;}
\DoxyCodeLine{308     \textcolor{keywordtype}{int} result = std::char\_traits<Char>::compare(data\_, other.data\_, str\_size);}
\DoxyCodeLine{309     \textcolor{keywordflow}{if} (result == 0)}
\DoxyCodeLine{310       result = size\_ == other.size\_ ? 0 : (size\_ < other.size\_ ? -\/1 : 1);}
\DoxyCodeLine{311     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{312   \}}
\DoxyCodeLine{313 }
\DoxyCodeLine{314   \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator==(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) \{}
\DoxyCodeLine{315     \textcolor{keywordflow}{return} lhs.compare(rhs) == 0;}
\DoxyCodeLine{316   \}}
\DoxyCodeLine{317   \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator!=(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) \{}
\DoxyCodeLine{318     \textcolor{keywordflow}{return} lhs.compare(rhs) != 0;}
\DoxyCodeLine{319   \}}
\DoxyCodeLine{320   \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator<(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) \{}
\DoxyCodeLine{321     \textcolor{keywordflow}{return} lhs.compare(rhs) < 0;}
\DoxyCodeLine{322   \}}
\DoxyCodeLine{323   \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator<=(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) \{}
\DoxyCodeLine{324     \textcolor{keywordflow}{return} lhs.compare(rhs) <= 0;}
\DoxyCodeLine{325   \}}
\DoxyCodeLine{326   \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator>(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) \{}
\DoxyCodeLine{327     \textcolor{keywordflow}{return} lhs.compare(rhs) > 0;}
\DoxyCodeLine{328   \}}
\DoxyCodeLine{329   \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator>=(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) \{}
\DoxyCodeLine{330     \textcolor{keywordflow}{return} lhs.compare(rhs) >= 0;}
\DoxyCodeLine{331   \}}
\DoxyCodeLine{332 \};}
\DoxyCodeLine{333 }
\DoxyCodeLine{334 \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char>}} \mbox{\hyperlink{classbasic__string__view}{string\_view}};}
\DoxyCodeLine{335 \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<wchar\_t>}} \mbox{\hyperlink{classbasic__string__view}{wstring\_view}};}
\DoxyCodeLine{336 }
\DoxyCodeLine{337 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{338 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg}};}
\DoxyCodeLine{339 }
\DoxyCodeLine{340 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{341 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}};}
\DoxyCodeLine{342 }
\DoxyCodeLine{343 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{344 \textcolor{keyword}{struct }\mbox{\hyperlink{structno__formatter__error}{no\_formatter\_error}} : std::false\_type \{\};}
\DoxyCodeLine{345 }
\DoxyCodeLine{346 \textcolor{comment}{// A formatter for objects of type T.}}
\DoxyCodeLine{347 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{348 \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}} \{}
\DoxyCodeLine{349   \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structno__formatter__error}{no\_formatter\_error<T>::value}},}
\DoxyCodeLine{350     \textcolor{stringliteral}{"{}don't know how to format the type, include fmt/ostream.h if it provides "{}}}
\DoxyCodeLine{351     \textcolor{stringliteral}{"{}an operator<< that should be used"{}});}
\DoxyCodeLine{352 }
\DoxyCodeLine{353   \textcolor{comment}{// The following functions are not defined intentionally.}}
\DoxyCodeLine{354   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{355   \textcolor{keyword}{typename} ParseContext::iterator parse(ParseContext \&);}
\DoxyCodeLine{356   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{357   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} T \&val, FormatContext \&ctx) -\/> \textcolor{keyword}{decltype}(ctx.out());}
\DoxyCodeLine{358 \};}
\DoxyCodeLine{359 }
\DoxyCodeLine{360 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{361 \textcolor{keyword}{struct }\mbox{\hyperlink{structconvert__to__int}{convert\_to\_int}} \{}
\DoxyCodeLine{362   \textcolor{keyword}{enum} \{}
\DoxyCodeLine{363     value = !std::is\_arithmetic<T>::value \&\& std::is\_convertible<T, int>::value}
\DoxyCodeLine{364   \};}
\DoxyCodeLine{365 \};}
\DoxyCodeLine{366 }
\DoxyCodeLine{367 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{368 }
\DoxyCodeLine{370 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{371 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1basic__buffer}{basic\_buffer}} \{}
\DoxyCodeLine{372  \textcolor{keyword}{private}:}
\DoxyCodeLine{373   \mbox{\hyperlink{classinternal_1_1basic__buffer}{basic\_buffer}}(\textcolor{keyword}{const} \mbox{\hyperlink{classinternal_1_1basic__buffer}{basic\_buffer}} \&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{374   \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classinternal_1_1basic__buffer}{basic\_buffer}} \&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{375 }
\DoxyCodeLine{376   T *ptr\_;}
\DoxyCodeLine{377   std::size\_t size\_;}
\DoxyCodeLine{378   std::size\_t capacity\_;}
\DoxyCodeLine{379 }
\DoxyCodeLine{380  \textcolor{keyword}{protected}:}
\DoxyCodeLine{381   \textcolor{comment}{// Don't initialize ptr\_ since it is not accessed to save a few cycles.}}
\DoxyCodeLine{382   \mbox{\hyperlink{classinternal_1_1basic__buffer}{basic\_buffer}}(std::size\_t sz) FMT\_NOEXCEPT: size\_(sz), capacity\_(sz) \{\}}
\DoxyCodeLine{383 }
\DoxyCodeLine{384   \mbox{\hyperlink{classinternal_1_1basic__buffer}{basic\_buffer}}(T *p = FMT\_NULL, std::size\_t sz = 0, std::size\_t cap = 0)}
\DoxyCodeLine{385     FMT\_NOEXCEPT: ptr\_(p), size\_(sz), capacity\_(cap) \{\}}
\DoxyCodeLine{386 }
\DoxyCodeLine{388   \textcolor{keywordtype}{void} \mbox{\hyperlink{classinternal_1_1basic__buffer_a0b603108f1aa614e64efaac6e081086d}{set}}(T *buf\_data, std::size\_t buf\_capacity) FMT\_NOEXCEPT \{}
\DoxyCodeLine{389     ptr\_ = buf\_data;}
\DoxyCodeLine{390     capacity\_ = buf\_capacity;}
\DoxyCodeLine{391   \}}
\DoxyCodeLine{392 }
\DoxyCodeLine{394   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} \mbox{\hyperlink{classinternal_1_1basic__buffer_a01fbeed379e2af2c79baf5c9b5dc92e8}{grow}}(std::size\_t \mbox{\hyperlink{classinternal_1_1basic__buffer_ae88bfc1cb8c896fa0b689ad8158cccae}{capacity}}) = 0;}
\DoxyCodeLine{395 }
\DoxyCodeLine{396  \textcolor{keyword}{public}:}
\DoxyCodeLine{397   \textcolor{keyword}{typedef} T value\_type;}
\DoxyCodeLine{398   \textcolor{keyword}{typedef} \textcolor{keyword}{const} T \&const\_reference;}
\DoxyCodeLine{399 }
\DoxyCodeLine{400   \textcolor{keyword}{virtual} \mbox{\hyperlink{classinternal_1_1basic__buffer}{\string~basic\_buffer}}() \{\}}
\DoxyCodeLine{401 }
\DoxyCodeLine{402   T *begin() FMT\_NOEXCEPT \{ \textcolor{keywordflow}{return} ptr\_; \}}
\DoxyCodeLine{403   T *end() FMT\_NOEXCEPT \{ \textcolor{keywordflow}{return} ptr\_ + size\_; \}}
\DoxyCodeLine{404 }
\DoxyCodeLine{406   std::size\_t \mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}}() const FMT\_NOEXCEPT \{ \textcolor{keywordflow}{return} size\_; \}}
\DoxyCodeLine{407 }
\DoxyCodeLine{409   std::size\_t \mbox{\hyperlink{classinternal_1_1basic__buffer_ae88bfc1cb8c896fa0b689ad8158cccae}{capacity}}() const FMT\_NOEXCEPT \{ \textcolor{keywordflow}{return} capacity\_; \}}
\DoxyCodeLine{410 }
\DoxyCodeLine{412   T *\mbox{\hyperlink{classinternal_1_1basic__buffer_a4716afee355656cd70e6719e5c0e6d62}{data}}() FMT\_NOEXCEPT \{ \textcolor{keywordflow}{return} ptr\_; \}}
\DoxyCodeLine{413 }
\DoxyCodeLine{415   \textcolor{keyword}{const} T *\mbox{\hyperlink{classinternal_1_1basic__buffer_a8b4d09d840ce377123ab97e86a1aee88}{data}}() const FMT\_NOEXCEPT \{ \textcolor{keywordflow}{return} ptr\_; \}}
\DoxyCodeLine{416 }
\DoxyCodeLine{420   \textcolor{keywordtype}{void} \mbox{\hyperlink{classinternal_1_1basic__buffer_adbd2b147e114f0cc4573f734d4326669}{resize}}(std::size\_t new\_size) \{}
\DoxyCodeLine{421     \mbox{\hyperlink{classinternal_1_1basic__buffer_ab4bbc728c01282567eebc165d545772a}{reserve}}(new\_size);}
\DoxyCodeLine{422     size\_ = new\_size;}
\DoxyCodeLine{423   \}}
\DoxyCodeLine{424 }
\DoxyCodeLine{426   \textcolor{keywordtype}{void} \mbox{\hyperlink{classinternal_1_1basic__buffer_a9a18325765c5245d1861874512355b72}{clear}}() \{ size\_ = 0; \}}
\DoxyCodeLine{427 }
\DoxyCodeLine{429   \textcolor{keywordtype}{void} \mbox{\hyperlink{classinternal_1_1basic__buffer_ab4bbc728c01282567eebc165d545772a}{reserve}}(std::size\_t new\_capacity) \{}
\DoxyCodeLine{430     \textcolor{keywordflow}{if} (new\_capacity > capacity\_)}
\DoxyCodeLine{431       \mbox{\hyperlink{classinternal_1_1basic__buffer_a01fbeed379e2af2c79baf5c9b5dc92e8}{grow}}(new\_capacity);}
\DoxyCodeLine{432   \}}
\DoxyCodeLine{433 }
\DoxyCodeLine{434   \textcolor{keywordtype}{void} push\_back(\textcolor{keyword}{const} T \&\mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{435     \mbox{\hyperlink{classinternal_1_1basic__buffer_ab4bbc728c01282567eebc165d545772a}{reserve}}(size\_ + 1);}
\DoxyCodeLine{436     ptr\_[size\_++] = \mbox{\hyperlink{classinternal_1_1value}{value}};}
\DoxyCodeLine{437   \}}
\DoxyCodeLine{438 }
\DoxyCodeLine{440   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{441   \textcolor{keywordtype}{void} \mbox{\hyperlink{classinternal_1_1basic__buffer_aba7ea1a95a28bc123712f2fd24cf7414}{append}}(\textcolor{keyword}{const} U *begin, \textcolor{keyword}{const} U *end);}
\DoxyCodeLine{442 }
\DoxyCodeLine{443   T \&operator[](std::size\_t index) \{ \textcolor{keywordflow}{return} ptr\_[index]; \}}
\DoxyCodeLine{444   \textcolor{keyword}{const} T \&operator[](std::size\_t index)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} ptr\_[index]; \}}
\DoxyCodeLine{445 \};}
\DoxyCodeLine{446 }
\DoxyCodeLine{447 \textcolor{keyword}{typedef} basic\_buffer<char> buffer;}
\DoxyCodeLine{448 \textcolor{keyword}{typedef} basic\_buffer<wchar\_t> wbuffer;}
\DoxyCodeLine{449 }
\DoxyCodeLine{450 \textcolor{comment}{// A container-\/backed buffer.}}
\DoxyCodeLine{451 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{452 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1container__buffer}{container\_buffer}} : \textcolor{keyword}{public} \mbox{\hyperlink{classinternal_1_1basic__buffer}{basic\_buffer}}<typename Container::value\_type> \{}
\DoxyCodeLine{453  \textcolor{keyword}{private}:}
\DoxyCodeLine{454   Container \&container\_;}
\DoxyCodeLine{455 }
\DoxyCodeLine{456  \textcolor{keyword}{protected}:}
\DoxyCodeLine{457   \textcolor{keywordtype}{void} \mbox{\hyperlink{classinternal_1_1container__buffer_a9dc9c633e12053ddf07af13b30b378b3}{grow}}(std::size\_t \mbox{\hyperlink{classinternal_1_1basic__buffer_ae88bfc1cb8c896fa0b689ad8158cccae}{capacity}}) FMT\_OVERRIDE \{}
\DoxyCodeLine{458     container\_.resize(\mbox{\hyperlink{classinternal_1_1basic__buffer_ae88bfc1cb8c896fa0b689ad8158cccae}{capacity}});}
\DoxyCodeLine{459     this-\/>\mbox{\hyperlink{classinternal_1_1basic__buffer_a0b603108f1aa614e64efaac6e081086d}{set}}(\&container\_[0], \mbox{\hyperlink{classinternal_1_1basic__buffer_ae88bfc1cb8c896fa0b689ad8158cccae}{capacity}});}
\DoxyCodeLine{460   \}}
\DoxyCodeLine{461 }
\DoxyCodeLine{462  \textcolor{keyword}{public}:}
\DoxyCodeLine{463   \textcolor{keyword}{explicit} \mbox{\hyperlink{classinternal_1_1container__buffer}{container\_buffer}}(Container \&c)}
\DoxyCodeLine{464     : \mbox{\hyperlink{classinternal_1_1basic__buffer}{basic\_buffer}}<typename Container::value\_type>(c.\mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}}()), container\_(c) \{\}}
\DoxyCodeLine{465 \};}
\DoxyCodeLine{466 }
\DoxyCodeLine{467 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1error__handler}{error\_handler}} \{}
\DoxyCodeLine{468   FMT\_CONSTEXPR \mbox{\hyperlink{structinternal_1_1error__handler}{error\_handler}}() \{\}}
\DoxyCodeLine{469   FMT\_CONSTEXPR \mbox{\hyperlink{structinternal_1_1error__handler}{error\_handler}}(\textcolor{keyword}{const} \mbox{\hyperlink{structinternal_1_1error__handler}{error\_handler}} \&) \{\}}
\DoxyCodeLine{470 }
\DoxyCodeLine{471   \textcolor{comment}{// This function is intentionally not constexpr to give a compile-\/time error.}}
\DoxyCodeLine{472   FMT\_API \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *message);}
\DoxyCodeLine{473 \};}
\DoxyCodeLine{474 }
\DoxyCodeLine{475 \textcolor{comment}{// Formatting of wide characters and strings into a narrow output is disallowed:}}
\DoxyCodeLine{476 \textcolor{comment}{//   fmt::format("{}\{\}"{}, L"{}test"{}); // error}}
\DoxyCodeLine{477 \textcolor{comment}{// To fix this, use a wide format string:}}
\DoxyCodeLine{478 \textcolor{comment}{//   fmt::format(L"{}\{\}"{}, L"{}test"{});}}
\DoxyCodeLine{479 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{480 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} require\_wchar() \{}
\DoxyCodeLine{481   \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{482       std::is\_same<wchar\_t, Char>::value,}
\DoxyCodeLine{483       \textcolor{stringliteral}{"{}formatting of wide characters into a narrow output is disallowed"{}});}
\DoxyCodeLine{484 \}}
\DoxyCodeLine{485 }
\DoxyCodeLine{486 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{487 \textcolor{keyword}{struct }named\_arg\_base;}
\DoxyCodeLine{488 }
\DoxyCodeLine{489 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{490 \textcolor{keyword}{struct }named\_arg;}
\DoxyCodeLine{491 }
\DoxyCodeLine{492 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{493 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1is__named__arg}{is\_named\_arg}} : std::false\_type \{\};}
\DoxyCodeLine{494 }
\DoxyCodeLine{495 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{496 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1is__named__arg}{is\_named\_arg}}<\mbox{\hyperlink{structinternal_1_1named__arg}{named\_arg}}<T, Char>> : std::true\_type \{\};}
\DoxyCodeLine{497 }
\DoxyCodeLine{498 \textcolor{keyword}{enum} type \{}
\DoxyCodeLine{499   none\_type, named\_arg\_type,}
\DoxyCodeLine{500   \textcolor{comment}{// Integer types should go first,}}
\DoxyCodeLine{501   int\_type, uint\_type, long\_long\_type, ulong\_long\_type, bool\_type, char\_type,}
\DoxyCodeLine{502   last\_integer\_type = char\_type,}
\DoxyCodeLine{503   \textcolor{comment}{// followed by floating-\/point types.}}
\DoxyCodeLine{504   double\_type, long\_double\_type, last\_numeric\_type = long\_double\_type,}
\DoxyCodeLine{505   cstring\_type, string\_type, pointer\_type, custom\_type}
\DoxyCodeLine{506 \};}
\DoxyCodeLine{507 }
\DoxyCodeLine{508 FMT\_CONSTEXPR \textcolor{keywordtype}{bool} is\_integral(type t) \{}
\DoxyCodeLine{509   FMT\_ASSERT(t != internal::named\_arg\_type, \textcolor{stringliteral}{"{}invalid argument type"{}});}
\DoxyCodeLine{510   \textcolor{keywordflow}{return} t > internal::none\_type \&\& t <= internal::last\_integer\_type;}
\DoxyCodeLine{511 \}}
\DoxyCodeLine{512 }
\DoxyCodeLine{513 FMT\_CONSTEXPR \textcolor{keywordtype}{bool} is\_arithmetic(type t) \{}
\DoxyCodeLine{514   FMT\_ASSERT(t != internal::named\_arg\_type, \textcolor{stringliteral}{"{}invalid argument type"{}});}
\DoxyCodeLine{515   \textcolor{keywordflow}{return} t > internal::none\_type \&\& t <= internal::last\_numeric\_type;}
\DoxyCodeLine{516 \}}
\DoxyCodeLine{517 }
\DoxyCodeLine{518 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{519 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1string__value}{string\_value}} \{}
\DoxyCodeLine{520   \textcolor{keyword}{const} Char *\mbox{\hyperlink{classinternal_1_1value}{value}};}
\DoxyCodeLine{521   std::size\_t size;}
\DoxyCodeLine{522 \};}
\DoxyCodeLine{523 }
\DoxyCodeLine{524 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{525 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1custom__value}{custom\_value}} \{}
\DoxyCodeLine{526   \textcolor{keyword}{const} \textcolor{keywordtype}{void} *\mbox{\hyperlink{classinternal_1_1value}{value}};}
\DoxyCodeLine{527   void (*format)(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *arg, Context \&ctx);}
\DoxyCodeLine{528 \};}
\DoxyCodeLine{529 }
\DoxyCodeLine{530 \textcolor{comment}{// A formatting argument value.}}
\DoxyCodeLine{531 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{532 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1value}{value}} \{}
\DoxyCodeLine{533  \textcolor{keyword}{public}:}
\DoxyCodeLine{534   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Context::char\_type char\_type;}
\DoxyCodeLine{535 }
\DoxyCodeLine{536   \textcolor{keyword}{union }\{}
\DoxyCodeLine{537     \textcolor{keywordtype}{int} int\_value;}
\DoxyCodeLine{538     \textcolor{keywordtype}{unsigned} uint\_value;}
\DoxyCodeLine{539     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} long\_long\_value;}
\DoxyCodeLine{540     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ulong\_long\_value;}
\DoxyCodeLine{541     \textcolor{keywordtype}{double} double\_value;}
\DoxyCodeLine{542     \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} long\_double\_value;}
\DoxyCodeLine{543     \textcolor{keyword}{const} \textcolor{keywordtype}{void} *pointer;}
\DoxyCodeLine{544     \mbox{\hyperlink{structinternal_1_1string__value}{string\_value<char\_type>}} string;}
\DoxyCodeLine{545     \mbox{\hyperlink{structinternal_1_1string__value}{string\_value<signed char>}} sstring;}
\DoxyCodeLine{546     \mbox{\hyperlink{structinternal_1_1string__value}{string\_value<unsigned char>}} ustring;}
\DoxyCodeLine{547     \mbox{\hyperlink{structinternal_1_1custom__value}{custom\_value<Context>}} custom;}
\DoxyCodeLine{548   \};}
\DoxyCodeLine{549 }
\DoxyCodeLine{550   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1value}{value}}(\textcolor{keywordtype}{int} val = 0) : int\_value(val) \{\}}
\DoxyCodeLine{551   \mbox{\hyperlink{classinternal_1_1value}{value}}(\textcolor{keywordtype}{unsigned} val) \{ uint\_value = val; \}}
\DoxyCodeLine{552   \mbox{\hyperlink{classinternal_1_1value}{value}}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val) \{ long\_long\_value = val; \}}
\DoxyCodeLine{553   \mbox{\hyperlink{classinternal_1_1value}{value}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val) \{ ulong\_long\_value = val; \}}
\DoxyCodeLine{554   \mbox{\hyperlink{classinternal_1_1value}{value}}(\textcolor{keywordtype}{double} val) \{ double\_value = val; \}}
\DoxyCodeLine{555   \mbox{\hyperlink{classinternal_1_1value}{value}}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} val) \{ long\_double\_value = val; \}}
\DoxyCodeLine{556   \mbox{\hyperlink{classinternal_1_1value}{value}}(\textcolor{keyword}{const} char\_type *val) \{ \textcolor{keywordtype}{string}.value = val; \}}
\DoxyCodeLine{557   \mbox{\hyperlink{classinternal_1_1value}{value}}(\textcolor{keyword}{const} \textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} *val) \{}
\DoxyCodeLine{558     \textcolor{keyword}{static\_assert}(std::is\_same<char, char\_type>::value,}
\DoxyCodeLine{559                   \textcolor{stringliteral}{"{}incompatible string types"{}});}
\DoxyCodeLine{560     sstring.value = val;}
\DoxyCodeLine{561   \}}
\DoxyCodeLine{562   \mbox{\hyperlink{classinternal_1_1value}{value}}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *val) \{}
\DoxyCodeLine{563     \textcolor{keyword}{static\_assert}(std::is\_same<char, char\_type>::value,}
\DoxyCodeLine{564                   \textcolor{stringliteral}{"{}incompatible string types"{}});}
\DoxyCodeLine{565     ustring.value = val;}
\DoxyCodeLine{566   \}}
\DoxyCodeLine{567   \mbox{\hyperlink{classinternal_1_1value}{value}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} val) \{}
\DoxyCodeLine{568     \textcolor{keywordtype}{string}.value = val.\mbox{\hyperlink{classbasic__string__view_ae88f246f09d5ee5610e979d074ea74e1}{data}}();}
\DoxyCodeLine{569     \textcolor{keywordtype}{string}.size = val.\mbox{\hyperlink{classbasic__string__view_a7fd9f4dcac1782259b0cd217af69d737}{size}}();}
\DoxyCodeLine{570   \}}
\DoxyCodeLine{571   \mbox{\hyperlink{classinternal_1_1value}{value}}(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *val) \{ pointer = val; \}}
\DoxyCodeLine{572 }
\DoxyCodeLine{573   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{574   \textcolor{keyword}{explicit} \mbox{\hyperlink{classinternal_1_1value}{value}}(\textcolor{keyword}{const} T \&val) \{}
\DoxyCodeLine{575     custom.value = \&val;}
\DoxyCodeLine{576     custom.format = \&format\_custom\_arg<T>;}
\DoxyCodeLine{577   \}}
\DoxyCodeLine{578 }
\DoxyCodeLine{579   \textcolor{keyword}{const} \mbox{\hyperlink{structinternal_1_1named__arg__base}{named\_arg\_base<char\_type>}} \&as\_named\_arg() \{}
\DoxyCodeLine{580     \textcolor{keywordflow}{return} *\textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\mbox{\hyperlink{structinternal_1_1named__arg__base}{named\_arg\_base<char\_type>}}*\textcolor{keyword}{>}(pointer);}
\DoxyCodeLine{581   \}}
\DoxyCodeLine{582 }
\DoxyCodeLine{583  \textcolor{keyword}{private}:}
\DoxyCodeLine{584   \textcolor{comment}{// Formats an argument of a custom type, such as a user-\/defined class.}}
\DoxyCodeLine{585   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{586   \textcolor{keyword}{static} \textcolor{keywordtype}{void} format\_custom\_arg(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *arg, Context \&ctx) \{}
\DoxyCodeLine{587     \textcolor{comment}{// Get the formatter type through the context to allow different contexts}}
\DoxyCodeLine{588     \textcolor{comment}{// have different extension points, e.g. `formatter<T>` for `format` and}}
\DoxyCodeLine{589     \textcolor{comment}{// `printf\_formatter<T>` for `printf`.}}
\DoxyCodeLine{590     \textcolor{keyword}{typename} Context::template formatter\_type<T>::type f;}
\DoxyCodeLine{591     \textcolor{keyword}{auto} \&\&parse\_ctx = ctx.parse\_context();}
\DoxyCodeLine{592     parse\_ctx.advance\_to(f.parse(parse\_ctx));}
\DoxyCodeLine{593     ctx.advance\_to(f.format(*\textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }T*\textcolor{keyword}{>}(arg), ctx));}
\DoxyCodeLine{594   \}}
\DoxyCodeLine{595 \};}
\DoxyCodeLine{596 }
\DoxyCodeLine{597 \textcolor{comment}{// Value initializer used to delay conversion to value and reduce memory churn.}}
\DoxyCodeLine{598 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T, type TYPE>}
\DoxyCodeLine{599 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1init}{init}} \{}
\DoxyCodeLine{600   T val;}
\DoxyCodeLine{601   \textcolor{keyword}{static} \textcolor{keyword}{const} type type\_tag = TYPE;}
\DoxyCodeLine{602 }
\DoxyCodeLine{603   FMT\_CONSTEXPR \mbox{\hyperlink{structinternal_1_1init}{init}}(\textcolor{keyword}{const} T \&v) : val(v) \{\}}
\DoxyCodeLine{604   FMT\_CONSTEXPR \textcolor{keyword}{operator} \mbox{\hyperlink{classinternal_1_1value}{value<Context>}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classinternal_1_1value}{value<Context>}}(val); \}}
\DoxyCodeLine{605 \};}
\DoxyCodeLine{606 }
\DoxyCodeLine{607 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{608 FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} make\_arg(\textcolor{keyword}{const} T \&\mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{609 }
\DoxyCodeLine{610 \textcolor{preprocessor}{\#define FMT\_MAKE\_VALUE(TAG, ArgType, ValueType) \(\backslash\)}}
\DoxyCodeLine{611 \textcolor{preprocessor}{  template <typename C> \(\backslash\)}}
\DoxyCodeLine{612 \textcolor{preprocessor}{  FMT\_CONSTEXPR init<C, ValueType, TAG> make\_value(ArgType val) \{ \(\backslash\)}}
\DoxyCodeLine{613 \textcolor{preprocessor}{    return static\_cast<ValueType>(val); \(\backslash\)}}
\DoxyCodeLine{614 \textcolor{preprocessor}{  \}}}
\DoxyCodeLine{615 }
\DoxyCodeLine{616 \textcolor{preprocessor}{\#define FMT\_MAKE\_VALUE\_SAME(TAG, Type) \(\backslash\)}}
\DoxyCodeLine{617 \textcolor{preprocessor}{  template <typename C> \(\backslash\)}}
\DoxyCodeLine{618 \textcolor{preprocessor}{  FMT\_CONSTEXPR init<C, Type, TAG> make\_value(Type val) \{ return val; \}}}
\DoxyCodeLine{619 }
\DoxyCodeLine{620 FMT\_MAKE\_VALUE(bool\_type, \textcolor{keywordtype}{bool}, \textcolor{keywordtype}{int})}
\DoxyCodeLine{621 FMT\_MAKE\_VALUE(int\_type, \textcolor{keywordtype}{short}, \textcolor{keywordtype}{int})}
\DoxyCodeLine{622 FMT\_MAKE\_VALUE(uint\_type, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}, \textcolor{keywordtype}{unsigned})}
\DoxyCodeLine{623 FMT\_MAKE\_VALUE\_SAME(int\_type, \textcolor{keywordtype}{int})}
\DoxyCodeLine{624 FMT\_MAKE\_VALUE\_SAME(uint\_type, \textcolor{keywordtype}{unsigned})}
\DoxyCodeLine{625 }
\DoxyCodeLine{626 \textcolor{comment}{// To minimize the number of types we need to deal with, long is translated}}
\DoxyCodeLine{627 \textcolor{comment}{// either to int or to long long depending on its size.}}
\DoxyCodeLine{628 \textcolor{keyword}{typedef} std::conditional<\textcolor{keyword}{sizeof}(long) == \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}), int, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}>::type}
\DoxyCodeLine{629         long\_type;}
\DoxyCodeLine{630 FMT\_MAKE\_VALUE(}
\DoxyCodeLine{631     (\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{long}) == \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}) ? int\_type : long\_long\_type), \textcolor{keywordtype}{long}, long\_type)}
\DoxyCodeLine{632 \textcolor{keyword}{typedef} std::conditional<\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} long) == \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned}),}
\DoxyCodeLine{633                          unsigned, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}>::type ulong\_type;}
\DoxyCodeLine{634 FMT\_MAKE\_VALUE(}
\DoxyCodeLine{635     (\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}) == \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned}) ? uint\_type : ulong\_long\_type),}
\DoxyCodeLine{636     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}, ulong\_type)}
\DoxyCodeLine{637 }
\DoxyCodeLine{638 FMT\_MAKE\_VALUE\_SAME(long\_long\_type, \textcolor{keywordtype}{long} \textcolor{keywordtype}{long})}
\DoxyCodeLine{639 FMT\_MAKE\_VALUE\_SAME(ulong\_long\_type, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long})}
\DoxyCodeLine{640 FMT\_MAKE\_VALUE(int\_type, \textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}, \textcolor{keywordtype}{int})}
\DoxyCodeLine{641 FMT\_MAKE\_VALUE(uint\_type, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}, \textcolor{keywordtype}{unsigned})}
\DoxyCodeLine{642 FMT\_MAKE\_VALUE(char\_type, \textcolor{keywordtype}{char}, \textcolor{keywordtype}{int})}
\DoxyCodeLine{643 }
\DoxyCodeLine{644 \textcolor{preprocessor}{\#if !defined(\_MSC\_VER) || defined(\_NATIVE\_WCHAR\_T\_DEFINED)}}
\DoxyCodeLine{645 \textcolor{keyword}{template} <\textcolor{keyword}{typename} C>}
\DoxyCodeLine{646 \textcolor{keyword}{inline} \mbox{\hyperlink{structinternal_1_1init}{init<C, int, char\_type>}} make\_value(\textcolor{keywordtype}{wchar\_t} val) \{}
\DoxyCodeLine{647   require\_wchar<typename C::char\_type>();}
\DoxyCodeLine{648   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(val);}
\DoxyCodeLine{649 \}}
\DoxyCodeLine{650 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{651 }
\DoxyCodeLine{652 FMT\_MAKE\_VALUE(double\_type, \textcolor{keywordtype}{float}, \textcolor{keywordtype}{double})}
\DoxyCodeLine{653 FMT\_MAKE\_VALUE\_SAME(double\_type, \textcolor{keywordtype}{double})}
\DoxyCodeLine{654 FMT\_MAKE\_VALUE\_SAME(long\_double\_type, \textcolor{keywordtype}{long} \textcolor{keywordtype}{double})}
\DoxyCodeLine{655 }
\DoxyCodeLine{656 \textcolor{comment}{// Formatting of wide strings into a narrow buffer and multibyte strings}}
\DoxyCodeLine{657 \textcolor{comment}{// into a wide buffer is disallowed (https://github.com/fmtlib/fmt/pull/606).}}
\DoxyCodeLine{658 FMT\_MAKE\_VALUE(cstring\_type, \textcolor{keyword}{typename} C::char\_type*,}
\DoxyCodeLine{659                \textcolor{keyword}{const} \textcolor{keyword}{typename} C::char\_type*)}
\DoxyCodeLine{660 FMT\_MAKE\_VALUE(cstring\_type, \textcolor{keyword}{const} \textcolor{keyword}{typename} C::char\_type*,}
\DoxyCodeLine{661                \textcolor{keyword}{const} \textcolor{keyword}{typename} C::char\_type*)}
\DoxyCodeLine{662 }
\DoxyCodeLine{663 FMT\_MAKE\_VALUE(cstring\_type, \textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}*, \textcolor{keyword}{const} \textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}*)}
\DoxyCodeLine{664 FMT\_MAKE\_VALUE\_SAME(cstring\_type, \textcolor{keyword}{const} \textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}*)}
\DoxyCodeLine{665 FMT\_MAKE\_VALUE(cstring\_type, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)}
\DoxyCodeLine{666 FMT\_MAKE\_VALUE\_SAME(cstring\_type, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)}
\DoxyCodeLine{667 FMT\_MAKE\_VALUE\_SAME(string\_type, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename C::char\_type>}})}
\DoxyCodeLine{668 FMT\_MAKE\_VALUE(string\_type,}
\DoxyCodeLine{669                \textcolor{keyword}{typename} \mbox{\hyperlink{structbasic__string__view_1_1type}{basic\_string\_view<typename C::char\_type>::type}},}
\DoxyCodeLine{670                \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename C::char\_type>}})}
\DoxyCodeLine{671 FMT\_MAKE\_VALUE(string\_type, \textcolor{keyword}{const} std::basic\_string<typename C::char\_type>\&,}
\DoxyCodeLine{672                \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename C::char\_type>}})}
\DoxyCodeLine{673 FMT\_MAKE\_VALUE(pointer\_type, \textcolor{keywordtype}{void}*, \textcolor{keyword}{const} \textcolor{keywordtype}{void}*)}
\DoxyCodeLine{674 FMT\_MAKE\_VALUE\_SAME(pointer\_type, \textcolor{keyword}{const} \textcolor{keywordtype}{void}*)}
\DoxyCodeLine{675 }
\DoxyCodeLine{676 \textcolor{preprocessor}{\#if FMT\_USE\_NULLPTR}}
\DoxyCodeLine{677 FMT\_MAKE\_VALUE(pointer\_type, std::nullptr\_t, \textcolor{keyword}{const} \textcolor{keywordtype}{void}*)}
\DoxyCodeLine{678 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{679 }
\DoxyCodeLine{680 \textcolor{comment}{// Formatting of arbitrary pointers is disallowed. If you want to output a}}
\DoxyCodeLine{681 \textcolor{comment}{// pointer cast it to "{}void *"{} or "{}const void *"{}. In particular, this forbids}}
\DoxyCodeLine{682 \textcolor{comment}{// formatting of "{}[const] volatile char *"{} which is printed as bool by}}
\DoxyCodeLine{683 \textcolor{comment}{// iostreams.}}
\DoxyCodeLine{684 \textcolor{keyword}{template} <\textcolor{keyword}{typename} C, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{685 \textcolor{keyword}{typename} std::enable\_if<!std::is\_same<T, typename C::char\_type>::value>::type}
\DoxyCodeLine{686     make\_value(\textcolor{keyword}{const} T *) \{}
\DoxyCodeLine{687   \textcolor{keyword}{static\_assert}(!\textcolor{keyword}{sizeof}(T), \textcolor{stringliteral}{"{}formatting of non-\/void pointers is disallowed"{}});}
\DoxyCodeLine{688 \}}
\DoxyCodeLine{689 }
\DoxyCodeLine{690 \textcolor{keyword}{template} <\textcolor{keyword}{typename} C, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{691 \textcolor{keyword}{inline} \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{692     std::is\_enum<T>::value \&\& \mbox{\hyperlink{structconvert__to__int}{convert\_to\_int<T, typename C::char\_type>::value}},}
\DoxyCodeLine{693     init<C, int, int\_type>>::type}
\DoxyCodeLine{694   make\_value(\textcolor{keyword}{const} T \&val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(val); \}}
\DoxyCodeLine{695 }
\DoxyCodeLine{696 \textcolor{keyword}{template} <\textcolor{keyword}{typename} C, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char = \textcolor{keyword}{typename} C::\textcolor{keywordtype}{char}\_type>}
\DoxyCodeLine{697 \textcolor{keyword}{inline} \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{698     std::is\_constructible<basic\_string\_view<Char>, T>::value,}
\DoxyCodeLine{699     init<C, basic\_string\_view<Char>, string\_type>>::type}
\DoxyCodeLine{700   make\_value(\textcolor{keyword}{const} T \&val) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(val); \}}
\DoxyCodeLine{701 }
\DoxyCodeLine{702 \textcolor{keyword}{template} <\textcolor{keyword}{typename} C, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char = \textcolor{keyword}{typename} C::\textcolor{keywordtype}{char}\_type>}
\DoxyCodeLine{703 \textcolor{keyword}{inline} \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{704     !\mbox{\hyperlink{structconvert__to__int}{convert\_to\_int<T, Char>::value}} \&\&}
\DoxyCodeLine{705     !std::is\_convertible<T, basic\_string\_view<Char>>::value \&\&}
\DoxyCodeLine{706     !std::is\_constructible<basic\_string\_view<Char>, T>::value,}
\DoxyCodeLine{707     \textcolor{comment}{// Implicit conversion to std::string is not handled here because it's}}
\DoxyCodeLine{708     \textcolor{comment}{// unsafe: https://github.com/fmtlib/fmt/issues/729}}
\DoxyCodeLine{709     init<C, const T \&, custom\_type>>::type}
\DoxyCodeLine{710   make\_value(\textcolor{keyword}{const} T \&val) \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{711 }
\DoxyCodeLine{712 \textcolor{keyword}{template} <\textcolor{keyword}{typename} C, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{713 init<C, const void*, named\_arg\_type>}
\DoxyCodeLine{714     make\_value(\textcolor{keyword}{const} named\_arg<T, typename C::char\_type> \&val) \{}
\DoxyCodeLine{715   \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<C>}} arg = make\_arg<C>(val.value);}
\DoxyCodeLine{716   std::memcpy(val.data, \&arg, \textcolor{keyword}{sizeof}(arg));}
\DoxyCodeLine{717   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&val);}
\DoxyCodeLine{718 \}}
\DoxyCodeLine{719 }
\DoxyCodeLine{720 \textcolor{comment}{// Maximum number of arguments with packed types.}}
\DoxyCodeLine{721 \textcolor{keyword}{enum} \{ max\_packed\_args = 15 \};}
\DoxyCodeLine{722 }
\DoxyCodeLine{723 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{724 \textcolor{keyword}{class }arg\_map;}
\DoxyCodeLine{725 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{726 }
\DoxyCodeLine{727 \textcolor{comment}{// A formatting argument. It is a trivially copyable/constructible type to}}
\DoxyCodeLine{728 \textcolor{comment}{// allow storage in basic\_memory\_buffer.}}
\DoxyCodeLine{729 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{730 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg}} \{}
\DoxyCodeLine{731  \textcolor{keyword}{private}:}
\DoxyCodeLine{732   \mbox{\hyperlink{classinternal_1_1value}{internal::value<Context>}} value\_;}
\DoxyCodeLine{733   internal::type type\_;}
\DoxyCodeLine{734 }
\DoxyCodeLine{735   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ContextType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{736   \textcolor{keyword}{friend} FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<ContextType>}}}
\DoxyCodeLine{737     internal::make\_arg(\textcolor{keyword}{const} T \&value);}
\DoxyCodeLine{738 }
\DoxyCodeLine{739   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Visitor, \textcolor{keyword}{typename} Ctx>}
\DoxyCodeLine{740   \textcolor{keyword}{friend} FMT\_CONSTEXPR \textcolor{keyword}{typename} \mbox{\hyperlink{structinternal_1_1result__of}{internal::result\_of}}<Visitor(\textcolor{keywordtype}{int})>::type}
\DoxyCodeLine{741     visit(Visitor \&\&vis, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Ctx>}} \&arg);}
\DoxyCodeLine{742 }
\DoxyCodeLine{743   \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<Context>;}
\DoxyCodeLine{744   \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1arg__map}{internal::arg\_map}}<Context>;}
\DoxyCodeLine{745 }
\DoxyCodeLine{746   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Context::char\_type char\_type;}
\DoxyCodeLine{747 }
\DoxyCodeLine{748  \textcolor{keyword}{public}:}
\DoxyCodeLine{749   \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__arg_1_1handle}{handle}} \{}
\DoxyCodeLine{750    \textcolor{keyword}{public}:}
\DoxyCodeLine{751     \textcolor{keyword}{explicit} \mbox{\hyperlink{classbasic__format__arg_1_1handle}{handle}}(\mbox{\hyperlink{structinternal_1_1custom__value}{internal::custom\_value<Context>}} custom): custom\_(custom) \{\}}
\DoxyCodeLine{752 }
\DoxyCodeLine{753     \textcolor{keywordtype}{void} format(Context \&ctx)\textcolor{keyword}{ const }\{ custom\_.format(custom\_.value, ctx); \}}
\DoxyCodeLine{754 }
\DoxyCodeLine{755    \textcolor{keyword}{private}:}
\DoxyCodeLine{756     \mbox{\hyperlink{structinternal_1_1custom__value}{internal::custom\_value<Context>}} custom\_;}
\DoxyCodeLine{757   \};}
\DoxyCodeLine{758 }
\DoxyCodeLine{759   FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg}}() : type\_(internal::none\_type) \{\}}
\DoxyCodeLine{760 }
\DoxyCodeLine{761   FMT\_EXPLICIT \textcolor{keyword}{operator} bool() const FMT\_NOEXCEPT \{}
\DoxyCodeLine{762     \textcolor{keywordflow}{return} type\_ != internal::none\_type;}
\DoxyCodeLine{763   \}}
\DoxyCodeLine{764 }
\DoxyCodeLine{765   internal::type type()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} type\_; \}}
\DoxyCodeLine{766 }
\DoxyCodeLine{767   \textcolor{keywordtype}{bool} is\_integral()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::is\_integral(type\_); \}}
\DoxyCodeLine{768   \textcolor{keywordtype}{bool} is\_arithmetic()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} internal::is\_arithmetic(type\_); \}}
\DoxyCodeLine{769 \};}
\DoxyCodeLine{770 }
\DoxyCodeLine{771 \textcolor{keyword}{struct }\mbox{\hyperlink{structmonostate}{monostate}} \{\};}
\DoxyCodeLine{772 }
\DoxyCodeLine{780 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Visitor, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{781 FMT\_CONSTEXPR \textcolor{keyword}{typename} \mbox{\hyperlink{structinternal_1_1result__of}{internal::result\_of}}<Visitor(\textcolor{keywordtype}{int})>::type}
\DoxyCodeLine{782     visit(Visitor \&\&vis, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} \&arg) \{}
\DoxyCodeLine{783   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Context::char\_type char\_type;}
\DoxyCodeLine{784   \textcolor{keywordflow}{switch} (arg.type\_) \{}
\DoxyCodeLine{785   \textcolor{keywordflow}{case} internal::none\_type:}
\DoxyCodeLine{786     \textcolor{keywordflow}{break};}
\DoxyCodeLine{787   \textcolor{keywordflow}{case} internal::named\_arg\_type:}
\DoxyCodeLine{788     FMT\_ASSERT(\textcolor{keyword}{false}, \textcolor{stringliteral}{"{}invalid argument type"{}});}
\DoxyCodeLine{789     \textcolor{keywordflow}{break};}
\DoxyCodeLine{790   \textcolor{keywordflow}{case} internal::int\_type:}
\DoxyCodeLine{791     \textcolor{keywordflow}{return} vis(arg.value\_.int\_value);}
\DoxyCodeLine{792   \textcolor{keywordflow}{case} internal::uint\_type:}
\DoxyCodeLine{793     \textcolor{keywordflow}{return} vis(arg.value\_.uint\_value);}
\DoxyCodeLine{794   \textcolor{keywordflow}{case} internal::long\_long\_type:}
\DoxyCodeLine{795     \textcolor{keywordflow}{return} vis(arg.value\_.long\_long\_value);}
\DoxyCodeLine{796   \textcolor{keywordflow}{case} internal::ulong\_long\_type:}
\DoxyCodeLine{797     \textcolor{keywordflow}{return} vis(arg.value\_.ulong\_long\_value);}
\DoxyCodeLine{798   \textcolor{keywordflow}{case} internal::bool\_type:}
\DoxyCodeLine{799     \textcolor{keywordflow}{return} vis(arg.value\_.int\_value != 0);}
\DoxyCodeLine{800   \textcolor{keywordflow}{case} internal::char\_type:}
\DoxyCodeLine{801     \textcolor{keywordflow}{return} vis(\textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(arg.value\_.int\_value));}
\DoxyCodeLine{802   \textcolor{keywordflow}{case} internal::double\_type:}
\DoxyCodeLine{803     \textcolor{keywordflow}{return} vis(arg.value\_.double\_value);}
\DoxyCodeLine{804   \textcolor{keywordflow}{case} internal::long\_double\_type:}
\DoxyCodeLine{805     \textcolor{keywordflow}{return} vis(arg.value\_.long\_double\_value);}
\DoxyCodeLine{806   \textcolor{keywordflow}{case} internal::cstring\_type:}
\DoxyCodeLine{807     \textcolor{keywordflow}{return} vis(arg.value\_.string.value);}
\DoxyCodeLine{808   \textcolor{keywordflow}{case} internal::string\_type:}
\DoxyCodeLine{809     \textcolor{keywordflow}{return} vis(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}}(}
\DoxyCodeLine{810                  arg.value\_.string.value, arg.value\_.string.size));}
\DoxyCodeLine{811   \textcolor{keywordflow}{case} internal::pointer\_type:}
\DoxyCodeLine{812     \textcolor{keywordflow}{return} vis(arg.value\_.pointer);}
\DoxyCodeLine{813   \textcolor{keywordflow}{case} internal::custom\_type:}
\DoxyCodeLine{814     \textcolor{keywordflow}{return} vis(\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__arg_1_1handle}{basic\_format\_arg<Context>::handle}}(arg.value\_.custom));}
\DoxyCodeLine{815   \}}
\DoxyCodeLine{816   \textcolor{keywordflow}{return} vis(\mbox{\hyperlink{structmonostate}{monostate}}());}
\DoxyCodeLine{817 \}}
\DoxyCodeLine{818 }
\DoxyCodeLine{819 \textcolor{comment}{// Parsing context consisting of a format string range being parsed and an}}
\DoxyCodeLine{820 \textcolor{comment}{// argument counter for automatic indexing.}}
\DoxyCodeLine{821 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} ErrorHandler = \textcolor{keywordtype}{int}ernal::error\_handler>}
\DoxyCodeLine{822 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__parse__context}{basic\_parse\_context}} : \textcolor{keyword}{private} ErrorHandler \{}
\DoxyCodeLine{823  \textcolor{keyword}{private}:}
\DoxyCodeLine{824   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str\_;}
\DoxyCodeLine{825   \textcolor{keywordtype}{int} next\_arg\_id\_;}
\DoxyCodeLine{826 }
\DoxyCodeLine{827  \textcolor{keyword}{public}:}
\DoxyCodeLine{828   \textcolor{keyword}{typedef} Char char\_type;}
\DoxyCodeLine{829   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} basic\_string\_view<Char>::iterator iterator;}
\DoxyCodeLine{830 }
\DoxyCodeLine{831   \textcolor{keyword}{explicit} FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__parse__context}{basic\_parse\_context}}(}
\DoxyCodeLine{832       \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str, ErrorHandler eh = ErrorHandler())}
\DoxyCodeLine{833     : ErrorHandler(eh), format\_str\_(format\_str), next\_arg\_id\_(0) \{\}}
\DoxyCodeLine{834 }
\DoxyCodeLine{835   \textcolor{comment}{// Returns an iterator to the beginning of the format string range being}}
\DoxyCodeLine{836   \textcolor{comment}{// parsed.}}
\DoxyCodeLine{837   FMT\_CONSTEXPR iterator begin() \textcolor{keyword}{const} FMT\_NOEXCEPT \{}
\DoxyCodeLine{838     \textcolor{keywordflow}{return} format\_str\_.begin();}
\DoxyCodeLine{839   \}}
\DoxyCodeLine{840 }
\DoxyCodeLine{841   \textcolor{comment}{// Returns an iterator past the end of the format string range being parsed.}}
\DoxyCodeLine{842   FMT\_CONSTEXPR iterator end() \textcolor{keyword}{const} FMT\_NOEXCEPT \{ \textcolor{keywordflow}{return} format\_str\_.end(); \}}
\DoxyCodeLine{843 }
\DoxyCodeLine{844   \textcolor{comment}{// Advances the begin iterator to ``it``.}}
\DoxyCodeLine{845   FMT\_CONSTEXPR \textcolor{keywordtype}{void} advance\_to(iterator it) \{}
\DoxyCodeLine{846     format\_str\_.remove\_prefix(internal::to\_unsigned(it -\/ begin()));}
\DoxyCodeLine{847   \}}
\DoxyCodeLine{848 }
\DoxyCodeLine{849   \textcolor{comment}{// Returns the next argument index.}}
\DoxyCodeLine{850   FMT\_CONSTEXPR \textcolor{keywordtype}{unsigned} next\_arg\_id();}
\DoxyCodeLine{851 }
\DoxyCodeLine{852   FMT\_CONSTEXPR \textcolor{keywordtype}{bool} check\_arg\_id(\textcolor{keywordtype}{unsigned}) \{}
\DoxyCodeLine{853     \textcolor{keywordflow}{if} (next\_arg\_id\_ > 0) \{}
\DoxyCodeLine{854       on\_error(\textcolor{stringliteral}{"{}cannot switch from automatic to manual argument indexing"{}});}
\DoxyCodeLine{855       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{856     \}}
\DoxyCodeLine{857     next\_arg\_id\_ = -\/1;}
\DoxyCodeLine{858     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{859   \}}
\DoxyCodeLine{860   \textcolor{keywordtype}{void} check\_arg\_id(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}) \{\}}
\DoxyCodeLine{861 }
\DoxyCodeLine{862   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *message) \{}
\DoxyCodeLine{863     ErrorHandler::on\_error(message);}
\DoxyCodeLine{864   \}}
\DoxyCodeLine{865 }
\DoxyCodeLine{866   FMT\_CONSTEXPR ErrorHandler error\_handler()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{867 \};}
\DoxyCodeLine{868 }
\DoxyCodeLine{869 \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__parse__context}{basic\_parse\_context<char>}} \mbox{\hyperlink{classbasic__parse__context}{parse\_context}};}
\DoxyCodeLine{870 \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__parse__context}{basic\_parse\_context<wchar\_t>}} \mbox{\hyperlink{classbasic__parse__context}{wparse\_context}};}
\DoxyCodeLine{871 }
\DoxyCodeLine{872 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{873 \textcolor{comment}{// A map from argument names to their values for named arguments.}}
\DoxyCodeLine{874 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{875 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1arg__map}{arg\_map}} \{}
\DoxyCodeLine{876  \textcolor{keyword}{private}:}
\DoxyCodeLine{877   \mbox{\hyperlink{classinternal_1_1arg__map}{arg\_map}}(\textcolor{keyword}{const} \mbox{\hyperlink{classinternal_1_1arg__map}{arg\_map}} \&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{878   \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classinternal_1_1arg__map}{arg\_map}} \&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{879 }
\DoxyCodeLine{880   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Context::char\_type char\_type;}
\DoxyCodeLine{881 }
\DoxyCodeLine{882   \textcolor{keyword}{struct }entry \{}
\DoxyCodeLine{883     \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} name;}
\DoxyCodeLine{884     \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} arg;}
\DoxyCodeLine{885   \};}
\DoxyCodeLine{886 }
\DoxyCodeLine{887   entry *map\_;}
\DoxyCodeLine{888   \textcolor{keywordtype}{unsigned} size\_;}
\DoxyCodeLine{889 }
\DoxyCodeLine{890   \textcolor{keywordtype}{void} push\_back(\mbox{\hyperlink{classinternal_1_1value}{value<Context>}} val) \{}
\DoxyCodeLine{891     \textcolor{keyword}{const} \mbox{\hyperlink{structinternal_1_1named__arg__base}{internal::named\_arg\_base<char\_type>}} \&named = val.as\_named\_arg();}
\DoxyCodeLine{892     map\_[size\_] = entry\{named.name, named.template deserialize<Context>()\};}
\DoxyCodeLine{893     ++size\_;}
\DoxyCodeLine{894   \}}
\DoxyCodeLine{895 }
\DoxyCodeLine{896  \textcolor{keyword}{public}:}
\DoxyCodeLine{897   \mbox{\hyperlink{classinternal_1_1arg__map}{arg\_map}}() : map\_(FMT\_NULL), size\_(0) \{\}}
\DoxyCodeLine{898   \textcolor{keywordtype}{void} \mbox{\hyperlink{structinternal_1_1init}{init}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<Context>}} \&args);}
\DoxyCodeLine{899   \mbox{\hyperlink{classinternal_1_1arg__map}{\string~arg\_map}}() \{ \textcolor{keyword}{delete} [] map\_; \}}
\DoxyCodeLine{900 }
\DoxyCodeLine{901   \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} find(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} name)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{902     \textcolor{comment}{// The list is unsorted, so just return the first matching name.}}
\DoxyCodeLine{903     \textcolor{keywordflow}{for} (entry *it = map\_, *end = map\_ + size\_; it != end; ++it) \{}
\DoxyCodeLine{904       \textcolor{keywordflow}{if} (it-\/>name == name)}
\DoxyCodeLine{905         \textcolor{keywordflow}{return} it-\/>arg;}
\DoxyCodeLine{906     \}}
\DoxyCodeLine{907     \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}}();}
\DoxyCodeLine{908   \}}
\DoxyCodeLine{909 \};}
\DoxyCodeLine{910 }
\DoxyCodeLine{911 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{912 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1context__base}{context\_base}} \{}
\DoxyCodeLine{913  \textcolor{keyword}{public}:}
\DoxyCodeLine{914   \textcolor{keyword}{typedef} OutputIt iterator;}
\DoxyCodeLine{915 }
\DoxyCodeLine{916  \textcolor{keyword}{private}:}
\DoxyCodeLine{917   \mbox{\hyperlink{classbasic__parse__context}{basic\_parse\_context<Char>}} parse\_context\_;}
\DoxyCodeLine{918   iterator out\_;}
\DoxyCodeLine{919   \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<Context>}} args\_;}
\DoxyCodeLine{920 }
\DoxyCodeLine{921  \textcolor{keyword}{protected}:}
\DoxyCodeLine{922   \textcolor{keyword}{typedef} Char char\_type;}
\DoxyCodeLine{923   \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} \mbox{\hyperlink{classbasic__format__arg}{format\_arg}};}
\DoxyCodeLine{924 }
\DoxyCodeLine{925   \mbox{\hyperlink{classinternal_1_1context__base}{context\_base}}(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} format\_str,}
\DoxyCodeLine{926                \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<Context>}} ctx\_args)}
\DoxyCodeLine{927   : parse\_context\_(format\_str), out\_(out), args\_(ctx\_args) \{\}}
\DoxyCodeLine{928 }
\DoxyCodeLine{929   \textcolor{comment}{// Returns the argument with specified index.}}
\DoxyCodeLine{930   \mbox{\hyperlink{classbasic__format__arg}{format\_arg}} do\_get\_arg(\textcolor{keywordtype}{unsigned} arg\_id) \{}
\DoxyCodeLine{931     \mbox{\hyperlink{classbasic__format__arg}{format\_arg}} arg = args\_.\mbox{\hyperlink{classbasic__format__args_ad381a683779a65c09c258faa2a0dbbea}{get}}(arg\_id);}
\DoxyCodeLine{932     \textcolor{keywordflow}{if} (!arg)}
\DoxyCodeLine{933       parse\_context\_.on\_error(\textcolor{stringliteral}{"{}argument index out of range"{}});}
\DoxyCodeLine{934     \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{935   \}}
\DoxyCodeLine{936 }
\DoxyCodeLine{937   \textcolor{comment}{// Checks if manual indexing is used and returns the argument with}}
\DoxyCodeLine{938   \textcolor{comment}{// specified index.}}
\DoxyCodeLine{939   \mbox{\hyperlink{classbasic__format__arg}{format\_arg}} get\_arg(\textcolor{keywordtype}{unsigned} arg\_id) \{}
\DoxyCodeLine{940     \textcolor{keywordflow}{return} this-\/>parse\_context().check\_arg\_id(arg\_id) ?}
\DoxyCodeLine{941       this-\/>do\_get\_arg(arg\_id) : \mbox{\hyperlink{classbasic__format__arg}{format\_arg}}();}
\DoxyCodeLine{942   \}}
\DoxyCodeLine{943 }
\DoxyCodeLine{944  \textcolor{keyword}{public}:}
\DoxyCodeLine{945   \mbox{\hyperlink{classbasic__parse__context}{basic\_parse\_context<char\_type>}} \&\mbox{\hyperlink{classbasic__parse__context}{parse\_context}}() \{}
\DoxyCodeLine{946     \textcolor{keywordflow}{return} parse\_context\_;}
\DoxyCodeLine{947   \}}
\DoxyCodeLine{948 }
\DoxyCodeLine{949   \mbox{\hyperlink{structinternal_1_1error__handler}{internal::error\_handler}} \mbox{\hyperlink{structinternal_1_1error__handler}{error\_handler}}() \{}
\DoxyCodeLine{950     \textcolor{keywordflow}{return} parse\_context\_.error\_handler();}
\DoxyCodeLine{951   \}}
\DoxyCodeLine{952 }
\DoxyCodeLine{953   \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *message) \{ parse\_context\_.on\_error(message); \}}
\DoxyCodeLine{954 }
\DoxyCodeLine{955   \textcolor{comment}{// Returns an iterator to the beginning of the output range.}}
\DoxyCodeLine{956   iterator out() \{ \textcolor{keywordflow}{return} out\_; \}}
\DoxyCodeLine{957   iterator begin() \{ \textcolor{keywordflow}{return} out\_; \}  \textcolor{comment}{// deprecated}}
\DoxyCodeLine{958 }
\DoxyCodeLine{959   \textcolor{comment}{// Advances the begin iterator to ``it``.}}
\DoxyCodeLine{960   \textcolor{keywordtype}{void} advance\_to(iterator it) \{ out\_ = it; \}}
\DoxyCodeLine{961 }
\DoxyCodeLine{962   \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<Context>}} args()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} args\_; \}}
\DoxyCodeLine{963 \};}
\DoxyCodeLine{964 }
\DoxyCodeLine{965 \textcolor{comment}{// Extracts a reference to the container from back\_insert\_iterator.}}
\DoxyCodeLine{966 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{967 \textcolor{keyword}{inline} Container \&get\_container(std::back\_insert\_iterator<Container> it) \{}
\DoxyCodeLine{968   \textcolor{keyword}{typedef} std::back\_insert\_iterator<Container> bi\_iterator;}
\DoxyCodeLine{969   \textcolor{keyword}{struct }accessor: bi\_iterator \{}
\DoxyCodeLine{970     accessor(bi\_iterator iter) : bi\_iterator(iter) \{\}}
\DoxyCodeLine{971     \textcolor{keyword}{using} bi\_iterator::container;}
\DoxyCodeLine{972   \};}
\DoxyCodeLine{973   \textcolor{keywordflow}{return} *accessor(it).container;}
\DoxyCodeLine{974 \}}
\DoxyCodeLine{975 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{976 }
\DoxyCodeLine{977 \textcolor{comment}{// Formatting context.}}
\DoxyCodeLine{978 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{979 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__context}{basic\_format\_context}} :}
\DoxyCodeLine{980   \textcolor{keyword}{public} \mbox{\hyperlink{classinternal_1_1context__base}{internal::context\_base}}<}
\DoxyCodeLine{981     OutputIt, basic\_format\_context<OutputIt, Char>, Char> \{}
\DoxyCodeLine{982  \textcolor{keyword}{public}:}
\DoxyCodeLine{984   \textcolor{keyword}{typedef} Char \mbox{\hyperlink{classbasic__format__context_ab6b3447e996c0b8117e4f6d98d4e1597}{char\_type}};}
\DoxyCodeLine{985 }
\DoxyCodeLine{986   \textcolor{comment}{// using formatter\_type = formatter<T, char\_type>;}}
\DoxyCodeLine{987   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{988   \textcolor{keyword}{struct }\mbox{\hyperlink{structbasic__format__context_1_1formatter__type}{formatter\_type}} \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structformatter}{formatter<T, char\_type>}} \mbox{\hyperlink{structformatter}{type}}; \};}
\DoxyCodeLine{989 }
\DoxyCodeLine{990  \textcolor{keyword}{private}:}
\DoxyCodeLine{991   \mbox{\hyperlink{classinternal_1_1arg__map}{internal::arg\_map<basic\_format\_context>}} map\_;}
\DoxyCodeLine{992 }
\DoxyCodeLine{993   \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context}} \&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{994   \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context}} \&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{995 }
\DoxyCodeLine{996   \textcolor{keyword}{typedef} \mbox{\hyperlink{classinternal_1_1context__base}{internal::context\_base<OutputIt, basic\_format\_context, Char>}} \mbox{\hyperlink{classinternal_1_1context__base}{base}};}
\DoxyCodeLine{997   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__arg}{base::format\_arg}} \mbox{\hyperlink{classbasic__format__arg}{format\_arg}};}
\DoxyCodeLine{998   \textcolor{keyword}{using} base::get\_arg;}
\DoxyCodeLine{999 }
\DoxyCodeLine{1000  \textcolor{keyword}{public}:}
\DoxyCodeLine{1001   \textcolor{keyword}{using} \textcolor{keyword}{typename} base::iterator;}
\DoxyCodeLine{1002 }
\DoxyCodeLine{1007   \mbox{\hyperlink{classbasic__format__context_a854f7ee2c3cffc5b650a4724578b935d}{basic\_format\_context}}(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} format\_str,}
\DoxyCodeLine{1008                 \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<basic\_format\_context>}} ctx\_args)}
\DoxyCodeLine{1009     : \mbox{\hyperlink{classinternal_1_1context__base}{base}}(out, format\_str, ctx\_args) \{\}}
\DoxyCodeLine{1010 }
\DoxyCodeLine{1011   format\_arg next\_arg() \{}
\DoxyCodeLine{1012     \textcolor{keywordflow}{return} this-\/>do\_get\_arg(this-\/>parse\_context().next\_arg\_id());}
\DoxyCodeLine{1013   \}}
\DoxyCodeLine{1014   format\_arg get\_arg(\textcolor{keywordtype}{unsigned} arg\_id) \{ \textcolor{keywordflow}{return} this-\/>do\_get\_arg(arg\_id); \}}
\DoxyCodeLine{1015 }
\DoxyCodeLine{1016   \textcolor{comment}{// Checks if manual indexing is used and returns the argument with the}}
\DoxyCodeLine{1017   \textcolor{comment}{// specified name.}}
\DoxyCodeLine{1018   format\_arg get\_arg(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} name);}
\DoxyCodeLine{1019 \};}
\DoxyCodeLine{1020 }
\DoxyCodeLine{1021 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1022 \textcolor{keyword}{struct }\mbox{\hyperlink{structbuffer__context}{buffer\_context}} \{}
\DoxyCodeLine{1023   \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context}}<}
\DoxyCodeLine{1024     std::back\_insert\_iterator<internal::basic\_buffer<Char>>, Char> \mbox{\hyperlink{classbasic__format__context}{type}};}
\DoxyCodeLine{1025 \};}
\DoxyCodeLine{1026 \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__context}{buffer\_context<char>::type}} \mbox{\hyperlink{classbasic__format__context}{format\_context}};}
\DoxyCodeLine{1027 \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__context}{buffer\_context<wchar\_t>::type}} \mbox{\hyperlink{classbasic__format__context}{wformat\_context}};}
\DoxyCodeLine{1028 }
\DoxyCodeLine{1029 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{1030 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1031 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1get__type}{get\_type}} \{}
\DoxyCodeLine{1032   \textcolor{keyword}{typedef} \textcolor{keyword}{decltype}(make\_value<Context>(}
\DoxyCodeLine{1033         declval<\textcolor{keyword}{typename} std::decay<T>::type\&>())) value\_type;}
\DoxyCodeLine{1034   \textcolor{keyword}{static} \textcolor{keyword}{const} type \mbox{\hyperlink{classinternal_1_1value}{value}} = value\_type::type\_tag;}
\DoxyCodeLine{1035 \};}
\DoxyCodeLine{1036 }
\DoxyCodeLine{1037 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{1038 FMT\_CONSTEXPR11 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} get\_types() \{ \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{1039 }
\DoxyCodeLine{1040 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} Arg, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1041 FMT\_CONSTEXPR11 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} get\_types() \{}
\DoxyCodeLine{1042   \textcolor{keywordflow}{return} get\_type<Context, Arg>::value | (get\_types<Context, Args...>() << 4);}
\DoxyCodeLine{1043 \}}
\DoxyCodeLine{1044 }
\DoxyCodeLine{1045 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1046 FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} make\_arg(\textcolor{keyword}{const} T \&value) \{}
\DoxyCodeLine{1047   \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} arg;}
\DoxyCodeLine{1048   arg.type\_ = get\_type<Context, T>::value;}
\DoxyCodeLine{1049   arg.value\_ = make\_value<Context>(value);}
\DoxyCodeLine{1050   \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{1051 \}}
\DoxyCodeLine{1052 }
\DoxyCodeLine{1053 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} IS\_PACKED, \textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1054 \textcolor{keyword}{inline} \textcolor{keyword}{typename} std::enable\_if<IS\_PACKED, value<Context>>::type}
\DoxyCodeLine{1055     make\_arg(\textcolor{keyword}{const} T \&value) \{}
\DoxyCodeLine{1056   \textcolor{keywordflow}{return} make\_value<Context>(value);}
\DoxyCodeLine{1057 \}}
\DoxyCodeLine{1058 }
\DoxyCodeLine{1059 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} IS\_PACKED, \textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1060 \textcolor{keyword}{inline} \textcolor{keyword}{typename} std::enable\_if<!IS\_PACKED, basic\_format\_arg<Context>>::type}
\DoxyCodeLine{1061     make\_arg(\textcolor{keyword}{const} T \&value) \{}
\DoxyCodeLine{1062   \textcolor{keywordflow}{return} make\_arg<Context>(value);}
\DoxyCodeLine{1063 \}}
\DoxyCodeLine{1064 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{1065 }
\DoxyCodeLine{1073 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} ...Args>}
\DoxyCodeLine{1074 \textcolor{keyword}{class }\mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}} \{}
\DoxyCodeLine{1075  \textcolor{keyword}{private}:}
\DoxyCodeLine{1076   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} NUM\_ARGS = \textcolor{keyword}{sizeof}...(Args);}
\DoxyCodeLine{1077 }
\DoxyCodeLine{1078   \textcolor{comment}{// Packed is a macro on MinGW so use IS\_PACKED instead.}}
\DoxyCodeLine{1079   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} IS\_PACKED = NUM\_ARGS < internal::max\_packed\_args;}
\DoxyCodeLine{1080 }
\DoxyCodeLine{1081   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::conditional<IS\_PACKED,}
\DoxyCodeLine{1082     \mbox{\hyperlink{classinternal_1_1value}{internal::value<Context>}}, \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}}>::type value\_type;}
\DoxyCodeLine{1083 }
\DoxyCodeLine{1084   \textcolor{comment}{// If the arguments are not packed, add one more element to mark the end.}}
\DoxyCodeLine{1085   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} DATA\_SIZE =}
\DoxyCodeLine{1086           NUM\_ARGS + (IS\_PACKED \&\& NUM\_ARGS != 0 ? 0 : 1);}
\DoxyCodeLine{1087   value\_type data\_[DATA\_SIZE];}
\DoxyCodeLine{1088 }
\DoxyCodeLine{1089   \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<Context>;}
\DoxyCodeLine{1090 }
\DoxyCodeLine{1091   \textcolor{keyword}{static} FMT\_CONSTEXPR11 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} get\_types() \{}
\DoxyCodeLine{1092     \textcolor{keywordflow}{return} IS\_PACKED ?}
\DoxyCodeLine{1093       \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(internal::get\_types<Context, Args...>()) :}
\DoxyCodeLine{1094       -\/\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(NUM\_ARGS);}
\DoxyCodeLine{1095   \}}
\DoxyCodeLine{1096 }
\DoxyCodeLine{1097  \textcolor{keyword}{public}:}
\DoxyCodeLine{1098 \textcolor{preprocessor}{\#if FMT\_USE\_CONSTEXPR11}}
\DoxyCodeLine{1099   \textcolor{keyword}{static} FMT\_CONSTEXPR11 \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} TYPES = get\_types();}
\DoxyCodeLine{1100 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1101   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} TYPES;}
\DoxyCodeLine{1102 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1103 }
\DoxyCodeLine{1104 \textcolor{preprocessor}{\#if (FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION <= 405) || \(\backslash\)}}
\DoxyCodeLine{1105 \textcolor{preprocessor}{    (FMT\_MSC\_VER \&\& FMT\_MSC\_VER <= 1800)}}
\DoxyCodeLine{1106   \textcolor{comment}{// Workaround array initialization issues in gcc <= 4.5 and MSVC <= 2013.}}
\DoxyCodeLine{1107   \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}(\textcolor{keyword}{const} Args \&... args) \{}
\DoxyCodeLine{1108     value\_type init[DATA\_SIZE] =}
\DoxyCodeLine{1109       \{internal::make\_arg<IS\_PACKED, Context>(args)...\};}
\DoxyCodeLine{1110     std::memcpy(data\_, init, \textcolor{keyword}{sizeof}(init));}
\DoxyCodeLine{1111   \}}
\DoxyCodeLine{1112 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1113   \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}(\textcolor{keyword}{const} Args \&... args)}
\DoxyCodeLine{1114     : data\_\{internal::make\_arg<IS\_PACKED, Context>(args)...\} \{\}}
\DoxyCodeLine{1115 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1116 \};}
\DoxyCodeLine{1117 }
\DoxyCodeLine{1118 \textcolor{preprocessor}{\#if !FMT\_USE\_CONSTEXPR11}}
\DoxyCodeLine{1119 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} ...Args>}
\DoxyCodeLine{1120 \textcolor{keyword}{const} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<Context, Args...>::TYPES = get\_types();}
\DoxyCodeLine{1121 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1122 }
\DoxyCodeLine{1130 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} ...Args>}
\DoxyCodeLine{1131 \textcolor{keyword}{inline} \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<Context, Args...>}
\DoxyCodeLine{1132     make\_format\_args(\textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{1133   \textcolor{keywordflow}{return} \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<Context, Args...>(args...);}
\DoxyCodeLine{1134 \}}
\DoxyCodeLine{1135 }
\DoxyCodeLine{1136 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ...Args>}
\DoxyCodeLine{1137 \textcolor{keyword}{inline} \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<\mbox{\hyperlink{classbasic__format__context}{format\_context}}, Args...>}
\DoxyCodeLine{1138     make\_format\_args(\textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{1139   \textcolor{keywordflow}{return} \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<\mbox{\hyperlink{classbasic__format__context}{format\_context}}, Args...>(args...);}
\DoxyCodeLine{1140 \}}
\DoxyCodeLine{1141 }
\DoxyCodeLine{1143 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{1144 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}} \{}
\DoxyCodeLine{1145  \textcolor{keyword}{public}:}
\DoxyCodeLine{1146   \textcolor{keyword}{typedef} \textcolor{keywordtype}{unsigned} size\_type;}
\DoxyCodeLine{1147   \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}}  \mbox{\hyperlink{classbasic__format__arg}{format\_arg}};}
\DoxyCodeLine{1148 }
\DoxyCodeLine{1149  \textcolor{keyword}{private}:}
\DoxyCodeLine{1150   \textcolor{comment}{// To reduce compiled code size per formatting function call, types of first}}
\DoxyCodeLine{1151   \textcolor{comment}{// max\_packed\_args arguments are passed in the types\_ field.}}
\DoxyCodeLine{1152   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} types\_;}
\DoxyCodeLine{1153   \textcolor{keyword}{union }\{}
\DoxyCodeLine{1154     \textcolor{comment}{// If the number of arguments is less than max\_packed\_args, the argument}}
\DoxyCodeLine{1155     \textcolor{comment}{// values are stored in values\_, otherwise they are stored in args\_.}}
\DoxyCodeLine{1156     \textcolor{comment}{// This is done to reduce compiled code size as storing larger objects}}
\DoxyCodeLine{1157     \textcolor{comment}{// may require more code (at least on x86-\/64) even if the same amount of}}
\DoxyCodeLine{1158     \textcolor{comment}{// data is actually copied to stack. It saves \string~10\% on the bloat test.}}
\DoxyCodeLine{1159     \textcolor{keyword}{const} \mbox{\hyperlink{classinternal_1_1value}{internal::value<Context>}} *values\_;}
\DoxyCodeLine{1160     \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__arg}{format\_arg}} *args\_;}
\DoxyCodeLine{1161   \};}
\DoxyCodeLine{1162 }
\DoxyCodeLine{1163   \textcolor{keyword}{typename} internal::type type(\textcolor{keywordtype}{unsigned} index)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1164     \textcolor{keywordtype}{unsigned} shift = index * 4;}
\DoxyCodeLine{1165     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} mask = 0xf;}
\DoxyCodeLine{1166     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}typename internal::type\textcolor{keyword}{>}(}
\DoxyCodeLine{1167       (types\_ \& (mask << shift)) >> shift);}
\DoxyCodeLine{1168   \}}
\DoxyCodeLine{1169 }
\DoxyCodeLine{1170   \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1arg__map}{internal::arg\_map}}<Context>;}
\DoxyCodeLine{1171 }
\DoxyCodeLine{1172   \textcolor{keywordtype}{void} set\_data(\textcolor{keyword}{const} \mbox{\hyperlink{classinternal_1_1value}{internal::value<Context>}} *values) \{ values\_ = values; \}}
\DoxyCodeLine{1173   \textcolor{keywordtype}{void} set\_data(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__arg}{format\_arg}} *args) \{ args\_ = args; \}}
\DoxyCodeLine{1174 }
\DoxyCodeLine{1175   \mbox{\hyperlink{classbasic__format__arg}{format\_arg}} do\_get(size\_type index)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1176     \mbox{\hyperlink{classbasic__format__arg}{format\_arg}} arg;}
\DoxyCodeLine{1177     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} signed\_types = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(types\_);}
\DoxyCodeLine{1178     \textcolor{keywordflow}{if} (signed\_types < 0) \{}
\DoxyCodeLine{1179       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} num\_args =}
\DoxyCodeLine{1180           \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(-\/signed\_types);}
\DoxyCodeLine{1181       \textcolor{keywordflow}{if} (index < num\_args)}
\DoxyCodeLine{1182         arg = args\_[index];}
\DoxyCodeLine{1183       \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{1184     \}}
\DoxyCodeLine{1185     \textcolor{keywordflow}{if} (index > internal::max\_packed\_args)}
\DoxyCodeLine{1186       \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{1187     arg.type\_ = type(index);}
\DoxyCodeLine{1188     \textcolor{keywordflow}{if} (arg.type\_ == internal::none\_type)}
\DoxyCodeLine{1189       \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{1190     \mbox{\hyperlink{classinternal_1_1value}{internal::value<Context>}} \&val = arg.value\_;}
\DoxyCodeLine{1191     val = values\_[index];}
\DoxyCodeLine{1192     \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{1193   \}}
\DoxyCodeLine{1194 }
\DoxyCodeLine{1195  \textcolor{keyword}{public}:}
\DoxyCodeLine{1196   \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}() : types\_(0) \{\}}
\DoxyCodeLine{1197 }
\DoxyCodeLine{1203   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1204   \mbox{\hyperlink{classbasic__format__args_aff6e7b681609f33b18afb00281259ce2}{basic\_format\_args}}(\textcolor{keyword}{const} \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store<Context, Args...>}} \&store)}
\DoxyCodeLine{1205   : types\_(static\_cast<unsigned long long>(store.TYPES)) \{}
\DoxyCodeLine{1206     set\_data(store.data\_);}
\DoxyCodeLine{1207   \}}
\DoxyCodeLine{1208 }
\DoxyCodeLine{1214   \mbox{\hyperlink{classbasic__format__args_a1ee5ccabb966711853a85daf1ac77689}{basic\_format\_args}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__arg}{format\_arg}} *args, size\_type count)}
\DoxyCodeLine{1215   : types\_(-\/static\_cast<int64\_t>(count)) \{}
\DoxyCodeLine{1216     set\_data(args);}
\DoxyCodeLine{1217   \}}
\DoxyCodeLine{1218 }
\DoxyCodeLine{1220   \mbox{\hyperlink{classbasic__format__arg}{format\_arg}} \mbox{\hyperlink{classbasic__format__args_ad381a683779a65c09c258faa2a0dbbea}{get}}(size\_type index)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1221     \mbox{\hyperlink{classbasic__format__arg}{format\_arg}} arg = do\_get(index);}
\DoxyCodeLine{1222     \textcolor{keywordflow}{if} (arg.type\_ == internal::named\_arg\_type)}
\DoxyCodeLine{1223       arg = arg.value\_.as\_named\_arg().template deserialize<Context>();}
\DoxyCodeLine{1224     \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{1225   \}}
\DoxyCodeLine{1226 }
\DoxyCodeLine{1227   \textcolor{keywordtype}{unsigned} max\_size()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1228     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} signed\_types = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(types\_);}
\DoxyCodeLine{1229     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(}
\DoxyCodeLine{1230         signed\_types < 0 ?}
\DoxyCodeLine{1231         -\/signed\_types : \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(internal::max\_packed\_args));}
\DoxyCodeLine{1232   \}}
\DoxyCodeLine{1233 \};}
\DoxyCodeLine{1234 }
\DoxyCodeLine{1236 \textcolor{comment}{// It is a separate type rather than a typedef to make symbols readable.}}
\DoxyCodeLine{1237 \textcolor{keyword}{struct }\mbox{\hyperlink{structformat__args}{format\_args}}: \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<format\_context> \{}
\DoxyCodeLine{1238   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ...Args>}
\DoxyCodeLine{1239   \mbox{\hyperlink{structformat__args}{format\_args}}(Args \&\& ... arg)}
\DoxyCodeLine{1240   : \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<format\_context>}}(std::forward<Args>(arg)...) \{\}}
\DoxyCodeLine{1241 \};}
\DoxyCodeLine{1242 \textcolor{keyword}{struct }\mbox{\hyperlink{structwformat__args}{wformat\_args}} : \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<wformat\_context> \{}
\DoxyCodeLine{1243   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ...Args>}
\DoxyCodeLine{1244   \mbox{\hyperlink{structwformat__args}{wformat\_args}}(Args \&\& ... arg)}
\DoxyCodeLine{1245   : \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<wformat\_context>}}(std::forward<Args>(arg)...) \{\}}
\DoxyCodeLine{1246 \};}
\DoxyCodeLine{1247 }
\DoxyCodeLine{1248 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{1249 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1250 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1named__arg__base}{named\_arg\_base}} \{}
\DoxyCodeLine{1251   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name;}
\DoxyCodeLine{1252 }
\DoxyCodeLine{1253   \textcolor{comment}{// Serialized value<context>.}}
\DoxyCodeLine{1254   \textcolor{keyword}{mutable} \textcolor{keywordtype}{char} \mbox{\hyperlink{structinternal_1_1basic__data}{data}}[\textcolor{keyword}{sizeof}(\mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<format\_context>}})];}
\DoxyCodeLine{1255 }
\DoxyCodeLine{1256   \mbox{\hyperlink{structinternal_1_1named__arg__base}{named\_arg\_base}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} nm) : name(nm) \{\}}
\DoxyCodeLine{1257 }
\DoxyCodeLine{1258   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{1259   \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} deserialize()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1260     \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} arg;}
\DoxyCodeLine{1261     std::memcpy(\&arg, \mbox{\hyperlink{structinternal_1_1basic__data}{data}}, \textcolor{keyword}{sizeof}(\mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}}));}
\DoxyCodeLine{1262     \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{1263   \}}
\DoxyCodeLine{1264 \};}
\DoxyCodeLine{1265 }
\DoxyCodeLine{1266 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1267 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1named__arg}{named\_arg}} : \mbox{\hyperlink{structinternal_1_1named__arg__base}{named\_arg\_base}}<Char> \{}
\DoxyCodeLine{1268   \textcolor{keyword}{const} T \&\mbox{\hyperlink{classinternal_1_1value}{value}};}
\DoxyCodeLine{1269 }
\DoxyCodeLine{1270   \mbox{\hyperlink{structinternal_1_1named__arg}{named\_arg}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name, \textcolor{keyword}{const} T \&val)}
\DoxyCodeLine{1271     : \mbox{\hyperlink{structinternal_1_1named__arg__base}{named\_arg\_base<Char>}}(name), \mbox{\hyperlink{classinternal_1_1value}{value}}(val) \{\}}
\DoxyCodeLine{1272 \};}
\DoxyCodeLine{1273 \}}
\DoxyCodeLine{1274 }
\DoxyCodeLine{1284 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1285 \textcolor{keyword}{inline} \mbox{\hyperlink{structinternal_1_1named__arg}{internal::named\_arg<T, char>}} arg(\mbox{\hyperlink{classbasic__string__view}{string\_view}} name, \textcolor{keyword}{const} T \&arg) \{}
\DoxyCodeLine{1286   \textcolor{keywordflow}{return} \mbox{\hyperlink{structinternal_1_1named__arg}{internal::named\_arg<T, char>}}(name, arg);}
\DoxyCodeLine{1287 \}}
\DoxyCodeLine{1288 }
\DoxyCodeLine{1289 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1290 \textcolor{keyword}{inline} \mbox{\hyperlink{structinternal_1_1named__arg}{internal::named\_arg<T, wchar\_t>}} arg(\mbox{\hyperlink{classbasic__string__view}{wstring\_view}} name, \textcolor{keyword}{const} T \&arg) \{}
\DoxyCodeLine{1291   \textcolor{keywordflow}{return} \mbox{\hyperlink{structinternal_1_1named__arg}{internal::named\_arg<T, wchar\_t>}}(name, arg);}
\DoxyCodeLine{1292 \}}
\DoxyCodeLine{1293 }
\DoxyCodeLine{1294 \textcolor{comment}{// This function template is deleted intentionally to disable nested named}}
\DoxyCodeLine{1295 \textcolor{comment}{// arguments as in ``format("{}\{\}"{}, arg("{}a"{}, arg("{}b"{}, 42)))``.}}
\DoxyCodeLine{1296 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1297 \textcolor{keywordtype}{void} arg(S, \mbox{\hyperlink{structinternal_1_1named__arg}{internal::named\_arg<T, Char>}}) = \textcolor{keyword}{delete};}
\DoxyCodeLine{1298 }
\DoxyCodeLine{1299 \textcolor{comment}{// A base class for compile-\/time strings. It is defined in the fmt namespace to}}
\DoxyCodeLine{1300 \textcolor{comment}{// make formatting functions visible via ADL, e.g. format(fmt("{}\{\}"{}), 42).}}
\DoxyCodeLine{1301 \textcolor{keyword}{struct }\mbox{\hyperlink{structcompile__string}{compile\_string}} \{\};}
\DoxyCodeLine{1302 }
\DoxyCodeLine{1303 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{1304 \textcolor{comment}{// If S is a format string type, format\_string\_traints<S>::char\_type gives its}}
\DoxyCodeLine{1305 \textcolor{comment}{// character type.}}
\DoxyCodeLine{1306 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1307 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1format__string__traits}{format\_string\_traits}} \{}
\DoxyCodeLine{1308  \textcolor{keyword}{private}:}
\DoxyCodeLine{1309   \textcolor{comment}{// Use constructability as a way to detect if format\_string\_traits is}}
\DoxyCodeLine{1310   \textcolor{comment}{// specialized because other methods are broken on MSVC2013.}}
\DoxyCodeLine{1311   \mbox{\hyperlink{structinternal_1_1format__string__traits}{format\_string\_traits}}();}
\DoxyCodeLine{1312 \};}
\DoxyCodeLine{1313 }
\DoxyCodeLine{1314 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1315 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1format__string__traits__base}{format\_string\_traits\_base}} \{ \textcolor{keyword}{typedef} Char char\_type; \};}
\DoxyCodeLine{1316 }
\DoxyCodeLine{1317 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1318 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1format__string__traits}{format\_string\_traits}}<Char *> : \mbox{\hyperlink{structinternal_1_1format__string__traits__base}{format\_string\_traits\_base<Char>}} \{\};}
\DoxyCodeLine{1319 }
\DoxyCodeLine{1320 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1321 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1format__string__traits}{format\_string\_traits}}<const Char *> : \mbox{\hyperlink{structinternal_1_1format__string__traits__base}{format\_string\_traits\_base<Char>}} \{\};}
\DoxyCodeLine{1322 }
\DoxyCodeLine{1323 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, std::\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{1324 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1format__string__traits}{format\_string\_traits}}<Char[N]> : \mbox{\hyperlink{structinternal_1_1format__string__traits__base}{format\_string\_traits\_base}}<Char> \{\};}
\DoxyCodeLine{1325 }
\DoxyCodeLine{1326 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, std::\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{1327 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1format__string__traits}{format\_string\_traits}}<const Char[N]> : \mbox{\hyperlink{structinternal_1_1format__string__traits__base}{format\_string\_traits\_base}}<Char> \{\};}
\DoxyCodeLine{1328 }
\DoxyCodeLine{1329 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1330 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1format__string__traits}{format\_string\_traits}}<std::basic\_string<Char>> :}
\DoxyCodeLine{1331     \mbox{\hyperlink{structinternal_1_1format__string__traits__base}{format\_string\_traits\_base}}<Char> \{\};}
\DoxyCodeLine{1332 }
\DoxyCodeLine{1333 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S>}
\DoxyCodeLine{1334 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1format__string__traits}{format\_string\_traits}}<}
\DoxyCodeLine{1335     S, typename std::enable\_if<std::is\_base\_of<}
\DoxyCodeLine{1336          basic\_string\_view<typename S::char\_type>, S>::value>::type> :}
\DoxyCodeLine{1337     \mbox{\hyperlink{structinternal_1_1format__string__traits__base}{format\_string\_traits\_base}}<typename S::char\_type> \{\};}
\DoxyCodeLine{1338 }
\DoxyCodeLine{1339 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S>}
\DoxyCodeLine{1340 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1is__format__string}{is\_format\_string}} :}
\DoxyCodeLine{1341     std::integral\_constant<}
\DoxyCodeLine{1342       bool, std::is\_constructible<format\_string\_traits<S>>::value> \{\};}
\DoxyCodeLine{1343 }
\DoxyCodeLine{1344 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S>}
\DoxyCodeLine{1345 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1is__compile__string}{is\_compile\_string}} :}
\DoxyCodeLine{1346     std::integral\_constant<bool, std::is\_base\_of<compile\_string, S>::value> \{\};}
\DoxyCodeLine{1347 }
\DoxyCodeLine{1348 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args, \textcolor{keyword}{typename} S>}
\DoxyCodeLine{1349 \textcolor{keyword}{inline} \textcolor{keyword}{typename} std::enable\_if<!is\_compile\_string<S>::value>::type}
\DoxyCodeLine{1350     check\_format\_string(\textcolor{keyword}{const} S \&) \{\}}
\DoxyCodeLine{1351 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args, \textcolor{keyword}{typename} S>}
\DoxyCodeLine{1352 \textcolor{keyword}{typename} std::enable\_if<is\_compile\_string<S>::value>::type}
\DoxyCodeLine{1353     check\_format\_string(S);}
\DoxyCodeLine{1354 }
\DoxyCodeLine{1355 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1356 std::basic\_string<Char> vformat(}
\DoxyCodeLine{1357     \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str,}
\DoxyCodeLine{1358     \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__context}{buffer\_context<Char>::type}}> args);}
\DoxyCodeLine{1359 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{1360 }
\DoxyCodeLine{1361 format\_context::iterator vformat\_to(}
\DoxyCodeLine{1362     \mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::buffer}} \&buf, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \mbox{\hyperlink{structformat__args}{format\_args}} args);}
\DoxyCodeLine{1363 wformat\_context::iterator vformat\_to(}
\DoxyCodeLine{1364     \mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::wbuffer}} \&buf, \mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str, \mbox{\hyperlink{structwformat__args}{wformat\_args}} args);}
\DoxyCodeLine{1365 }
\DoxyCodeLine{1366 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{1367 \textcolor{keyword}{struct }\mbox{\hyperlink{structis__contiguous}{is\_contiguous}} : std::false\_type \{\};}
\DoxyCodeLine{1368 }
\DoxyCodeLine{1369 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1370 \textcolor{keyword}{struct }\mbox{\hyperlink{structis__contiguous}{is\_contiguous}}<std::basic\_string<Char>> : std::true\_type \{\};}
\DoxyCodeLine{1371 }
\DoxyCodeLine{1372 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1373 \textcolor{keyword}{struct }\mbox{\hyperlink{structis__contiguous}{is\_contiguous}}<internal::basic\_buffer<Char>> : std::true\_type \{\};}
\DoxyCodeLine{1374 }
\DoxyCodeLine{1376 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{1377 \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1378   \mbox{\hyperlink{structis__contiguous}{is\_contiguous<Container>::value}}, std::back\_insert\_iterator<Container>>::type}
\DoxyCodeLine{1379     vformat\_to(std::back\_insert\_iterator<Container> out,}
\DoxyCodeLine{1380                \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \mbox{\hyperlink{structformat__args}{format\_args}} args) \{}
\DoxyCodeLine{1381   \mbox{\hyperlink{classinternal_1_1container__buffer}{internal::container\_buffer<Container>}} buf(internal::get\_container(out));}
\DoxyCodeLine{1382   vformat\_to(buf, format\_str, args);}
\DoxyCodeLine{1383   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1384 \}}
\DoxyCodeLine{1385 }
\DoxyCodeLine{1386 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{1387 \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1388   \mbox{\hyperlink{structis__contiguous}{is\_contiguous<Container>::value}}, std::back\_insert\_iterator<Container>>::type}
\DoxyCodeLine{1389   vformat\_to(std::back\_insert\_iterator<Container> out,}
\DoxyCodeLine{1390              \mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str, \mbox{\hyperlink{structwformat__args}{wformat\_args}} args) \{}
\DoxyCodeLine{1391   \mbox{\hyperlink{classinternal_1_1container__buffer}{internal::container\_buffer<Container>}} buf(internal::get\_container(out));}
\DoxyCodeLine{1392   vformat\_to(buf, format\_str, args);}
\DoxyCodeLine{1393   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1394 \}}
\DoxyCodeLine{1395 }
\DoxyCodeLine{1396 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1397 \textcolor{keyword}{inline} \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1398   \mbox{\hyperlink{structis__contiguous}{is\_contiguous<Container>::value}}, std::back\_insert\_iterator<Container>>::type}
\DoxyCodeLine{1399     format\_to(std::back\_insert\_iterator<Container> out,}
\DoxyCodeLine{1400               \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{1401   \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<\mbox{\hyperlink{classbasic__format__context}{format\_context}}, Args...> as\{args...\};}
\DoxyCodeLine{1402   \textcolor{keywordflow}{return} vformat\_to(out, format\_str, as);}
\DoxyCodeLine{1403 \}}
\DoxyCodeLine{1404 }
\DoxyCodeLine{1405 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1406 \textcolor{keyword}{inline} \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1407   \mbox{\hyperlink{structis__contiguous}{is\_contiguous<Container>::value}}, std::back\_insert\_iterator<Container>>::type}
\DoxyCodeLine{1408     format\_to(std::back\_insert\_iterator<Container> out,}
\DoxyCodeLine{1409               \mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str, \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{1410   \textcolor{keywordflow}{return} vformat\_to(out, format\_str,}
\DoxyCodeLine{1411                     make\_format\_args<wformat\_context>(args...));}
\DoxyCodeLine{1412 \}}
\DoxyCodeLine{1413 }
\DoxyCodeLine{1414 \textcolor{keyword}{template} <}
\DoxyCodeLine{1415     \textcolor{keyword}{typename} String,}
\DoxyCodeLine{1416     \textcolor{keyword}{typename} Char = \textcolor{keyword}{typename} \mbox{\hyperlink{structinternal_1_1format__string__traits}{internal::format\_string\_traits<String>::char\_type}}>}
\DoxyCodeLine{1417 \textcolor{keyword}{inline} std::basic\_string<Char> vformat(}
\DoxyCodeLine{1418     \textcolor{keyword}{const} String \&format\_str,}
\DoxyCodeLine{1419     \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__context}{buffer\_context<Char>::type}}> args) \{}
\DoxyCodeLine{1420   \textcolor{comment}{// Convert format string to string\_view to reduce the number of overloads.}}
\DoxyCodeLine{1421   \textcolor{keywordflow}{return} internal::vformat(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(format\_str), args);}
\DoxyCodeLine{1422 \}}
\DoxyCodeLine{1423 }
\DoxyCodeLine{1434 \textcolor{keyword}{template} <\textcolor{keyword}{typename} String, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1435 \textcolor{keyword}{inline} std::basic\_string<}
\DoxyCodeLine{1436   \textcolor{keyword}{typename} \mbox{\hyperlink{structinternal_1_1format__string__traits}{internal::format\_string\_traits<String>::char\_type}}>}
\DoxyCodeLine{1437     format(\textcolor{keyword}{const} String \&format\_str, \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{1438   internal::check\_format\_string<Args...>(format\_str);}
\DoxyCodeLine{1439   \textcolor{comment}{// This should be just}}
\DoxyCodeLine{1440   \textcolor{comment}{//   return vformat(format\_str, make\_format\_args(args...));}}
\DoxyCodeLine{1441   \textcolor{comment}{// but gcc has trouble optimizing the latter, so break it down.}}
\DoxyCodeLine{1442   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structinternal_1_1format__string__traits}{internal::format\_string\_traits<String>::char\_type}} char\_t;}
\DoxyCodeLine{1443   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__context}{buffer\_context<char\_t>::type}} context\_t;}
\DoxyCodeLine{1444   \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<context\_t, Args...> as\{args...\};}
\DoxyCodeLine{1445   \textcolor{keywordflow}{return} internal::vformat(}
\DoxyCodeLine{1446       \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_t>}}(format\_str), \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<context\_t>}}(as));}
\DoxyCodeLine{1447 \}}
\DoxyCodeLine{1448 }
\DoxyCodeLine{1449 FMT\_API \textcolor{keywordtype}{void} vprint(std::FILE *f, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \mbox{\hyperlink{structformat__args}{format\_args}} args);}
\DoxyCodeLine{1450 FMT\_API \textcolor{keywordtype}{void} vprint(std::FILE *f, \mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str, \mbox{\hyperlink{structwformat__args}{wformat\_args}} args);}
\DoxyCodeLine{1451 }
\DoxyCodeLine{1461 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1462 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} print(std::FILE *f, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{1463   \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<\mbox{\hyperlink{classbasic__format__context}{format\_context}}, Args...> as(args...);}
\DoxyCodeLine{1464   vprint(f, format\_str, as);}
\DoxyCodeLine{1465 \}}
\DoxyCodeLine{1470 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1471 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} print(std::FILE *f, \mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str,}
\DoxyCodeLine{1472                   \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{1473   \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<\mbox{\hyperlink{classbasic__format__context}{wformat\_context}}, Args...> as(args...);}
\DoxyCodeLine{1474   vprint(f, format\_str, as);}
\DoxyCodeLine{1475 \}}
\DoxyCodeLine{1476 }
\DoxyCodeLine{1477 FMT\_API \textcolor{keywordtype}{void} vprint(\mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \mbox{\hyperlink{structformat__args}{format\_args}} args);}
\DoxyCodeLine{1478 FMT\_API \textcolor{keywordtype}{void} vprint(\mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str, \mbox{\hyperlink{structwformat__args}{wformat\_args}} args);}
\DoxyCodeLine{1479 }
\DoxyCodeLine{1489 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1490 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} print(\mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{1491   \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<\mbox{\hyperlink{classbasic__format__context}{format\_context}}, Args...> as\{args...\};}
\DoxyCodeLine{1492   vprint(format\_str, as);}
\DoxyCodeLine{1493 \}}
\DoxyCodeLine{1494 }
\DoxyCodeLine{1495 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1496 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} print(\mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str, \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{1497   \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<\mbox{\hyperlink{classbasic__format__context}{wformat\_context}}, Args...> as(args...);}
\DoxyCodeLine{1498   vprint(format\_str, as);}
\DoxyCodeLine{1499 \}}
\DoxyCodeLine{1500 FMT\_END\_NAMESPACE}
\DoxyCodeLine{1501 }
\DoxyCodeLine{1502 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_CORE\_H\_}}

\end{DoxyCode}
