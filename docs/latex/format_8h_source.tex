\hypertarget{format_8h_source}{}\doxysection{format.\+h}
\label{format_8h_source}\index{/Users/pvelesko/local/CHIP-\/SPV/spdlog/fmt/bundled/format.h@{/Users/pvelesko/local/CHIP-\/SPV/spdlog/fmt/bundled/format.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{ Formatting library for C++}}
\DoxyCodeLine{3 \textcolor{comment}{}}
\DoxyCodeLine{4 \textcolor{comment}{ Copyright (c) 2012 -\/ present, Victor Zverovich}}
\DoxyCodeLine{5 \textcolor{comment}{ All rights reserved.}}
\DoxyCodeLine{6 \textcolor{comment}{}}
\DoxyCodeLine{7 \textcolor{comment}{ Redistribution and use in source and binary forms, with or without}}
\DoxyCodeLine{8 \textcolor{comment}{ modification, are permitted provided that the following conditions are met:}}
\DoxyCodeLine{9 \textcolor{comment}{}}
\DoxyCodeLine{10 \textcolor{comment}{ 1. Redistributions of source code must retain the above copyright notice, this}}
\DoxyCodeLine{11 \textcolor{comment}{    list of conditions and the following disclaimer.}}
\DoxyCodeLine{12 \textcolor{comment}{ 2. Redistributions in binary form must reproduce the above copyright notice,}}
\DoxyCodeLine{13 \textcolor{comment}{    this list of conditions and the following disclaimer in the documentation}}
\DoxyCodeLine{14 \textcolor{comment}{    and/or other materials provided with the distribution.}}
\DoxyCodeLine{15 \textcolor{comment}{}}
\DoxyCodeLine{16 \textcolor{comment}{ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "{}AS IS"{} AND}}
\DoxyCodeLine{17 \textcolor{comment}{ ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED}}
\DoxyCodeLine{18 \textcolor{comment}{ WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE}}
\DoxyCodeLine{19 \textcolor{comment}{ DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR}}
\DoxyCodeLine{20 \textcolor{comment}{ ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES}}
\DoxyCodeLine{21 \textcolor{comment}{ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;}}
\DoxyCodeLine{22 \textcolor{comment}{ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND}}
\DoxyCodeLine{23 \textcolor{comment}{ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}}
\DoxyCodeLine{24 \textcolor{comment}{ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS}}
\DoxyCodeLine{25 \textcolor{comment}{ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}}
\DoxyCodeLine{26 \textcolor{comment}{ */}}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{preprocessor}{\#ifndef FMT\_FORMAT\_H\_}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#define FMT\_FORMAT\_H\_}}
\DoxyCodeLine{30 }
\DoxyCodeLine{31 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#include <stdint.h>}}
\DoxyCodeLine{39 }
\DoxyCodeLine{40 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{41 \textcolor{preprocessor}{\# define FMT\_CLANG\_VERSION (\_\_clang\_major\_\_ * 100 + \_\_clang\_minor\_\_)}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{43 \textcolor{preprocessor}{\# define FMT\_CLANG\_VERSION 0}}
\DoxyCodeLine{44 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{45 }
\DoxyCodeLine{46 \textcolor{preprocessor}{\#ifdef \_\_INTEL\_COMPILER}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\# define FMT\_ICC\_VERSION \_\_INTEL\_COMPILER}}
\DoxyCodeLine{48 \textcolor{preprocessor}{\#elif defined(\_\_ICL)}}
\DoxyCodeLine{49 \textcolor{preprocessor}{\# define FMT\_ICC\_VERSION \_\_ICL}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{51 \textcolor{preprocessor}{\# define FMT\_ICC\_VERSION 0}}
\DoxyCodeLine{52 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{53 }
\DoxyCodeLine{54 \textcolor{preprocessor}{\#ifdef \_\_NVCC\_\_}}
\DoxyCodeLine{55 \textcolor{preprocessor}{\# define FMT\_CUDA\_VERSION (\_\_CUDACC\_VER\_MAJOR\_\_ * 100 + \_\_CUDACC\_VER\_MINOR\_\_)}}
\DoxyCodeLine{56 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{57 \textcolor{preprocessor}{\# define FMT\_CUDA\_VERSION 0}}
\DoxyCodeLine{58 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{59 }
\DoxyCodeLine{60 \textcolor{preprocessor}{\#include "{}core.h"{}}}
\DoxyCodeLine{61 }
\DoxyCodeLine{62 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION >= 406 || FMT\_CLANG\_VERSION}}
\DoxyCodeLine{63 \textcolor{preprocessor}{\# pragma GCC diagnostic push}}
\DoxyCodeLine{64 }
\DoxyCodeLine{65 \textcolor{comment}{// Disable the warning about declaration shadowing because it affects too}}
\DoxyCodeLine{66 \textcolor{comment}{// many valid cases.}}
\DoxyCodeLine{67 \textcolor{preprocessor}{\# pragma GCC diagnostic ignored "{}-\/Wshadow"{}}}
\DoxyCodeLine{68 }
\DoxyCodeLine{69 \textcolor{comment}{// Disable the warning about implicit conversions that may change the sign of}}
\DoxyCodeLine{70 \textcolor{comment}{// an integer; silencing it otherwise would require many explicit casts.}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\# pragma GCC diagnostic ignored "{}-\/Wsign-\/conversion"{}}}
\DoxyCodeLine{72 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{73 }
\DoxyCodeLine{74 \textcolor{preprocessor}{\# if FMT\_CLANG\_VERSION}}
\DoxyCodeLine{75 \textcolor{preprocessor}{\#  pragma GCC diagnostic ignored "{}-\/Wgnu-\/string-\/literal-\/operator-\/template"{}}}
\DoxyCodeLine{76 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{77 }
\DoxyCodeLine{78 \textcolor{preprocessor}{\#ifdef \_SECURE\_SCL}}
\DoxyCodeLine{79 \textcolor{preprocessor}{\# define FMT\_SECURE\_SCL \_SECURE\_SCL}}
\DoxyCodeLine{80 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{81 \textcolor{preprocessor}{\# define FMT\_SECURE\_SCL 0}}
\DoxyCodeLine{82 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{83 }
\DoxyCodeLine{84 \textcolor{preprocessor}{\#if FMT\_SECURE\_SCL}}
\DoxyCodeLine{85 \textcolor{preprocessor}{\# include <iterator>}}
\DoxyCodeLine{86 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{87 }
\DoxyCodeLine{88 \textcolor{preprocessor}{\#ifdef \_\_has\_builtin}}
\DoxyCodeLine{89 \textcolor{preprocessor}{\# define FMT\_HAS\_BUILTIN(x) \_\_has\_builtin(x)}}
\DoxyCodeLine{90 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{91 \textcolor{preprocessor}{\# define FMT\_HAS\_BUILTIN(x) 0}}
\DoxyCodeLine{92 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{93 }
\DoxyCodeLine{94 \textcolor{preprocessor}{\#ifdef \_\_GNUC\_LIBSTD\_\_}}
\DoxyCodeLine{95 \textcolor{preprocessor}{\# define FMT\_GNUC\_LIBSTD\_VERSION (\_\_GNUC\_LIBSTD\_\_ * 100 + \_\_GNUC\_LIBSTD\_MINOR\_\_)}}
\DoxyCodeLine{96 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{97 }
\DoxyCodeLine{98 \textcolor{preprocessor}{\#ifndef FMT\_THROW}}
\DoxyCodeLine{99 \textcolor{preprocessor}{\# if FMT\_EXCEPTIONS}}
\DoxyCodeLine{100 \textcolor{preprocessor}{\#  if FMT\_MSC\_VER}}
\DoxyCodeLine{101 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{102 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{103 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Exception>}
\DoxyCodeLine{104 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} do\_throw(\textcolor{keyword}{const} Exception \&x) \{}
\DoxyCodeLine{105   \textcolor{comment}{// Silence unreachable code warnings in MSVC because these are nearly}}
\DoxyCodeLine{106   \textcolor{comment}{// impossible to fix in a generic code.}}
\DoxyCodeLine{107   \textcolor{keyword}{volatile} \textcolor{keywordtype}{bool} b = \textcolor{keyword}{true};}
\DoxyCodeLine{108   \textcolor{keywordflow}{if} (b)}
\DoxyCodeLine{109     \textcolor{keywordflow}{throw} x;}
\DoxyCodeLine{110 \}}
\DoxyCodeLine{111 \}}
\DoxyCodeLine{112 FMT\_END\_NAMESPACE}
\DoxyCodeLine{113 \textcolor{preprocessor}{\#   define FMT\_THROW(x) fmt::internal::do\_throw(x)}}
\DoxyCodeLine{114 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{115 \textcolor{preprocessor}{\#   define FMT\_THROW(x) throw x}}
\DoxyCodeLine{116 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{117 \textcolor{preprocessor}{\# else}}
\DoxyCodeLine{118 \textcolor{preprocessor}{\#  define FMT\_THROW(x) do \{ static\_cast<void>(sizeof(x)); assert(false); \} while(false);}}
\DoxyCodeLine{119 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{120 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{121 }
\DoxyCodeLine{122 \textcolor{preprocessor}{\#ifndef FMT\_USE\_USER\_DEFINED\_LITERALS}}
\DoxyCodeLine{123 \textcolor{comment}{// For Intel's compiler and NVIDIA's compiler both it and the system gcc/msc}}
\DoxyCodeLine{124 \textcolor{comment}{// must support UDLs.}}
\DoxyCodeLine{125 \textcolor{preprocessor}{\# if (FMT\_HAS\_FEATURE(cxx\_user\_literals) || \(\backslash\)}}
\DoxyCodeLine{126 \textcolor{preprocessor}{      FMT\_GCC\_VERSION >= 407 || FMT\_MSC\_VER >= 1900) \&\& \(\backslash\)}}
\DoxyCodeLine{127 \textcolor{preprocessor}{      (!(FMT\_ICC\_VERSION || FMT\_CUDA\_VERSION) || \(\backslash\)}}
\DoxyCodeLine{128 \textcolor{preprocessor}{       FMT\_ICC\_VERSION >= 1500 || FMT\_CUDA\_VERSION >= 700)}}
\DoxyCodeLine{129 \textcolor{preprocessor}{\#  define FMT\_USE\_USER\_DEFINED\_LITERALS 1}}
\DoxyCodeLine{130 \textcolor{preprocessor}{\# else}}
\DoxyCodeLine{131 \textcolor{preprocessor}{\#  define FMT\_USE\_USER\_DEFINED\_LITERALS 0}}
\DoxyCodeLine{132 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{133 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{134 }
\DoxyCodeLine{135 \textcolor{comment}{// EDG C++ Front End based compilers (icc, nvcc) do not currently support UDL}}
\DoxyCodeLine{136 \textcolor{comment}{// templates.}}
\DoxyCodeLine{137 \textcolor{preprocessor}{\#if FMT\_USE\_USER\_DEFINED\_LITERALS \&\& \(\backslash\)}}
\DoxyCodeLine{138 \textcolor{preprocessor}{    FMT\_ICC\_VERSION == 0 \&\& \(\backslash\)}}
\DoxyCodeLine{139 \textcolor{preprocessor}{    FMT\_CUDA\_VERSION == 0 \&\& \(\backslash\)}}
\DoxyCodeLine{140 \textcolor{preprocessor}{    ((FMT\_GCC\_VERSION >= 600 \&\& \_\_cplusplus >= 201402L) || \(\backslash\)}}
\DoxyCodeLine{141 \textcolor{preprocessor}{    (defined(FMT\_CLANG\_VERSION) \&\& FMT\_CLANG\_VERSION >= 304))}}
\DoxyCodeLine{142 \textcolor{preprocessor}{\# define FMT\_UDL\_TEMPLATE 1}}
\DoxyCodeLine{143 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{144 \textcolor{preprocessor}{\# define FMT\_UDL\_TEMPLATE 0}}
\DoxyCodeLine{145 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{146 }
\DoxyCodeLine{147 \textcolor{preprocessor}{\#ifndef FMT\_USE\_EXTERN\_TEMPLATES}}
\DoxyCodeLine{148 \textcolor{preprocessor}{\# ifndef FMT\_HEADER\_ONLY}}
\DoxyCodeLine{149 \textcolor{preprocessor}{\#  define FMT\_USE\_EXTERN\_TEMPLATES \(\backslash\)}}
\DoxyCodeLine{150 \textcolor{preprocessor}{     ((FMT\_CLANG\_VERSION >= 209 \&\& \_\_cplusplus >= 201103L) || \(\backslash\)}}
\DoxyCodeLine{151 \textcolor{preprocessor}{      (FMT\_GCC\_VERSION >= 303 \&\& FMT\_HAS\_GXX\_CXX11))}}
\DoxyCodeLine{152 \textcolor{preprocessor}{\# else}}
\DoxyCodeLine{153 \textcolor{preprocessor}{\#  define FMT\_USE\_EXTERN\_TEMPLATES 0}}
\DoxyCodeLine{154 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{155 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{156 }
\DoxyCodeLine{157 \textcolor{preprocessor}{\#if FMT\_HAS\_GXX\_CXX11 || FMT\_HAS\_FEATURE(cxx\_trailing\_return) || \(\backslash\)}}
\DoxyCodeLine{158 \textcolor{preprocessor}{    FMT\_MSC\_VER >= 1600}}
\DoxyCodeLine{159 \textcolor{preprocessor}{\# define FMT\_USE\_TRAILING\_RETURN 1}}
\DoxyCodeLine{160 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{161 \textcolor{preprocessor}{\# define FMT\_USE\_TRAILING\_RETURN 0}}
\DoxyCodeLine{162 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{163 }
\DoxyCodeLine{164 \textcolor{preprocessor}{\#ifndef FMT\_USE\_GRISU}}
\DoxyCodeLine{165 \textcolor{preprocessor}{\# define FMT\_USE\_GRISU 0}}
\DoxyCodeLine{166 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{167 }
\DoxyCodeLine{168 \textcolor{comment}{// \_\_builtin\_clz is broken in clang with Microsoft CodeGen:}}
\DoxyCodeLine{169 \textcolor{comment}{// https://github.com/fmtlib/fmt/issues/519}}
\DoxyCodeLine{170 \textcolor{preprocessor}{\#ifndef \_MSC\_VER}}
\DoxyCodeLine{171 \textcolor{preprocessor}{\# if FMT\_GCC\_VERSION >= 400 || FMT\_HAS\_BUILTIN(\_\_builtin\_clz)}}
\DoxyCodeLine{172 \textcolor{preprocessor}{\#  define FMT\_BUILTIN\_CLZ(n) \_\_builtin\_clz(n)}}
\DoxyCodeLine{173 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{174 }
\DoxyCodeLine{175 \textcolor{preprocessor}{\# if FMT\_GCC\_VERSION >= 400 || FMT\_HAS\_BUILTIN(\_\_builtin\_clzll)}}
\DoxyCodeLine{176 \textcolor{preprocessor}{\#  define FMT\_BUILTIN\_CLZLL(n) \_\_builtin\_clzll(n)}}
\DoxyCodeLine{177 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{178 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{179 }
\DoxyCodeLine{180 \textcolor{comment}{// A workaround for gcc 4.4 that doesn't support union members with ctors.}}
\DoxyCodeLine{181 \textcolor{preprocessor}{\#if (FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION <= 404) || \(\backslash\)}}
\DoxyCodeLine{182 \textcolor{preprocessor}{    (FMT\_MSC\_VER \&\& FMT\_MSC\_VER <= 1800)}}
\DoxyCodeLine{183 \textcolor{preprocessor}{\# define FMT\_UNION struct}}
\DoxyCodeLine{184 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{185 \textcolor{preprocessor}{\# define FMT\_UNION union}}
\DoxyCodeLine{186 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{187 }
\DoxyCodeLine{188 \textcolor{comment}{// Some compilers masquerade as both MSVC and GCC-\/likes or otherwise support}}
\DoxyCodeLine{189 \textcolor{comment}{// \_\_builtin\_clz and \_\_builtin\_clzll, so only define FMT\_BUILTIN\_CLZ using the}}
\DoxyCodeLine{190 \textcolor{comment}{// MSVC intrinsics if the clz and clzll builtins are not available.}}
\DoxyCodeLine{191 \textcolor{preprocessor}{\#if FMT\_MSC\_VER \&\& !defined(FMT\_BUILTIN\_CLZLL) \&\& !defined(\_MANAGED)}}
\DoxyCodeLine{192 \textcolor{preprocessor}{\# include <intrin.h>}  \textcolor{comment}{// \_BitScanReverse, \_BitScanReverse64}}
\DoxyCodeLine{193 }
\DoxyCodeLine{194 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{195 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{196 \textcolor{comment}{// Avoid Clang with Microsoft CodeGen's -\/Wunknown-\/pragmas warning.}}
\DoxyCodeLine{197 \textcolor{preprocessor}{\# ifndef \_\_clang\_\_}}
\DoxyCodeLine{198 \textcolor{preprocessor}{\#  pragma intrinsic(\_BitScanReverse)}}
\DoxyCodeLine{199 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{200 \textcolor{keyword}{inline} uint32\_t clz(uint32\_t x) \{}
\DoxyCodeLine{201   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} r = 0;}
\DoxyCodeLine{202   \_BitScanReverse(\&r, x);}
\DoxyCodeLine{203 }
\DoxyCodeLine{204   assert(x != 0);}
\DoxyCodeLine{205   \textcolor{comment}{// Static analysis complains about using uninitialized data}}
\DoxyCodeLine{206   \textcolor{comment}{// "{}r"{}, but the only way that can happen is if "{}x"{} is 0,}}
\DoxyCodeLine{207   \textcolor{comment}{// which the callers guarantee to not happen.}}
\DoxyCodeLine{208 \textcolor{preprocessor}{\# pragma warning(suppress: 6102)}}
\DoxyCodeLine{209   \textcolor{keywordflow}{return} 31 -\/ r;}
\DoxyCodeLine{210 \}}
\DoxyCodeLine{211 \textcolor{preprocessor}{\# define FMT\_BUILTIN\_CLZ(n) fmt::internal::clz(n)}}
\DoxyCodeLine{212 }
\DoxyCodeLine{213 \textcolor{preprocessor}{\# if defined(\_WIN64) \&\& !defined(\_\_clang\_\_)}}
\DoxyCodeLine{214 \textcolor{preprocessor}{\#  pragma intrinsic(\_BitScanReverse64)}}
\DoxyCodeLine{215 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{216 }
\DoxyCodeLine{217 \textcolor{keyword}{inline} uint32\_t clzll(uint64\_t x) \{}
\DoxyCodeLine{218   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} r = 0;}
\DoxyCodeLine{219 \textcolor{preprocessor}{\# ifdef \_WIN64}}
\DoxyCodeLine{220   \_BitScanReverse64(\&r, x);}
\DoxyCodeLine{221 \textcolor{preprocessor}{\# else}}
\DoxyCodeLine{222   \textcolor{comment}{// Scan the high 32 bits.}}
\DoxyCodeLine{223   \textcolor{keywordflow}{if} (\_BitScanReverse(\&r, \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(x >> 32)))}
\DoxyCodeLine{224     \textcolor{keywordflow}{return} 63 -\/ (r + 32);}
\DoxyCodeLine{225 }
\DoxyCodeLine{226   \textcolor{comment}{// Scan the low 32 bits.}}
\DoxyCodeLine{227   \_BitScanReverse(\&r, \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(x));}
\DoxyCodeLine{228 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{229 }
\DoxyCodeLine{230   assert(x != 0);}
\DoxyCodeLine{231   \textcolor{comment}{// Static analysis complains about using uninitialized data}}
\DoxyCodeLine{232   \textcolor{comment}{// "{}r"{}, but the only way that can happen is if "{}x"{} is 0,}}
\DoxyCodeLine{233   \textcolor{comment}{// which the callers guarantee to not happen.}}
\DoxyCodeLine{234 \textcolor{preprocessor}{\# pragma warning(suppress: 6102)}}
\DoxyCodeLine{235   \textcolor{keywordflow}{return} 63 -\/ r;}
\DoxyCodeLine{236 \}}
\DoxyCodeLine{237 \textcolor{preprocessor}{\# define FMT\_BUILTIN\_CLZLL(n) fmt::internal::clzll(n)}}
\DoxyCodeLine{238 \}}
\DoxyCodeLine{239 FMT\_END\_NAMESPACE}
\DoxyCodeLine{240 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{241 }
\DoxyCodeLine{242 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{243 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{244 }
\DoxyCodeLine{245 \textcolor{comment}{// An equivalent of `*reinterpret\_cast<Dest*>(\&source)` that doesn't produce}}
\DoxyCodeLine{246 \textcolor{comment}{// undefined behavior (e.g. due to type aliasing).}}
\DoxyCodeLine{247 \textcolor{comment}{// Example: uint64\_t d = bit\_cast<uint64\_t>(2.718);}}
\DoxyCodeLine{248 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Dest, \textcolor{keyword}{typename} Source>}
\DoxyCodeLine{249 \textcolor{keyword}{inline} Dest bit\_cast(\textcolor{keyword}{const} Source\& source) \{}
\DoxyCodeLine{250   \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(Dest) == \textcolor{keyword}{sizeof}(Source), \textcolor{stringliteral}{"{}size mismatch"{}});}
\DoxyCodeLine{251   Dest dest;}
\DoxyCodeLine{252   std::memcpy(\&dest, \&source, \textcolor{keyword}{sizeof}(dest));}
\DoxyCodeLine{253   \textcolor{keywordflow}{return} dest;}
\DoxyCodeLine{254 \}}
\DoxyCodeLine{255 }
\DoxyCodeLine{256 \textcolor{comment}{// An implementation of begin and end for pre-\/C++11 compilers such as gcc 4.}}
\DoxyCodeLine{257 \textcolor{keyword}{template} <\textcolor{keyword}{typename} C>}
\DoxyCodeLine{258 FMT\_CONSTEXPR \textcolor{keyword}{auto} begin(\textcolor{keyword}{const} C \&c) -\/> \textcolor{keyword}{decltype}(c.begin()) \{}
\DoxyCodeLine{259   \textcolor{keywordflow}{return} c.begin();}
\DoxyCodeLine{260 \}}
\DoxyCodeLine{261 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{262 FMT\_CONSTEXPR T *begin(T (\&array)[N]) FMT\_NOEXCEPT \{ \textcolor{keywordflow}{return} array; \}}
\DoxyCodeLine{263 \textcolor{keyword}{template} <\textcolor{keyword}{typename} C>}
\DoxyCodeLine{264 FMT\_CONSTEXPR \textcolor{keyword}{auto} end(\textcolor{keyword}{const} C \&c) -\/> \textcolor{keyword}{decltype}(c.end()) \{ \textcolor{keywordflow}{return} c.end(); \}}
\DoxyCodeLine{265 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{266 FMT\_CONSTEXPR T *end(T (\&array)[N]) FMT\_NOEXCEPT \{ \textcolor{keywordflow}{return} array + N; \}}
\DoxyCodeLine{267 }
\DoxyCodeLine{268 \textcolor{comment}{// For std::result\_of in gcc 4.4.}}
\DoxyCodeLine{269 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result>}
\DoxyCodeLine{270 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1function}{function}} \{}
\DoxyCodeLine{271   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{272   \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1function_1_1result}{result}} \{ \textcolor{keyword}{typedef} Result type; \};}
\DoxyCodeLine{273 \};}
\DoxyCodeLine{274 }
\DoxyCodeLine{275 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1dummy__int}{dummy\_int}} \{}
\DoxyCodeLine{276   \textcolor{keywordtype}{int} \mbox{\hyperlink{structinternal_1_1basic__data}{data}}[2];}
\DoxyCodeLine{277   \textcolor{keyword}{operator} int()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{278 \};}
\DoxyCodeLine{279 \textcolor{keyword}{typedef} std::numeric\_limits<internal::dummy\_int> fputil;}
\DoxyCodeLine{280 }
\DoxyCodeLine{281 \textcolor{comment}{// Dummy implementations of system functions such as signbit and ecvt called}}
\DoxyCodeLine{282 \textcolor{comment}{// if the latter are not available.}}
\DoxyCodeLine{283 \textcolor{keyword}{inline} \mbox{\hyperlink{structinternal_1_1dummy__int}{dummy\_int}} signbit(...) \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{structinternal_1_1dummy__int}{dummy\_int}}(); \}}
\DoxyCodeLine{284 \textcolor{keyword}{inline} dummy\_int \_ecvt\_s(...) \{ \textcolor{keywordflow}{return} dummy\_int(); \}}
\DoxyCodeLine{285 \textcolor{keyword}{inline} dummy\_int isinf(...) \{ \textcolor{keywordflow}{return} dummy\_int(); \}}
\DoxyCodeLine{286 \textcolor{keyword}{inline} dummy\_int \_finite(...) \{ \textcolor{keywordflow}{return} dummy\_int(); \}}
\DoxyCodeLine{287 \textcolor{keyword}{inline} dummy\_int isnan(...) \{ \textcolor{keywordflow}{return} dummy\_int(); \}}
\DoxyCodeLine{288 \textcolor{keyword}{inline} dummy\_int \_isnan(...) \{ \textcolor{keywordflow}{return} dummy\_int(); \}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} use\_grisu() \{}
\DoxyCodeLine{291   \textcolor{keywordflow}{return} FMT\_USE\_GRISU \&\& std::numeric\_limits<double>::is\_iec559;}
\DoxyCodeLine{292 \}}
\DoxyCodeLine{293 }
\DoxyCodeLine{294 \textcolor{comment}{// Formats value using Grisu2 algorithm:}}
\DoxyCodeLine{295 \textcolor{comment}{// https://www.cs.tufts.edu/\string~nr/cs257/archive/florian-\/loitsch/printf.pdf}}
\DoxyCodeLine{296 FMT\_API \textcolor{keywordtype}{void} grisu2\_format(\textcolor{keywordtype}{double} value, \textcolor{keywordtype}{char} *buffer, \textcolor{keywordtype}{size\_t} \&size, \textcolor{keywordtype}{char} type,}
\DoxyCodeLine{297                            \textcolor{keywordtype}{int} precision, \textcolor{keywordtype}{bool} write\_decimal\_point);}
\DoxyCodeLine{298 }
\DoxyCodeLine{299 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Allocator>}
\DoxyCodeLine{300 \textcolor{keyword}{typename} Allocator::value\_type *allocate(Allocator\& alloc, std::size\_t n) \{}
\DoxyCodeLine{301 \textcolor{preprocessor}{\#if \_\_cplusplus >= 201103L || FMT\_MSC\_VER >= 1700}}
\DoxyCodeLine{302   \textcolor{keywordflow}{return} std::allocator\_traits<Allocator>::allocate(alloc, n);}
\DoxyCodeLine{303 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{304   \textcolor{keywordflow}{return} alloc.allocate(n);}
\DoxyCodeLine{305 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{306 \}}
\DoxyCodeLine{307 }
\DoxyCodeLine{308 \textcolor{comment}{// A helper function to suppress bogus "{}conditional expression is constant"{}}}
\DoxyCodeLine{309 \textcolor{comment}{// warnings.}}
\DoxyCodeLine{310 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{311 \textcolor{keyword}{inline} T const\_check(T value) \{ \textcolor{keywordflow}{return} value; \}}
\DoxyCodeLine{312 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{313 FMT\_END\_NAMESPACE}
\DoxyCodeLine{314 }
\DoxyCodeLine{315 \textcolor{keyword}{namespace }std \{}
\DoxyCodeLine{316 \textcolor{comment}{// Standard permits specialization of std::numeric\_limits. This specialization}}
\DoxyCodeLine{317 \textcolor{comment}{// is used to resolve ambiguity between isinf and std::isinf in glibc:}}
\DoxyCodeLine{318 \textcolor{comment}{// https://gcc.gnu.org/bugzilla/show\_bug.cgi?id=48891}}
\DoxyCodeLine{319 \textcolor{comment}{// and the same for isnan and signbit.}}
\DoxyCodeLine{320 \textcolor{keyword}{template} <>}
\DoxyCodeLine{321 \textcolor{keyword}{class }numeric\_limits<fmt::\mbox{\hyperlink{structinternal_1_1dummy__int}{internal::dummy\_int}}> :}
\DoxyCodeLine{322     \textcolor{keyword}{public} std::numeric\_limits<int> \{}
\DoxyCodeLine{323  \textcolor{keyword}{public}:}
\DoxyCodeLine{324   \textcolor{comment}{// Portable version of isinf.}}
\DoxyCodeLine{325   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{326   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} isinfinity(T x) \{}
\DoxyCodeLine{327     \textcolor{keyword}{using namespace }fmt::internal;}
\DoxyCodeLine{328     \textcolor{comment}{// The resolution "{}priority"{} is:}}
\DoxyCodeLine{329     \textcolor{comment}{// isinf macro > std::isinf > ::isinf > fmt::internal::isinf}}
\DoxyCodeLine{330     \textcolor{keywordflow}{if} (const\_check(\textcolor{keyword}{sizeof}(isinf(x)) != \textcolor{keyword}{sizeof}(dummy\_int)))}
\DoxyCodeLine{331       \textcolor{keywordflow}{return} isinf(x) != 0;}
\DoxyCodeLine{332     \textcolor{keywordflow}{return} !\_finite(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(x));}
\DoxyCodeLine{333   \}}
\DoxyCodeLine{334 }
\DoxyCodeLine{335   \textcolor{comment}{// Portable version of isnan.}}
\DoxyCodeLine{336   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{337   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} isnotanumber(T x) \{}
\DoxyCodeLine{338     \textcolor{keyword}{using namespace }fmt::internal;}
\DoxyCodeLine{339     \textcolor{keywordflow}{if} (const\_check(\textcolor{keyword}{sizeof}(isnan(x)) != \textcolor{keyword}{sizeof}(fmt::internal::dummy\_int)))}
\DoxyCodeLine{340       \textcolor{keywordflow}{return} isnan(x) != 0;}
\DoxyCodeLine{341     \textcolor{keywordflow}{return} \_isnan(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(x)) != 0;}
\DoxyCodeLine{342   \}}
\DoxyCodeLine{343 }
\DoxyCodeLine{344   \textcolor{comment}{// Portable version of signbit.}}
\DoxyCodeLine{345   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} isnegative(\textcolor{keywordtype}{double} x) \{}
\DoxyCodeLine{346     \textcolor{keyword}{using namespace }fmt::internal;}
\DoxyCodeLine{347     \textcolor{keywordflow}{if} (const\_check(\textcolor{keyword}{sizeof}(signbit(x)) != \textcolor{keyword}{sizeof}(fmt::internal::dummy\_int)))}
\DoxyCodeLine{348       \textcolor{keywordflow}{return} signbit(x) != 0;}
\DoxyCodeLine{349     \textcolor{keywordflow}{if} (x < 0) \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{350     \textcolor{keywordflow}{if} (!isnotanumber(x)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{351     \textcolor{keywordtype}{int} dec = 0, sign = 0;}
\DoxyCodeLine{352     \textcolor{keywordtype}{char} buffer[2];  \textcolor{comment}{// The buffer size must be >= 2 or \_ecvt\_s will fail.}}
\DoxyCodeLine{353     \_ecvt\_s(buffer, \textcolor{keyword}{sizeof}(buffer), x, 0, \&dec, \&sign);}
\DoxyCodeLine{354     \textcolor{keywordflow}{return} sign != 0;}
\DoxyCodeLine{355   \}}
\DoxyCodeLine{356 \};}
\DoxyCodeLine{357 \}  \textcolor{comment}{// namespace std}}
\DoxyCodeLine{358 }
\DoxyCodeLine{359 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{360 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{361 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__writer}{basic\_writer}};}
\DoxyCodeLine{362 }
\DoxyCodeLine{363 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T = \textcolor{keyword}{typename} OutputIt::value\_type>}
\DoxyCodeLine{364 \textcolor{keyword}{class }\mbox{\hyperlink{classoutput__range}{output\_range}} \{}
\DoxyCodeLine{365  \textcolor{keyword}{private}:}
\DoxyCodeLine{366   OutputIt it\_;}
\DoxyCodeLine{367 }
\DoxyCodeLine{368   \textcolor{comment}{// Unused yet.}}
\DoxyCodeLine{369   \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} sentinel;}
\DoxyCodeLine{370   sentinel end() \textcolor{keyword}{const};}
\DoxyCodeLine{371 }
\DoxyCodeLine{372  \textcolor{keyword}{public}:}
\DoxyCodeLine{373   \textcolor{keyword}{typedef} OutputIt iterator;}
\DoxyCodeLine{374   \textcolor{keyword}{typedef} T value\_type;}
\DoxyCodeLine{375 }
\DoxyCodeLine{376   \textcolor{keyword}{explicit} \mbox{\hyperlink{classoutput__range}{output\_range}}(OutputIt it): it\_(it) \{\}}
\DoxyCodeLine{377   OutputIt begin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} it\_; \}}
\DoxyCodeLine{378 \};}
\DoxyCodeLine{379 }
\DoxyCodeLine{380 \textcolor{comment}{// A range where begin() returns back\_insert\_iterator.}}
\DoxyCodeLine{381 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{382 \textcolor{keyword}{class }\mbox{\hyperlink{classback__insert__range}{back\_insert\_range}}:}
\DoxyCodeLine{383     \textcolor{keyword}{public} \mbox{\hyperlink{classoutput__range}{output\_range}}<std::back\_insert\_iterator<Container>> \{}
\DoxyCodeLine{384   \textcolor{keyword}{typedef} \mbox{\hyperlink{classoutput__range}{output\_range<std::back\_insert\_iterator<Container>}}> \mbox{\hyperlink{classoutput__range}{base}};}
\DoxyCodeLine{385  \textcolor{keyword}{public}:}
\DoxyCodeLine{386   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Container::value\_type value\_type;}
\DoxyCodeLine{387 }
\DoxyCodeLine{388   \mbox{\hyperlink{classback__insert__range}{back\_insert\_range}}(Container \&c): \mbox{\hyperlink{classoutput__range}{base}}(std::back\_inserter(c)) \{\}}
\DoxyCodeLine{389   \mbox{\hyperlink{classback__insert__range}{back\_insert\_range}}(\textcolor{keyword}{typename} base::iterator it): \mbox{\hyperlink{classoutput__range}{base}}(it) \{\}}
\DoxyCodeLine{390 \};}
\DoxyCodeLine{391 }
\DoxyCodeLine{392 \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__writer}{basic\_writer<back\_insert\_range<internal::buffer>}}> \mbox{\hyperlink{classbasic__writer}{writer}};}
\DoxyCodeLine{393 \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__writer}{basic\_writer<back\_insert\_range<internal::wbuffer>}}> \mbox{\hyperlink{classbasic__writer}{wwriter}};}
\DoxyCodeLine{394 }
\DoxyCodeLine{396 \textcolor{keyword}{class }\mbox{\hyperlink{classformat__error}{format\_error}} : \textcolor{keyword}{public} std::runtime\_error \{}
\DoxyCodeLine{397  \textcolor{keyword}{public}:}
\DoxyCodeLine{398   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *message)}
\DoxyCodeLine{399   : std::runtime\_error(message) \{\}}
\DoxyCodeLine{400 }
\DoxyCodeLine{401   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{keyword}{const} std::string \&message)}
\DoxyCodeLine{402   : std::runtime\_error(message) \{\}}
\DoxyCodeLine{403 \};}
\DoxyCodeLine{404 }
\DoxyCodeLine{405 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{406 }
\DoxyCodeLine{407 \textcolor{preprocessor}{\#if FMT\_SECURE\_SCL}}
\DoxyCodeLine{408 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{409 \textcolor{keyword}{struct }checked \{ \textcolor{keyword}{typedef} stdext::checked\_array\_iterator<T*> type; \};}
\DoxyCodeLine{410 }
\DoxyCodeLine{411 \textcolor{comment}{// Make a checked iterator to avoid warnings on MSVC.}}
\DoxyCodeLine{412 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{413 \textcolor{keyword}{inline} stdext::checked\_array\_iterator<T*> make\_checked(T *p, std::size\_t size) \{}
\DoxyCodeLine{414   \textcolor{keywordflow}{return} \{p, size\};}
\DoxyCodeLine{415 \}}
\DoxyCodeLine{416 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{417 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{418 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1checked}{checked}} \{ \textcolor{keyword}{typedef} T *type; \};}
\DoxyCodeLine{419 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{420 \textcolor{keyword}{inline} T *make\_checked(T *p, std::size\_t) \{ \textcolor{keywordflow}{return} p; \}}
\DoxyCodeLine{421 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{422 }
\DoxyCodeLine{423 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{424 \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{425 \textcolor{keywordtype}{void} \mbox{\hyperlink{classinternal_1_1basic__buffer_aba7ea1a95a28bc123712f2fd24cf7414}{basic\_buffer<T>::append}}(\textcolor{keyword}{const} U *begin, \textcolor{keyword}{const} U *end) \{}
\DoxyCodeLine{426   std::size\_t new\_size = size\_ + internal::to\_unsigned(end -\/ begin);}
\DoxyCodeLine{427   reserve(new\_size);}
\DoxyCodeLine{428   std::uninitialized\_copy(begin, end,}
\DoxyCodeLine{429                           internal::make\_checked(ptr\_, capacity\_) + size\_);}
\DoxyCodeLine{430   size\_ = new\_size;}
\DoxyCodeLine{431 \}}
\DoxyCodeLine{432 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{433 }
\DoxyCodeLine{434 \textcolor{comment}{// A UTF-\/8 code unit type.}}
\DoxyCodeLine{435 \textcolor{keyword}{struct }\mbox{\hyperlink{structchar8__t}{char8\_t}} \{}
\DoxyCodeLine{436   \textcolor{keywordtype}{char} value;}
\DoxyCodeLine{437   FMT\_CONSTEXPR \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() \textcolor{keyword}{const} FMT\_NOEXCEPT \{}
\DoxyCodeLine{438     \textcolor{keywordflow}{return} value != 0;}
\DoxyCodeLine{439   \}}
\DoxyCodeLine{440 \};}
\DoxyCodeLine{441 }
\DoxyCodeLine{442 \textcolor{comment}{// A UTF-\/8 string view.}}
\DoxyCodeLine{443 \textcolor{keyword}{class }\mbox{\hyperlink{classu8string__view}{u8string\_view}} : \textcolor{keyword}{public} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}}<char8\_t> \{}
\DoxyCodeLine{444  \textcolor{keyword}{private}:}
\DoxyCodeLine{445   \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char8\_t>}} \mbox{\hyperlink{classbasic__string__view}{base}};}
\DoxyCodeLine{446 }
\DoxyCodeLine{447  \textcolor{keyword}{public}:}
\DoxyCodeLine{448   \textcolor{keyword}{using} basic\_string\_view::basic\_string\_view;}
\DoxyCodeLine{449   \textcolor{keyword}{using} basic\_string\_view::char\_type;}
\DoxyCodeLine{450 }
\DoxyCodeLine{451   \mbox{\hyperlink{classu8string__view}{u8string\_view}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *s)}
\DoxyCodeLine{452     : \mbox{\hyperlink{classbasic__string__view}{base}}(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\mbox{\hyperlink{structchar8__t}{char8\_t}}*\textcolor{keyword}{>}(s)) \{\}}
\DoxyCodeLine{453 }
\DoxyCodeLine{454   \mbox{\hyperlink{classu8string__view}{u8string\_view}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, \textcolor{keywordtype}{size\_t} count) FMT\_NOEXCEPT}
\DoxyCodeLine{455     : \mbox{\hyperlink{classbasic__string__view}{base}}(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\mbox{\hyperlink{structchar8__t}{char8\_t}}*\textcolor{keyword}{>}(s), count) \{\}}
\DoxyCodeLine{456 \};}
\DoxyCodeLine{457 }
\DoxyCodeLine{458 \textcolor{preprocessor}{\#if FMT\_USE\_USER\_DEFINED\_LITERALS}}
\DoxyCodeLine{459 \textcolor{keyword}{inline} \textcolor{keyword}{namespace }literals \{}
\DoxyCodeLine{460 \textcolor{keyword}{inline} \mbox{\hyperlink{classu8string__view}{u8string\_view}} \textcolor{keyword}{operator}\textcolor{stringliteral}{"{}"{}} \_u(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, std::size\_t n) \{}
\DoxyCodeLine{461   \textcolor{keywordflow}{return} \mbox{\hyperlink{classu8string__view}{u8string\_view}}(s, n);}
\DoxyCodeLine{462 \}}
\DoxyCodeLine{463 \}}
\DoxyCodeLine{464 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{465 }
\DoxyCodeLine{466 \textcolor{comment}{// A wrapper around std::locale used to reduce compile times since <locale>}}
\DoxyCodeLine{467 \textcolor{comment}{// is very heavy.}}
\DoxyCodeLine{468 \textcolor{keyword}{class }\mbox{\hyperlink{classlocale}{locale}};}
\DoxyCodeLine{469 }
\DoxyCodeLine{470 \textcolor{keyword}{class }\mbox{\hyperlink{classlocale__provider}{locale\_provider}} \{}
\DoxyCodeLine{471  \textcolor{keyword}{public}:}
\DoxyCodeLine{472   \textcolor{keyword}{virtual} \mbox{\hyperlink{classlocale__provider}{\string~locale\_provider}}() \{\}}
\DoxyCodeLine{473   \textcolor{keyword}{virtual} fmt::locale \mbox{\hyperlink{classlocale}{locale}}();}
\DoxyCodeLine{474 \};}
\DoxyCodeLine{475 }
\DoxyCodeLine{476 \textcolor{comment}{// The number of characters to store in the basic\_memory\_buffer object itself}}
\DoxyCodeLine{477 \textcolor{comment}{// to avoid dynamic memory allocation.}}
\DoxyCodeLine{478 \textcolor{keyword}{enum} \{ inline\_buffer\_size = 500 \};}
\DoxyCodeLine{479 }
\DoxyCodeLine{509 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, std::size\_t SIZE = inline\_buffer\_size,}
\DoxyCodeLine{510           \textcolor{keyword}{typename} Allocator = std::allocator<T> >}
\DoxyCodeLine{511 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}}: \textcolor{keyword}{private} Allocator, \textcolor{keyword}{public} \mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::basic\_buffer}}<T> \{}
\DoxyCodeLine{512  \textcolor{keyword}{private}:}
\DoxyCodeLine{513   T store\_[SIZE];}
\DoxyCodeLine{514 }
\DoxyCodeLine{515   \textcolor{comment}{// Deallocate memory allocated by the buffer.}}
\DoxyCodeLine{516   \textcolor{keywordtype}{void} deallocate() \{}
\DoxyCodeLine{517     T* \mbox{\hyperlink{classinternal_1_1basic__buffer_a4716afee355656cd70e6719e5c0e6d62}{data}} = this-\/>\mbox{\hyperlink{classinternal_1_1basic__buffer_a4716afee355656cd70e6719e5c0e6d62}{data}}();}
\DoxyCodeLine{518     \textcolor{keywordflow}{if} (data != store\_) Allocator::deallocate(\mbox{\hyperlink{classinternal_1_1basic__buffer_a4716afee355656cd70e6719e5c0e6d62}{data}}, this-\/>\mbox{\hyperlink{classinternal_1_1basic__buffer_ae88bfc1cb8c896fa0b689ad8158cccae}{capacity}}());}
\DoxyCodeLine{519   \}}
\DoxyCodeLine{520 }
\DoxyCodeLine{521  \textcolor{keyword}{protected}:}
\DoxyCodeLine{522   \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__memory__buffer_a2f01489b9805a99cdc93ab0aee6730eb}{grow}}(std::size\_t \mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}}) FMT\_OVERRIDE;}
\DoxyCodeLine{523 }
\DoxyCodeLine{524  \textcolor{keyword}{public}:}
\DoxyCodeLine{525   \textcolor{keyword}{explicit} \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}}(\textcolor{keyword}{const} Allocator \&alloc = Allocator())}
\DoxyCodeLine{526       : Allocator(alloc) \{}
\DoxyCodeLine{527     this-\/>\mbox{\hyperlink{classinternal_1_1basic__buffer_a0b603108f1aa614e64efaac6e081086d}{set}}(store\_, SIZE);}
\DoxyCodeLine{528   \}}
\DoxyCodeLine{529   \mbox{\hyperlink{classbasic__memory__buffer}{\string~basic\_memory\_buffer}}() \{ deallocate(); \}}
\DoxyCodeLine{530 }
\DoxyCodeLine{531  \textcolor{keyword}{private}:}
\DoxyCodeLine{532   \textcolor{comment}{// Move data from other to this buffer.}}
\DoxyCodeLine{533   \textcolor{keywordtype}{void} move(\mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}} \&other) \{}
\DoxyCodeLine{534     Allocator \&this\_alloc = *\textcolor{keyword}{this}, \&other\_alloc = other;}
\DoxyCodeLine{535     this\_alloc = std::move(other\_alloc);}
\DoxyCodeLine{536     T* \mbox{\hyperlink{classinternal_1_1basic__buffer_a4716afee355656cd70e6719e5c0e6d62}{data}} = other.\mbox{\hyperlink{classinternal_1_1basic__buffer_a4716afee355656cd70e6719e5c0e6d62}{data}}();}
\DoxyCodeLine{537     std::size\_t \mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}} = other.\mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}}(), \mbox{\hyperlink{classinternal_1_1basic__buffer_ae88bfc1cb8c896fa0b689ad8158cccae}{capacity}} = other.\mbox{\hyperlink{classinternal_1_1basic__buffer_ae88bfc1cb8c896fa0b689ad8158cccae}{capacity}}();}
\DoxyCodeLine{538     \textcolor{keywordflow}{if} (\mbox{\hyperlink{classinternal_1_1basic__buffer_a4716afee355656cd70e6719e5c0e6d62}{data}} == other.store\_) \{}
\DoxyCodeLine{539       this-\/>\mbox{\hyperlink{classinternal_1_1basic__buffer_a0b603108f1aa614e64efaac6e081086d}{set}}(store\_, \mbox{\hyperlink{classinternal_1_1basic__buffer_ae88bfc1cb8c896fa0b689ad8158cccae}{capacity}});}
\DoxyCodeLine{540       std::uninitialized\_copy(other.store\_, other.store\_ + \mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}},}
\DoxyCodeLine{541                               internal::make\_checked(store\_, \mbox{\hyperlink{classinternal_1_1basic__buffer_ae88bfc1cb8c896fa0b689ad8158cccae}{capacity}}));}
\DoxyCodeLine{542     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{543       this-\/>\mbox{\hyperlink{classinternal_1_1basic__buffer_a0b603108f1aa614e64efaac6e081086d}{set}}(data, \mbox{\hyperlink{classinternal_1_1basic__buffer_ae88bfc1cb8c896fa0b689ad8158cccae}{capacity}});}
\DoxyCodeLine{544       \textcolor{comment}{// Set pointer to the inline array so that delete is not called}}
\DoxyCodeLine{545       \textcolor{comment}{// when deallocating.}}
\DoxyCodeLine{546       other.\mbox{\hyperlink{classinternal_1_1basic__buffer_a0b603108f1aa614e64efaac6e081086d}{set}}(other.store\_, 0);}
\DoxyCodeLine{547     \}}
\DoxyCodeLine{548     this-\/>\mbox{\hyperlink{classinternal_1_1basic__buffer_adbd2b147e114f0cc4573f734d4326669}{resize}}(size);}
\DoxyCodeLine{549   \}}
\DoxyCodeLine{550 }
\DoxyCodeLine{551  \textcolor{keyword}{public}:}
\DoxyCodeLine{558   \mbox{\hyperlink{classbasic__memory__buffer_a981f02b3da4bdd36d32c065369c66f7d}{basic\_memory\_buffer}}(\mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}} \&\&other) \{}
\DoxyCodeLine{559     move(other);}
\DoxyCodeLine{560   \}}
\DoxyCodeLine{561 }
\DoxyCodeLine{567   \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}} \&\mbox{\hyperlink{classbasic__memory__buffer_a854acc556e672be252a00e1b07cde8cc}{operator=}}(\mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}} \&\&other) \{}
\DoxyCodeLine{568     assert(\textcolor{keyword}{this} != \&other);}
\DoxyCodeLine{569     deallocate();}
\DoxyCodeLine{570     move(other);}
\DoxyCodeLine{571     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{572   \}}
\DoxyCodeLine{573 }
\DoxyCodeLine{574   \textcolor{comment}{// Returns a copy of the allocator associated with this buffer.}}
\DoxyCodeLine{575   Allocator get\_allocator()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{576 \};}
\DoxyCodeLine{577 }
\DoxyCodeLine{578 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} SIZE, \textcolor{keyword}{typename} Allocator>}
\DoxyCodeLine{579 \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__memory__buffer_a2f01489b9805a99cdc93ab0aee6730eb}{basic\_memory\_buffer<T, SIZE, Allocator>::grow}}(std::size\_t size) \{}
\DoxyCodeLine{580   std::size\_t old\_capacity = this-\/>capacity();}
\DoxyCodeLine{581   std::size\_t new\_capacity = old\_capacity + old\_capacity / 2;}
\DoxyCodeLine{582   \textcolor{keywordflow}{if} (size > new\_capacity)}
\DoxyCodeLine{583       new\_capacity = size;}
\DoxyCodeLine{584   T *old\_data = this-\/>data();}
\DoxyCodeLine{585   T *new\_data = internal::allocate<Allocator>(*\textcolor{keyword}{this}, new\_capacity);}
\DoxyCodeLine{586   \textcolor{comment}{// The following code doesn't throw, so the raw pointer above doesn't leak.}}
\DoxyCodeLine{587   std::uninitialized\_copy(old\_data, old\_data + this-\/>size(),}
\DoxyCodeLine{588                           internal::make\_checked(new\_data, new\_capacity));}
\DoxyCodeLine{589   this-\/>set(new\_data, new\_capacity);}
\DoxyCodeLine{590   \textcolor{comment}{// deallocate must not throw according to the standard, but even if it does,}}
\DoxyCodeLine{591   \textcolor{comment}{// the buffer already uses the new storage and will deallocate it in}}
\DoxyCodeLine{592   \textcolor{comment}{// destructor.}}
\DoxyCodeLine{593   \textcolor{keywordflow}{if} (old\_data != store\_)}
\DoxyCodeLine{594     Allocator::deallocate(old\_data, old\_capacity);}
\DoxyCodeLine{595 \}}
\DoxyCodeLine{596 }
\DoxyCodeLine{597 \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<char>}} \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}};}
\DoxyCodeLine{598 \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<wchar\_t>}} \mbox{\hyperlink{classbasic__memory__buffer}{wmemory\_buffer}};}
\DoxyCodeLine{599 }
\DoxyCodeLine{609 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{610 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__fixed__buffer}{basic\_fixed\_buffer}} : \textcolor{keyword}{public} \mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::basic\_buffer}}<Char> \{}
\DoxyCodeLine{611  \textcolor{keyword}{public}:}
\DoxyCodeLine{618   \mbox{\hyperlink{classbasic__fixed__buffer_a3a1531bcd858f978604e6db6833ce19a}{basic\_fixed\_buffer}}(Char *array, std::size\_t \mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}}) \{}
\DoxyCodeLine{619     this-\/>\mbox{\hyperlink{classinternal_1_1basic__buffer_a0b603108f1aa614e64efaac6e081086d}{set}}(array, \mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}});}
\DoxyCodeLine{620   \}}
\DoxyCodeLine{621 }
\DoxyCodeLine{628   \textcolor{keyword}{template} <std::\textcolor{keywordtype}{size\_t} SIZE>}
\DoxyCodeLine{629   \textcolor{keyword}{explicit} \mbox{\hyperlink{classbasic__fixed__buffer_a57df34f81b84c41bc0888e0174ad59b0}{basic\_fixed\_buffer}}(Char (\&array)[SIZE]) \{}
\DoxyCodeLine{630     this-\/>\mbox{\hyperlink{classinternal_1_1basic__buffer_a0b603108f1aa614e64efaac6e081086d}{set}}(array, SIZE);}
\DoxyCodeLine{631   \}}
\DoxyCodeLine{632 }
\DoxyCodeLine{633  \textcolor{keyword}{protected}:}
\DoxyCodeLine{634   FMT\_API \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__fixed__buffer_aa806637adc0d00c33902eba220961f9b}{grow}}(std::size\_t \mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}}) FMT\_OVERRIDE;}
\DoxyCodeLine{635 \};}
\DoxyCodeLine{636 }
\DoxyCodeLine{637 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{638 }
\DoxyCodeLine{639 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{640 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1char__traits}{char\_traits}};}
\DoxyCodeLine{641 }
\DoxyCodeLine{642 \textcolor{keyword}{template} <>}
\DoxyCodeLine{643 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1char__traits}{char\_traits}}<char> \{}
\DoxyCodeLine{644   \textcolor{comment}{// Formats a floating-\/point number.}}
\DoxyCodeLine{645   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{646   FMT\_API \textcolor{keyword}{static} \textcolor{keywordtype}{int} format\_float(\textcolor{keywordtype}{char} *\mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}}, std::size\_t size,}
\DoxyCodeLine{647       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *format, \textcolor{keywordtype}{int} precision, T \mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{648 \};}
\DoxyCodeLine{649 }
\DoxyCodeLine{650 \textcolor{keyword}{template} <>}
\DoxyCodeLine{651 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1char__traits}{char\_traits}}<wchar\_t> \{}
\DoxyCodeLine{652   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{653   FMT\_API \textcolor{keyword}{static} \textcolor{keywordtype}{int} format\_float(\textcolor{keywordtype}{wchar\_t} *\mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}}, std::size\_t size,}
\DoxyCodeLine{654       \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t} *format, \textcolor{keywordtype}{int} precision, T \mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{655 \};}
\DoxyCodeLine{656 }
\DoxyCodeLine{657 \textcolor{preprocessor}{\#if FMT\_USE\_EXTERN\_TEMPLATES}}
\DoxyCodeLine{658 \textcolor{keyword}{extern} \textcolor{keyword}{template} \textcolor{keywordtype}{int} \mbox{\hyperlink{structinternal_1_1char__traits}{char\_traits<char>::format\_float<double>}}(}
\DoxyCodeLine{659     \textcolor{keywordtype}{char} *\mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}}, std::size\_t size, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* format, \textcolor{keywordtype}{int} precision,}
\DoxyCodeLine{660     \textcolor{keywordtype}{double} \mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{661 \textcolor{keyword}{extern} \textcolor{keyword}{template} \textcolor{keywordtype}{int} \mbox{\hyperlink{structinternal_1_1char__traits}{char\_traits<char>::format\_float<long double>}}(}
\DoxyCodeLine{662     \textcolor{keywordtype}{char} *\mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}}, std::size\_t size, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* format, \textcolor{keywordtype}{int} precision,}
\DoxyCodeLine{663     \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} \mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{664 }
\DoxyCodeLine{665 \textcolor{keyword}{extern} \textcolor{keyword}{template} \textcolor{keywordtype}{int} \mbox{\hyperlink{structinternal_1_1char__traits}{char\_traits<wchar\_t>::format\_float<double>}}(}
\DoxyCodeLine{666     \textcolor{keywordtype}{wchar\_t} *\mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}}, std::size\_t size, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* format, \textcolor{keywordtype}{int} precision,}
\DoxyCodeLine{667     \textcolor{keywordtype}{double} \mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{668 \textcolor{keyword}{extern} \textcolor{keyword}{template} \textcolor{keywordtype}{int} \mbox{\hyperlink{structinternal_1_1char__traits}{char\_traits<wchar\_t>::format\_float<long double>}}(}
\DoxyCodeLine{669     \textcolor{keywordtype}{wchar\_t} *\mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}}, std::size\_t size, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* format, \textcolor{keywordtype}{int} precision,}
\DoxyCodeLine{670     \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} \mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{671 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{672 }
\DoxyCodeLine{673 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{674 \textcolor{keyword}{inline} \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{675   \mbox{\hyperlink{structis__contiguous}{is\_contiguous<Container>::value}},}
\DoxyCodeLine{676   \textcolor{keyword}{typename} checked<typename Container::value\_type>::type>::type}
\DoxyCodeLine{677     reserve(std::back\_insert\_iterator<Container> \&it, std::size\_t n) \{}
\DoxyCodeLine{678   Container \&c = internal::get\_container(it);}
\DoxyCodeLine{679   std::size\_t size = c.size();}
\DoxyCodeLine{680   c.resize(size + n);}
\DoxyCodeLine{681   \textcolor{keywordflow}{return} make\_checked(\&c[size], n);}
\DoxyCodeLine{682 \}}
\DoxyCodeLine{683 }
\DoxyCodeLine{684 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{685 \textcolor{keyword}{inline} Iterator \&reserve(Iterator \&it, std::size\_t) \{ \textcolor{keywordflow}{return} it; \}}
\DoxyCodeLine{686 }
\DoxyCodeLine{687 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{688 \textcolor{keyword}{class }null\_terminating\_iterator;}
\DoxyCodeLine{689 }
\DoxyCodeLine{690 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{691 FMT\_CONSTEXPR\_DECL \textcolor{keyword}{const} Char *pointer\_from(null\_terminating\_iterator<Char> it);}
\DoxyCodeLine{692 }
\DoxyCodeLine{693 \textcolor{comment}{// An iterator that produces a null terminator on *end. This simplifies parsing}}
\DoxyCodeLine{694 \textcolor{comment}{// and allows comparing the performance of processing a null-\/terminated string}}
\DoxyCodeLine{695 \textcolor{comment}{// vs string\_view.}}
\DoxyCodeLine{696 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{697 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}} \{}
\DoxyCodeLine{698  \textcolor{keyword}{public}:}
\DoxyCodeLine{699   \textcolor{keyword}{typedef} std::ptrdiff\_t difference\_type;}
\DoxyCodeLine{700   \textcolor{keyword}{typedef} Char value\_type;}
\DoxyCodeLine{701   \textcolor{keyword}{typedef} \textcolor{keyword}{const} Char* pointer;}
\DoxyCodeLine{702   \textcolor{keyword}{typedef} \textcolor{keyword}{const} Char\& reference;}
\DoxyCodeLine{703   \textcolor{keyword}{typedef} std::random\_access\_iterator\_tag iterator\_category;}
\DoxyCodeLine{704 }
\DoxyCodeLine{705   \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}}() : ptr\_(0), end\_(0) \{\}}
\DoxyCodeLine{706 }
\DoxyCodeLine{707   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}}(\textcolor{keyword}{const} Char *ptr, \textcolor{keyword}{const} Char *end)}
\DoxyCodeLine{708     : ptr\_(ptr), end\_(end) \{\}}
\DoxyCodeLine{709 }
\DoxyCodeLine{710   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{711   FMT\_CONSTEXPR \textcolor{keyword}{explicit} \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}}(\textcolor{keyword}{const} Range \&r)}
\DoxyCodeLine{712     : ptr\_(r.begin()), end\_(r.end()) \{\}}
\DoxyCodeLine{713 }
\DoxyCodeLine{714   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}} \&operator=(\textcolor{keyword}{const} Char *ptr) \{}
\DoxyCodeLine{715     assert(ptr <= end\_);}
\DoxyCodeLine{716     ptr\_ = ptr;}
\DoxyCodeLine{717     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{718   \}}
\DoxyCodeLine{719 }
\DoxyCodeLine{720   FMT\_CONSTEXPR Char operator*()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{721     \textcolor{keywordflow}{return} ptr\_ != end\_ ? *ptr\_ : 0;}
\DoxyCodeLine{722   \}}
\DoxyCodeLine{723 }
\DoxyCodeLine{724   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}} operator++() \{}
\DoxyCodeLine{725     ++ptr\_;}
\DoxyCodeLine{726     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{727   \}}
\DoxyCodeLine{728 }
\DoxyCodeLine{729   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}} operator++(\textcolor{keywordtype}{int}) \{}
\DoxyCodeLine{730     \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}} result(*\textcolor{keyword}{this});}
\DoxyCodeLine{731     ++ptr\_;}
\DoxyCodeLine{732     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{733   \}}
\DoxyCodeLine{734 }
\DoxyCodeLine{735   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}} operator-\/-\/() \{}
\DoxyCodeLine{736     -\/-\/ptr\_;}
\DoxyCodeLine{737     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{738   \}}
\DoxyCodeLine{739 }
\DoxyCodeLine{740   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}} operator+(difference\_type n) \{}
\DoxyCodeLine{741     \textcolor{keywordflow}{return} \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}}(ptr\_ + n, end\_);}
\DoxyCodeLine{742   \}}
\DoxyCodeLine{743 }
\DoxyCodeLine{744   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}} operator-\/(difference\_type n) \{}
\DoxyCodeLine{745     \textcolor{keywordflow}{return} \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}}(ptr\_ -\/ n, end\_);}
\DoxyCodeLine{746   \}}
\DoxyCodeLine{747 }
\DoxyCodeLine{748   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}} operator+=(difference\_type n) \{}
\DoxyCodeLine{749     ptr\_ += n;}
\DoxyCodeLine{750     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{751   \}}
\DoxyCodeLine{752 }
\DoxyCodeLine{753   FMT\_CONSTEXPR difference\_type operator-\/(}
\DoxyCodeLine{754       \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}} other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{755     \textcolor{keywordflow}{return} ptr\_ -\/ other.ptr\_;}
\DoxyCodeLine{756   \}}
\DoxyCodeLine{757 }
\DoxyCodeLine{758   FMT\_CONSTEXPR \textcolor{keywordtype}{bool} operator!=(\mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}} other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{759     \textcolor{keywordflow}{return} ptr\_ != other.ptr\_;}
\DoxyCodeLine{760   \}}
\DoxyCodeLine{761 }
\DoxyCodeLine{762   \textcolor{keywordtype}{bool} operator>=(\mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator}} other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{763     \textcolor{keywordflow}{return} ptr\_ >= other.ptr\_;}
\DoxyCodeLine{764   \}}
\DoxyCodeLine{765 }
\DoxyCodeLine{766   \textcolor{comment}{// This should be a friend specialization pointer\_from<Char> but the latter}}
\DoxyCodeLine{767   \textcolor{comment}{// doesn't compile by gcc 5.1 due to a compiler bug.}}
\DoxyCodeLine{768   \textcolor{keyword}{template} <\textcolor{keyword}{typename} CharT>}
\DoxyCodeLine{769   \textcolor{keyword}{friend} FMT\_CONSTEXPR\_DECL \textcolor{keyword}{const} CharT *pointer\_from(}
\DoxyCodeLine{770       \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{null\_terminating\_iterator<CharT>}} it);}
\DoxyCodeLine{771 }
\DoxyCodeLine{772  \textcolor{keyword}{private}:}
\DoxyCodeLine{773   \textcolor{keyword}{const} Char *ptr\_;}
\DoxyCodeLine{774   \textcolor{keyword}{const} Char *end\_;}
\DoxyCodeLine{775 \};}
\DoxyCodeLine{776 }
\DoxyCodeLine{777 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{778 FMT\_CONSTEXPR \textcolor{keyword}{const} T *pointer\_from(\textcolor{keyword}{const} T *p) \{ \textcolor{keywordflow}{return} p; \}}
\DoxyCodeLine{779 }
\DoxyCodeLine{780 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{781 FMT\_CONSTEXPR \textcolor{keyword}{const} Char *pointer\_from(null\_terminating\_iterator<Char> it) \{}
\DoxyCodeLine{782   \textcolor{keywordflow}{return} it.ptr\_;}
\DoxyCodeLine{783 \}}
\DoxyCodeLine{784 }
\DoxyCodeLine{785 \textcolor{comment}{// An output iterator that counts the number of objects written to it and}}
\DoxyCodeLine{786 \textcolor{comment}{// discards them.}}
\DoxyCodeLine{787 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{788 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1counting__iterator}{counting\_iterator}} \{}
\DoxyCodeLine{789  \textcolor{keyword}{private}:}
\DoxyCodeLine{790   std::size\_t count\_;}
\DoxyCodeLine{791   \textcolor{keyword}{mutable} T blackhole\_;}
\DoxyCodeLine{792 }
\DoxyCodeLine{793  \textcolor{keyword}{public}:}
\DoxyCodeLine{794   \textcolor{keyword}{typedef} std::output\_iterator\_tag iterator\_category;}
\DoxyCodeLine{795   \textcolor{keyword}{typedef} T value\_type;}
\DoxyCodeLine{796   \textcolor{keyword}{typedef} std::ptrdiff\_t difference\_type;}
\DoxyCodeLine{797   \textcolor{keyword}{typedef} T* pointer;}
\DoxyCodeLine{798   \textcolor{keyword}{typedef} T\& reference;}
\DoxyCodeLine{799   \textcolor{keyword}{typedef} \mbox{\hyperlink{classinternal_1_1counting__iterator}{counting\_iterator}} \mbox{\hyperlink{classinternal_1_1counting__iterator}{\_Unchecked\_type}};  \textcolor{comment}{// Mark iterator as checked.}}
\DoxyCodeLine{800 }
\DoxyCodeLine{801   \mbox{\hyperlink{classinternal_1_1counting__iterator}{counting\_iterator}}(): count\_(0) \{\}}
\DoxyCodeLine{802 }
\DoxyCodeLine{803   std::size\_t count()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} count\_; \}}
\DoxyCodeLine{804 }
\DoxyCodeLine{805   \mbox{\hyperlink{classinternal_1_1counting__iterator}{counting\_iterator}}\& operator++() \{}
\DoxyCodeLine{806     ++count\_;}
\DoxyCodeLine{807     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{808   \}}
\DoxyCodeLine{809 }
\DoxyCodeLine{810   \mbox{\hyperlink{classinternal_1_1counting__iterator}{counting\_iterator}} operator++(\textcolor{keywordtype}{int}) \{}
\DoxyCodeLine{811     \textcolor{keyword}{auto} it = *\textcolor{keyword}{this};}
\DoxyCodeLine{812     ++*\textcolor{keyword}{this};}
\DoxyCodeLine{813     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{814   \}}
\DoxyCodeLine{815 }
\DoxyCodeLine{816   T \&operator*()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} blackhole\_; \}}
\DoxyCodeLine{817 \};}
\DoxyCodeLine{818 }
\DoxyCodeLine{819 \textcolor{comment}{// An output iterator that truncates the output and counts the number of objects}}
\DoxyCodeLine{820 \textcolor{comment}{// written to it.}}
\DoxyCodeLine{821 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{822 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1truncating__iterator}{truncating\_iterator}} \{}
\DoxyCodeLine{823  \textcolor{keyword}{private}:}
\DoxyCodeLine{824   \textcolor{keyword}{typedef} std::iterator\_traits<OutputIt> traits;}
\DoxyCodeLine{825 }
\DoxyCodeLine{826   OutputIt out\_;}
\DoxyCodeLine{827   std::size\_t limit\_;}
\DoxyCodeLine{828   std::size\_t count\_;}
\DoxyCodeLine{829   \textcolor{keyword}{mutable} \textcolor{keyword}{typename} traits::value\_type blackhole\_;}
\DoxyCodeLine{830 }
\DoxyCodeLine{831  \textcolor{keyword}{public}:}
\DoxyCodeLine{832   \textcolor{keyword}{typedef} std::output\_iterator\_tag iterator\_category;}
\DoxyCodeLine{833   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits::value\_type value\_type;}
\DoxyCodeLine{834   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits::difference\_type difference\_type;}
\DoxyCodeLine{835   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits::pointer pointer;}
\DoxyCodeLine{836   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} traits::reference reference;}
\DoxyCodeLine{837   \textcolor{keyword}{typedef} \mbox{\hyperlink{classinternal_1_1truncating__iterator}{truncating\_iterator}} \mbox{\hyperlink{classinternal_1_1truncating__iterator}{\_Unchecked\_type}};  \textcolor{comment}{// Mark iterator as checked.}}
\DoxyCodeLine{838 }
\DoxyCodeLine{839   \mbox{\hyperlink{classinternal_1_1truncating__iterator}{truncating\_iterator}}(OutputIt out, std::size\_t limit)}
\DoxyCodeLine{840     : out\_(out), limit\_(limit), count\_(0) \{\}}
\DoxyCodeLine{841 }
\DoxyCodeLine{842   OutputIt \mbox{\hyperlink{classbase}{base}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} out\_; \}}
\DoxyCodeLine{843   std::size\_t count()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} count\_; \}}
\DoxyCodeLine{844 }
\DoxyCodeLine{845   \mbox{\hyperlink{classinternal_1_1truncating__iterator}{truncating\_iterator}}\& operator++() \{}
\DoxyCodeLine{846     \textcolor{keywordflow}{if} (count\_++ < limit\_)}
\DoxyCodeLine{847       ++out\_;}
\DoxyCodeLine{848     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{849   \}}
\DoxyCodeLine{850 }
\DoxyCodeLine{851   \mbox{\hyperlink{classinternal_1_1truncating__iterator}{truncating\_iterator}} operator++(\textcolor{keywordtype}{int}) \{}
\DoxyCodeLine{852     \textcolor{keyword}{auto} it = *\textcolor{keyword}{this};}
\DoxyCodeLine{853     ++*\textcolor{keyword}{this};}
\DoxyCodeLine{854     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{855   \}}
\DoxyCodeLine{856 }
\DoxyCodeLine{857   reference operator*()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} count\_ < limit\_ ? *out\_ : blackhole\_; \}}
\DoxyCodeLine{858 \};}
\DoxyCodeLine{859 }
\DoxyCodeLine{860 \textcolor{comment}{// Returns true if value is negative, false otherwise.}}
\DoxyCodeLine{861 \textcolor{comment}{// Same as (value < 0) but doesn't produce warnings if T is an unsigned type.}}
\DoxyCodeLine{862 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{863 FMT\_CONSTEXPR \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{864     std::numeric\_limits<T>::is\_signed, \textcolor{keywordtype}{bool}>::type is\_negative(T \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{865   \textcolor{keywordflow}{return} \mbox{\hyperlink{classinternal_1_1value}{value}} < 0;}
\DoxyCodeLine{866 \}}
\DoxyCodeLine{867 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{868 FMT\_CONSTEXPR \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{869     !std::numeric\_limits<T>::is\_signed, \textcolor{keywordtype}{bool}>::type is\_negative(T) \{}
\DoxyCodeLine{870   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{871 \}}
\DoxyCodeLine{872 }
\DoxyCodeLine{873 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{874 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1int__traits}{int\_traits}} \{}
\DoxyCodeLine{875   \textcolor{comment}{// Smallest of uint32\_t and uint64\_t that is large enough to represent}}
\DoxyCodeLine{876   \textcolor{comment}{// all values of T.}}
\DoxyCodeLine{877   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::conditional<}
\DoxyCodeLine{878     std::numeric\_limits<T>::digits <= 32, uint32\_t, uint64\_t>::type main\_type;}
\DoxyCodeLine{879 \};}
\DoxyCodeLine{880 }
\DoxyCodeLine{881 \textcolor{comment}{// Static data is placed in this class template to allow header-\/only}}
\DoxyCodeLine{882 \textcolor{comment}{// configuration.}}
\DoxyCodeLine{883 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{884 \textcolor{keyword}{struct }FMT\_API \mbox{\hyperlink{structinternal_1_1basic__data}{basic\_data}} \{}
\DoxyCodeLine{885   \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t POWERS\_OF\_10\_32[];}
\DoxyCodeLine{886   \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t ZERO\_OR\_POWERS\_OF\_10\_32[];}
\DoxyCodeLine{887   \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t ZERO\_OR\_POWERS\_OF\_10\_64[];}
\DoxyCodeLine{888   \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t POW10\_SIGNIFICANDS[];}
\DoxyCodeLine{889   \textcolor{keyword}{static} \textcolor{keyword}{const} int16\_t POW10\_EXPONENTS[];}
\DoxyCodeLine{890   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} DIGITS[];}
\DoxyCodeLine{891   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} RESET\_COLOR[];}
\DoxyCodeLine{892   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t} WRESET\_COLOR[];}
\DoxyCodeLine{893 \};}
\DoxyCodeLine{894 }
\DoxyCodeLine{895 \textcolor{preprocessor}{\#if FMT\_USE\_EXTERN\_TEMPLATES}}
\DoxyCodeLine{896 \textcolor{keyword}{extern} \textcolor{keyword}{template} \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1basic__data}{basic\_data<void>}};}
\DoxyCodeLine{897 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{898 }
\DoxyCodeLine{899 \textcolor{keyword}{typedef} \mbox{\hyperlink{structinternal_1_1basic__data}{basic\_data<>}} \mbox{\hyperlink{structinternal_1_1basic__data}{data}};}
\DoxyCodeLine{900 }
\DoxyCodeLine{901 \textcolor{preprocessor}{\#ifdef FMT\_BUILTIN\_CLZLL}}
\DoxyCodeLine{902 \textcolor{comment}{// Returns the number of decimal digits in n. Leading zeros are not counted}}
\DoxyCodeLine{903 \textcolor{comment}{// except for n == 0 in which case count\_digits returns 1.}}
\DoxyCodeLine{904 \textcolor{keyword}{inline} \textcolor{keywordtype}{unsigned} count\_digits(uint64\_t n) \{}
\DoxyCodeLine{905   \textcolor{comment}{// Based on http://graphics.stanford.edu/\string~seander/bithacks.html\#IntegerLog10}}
\DoxyCodeLine{906   \textcolor{comment}{// and the benchmark https://github.com/localvoid/cxx-\/benchmark-\/count-\/digits.}}
\DoxyCodeLine{907   \textcolor{keywordtype}{int} t = (64 -\/ FMT\_BUILTIN\_CLZLL(n | 1)) * 1233 >> 12;}
\DoxyCodeLine{908   \textcolor{keywordflow}{return} to\_unsigned(t) -\/ (n < data::ZERO\_OR\_POWERS\_OF\_10\_64[t]) + 1;}
\DoxyCodeLine{909 \}}
\DoxyCodeLine{910 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{911 \textcolor{comment}{// Fallback version of count\_digits used when \_\_builtin\_clz is not available.}}
\DoxyCodeLine{912 \textcolor{keyword}{inline} \textcolor{keywordtype}{unsigned} count\_digits(uint64\_t n) \{}
\DoxyCodeLine{913   \textcolor{keywordtype}{unsigned} count = 1;}
\DoxyCodeLine{914   \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{915     \textcolor{comment}{// Integer division is slow so do it for a group of four digits instead}}
\DoxyCodeLine{916     \textcolor{comment}{// of for every digit. The idea comes from the talk by Alexandrescu}}
\DoxyCodeLine{917     \textcolor{comment}{// "{}Three Optimization Tips for C++"{}. See speed-\/test for a comparison.}}
\DoxyCodeLine{918     \textcolor{keywordflow}{if} (n < 10) \textcolor{keywordflow}{return} count;}
\DoxyCodeLine{919     \textcolor{keywordflow}{if} (n < 100) \textcolor{keywordflow}{return} count + 1;}
\DoxyCodeLine{920     \textcolor{keywordflow}{if} (n < 1000) \textcolor{keywordflow}{return} count + 2;}
\DoxyCodeLine{921     \textcolor{keywordflow}{if} (n < 10000) \textcolor{keywordflow}{return} count + 3;}
\DoxyCodeLine{922     n /= 10000u;}
\DoxyCodeLine{923     count += 4;}
\DoxyCodeLine{924   \}}
\DoxyCodeLine{925 \}}
\DoxyCodeLine{926 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{927 }
\DoxyCodeLine{928 \textcolor{comment}{// Counts the number of code points in a UTF-\/8 string.}}
\DoxyCodeLine{929 FMT\_API \textcolor{keywordtype}{size\_t} count\_code\_points(\mbox{\hyperlink{classu8string__view}{u8string\_view}} s);}
\DoxyCodeLine{930 }
\DoxyCodeLine{931 \textcolor{preprocessor}{\#if FMT\_HAS\_CPP\_ATTRIBUTE(always\_inline)}}
\DoxyCodeLine{932 \textcolor{preprocessor}{\# define FMT\_ALWAYS\_INLINE \_\_attribute\_\_((always\_inline))}}
\DoxyCodeLine{933 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{934 \textcolor{preprocessor}{\# define FMT\_ALWAYS\_INLINE}}
\DoxyCodeLine{935 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{936 }
\DoxyCodeLine{937 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{938 \textcolor{keyword}{inline} \textcolor{keywordtype}{char} *lg(uint32\_t n, Handler h) FMT\_ALWAYS\_INLINE;}
\DoxyCodeLine{939 }
\DoxyCodeLine{940 \textcolor{comment}{// Computes g = floor(log10(n)) and calls h.on<g>(n);}}
\DoxyCodeLine{941 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{942 \textcolor{keyword}{inline} \textcolor{keywordtype}{char} *lg(uint32\_t n, Handler h) \{}
\DoxyCodeLine{943   \textcolor{keywordflow}{return} n < 100 ? n < 10 ? h.template on<0>(n) : h.template on<1>(n)}
\DoxyCodeLine{944                  : n < 1000000}
\DoxyCodeLine{945                        ? n < 10000 ? n < 1000 ? h.template on<2>(n)}
\DoxyCodeLine{946                                               : h.template on<3>(n)}
\DoxyCodeLine{947                                    : n < 100000 ? h.template on<4>(n)}
\DoxyCodeLine{948                                                 : h.template on<5>(n)}
\DoxyCodeLine{949                        : n < 100000000 ? n < 10000000 ? h.template on<6>(n)}
\DoxyCodeLine{950                                                       : h.template on<7>(n)}
\DoxyCodeLine{951                                        : n < 1000000000 ? h.template on<8>(n)}
\DoxyCodeLine{952                                                         : h.template on<9>(n);}
\DoxyCodeLine{953 \}}
\DoxyCodeLine{954 }
\DoxyCodeLine{955 \textcolor{comment}{// An lg handler that formats a decimal number.}}
\DoxyCodeLine{956 \textcolor{comment}{// Usage: lg(n, decimal\_formatter(buffer));}}
\DoxyCodeLine{957 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1decimal__formatter}{decimal\_formatter}} \{}
\DoxyCodeLine{958  \textcolor{keyword}{private}:}
\DoxyCodeLine{959   \textcolor{keywordtype}{char} *buffer\_;}
\DoxyCodeLine{960 }
\DoxyCodeLine{961   \textcolor{keywordtype}{void} write\_pair(\textcolor{keywordtype}{unsigned} N, uint32\_t index) \{}
\DoxyCodeLine{962     std::memcpy(buffer\_ + N, data::DIGITS + index * 2, 2);}
\DoxyCodeLine{963   \}}
\DoxyCodeLine{964 }
\DoxyCodeLine{965  \textcolor{keyword}{public}:}
\DoxyCodeLine{966   \textcolor{keyword}{explicit} \mbox{\hyperlink{classinternal_1_1decimal__formatter}{decimal\_formatter}}(\textcolor{keywordtype}{char} *buf) : buffer\_(buf) \{\}}
\DoxyCodeLine{967 }
\DoxyCodeLine{968   \textcolor{keyword}{template} <\textcolor{keywordtype}{unsigned} N> \textcolor{keywordtype}{char} *on(uint32\_t u) \{}
\DoxyCodeLine{969     \textcolor{keywordflow}{if} (N == 0) \{}
\DoxyCodeLine{970       *buffer\_ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(u) + \textcolor{charliteral}{'0'};}
\DoxyCodeLine{971     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N == 1) \{}
\DoxyCodeLine{972       write\_pair(0, u);}
\DoxyCodeLine{973     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{974       \textcolor{comment}{// The idea of using 4.32 fixed-\/point numbers is based on}}
\DoxyCodeLine{975       \textcolor{comment}{// https://github.com/jeaiii/itoa}}
\DoxyCodeLine{976       \textcolor{keywordtype}{unsigned} n = N -\/ 1;}
\DoxyCodeLine{977       \textcolor{keywordtype}{unsigned} a = n / 5 * n * 53 / 16;}
\DoxyCodeLine{978       uint64\_t t = ((1ULL << (32 + a)) /}
\DoxyCodeLine{979                    data::ZERO\_OR\_POWERS\_OF\_10\_32[n] + 1 -\/ n / 9);}
\DoxyCodeLine{980       t = ((t * u) >> a) + n / 5 * 4;}
\DoxyCodeLine{981       write\_pair(0, t >> 32);}
\DoxyCodeLine{982       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 2; i < N; i += 2) \{}
\DoxyCodeLine{983         t = 100ULL * \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(t);}
\DoxyCodeLine{984         write\_pair(i, t >> 32);}
\DoxyCodeLine{985       \}}
\DoxyCodeLine{986       \textcolor{keywordflow}{if} (N \% 2 == 0) \{}
\DoxyCodeLine{987         buffer\_[N] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(}
\DoxyCodeLine{988           (10ULL * \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(t)) >> 32) + \textcolor{charliteral}{'0'};}
\DoxyCodeLine{989       \}}
\DoxyCodeLine{990     \}}
\DoxyCodeLine{991     \textcolor{keywordflow}{return} buffer\_ += N + 1;}
\DoxyCodeLine{992   \}}
\DoxyCodeLine{993 \};}
\DoxyCodeLine{994 }
\DoxyCodeLine{995 \textcolor{comment}{// An lg handler that formats a decimal number with a terminating null.}}
\DoxyCodeLine{996 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1decimal__formatter__null}{decimal\_formatter\_null}} : \textcolor{keyword}{public} \mbox{\hyperlink{classinternal_1_1decimal__formatter}{decimal\_formatter}} \{}
\DoxyCodeLine{997  \textcolor{keyword}{public}:}
\DoxyCodeLine{998   \textcolor{keyword}{explicit} \mbox{\hyperlink{classinternal_1_1decimal__formatter__null}{decimal\_formatter\_null}}(\textcolor{keywordtype}{char} *buf) : \mbox{\hyperlink{classinternal_1_1decimal__formatter}{decimal\_formatter}}(buf) \{\}}
\DoxyCodeLine{999 }
\DoxyCodeLine{1000   \textcolor{keyword}{template} <\textcolor{keywordtype}{unsigned} N> \textcolor{keywordtype}{char} *on(uint32\_t u) \{}
\DoxyCodeLine{1001     \textcolor{keywordtype}{char} *buf = decimal\_formatter::on<N>(u);}
\DoxyCodeLine{1002     *buf = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{1003     \textcolor{keywordflow}{return} buf;}
\DoxyCodeLine{1004   \}}
\DoxyCodeLine{1005 \};}
\DoxyCodeLine{1006 }
\DoxyCodeLine{1007 \textcolor{preprocessor}{\#ifdef FMT\_BUILTIN\_CLZ}}
\DoxyCodeLine{1008 \textcolor{comment}{// Optional version of count\_digits for better performance on 32-\/bit platforms.}}
\DoxyCodeLine{1009 \textcolor{keyword}{inline} \textcolor{keywordtype}{unsigned} count\_digits(uint32\_t n) \{}
\DoxyCodeLine{1010   \textcolor{keywordtype}{int} t = (32 -\/ FMT\_BUILTIN\_CLZ(n | 1)) * 1233 >> 12;}
\DoxyCodeLine{1011   \textcolor{keywordflow}{return} to\_unsigned(t) -\/ (n < data::ZERO\_OR\_POWERS\_OF\_10\_32[t]) + 1;}
\DoxyCodeLine{1012 \}}
\DoxyCodeLine{1013 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1014 }
\DoxyCodeLine{1015 \textcolor{comment}{// A functor that doesn't add a thousands separator.}}
\DoxyCodeLine{1016 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1no__thousands__sep}{no\_thousands\_sep}} \{}
\DoxyCodeLine{1017   \textcolor{keyword}{typedef} \textcolor{keywordtype}{char} char\_type;}
\DoxyCodeLine{1018 }
\DoxyCodeLine{1019   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1020   \textcolor{keywordtype}{void} operator()(Char *) \{\}}
\DoxyCodeLine{1021 \};}
\DoxyCodeLine{1022 }
\DoxyCodeLine{1023 \textcolor{comment}{// A functor that adds a thousands separator.}}
\DoxyCodeLine{1024 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1025 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1add__thousands__sep}{add\_thousands\_sep}} \{}
\DoxyCodeLine{1026  \textcolor{keyword}{private}:}
\DoxyCodeLine{1027   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} sep\_;}
\DoxyCodeLine{1028 }
\DoxyCodeLine{1029   \textcolor{comment}{// Index of a decimal digit with the least significant digit having index 0.}}
\DoxyCodeLine{1030   \textcolor{keywordtype}{unsigned} digit\_index\_;}
\DoxyCodeLine{1031 }
\DoxyCodeLine{1032  \textcolor{keyword}{public}:}
\DoxyCodeLine{1033   \textcolor{keyword}{typedef} Char char\_type;}
\DoxyCodeLine{1034 }
\DoxyCodeLine{1035   \textcolor{keyword}{explicit} \mbox{\hyperlink{classinternal_1_1add__thousands__sep}{add\_thousands\_sep}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} sep)}
\DoxyCodeLine{1036     : sep\_(sep), digit\_index\_(0) \{\}}
\DoxyCodeLine{1037 }
\DoxyCodeLine{1038   \textcolor{keywordtype}{void} operator()(Char *\&\mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}}) \{}
\DoxyCodeLine{1039     \textcolor{keywordflow}{if} (++digit\_index\_ \% 3 != 0)}
\DoxyCodeLine{1040       \textcolor{keywordflow}{return};}
\DoxyCodeLine{1041     \mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}} -\/= sep\_.\mbox{\hyperlink{classbasic__string__view_a7fd9f4dcac1782259b0cd217af69d737}{size}}();}
\DoxyCodeLine{1042     std::uninitialized\_copy(sep\_.\mbox{\hyperlink{classbasic__string__view_ae88f246f09d5ee5610e979d074ea74e1}{data}}(), sep\_.\mbox{\hyperlink{classbasic__string__view_ae88f246f09d5ee5610e979d074ea74e1}{data}}() + sep\_.\mbox{\hyperlink{classbasic__string__view_a7fd9f4dcac1782259b0cd217af69d737}{size}}(),}
\DoxyCodeLine{1043                             internal::make\_checked(\mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}}, sep\_.\mbox{\hyperlink{classbasic__string__view_a7fd9f4dcac1782259b0cd217af69d737}{size}}()));}
\DoxyCodeLine{1044   \}}
\DoxyCodeLine{1045 \};}
\DoxyCodeLine{1046 }
\DoxyCodeLine{1047 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1048 FMT\_API Char thousands\_sep(\mbox{\hyperlink{classlocale__provider}{locale\_provider}} *lp);}
\DoxyCodeLine{1049 }
\DoxyCodeLine{1050 \textcolor{comment}{// Formats a decimal unsigned integer value writing into buffer.}}
\DoxyCodeLine{1051 \textcolor{comment}{// thousands\_sep is a functor that is called after writing each char to}}
\DoxyCodeLine{1052 \textcolor{comment}{// add a thousands separator if necessary.}}
\DoxyCodeLine{1053 \textcolor{keyword}{template} <\textcolor{keyword}{typename} UInt, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} ThousandsSep>}
\DoxyCodeLine{1054 \textcolor{keyword}{inline} Char *format\_decimal(Char *\mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}}, UInt \mbox{\hyperlink{classinternal_1_1value}{value}}, \textcolor{keywordtype}{unsigned} num\_digits,}
\DoxyCodeLine{1055                             ThousandsSep thousands\_sep) \{}
\DoxyCodeLine{1056   \mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}} += num\_digits;}
\DoxyCodeLine{1057   Char *end = \mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}};}
\DoxyCodeLine{1058   \textcolor{keywordflow}{while} (\mbox{\hyperlink{classinternal_1_1value}{value}} >= 100) \{}
\DoxyCodeLine{1059     \textcolor{comment}{// Integer division is slow so do it for a group of two digits instead}}
\DoxyCodeLine{1060     \textcolor{comment}{// of for every digit. The idea comes from the talk by Alexandrescu}}
\DoxyCodeLine{1061     \textcolor{comment}{// "{}Three Optimization Tips for C++"{}. See speed-\/test for a comparison.}}
\DoxyCodeLine{1062     \textcolor{keywordtype}{unsigned} index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}((\mbox{\hyperlink{classinternal_1_1value}{value}} \% 100) * 2);}
\DoxyCodeLine{1063     \mbox{\hyperlink{classinternal_1_1value}{value}} /= 100;}
\DoxyCodeLine{1064     *-\/-\/\mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}} = data::DIGITS[index + 1];}
\DoxyCodeLine{1065     thousands\_sep(\mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}});}
\DoxyCodeLine{1066     *-\/-\/\mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}} = data::DIGITS[index];}
\DoxyCodeLine{1067     thousands\_sep(\mbox{\hyperlink{classinternal_1_1basic__buffer}{buffer}});}
\DoxyCodeLine{1068   \}}
\DoxyCodeLine{1069   \textcolor{keywordflow}{if} (value < 10) \{}
\DoxyCodeLine{1070     *-\/-\/buffer = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + value);}
\DoxyCodeLine{1071     \textcolor{keywordflow}{return} end;}
\DoxyCodeLine{1072   \}}
\DoxyCodeLine{1073   \textcolor{keywordtype}{unsigned} index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(value * 2);}
\DoxyCodeLine{1074   *-\/-\/buffer = data::DIGITS[index + 1];}
\DoxyCodeLine{1075   thousands\_sep(buffer);}
\DoxyCodeLine{1076   *-\/-\/buffer = data::DIGITS[index];}
\DoxyCodeLine{1077   \textcolor{keywordflow}{return} end;}
\DoxyCodeLine{1078 \}}
\DoxyCodeLine{1079 }
\DoxyCodeLine{1080 \textcolor{keyword}{template} <\textcolor{keyword}{typename} UInt, \textcolor{keyword}{typename} Iterator, \textcolor{keyword}{typename} ThousandsSep>}
\DoxyCodeLine{1081 \textcolor{keyword}{inline} Iterator format\_decimal(}
\DoxyCodeLine{1082     Iterator out, UInt value, \textcolor{keywordtype}{unsigned} num\_digits, ThousandsSep sep) \{}
\DoxyCodeLine{1083   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ThousandsSep::char\_type char\_type;}
\DoxyCodeLine{1084   \textcolor{comment}{// Buffer should be large enough to hold all digits (digits10 + 1) and null.}}
\DoxyCodeLine{1085   char\_type buffer[std::numeric\_limits<UInt>::digits10 + 2];}
\DoxyCodeLine{1086   format\_decimal(buffer, value, num\_digits, sep);}
\DoxyCodeLine{1087   \textcolor{keywordflow}{return} std::copy\_n(buffer, num\_digits, out);}
\DoxyCodeLine{1088 \}}
\DoxyCodeLine{1089 }
\DoxyCodeLine{1090 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It, \textcolor{keyword}{typename} UInt>}
\DoxyCodeLine{1091 \textcolor{keyword}{inline} It format\_decimal(It out, UInt value, \textcolor{keywordtype}{unsigned} num\_digits) \{}
\DoxyCodeLine{1092   \textcolor{keywordflow}{return} format\_decimal(out, value, num\_digits, no\_thousands\_sep());}
\DoxyCodeLine{1093 \}}
\DoxyCodeLine{1094 }
\DoxyCodeLine{1095 \textcolor{keyword}{template} <\textcolor{keywordtype}{unsigned} BASE\_BITS, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} UInt>}
\DoxyCodeLine{1096 \textcolor{keyword}{inline} Char *format\_uint(Char *buffer, UInt value, \textcolor{keywordtype}{unsigned} num\_digits,}
\DoxyCodeLine{1097                          \textcolor{keywordtype}{bool} upper = \textcolor{keyword}{false}) \{}
\DoxyCodeLine{1098   buffer += num\_digits;}
\DoxyCodeLine{1099   Char *end = buffer;}
\DoxyCodeLine{1100   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{1101     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *digits = upper ? \textcolor{stringliteral}{"{}0123456789ABCDEF"{}} : \textcolor{stringliteral}{"{}0123456789abcdef"{}};}
\DoxyCodeLine{1102     \textcolor{keywordtype}{unsigned} digit = (value \& ((1 << BASE\_BITS) -\/ 1));}
\DoxyCodeLine{1103     *-\/-\/buffer = BASE\_BITS < 4 ? static\_cast<char>(\textcolor{charliteral}{'0'} + digit) : digits[digit];}
\DoxyCodeLine{1104   \} \textcolor{keywordflow}{while} ((value >>= BASE\_BITS) != 0);}
\DoxyCodeLine{1105   \textcolor{keywordflow}{return} end;}
\DoxyCodeLine{1106 \}}
\DoxyCodeLine{1107 }
\DoxyCodeLine{1108 \textcolor{keyword}{template} <\textcolor{keywordtype}{unsigned} BASE\_BITS, \textcolor{keyword}{typename} It, \textcolor{keyword}{typename} UInt>}
\DoxyCodeLine{1109 \textcolor{keyword}{inline} It format\_uint(It out, UInt value, \textcolor{keywordtype}{unsigned} num\_digits,}
\DoxyCodeLine{1110                       \textcolor{keywordtype}{bool} upper = \textcolor{keyword}{false}) \{}
\DoxyCodeLine{1111   \textcolor{comment}{// Buffer should be large enough to hold all digits (digits / BASE\_BITS + 1)}}
\DoxyCodeLine{1112   \textcolor{comment}{// and null.}}
\DoxyCodeLine{1113   \textcolor{keywordtype}{char} buffer[std::numeric\_limits<UInt>::digits / BASE\_BITS + 2];}
\DoxyCodeLine{1114   format\_uint<BASE\_BITS>(buffer, value, num\_digits, upper);}
\DoxyCodeLine{1115   \textcolor{keywordflow}{return} std::copy\_n(buffer, num\_digits, out);}
\DoxyCodeLine{1116 \}}
\DoxyCodeLine{1117 }
\DoxyCodeLine{1118 \textcolor{preprocessor}{\#ifndef \_WIN32}}
\DoxyCodeLine{1119 \textcolor{preprocessor}{\# define FMT\_USE\_WINDOWS\_H 0}}
\DoxyCodeLine{1120 \textcolor{preprocessor}{\#elif !defined(FMT\_USE\_WINDOWS\_H)}}
\DoxyCodeLine{1121 \textcolor{preprocessor}{\# define FMT\_USE\_WINDOWS\_H 1}}
\DoxyCodeLine{1122 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1123 }
\DoxyCodeLine{1124 \textcolor{comment}{// Define FMT\_USE\_WINDOWS\_H to 0 to disable use of windows.h.}}
\DoxyCodeLine{1125 \textcolor{comment}{// All the functionality that relies on it will be disabled too.}}
\DoxyCodeLine{1126 \textcolor{preprocessor}{\#if FMT\_USE\_WINDOWS\_H}}
\DoxyCodeLine{1127 \textcolor{comment}{// A converter from UTF-\/8 to UTF-\/16.}}
\DoxyCodeLine{1128 \textcolor{comment}{// It is only provided for Windows since other systems support UTF-\/8 natively.}}
\DoxyCodeLine{1129 \textcolor{keyword}{class }utf8\_to\_utf16 \{}
\DoxyCodeLine{1130  \textcolor{keyword}{private}:}
\DoxyCodeLine{1131   \mbox{\hyperlink{classbasic__memory__buffer}{wmemory\_buffer}} buffer\_;}
\DoxyCodeLine{1132 }
\DoxyCodeLine{1133  \textcolor{keyword}{public}:}
\DoxyCodeLine{1134   FMT\_API \textcolor{keyword}{explicit} utf8\_to\_utf16(\mbox{\hyperlink{classbasic__string__view}{string\_view}} s);}
\DoxyCodeLine{1135   \textcolor{keyword}{operator} \mbox{\hyperlink{classbasic__string__view}{wstring\_view}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__string__view}{wstring\_view}}(\&buffer\_[0], size()); \}}
\DoxyCodeLine{1136   \textcolor{keywordtype}{size\_t} size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} buffer\_.\mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}}() -\/ 1; \}}
\DoxyCodeLine{1137   \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t} *c\_str()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \&buffer\_[0]; \}}
\DoxyCodeLine{1138   std::wstring str()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} std::wstring(\&buffer\_[0], size()); \}}
\DoxyCodeLine{1139 \};}
\DoxyCodeLine{1140 }
\DoxyCodeLine{1141 \textcolor{comment}{// A converter from UTF-\/16 to UTF-\/8.}}
\DoxyCodeLine{1142 \textcolor{comment}{// It is only provided for Windows since other systems support UTF-\/8 natively.}}
\DoxyCodeLine{1143 \textcolor{keyword}{class }utf16\_to\_utf8 \{}
\DoxyCodeLine{1144  \textcolor{keyword}{private}:}
\DoxyCodeLine{1145   \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}} buffer\_;}
\DoxyCodeLine{1146 }
\DoxyCodeLine{1147  \textcolor{keyword}{public}:}
\DoxyCodeLine{1148   utf16\_to\_utf8() \{\}}
\DoxyCodeLine{1149   FMT\_API \textcolor{keyword}{explicit} utf16\_to\_utf8(\mbox{\hyperlink{classbasic__string__view}{wstring\_view}} s);}
\DoxyCodeLine{1150   \textcolor{keyword}{operator} \mbox{\hyperlink{classbasic__string__view}{string\_view}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__string__view}{string\_view}}(\&buffer\_[0], size()); \}}
\DoxyCodeLine{1151   \textcolor{keywordtype}{size\_t} size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} buffer\_.\mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}}() -\/ 1; \}}
\DoxyCodeLine{1152   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *c\_str()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \&buffer\_[0]; \}}
\DoxyCodeLine{1153   std::string str()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} std::string(\&buffer\_[0], size()); \}}
\DoxyCodeLine{1154 }
\DoxyCodeLine{1155   \textcolor{comment}{// Performs conversion returning a system error code instead of}}
\DoxyCodeLine{1156   \textcolor{comment}{// throwing exception on conversion error. This method may still throw}}
\DoxyCodeLine{1157   \textcolor{comment}{// in case of memory allocation error.}}
\DoxyCodeLine{1158   FMT\_API \textcolor{keywordtype}{int} convert(\mbox{\hyperlink{classbasic__string__view}{wstring\_view}} s);}
\DoxyCodeLine{1159 \};}
\DoxyCodeLine{1160 }
\DoxyCodeLine{1161 FMT\_API \textcolor{keywordtype}{void} format\_windows\_error(fmt::internal::buffer \&out, \textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}},}
\DoxyCodeLine{1162                                   fmt::string\_view message) FMT\_NOEXCEPT;}
\DoxyCodeLine{1163 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1164 }
\DoxyCodeLine{1165 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1166 \textcolor{keyword}{struct }\textcolor{keyword}{null} \{\};}
\DoxyCodeLine{1167 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{1168 }
\DoxyCodeLine{1169 \textcolor{keyword}{enum} alignment \{}
\DoxyCodeLine{1170   ALIGN\_DEFAULT, ALIGN\_LEFT, ALIGN\_RIGHT, ALIGN\_CENTER, ALIGN\_NUMERIC}
\DoxyCodeLine{1171 \};}
\DoxyCodeLine{1172 }
\DoxyCodeLine{1173 \textcolor{comment}{// Flags.}}
\DoxyCodeLine{1174 \textcolor{keyword}{enum} \{SIGN\_FLAG = 1, PLUS\_FLAG = 2, MINUS\_FLAG = 4, HASH\_FLAG = 8\};}
\DoxyCodeLine{1175 }
\DoxyCodeLine{1176 \textcolor{keyword}{enum} format\_spec\_tag \{fill\_tag, align\_tag, width\_tag, type\_tag\};}
\DoxyCodeLine{1177 }
\DoxyCodeLine{1178 \textcolor{comment}{// Format specifier.}}
\DoxyCodeLine{1179 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, format\_spec\_tag>}
\DoxyCodeLine{1180 \textcolor{keyword}{class }\mbox{\hyperlink{classformat__spec}{format\_spec}} \{}
\DoxyCodeLine{1181  \textcolor{keyword}{private}:}
\DoxyCodeLine{1182   T value\_;}
\DoxyCodeLine{1183 }
\DoxyCodeLine{1184  \textcolor{keyword}{public}:}
\DoxyCodeLine{1185   \textcolor{keyword}{typedef} T value\_type;}
\DoxyCodeLine{1186 }
\DoxyCodeLine{1187   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__spec}{format\_spec}}(T value) : value\_(value) \{\}}
\DoxyCodeLine{1188 }
\DoxyCodeLine{1189   T value()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} value\_; \}}
\DoxyCodeLine{1190 \};}
\DoxyCodeLine{1191 }
\DoxyCodeLine{1192 \textcolor{comment}{// template <typename Char>}}
\DoxyCodeLine{1193 \textcolor{comment}{// typedef format\_spec<Char, fill\_tag> fill\_spec;}}
\DoxyCodeLine{1194 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1195 \textcolor{keyword}{class }\mbox{\hyperlink{classfill__spec}{fill\_spec}} : \textcolor{keyword}{public} \mbox{\hyperlink{classformat__spec}{format\_spec<Char, fill\_tag>}} \{}
\DoxyCodeLine{1196  \textcolor{keyword}{public}:}
\DoxyCodeLine{1197   \textcolor{keyword}{explicit} \mbox{\hyperlink{classfill__spec}{fill\_spec}}(Char value) : \mbox{\hyperlink{classformat__spec}{format\_spec<Char, fill\_tag>}}(value) \{\}}
\DoxyCodeLine{1198 \};}
\DoxyCodeLine{1199 }
\DoxyCodeLine{1200 \textcolor{keyword}{typedef} \mbox{\hyperlink{classformat__spec}{format\_spec<unsigned, width\_tag>}} \mbox{\hyperlink{classformat__spec}{width\_spec}};}
\DoxyCodeLine{1201 \textcolor{keyword}{typedef} \mbox{\hyperlink{classformat__spec}{format\_spec<char, type\_tag>}} \mbox{\hyperlink{classformat__spec}{type\_spec}};}
\DoxyCodeLine{1202 }
\DoxyCodeLine{1203 \textcolor{comment}{// An empty format specifier.}}
\DoxyCodeLine{1204 \textcolor{keyword}{struct }\mbox{\hyperlink{structempty__spec}{empty\_spec}} \{\};}
\DoxyCodeLine{1205 }
\DoxyCodeLine{1206 \textcolor{comment}{// An alignment specifier.}}
\DoxyCodeLine{1207 \textcolor{keyword}{struct }\mbox{\hyperlink{structalign__spec}{align\_spec}} : \mbox{\hyperlink{structempty__spec}{empty\_spec}} \{}
\DoxyCodeLine{1208   \textcolor{keywordtype}{unsigned} width\_;}
\DoxyCodeLine{1209   \textcolor{comment}{// Fill is always wchar\_t and cast to char if necessary to avoid having}}
\DoxyCodeLine{1210   \textcolor{comment}{// two specialization of AlignSpec and its subclasses.}}
\DoxyCodeLine{1211   \textcolor{keywordtype}{wchar\_t} fill\_;}
\DoxyCodeLine{1212   alignment align\_;}
\DoxyCodeLine{1213 }
\DoxyCodeLine{1214   FMT\_CONSTEXPR \mbox{\hyperlink{structalign__spec}{align\_spec}}(}
\DoxyCodeLine{1215       \textcolor{keywordtype}{unsigned} width, \textcolor{keywordtype}{wchar\_t} fill, alignment align = ALIGN\_DEFAULT)}
\DoxyCodeLine{1216   : width\_(width), fill\_(fill), align\_(align) \{\}}
\DoxyCodeLine{1217 }
\DoxyCodeLine{1218   FMT\_CONSTEXPR \textcolor{keywordtype}{unsigned} width()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} width\_; \}}
\DoxyCodeLine{1219   FMT\_CONSTEXPR \textcolor{keywordtype}{wchar\_t} fill()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} fill\_; \}}
\DoxyCodeLine{1220   FMT\_CONSTEXPR alignment align()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} align\_; \}}
\DoxyCodeLine{1221 }
\DoxyCodeLine{1222   \textcolor{keywordtype}{int} precision()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} -\/1; \}}
\DoxyCodeLine{1223 \};}
\DoxyCodeLine{1224 }
\DoxyCodeLine{1225 \textcolor{comment}{// Format specifiers.}}
\DoxyCodeLine{1226 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1227 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__specs}{basic\_format\_specs}} : \textcolor{keyword}{public} \mbox{\hyperlink{structalign__spec}{align\_spec}} \{}
\DoxyCodeLine{1228  \textcolor{keyword}{public}:}
\DoxyCodeLine{1229   \textcolor{keywordtype}{unsigned} flags\_;}
\DoxyCodeLine{1230   \textcolor{keywordtype}{int} precision\_;}
\DoxyCodeLine{1231   Char type\_;}
\DoxyCodeLine{1232 }
\DoxyCodeLine{1233   FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__format__specs}{basic\_format\_specs}}(}
\DoxyCodeLine{1234       \textcolor{keywordtype}{unsigned} width = 0, \textcolor{keywordtype}{char} type = 0, \textcolor{keywordtype}{wchar\_t} fill = \textcolor{charliteral}{' '})}
\DoxyCodeLine{1235   : \mbox{\hyperlink{structalign__spec}{align\_spec}}(width, fill), flags\_(0), precision\_(-\/1), type\_(type) \{\}}
\DoxyCodeLine{1236 }
\DoxyCodeLine{1237   FMT\_CONSTEXPR \textcolor{keywordtype}{bool} flag(\textcolor{keywordtype}{unsigned} f)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} (flags\_ \& f) != 0; \}}
\DoxyCodeLine{1238   FMT\_CONSTEXPR \textcolor{keywordtype}{int} precision()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} precision\_; \}}
\DoxyCodeLine{1239   FMT\_CONSTEXPR Char type()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} type\_; \}}
\DoxyCodeLine{1240 \};}
\DoxyCodeLine{1241 }
\DoxyCodeLine{1242 \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__specs}{basic\_format\_specs<char>}} \mbox{\hyperlink{classbasic__format__specs}{format\_specs}};}
\DoxyCodeLine{1243 }
\DoxyCodeLine{1244 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{1245 FMT\_CONSTEXPR \textcolor{keywordtype}{unsigned} \mbox{\hyperlink{classbasic__parse__context}{basic\_parse\_context<Char, ErrorHandler>::next\_arg\_id}}() \{}
\DoxyCodeLine{1246   \textcolor{keywordflow}{if} (next\_arg\_id\_ >= 0)}
\DoxyCodeLine{1247     \textcolor{keywordflow}{return} internal::to\_unsigned(next\_arg\_id\_++);}
\DoxyCodeLine{1248   on\_error(\textcolor{stringliteral}{"{}cannot switch from manual to automatic argument indexing"{}});}
\DoxyCodeLine{1249   \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1250 \}}
\DoxyCodeLine{1251 }
\DoxyCodeLine{1252 \textcolor{keyword}{namespace }\textcolor{keyword}{internal} \{}
\DoxyCodeLine{1253 }
\DoxyCodeLine{1254 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S>}
\DoxyCodeLine{1255 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1format__string__traits}{format\_string\_traits}}<}
\DoxyCodeLine{1256   S, \textcolor{keyword}{typename} std::enable\_if<std::is\_base\_of<compile\_string, S>::value>::type>:}
\DoxyCodeLine{1257     \mbox{\hyperlink{structinternal_1_1format__string__traits__base}{format\_string\_traits\_base<char>}} \{\};}
\DoxyCodeLine{1258 }
\DoxyCodeLine{1259 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{1260 FMT\_CONSTEXPR \textcolor{keywordtype}{void} handle\_int\_type\_spec(Char spec, Handler \&\&handler) \{}
\DoxyCodeLine{1261   \textcolor{keywordflow}{switch} (spec) \{}
\DoxyCodeLine{1262   \textcolor{keywordflow}{case} 0: \textcolor{keywordflow}{case} \textcolor{charliteral}{'d'}:}
\DoxyCodeLine{1263     handler.on\_dec();}
\DoxyCodeLine{1264     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1265   \textcolor{keywordflow}{case} \textcolor{charliteral}{'x'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'X'}:}
\DoxyCodeLine{1266     handler.on\_hex();}
\DoxyCodeLine{1267     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1268   \textcolor{keywordflow}{case} \textcolor{charliteral}{'b'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'B'}:}
\DoxyCodeLine{1269     handler.on\_bin();}
\DoxyCodeLine{1270     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1271   \textcolor{keywordflow}{case} \textcolor{charliteral}{'o'}:}
\DoxyCodeLine{1272     handler.on\_oct();}
\DoxyCodeLine{1273     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1274   \textcolor{keywordflow}{case} \textcolor{charliteral}{'n'}:}
\DoxyCodeLine{1275     handler.on\_num();}
\DoxyCodeLine{1276     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1277   \textcolor{keywordflow}{default}:}
\DoxyCodeLine{1278     handler.on\_error();}
\DoxyCodeLine{1279   \}}
\DoxyCodeLine{1280 \}}
\DoxyCodeLine{1281 }
\DoxyCodeLine{1282 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{1283 FMT\_CONSTEXPR \textcolor{keywordtype}{void} handle\_float\_type\_spec(Char spec, Handler \&\&handler) \{}
\DoxyCodeLine{1284   \textcolor{keywordflow}{switch} (spec) \{}
\DoxyCodeLine{1285   \textcolor{keywordflow}{case} 0: \textcolor{keywordflow}{case} \textcolor{charliteral}{'g'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'G'}:}
\DoxyCodeLine{1286     handler.on\_general();}
\DoxyCodeLine{1287     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1288   \textcolor{keywordflow}{case} \textcolor{charliteral}{'e'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'E'}:}
\DoxyCodeLine{1289     handler.on\_exp();}
\DoxyCodeLine{1290     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1291   \textcolor{keywordflow}{case} \textcolor{charliteral}{'f'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'F'}:}
\DoxyCodeLine{1292     handler.on\_fixed();}
\DoxyCodeLine{1293     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1294    \textcolor{keywordflow}{case} \textcolor{charliteral}{'a'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'A'}:}
\DoxyCodeLine{1295     handler.on\_hex();}
\DoxyCodeLine{1296     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1297   \textcolor{keywordflow}{default}:}
\DoxyCodeLine{1298     handler.on\_error();}
\DoxyCodeLine{1299     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1300   \}}
\DoxyCodeLine{1301 \}}
\DoxyCodeLine{1302 }
\DoxyCodeLine{1303 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{1304 FMT\_CONSTEXPR \textcolor{keywordtype}{void} handle\_char\_specs(}
\DoxyCodeLine{1305     \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__specs}{basic\_format\_specs<Char>}} *specs, Handler \&\&handler) \{}
\DoxyCodeLine{1306   \textcolor{keywordflow}{if} (!specs) \textcolor{keywordflow}{return} handler.on\_char();}
\DoxyCodeLine{1307   \textcolor{keywordflow}{if} (specs-\/>type() \&\& specs-\/>type() != \textcolor{charliteral}{'c'}) \textcolor{keywordflow}{return} handler.on\_int();}
\DoxyCodeLine{1308   \textcolor{keywordflow}{if} (specs-\/>align() == ALIGN\_NUMERIC || specs-\/>flag(\string~0u) != 0)}
\DoxyCodeLine{1309     handler.on\_error(\textcolor{stringliteral}{"{}invalid format specifier for char"{}});}
\DoxyCodeLine{1310   handler.on\_char();}
\DoxyCodeLine{1311 \}}
\DoxyCodeLine{1312 }
\DoxyCodeLine{1313 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{1314 FMT\_CONSTEXPR \textcolor{keywordtype}{void} handle\_cstring\_type\_spec(Char spec, Handler \&\&handler) \{}
\DoxyCodeLine{1315   \textcolor{keywordflow}{if} (spec == 0 || spec == \textcolor{charliteral}{'s'})}
\DoxyCodeLine{1316     handler.on\_string();}
\DoxyCodeLine{1317   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (spec == \textcolor{charliteral}{'p'})}
\DoxyCodeLine{1318     handler.on\_pointer();}
\DoxyCodeLine{1319   \textcolor{keywordflow}{else}}
\DoxyCodeLine{1320     handler.on\_error(\textcolor{stringliteral}{"{}invalid type specifier"{}});}
\DoxyCodeLine{1321 \}}
\DoxyCodeLine{1322 }
\DoxyCodeLine{1323 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{1324 FMT\_CONSTEXPR \textcolor{keywordtype}{void} check\_string\_type\_spec(Char spec, ErrorHandler \&\&eh) \{}
\DoxyCodeLine{1325   \textcolor{keywordflow}{if} (spec != 0 \&\& spec != \textcolor{charliteral}{'s'})}
\DoxyCodeLine{1326     eh.on\_error(\textcolor{stringliteral}{"{}invalid type specifier"{}});}
\DoxyCodeLine{1327 \}}
\DoxyCodeLine{1328 }
\DoxyCodeLine{1329 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{1330 FMT\_CONSTEXPR \textcolor{keywordtype}{void} check\_pointer\_type\_spec(Char spec, ErrorHandler \&\&eh) \{}
\DoxyCodeLine{1331   \textcolor{keywordflow}{if} (spec != 0 \&\& spec != \textcolor{charliteral}{'p'})}
\DoxyCodeLine{1332     eh.on\_error(\textcolor{stringliteral}{"{}invalid type specifier"{}});}
\DoxyCodeLine{1333 \}}
\DoxyCodeLine{1334 }
\DoxyCodeLine{1335 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{1336 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1int__type__checker}{int\_type\_checker}} : \textcolor{keyword}{private} ErrorHandler \{}
\DoxyCodeLine{1337  \textcolor{keyword}{public}:}
\DoxyCodeLine{1338   FMT\_CONSTEXPR \textcolor{keyword}{explicit} \mbox{\hyperlink{classinternal_1_1int__type__checker}{int\_type\_checker}}(ErrorHandler eh) : ErrorHandler(eh) \{\}}
\DoxyCodeLine{1339 }
\DoxyCodeLine{1340   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dec() \{\}}
\DoxyCodeLine{1341   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_hex() \{\}}
\DoxyCodeLine{1342   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_bin() \{\}}
\DoxyCodeLine{1343   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_oct() \{\}}
\DoxyCodeLine{1344   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_num() \{\}}
\DoxyCodeLine{1345 }
\DoxyCodeLine{1346   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error() \{}
\DoxyCodeLine{1347     ErrorHandler::on\_error(\textcolor{stringliteral}{"{}invalid type specifier"{}});}
\DoxyCodeLine{1348   \}}
\DoxyCodeLine{1349 \};}
\DoxyCodeLine{1350 }
\DoxyCodeLine{1351 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{1352 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1float__type__checker}{float\_type\_checker}} : \textcolor{keyword}{private} ErrorHandler \{}
\DoxyCodeLine{1353  \textcolor{keyword}{public}:}
\DoxyCodeLine{1354   FMT\_CONSTEXPR \textcolor{keyword}{explicit} \mbox{\hyperlink{classinternal_1_1float__type__checker}{float\_type\_checker}}(ErrorHandler eh)}
\DoxyCodeLine{1355     : ErrorHandler(eh) \{\}}
\DoxyCodeLine{1356 }
\DoxyCodeLine{1357   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_general() \{\}}
\DoxyCodeLine{1358   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_exp() \{\}}
\DoxyCodeLine{1359   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_fixed() \{\}}
\DoxyCodeLine{1360   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_hex() \{\}}
\DoxyCodeLine{1361 }
\DoxyCodeLine{1362   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error() \{}
\DoxyCodeLine{1363     ErrorHandler::on\_error(\textcolor{stringliteral}{"{}invalid type specifier"{}});}
\DoxyCodeLine{1364   \}}
\DoxyCodeLine{1365 \};}
\DoxyCodeLine{1366 }
\DoxyCodeLine{1367 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler, \textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{1368 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1char__specs__checker}{char\_specs\_checker}} : \textcolor{keyword}{public} ErrorHandler \{}
\DoxyCodeLine{1369  \textcolor{keyword}{private}:}
\DoxyCodeLine{1370   CharType type\_;}
\DoxyCodeLine{1371 }
\DoxyCodeLine{1372  \textcolor{keyword}{public}:}
\DoxyCodeLine{1373   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1char__specs__checker}{char\_specs\_checker}}(CharType type, ErrorHandler eh)}
\DoxyCodeLine{1374     : ErrorHandler(eh), type\_(type) \{\}}
\DoxyCodeLine{1375 }
\DoxyCodeLine{1376   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_int() \{}
\DoxyCodeLine{1377     handle\_int\_type\_spec(type\_, \mbox{\hyperlink{classinternal_1_1int__type__checker}{int\_type\_checker<ErrorHandler>}}(*\textcolor{keyword}{this}));}
\DoxyCodeLine{1378   \}}
\DoxyCodeLine{1379   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_char() \{\}}
\DoxyCodeLine{1380 \};}
\DoxyCodeLine{1381 }
\DoxyCodeLine{1382 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{1383 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1cstring__type__checker}{cstring\_type\_checker}} : \textcolor{keyword}{public} ErrorHandler \{}
\DoxyCodeLine{1384  \textcolor{keyword}{public}:}
\DoxyCodeLine{1385   FMT\_CONSTEXPR \textcolor{keyword}{explicit} \mbox{\hyperlink{classinternal_1_1cstring__type__checker}{cstring\_type\_checker}}(ErrorHandler eh)}
\DoxyCodeLine{1386     : ErrorHandler(eh) \{\}}
\DoxyCodeLine{1387 }
\DoxyCodeLine{1388   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_string() \{\}}
\DoxyCodeLine{1389   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_pointer() \{\}}
\DoxyCodeLine{1390 \};}
\DoxyCodeLine{1391 }
\DoxyCodeLine{1392 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{1393 \textcolor{keywordtype}{void} \mbox{\hyperlink{classinternal_1_1arg__map}{arg\_map<Context>::init}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<Context>}} \&args) \{}
\DoxyCodeLine{1394   \textcolor{keywordflow}{if} (map\_)}
\DoxyCodeLine{1395     \textcolor{keywordflow}{return};}
\DoxyCodeLine{1396   map\_ = \textcolor{keyword}{new} entry[args.max\_size()];}
\DoxyCodeLine{1397   \textcolor{keywordtype}{bool} use\_values = args.type(max\_packed\_args -\/ 1) == internal::none\_type;}
\DoxyCodeLine{1398   \textcolor{keywordflow}{if} (use\_values) \{}
\DoxyCodeLine{1399     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0;\textcolor{comment}{/*nothing*/}; ++i) \{}
\DoxyCodeLine{1400       internal::type arg\_type = args.type(i);}
\DoxyCodeLine{1401       \textcolor{keywordflow}{switch} (arg\_type) \{}
\DoxyCodeLine{1402         \textcolor{keywordflow}{case} internal::none\_type:}
\DoxyCodeLine{1403           \textcolor{keywordflow}{return};}
\DoxyCodeLine{1404         \textcolor{keywordflow}{case} internal::named\_arg\_type:}
\DoxyCodeLine{1405           push\_back(args.values\_[i]);}
\DoxyCodeLine{1406           \textcolor{keywordflow}{break};}
\DoxyCodeLine{1407         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{1408           \textcolor{keywordflow}{break}; \textcolor{comment}{// Do nothing.}}
\DoxyCodeLine{1409       \}}
\DoxyCodeLine{1410     \}}
\DoxyCodeLine{1411   \}}
\DoxyCodeLine{1412   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; ; ++i) \{}
\DoxyCodeLine{1413     \textcolor{keywordflow}{switch} (args.args\_[i].type\_) \{}
\DoxyCodeLine{1414       \textcolor{keywordflow}{case} internal::none\_type:}
\DoxyCodeLine{1415         \textcolor{keywordflow}{return};}
\DoxyCodeLine{1416       \textcolor{keywordflow}{case} internal::named\_arg\_type:}
\DoxyCodeLine{1417         push\_back(args.args\_[i].value\_);}
\DoxyCodeLine{1418         \textcolor{keywordflow}{break};}
\DoxyCodeLine{1419       \textcolor{keywordflow}{default}:}
\DoxyCodeLine{1420         \textcolor{keywordflow}{break}; \textcolor{comment}{// Do nothing.}}
\DoxyCodeLine{1421     \}}
\DoxyCodeLine{1422   \}}
\DoxyCodeLine{1423 \}}
\DoxyCodeLine{1424 }
\DoxyCodeLine{1425 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{1426 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1arg__formatter__base}{arg\_formatter\_base}} \{}
\DoxyCodeLine{1427  \textcolor{keyword}{public}:}
\DoxyCodeLine{1428   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Range::value\_type char\_type;}
\DoxyCodeLine{1429   \textcolor{keyword}{typedef} \textcolor{keyword}{decltype}(internal::declval<Range>().begin()) iterator;}
\DoxyCodeLine{1430   \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__specs}{basic\_format\_specs<char\_type>}} \mbox{\hyperlink{classbasic__format__specs}{format\_specs}};}
\DoxyCodeLine{1431 }
\DoxyCodeLine{1432  \textcolor{keyword}{private}:}
\DoxyCodeLine{1433   \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__writer}{basic\_writer<Range>}} \mbox{\hyperlink{classbasic__writer}{writer\_type}};}
\DoxyCodeLine{1434   \mbox{\hyperlink{classbasic__writer}{writer\_type}} writer\_;}
\DoxyCodeLine{1435   \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} *specs\_;}
\DoxyCodeLine{1436 }
\DoxyCodeLine{1437   \textcolor{keyword}{struct }char\_writer \{}
\DoxyCodeLine{1438     char\_type \mbox{\hyperlink{classinternal_1_1value}{value}};}
\DoxyCodeLine{1439     \textcolor{keyword}{template} <\textcolor{keyword}{typename} It>}
\DoxyCodeLine{1440     \textcolor{keywordtype}{void} operator()(It \&\&it)\textcolor{keyword}{ const }\{ *it++ = \mbox{\hyperlink{classinternal_1_1value}{value}}; \}}
\DoxyCodeLine{1441   \};}
\DoxyCodeLine{1442 }
\DoxyCodeLine{1443   \textcolor{keywordtype}{void} write\_char(char\_type \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{1444     \textcolor{keywordflow}{if} (specs\_)}
\DoxyCodeLine{1445       writer\_.write\_padded(1, *specs\_, char\_writer\{\mbox{\hyperlink{classinternal_1_1value}{value}}\});}
\DoxyCodeLine{1446     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1447       writer\_.write(\mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{1448   \}}
\DoxyCodeLine{1449 }
\DoxyCodeLine{1450   \textcolor{keywordtype}{void} write\_pointer(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *p) \{}
\DoxyCodeLine{1451     \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} specs = specs\_ ? *specs\_ : \mbox{\hyperlink{classbasic__format__specs}{format\_specs}}();}
\DoxyCodeLine{1452     specs.flags\_ = HASH\_FLAG;}
\DoxyCodeLine{1453     specs.type\_ = \textcolor{charliteral}{'x'};}
\DoxyCodeLine{1454     writer\_.write\_int(\textcolor{keyword}{reinterpret\_cast<}uintptr\_t\textcolor{keyword}{>}(p), specs);}
\DoxyCodeLine{1455   \}}
\DoxyCodeLine{1456 }
\DoxyCodeLine{1457  \textcolor{keyword}{protected}:}
\DoxyCodeLine{1458   \mbox{\hyperlink{classbasic__writer}{writer\_type}} \&\mbox{\hyperlink{classbasic__writer}{writer}}() \{ \textcolor{keywordflow}{return} writer\_; \}}
\DoxyCodeLine{1459   \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} *spec() \{ \textcolor{keywordflow}{return} specs\_; \}}
\DoxyCodeLine{1460   iterator out() \{ \textcolor{keywordflow}{return} writer\_.out(); \}}
\DoxyCodeLine{1461 }
\DoxyCodeLine{1462   \textcolor{keywordtype}{void} write(\textcolor{keywordtype}{bool} \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{1463     \mbox{\hyperlink{classbasic__string__view}{string\_view}} sv(\mbox{\hyperlink{classinternal_1_1value}{value}} ? \textcolor{stringliteral}{"{}true"{}} : \textcolor{stringliteral}{"{}false"{}});}
\DoxyCodeLine{1464     specs\_ ? writer\_.write\_str(sv, *specs\_) : writer\_.write(sv);}
\DoxyCodeLine{1465   \}}
\DoxyCodeLine{1466 }
\DoxyCodeLine{1467   \textcolor{keywordtype}{void} write(\textcolor{keyword}{const} char\_type *\mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{1468     \textcolor{keywordflow}{if} (!\mbox{\hyperlink{classinternal_1_1value}{value}})}
\DoxyCodeLine{1469       FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}string pointer is null"{}}));}
\DoxyCodeLine{1470     \textcolor{keyword}{auto} length = std::char\_traits<char\_type>::length(\mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{1471     \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} sv(\mbox{\hyperlink{classinternal_1_1value}{value}}, length);}
\DoxyCodeLine{1472     specs\_ ? writer\_.write\_str(sv, *specs\_) : writer\_.write(sv);}
\DoxyCodeLine{1473   \}}
\DoxyCodeLine{1474 }
\DoxyCodeLine{1475  \textcolor{keyword}{public}:}
\DoxyCodeLine{1476   \mbox{\hyperlink{classinternal_1_1arg__formatter__base}{arg\_formatter\_base}}(Range r, \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} *s): writer\_(r), specs\_(s) \{\}}
\DoxyCodeLine{1477 }
\DoxyCodeLine{1478   iterator operator()(\mbox{\hyperlink{structmonostate}{monostate}}) \{}
\DoxyCodeLine{1479     FMT\_ASSERT(\textcolor{keyword}{false}, \textcolor{stringliteral}{"{}invalid argument type"{}});}
\DoxyCodeLine{1480     \textcolor{keywordflow}{return} out();}
\DoxyCodeLine{1481   \}}
\DoxyCodeLine{1482 }
\DoxyCodeLine{1483   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1484   \textcolor{keyword}{typename} std::enable\_if<std::is\_integral<T>::value, iterator>::type}
\DoxyCodeLine{1485       operator()(T \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{1486     \textcolor{comment}{// MSVC2013 fails to compile separate overloads for bool and char\_type so}}
\DoxyCodeLine{1487     \textcolor{comment}{// use std::is\_same instead.}}
\DoxyCodeLine{1488     \textcolor{keywordflow}{if} (std::is\_same<T, bool>::value) \{}
\DoxyCodeLine{1489       \textcolor{keywordflow}{if} (specs\_ \&\& specs\_-\/>type\_)}
\DoxyCodeLine{1490         \textcolor{keywordflow}{return} (*\textcolor{keyword}{this})(\mbox{\hyperlink{classinternal_1_1value}{value}} ? 1 : 0);}
\DoxyCodeLine{1491       write(\mbox{\hyperlink{classinternal_1_1value}{value}} != 0);}
\DoxyCodeLine{1492     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (std::is\_same<T, char\_type>::value) \{}
\DoxyCodeLine{1493       internal::handle\_char\_specs(}
\DoxyCodeLine{1494         specs\_, \mbox{\hyperlink{structinternal_1_1arg__formatter__base_1_1char__spec__handler}{char\_spec\_handler}}(*\textcolor{keyword}{this}, \textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(\mbox{\hyperlink{classinternal_1_1value}{value}})));}
\DoxyCodeLine{1495     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1496       specs\_ ? writer\_.write\_int(\mbox{\hyperlink{classinternal_1_1value}{value}}, *specs\_) : writer\_.write(\mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{1497     \}}
\DoxyCodeLine{1498     \textcolor{keywordflow}{return} out();}
\DoxyCodeLine{1499   \}}
\DoxyCodeLine{1500 }
\DoxyCodeLine{1501   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1502   \textcolor{keyword}{typename} std::enable\_if<std::is\_floating\_point<T>::value, iterator>::type}
\DoxyCodeLine{1503       operator()(T \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{1504     writer\_.write\_double(\mbox{\hyperlink{classinternal_1_1value}{value}}, specs\_ ? *specs\_ : \mbox{\hyperlink{classbasic__format__specs}{format\_specs}}());}
\DoxyCodeLine{1505     \textcolor{keywordflow}{return} out();}
\DoxyCodeLine{1506   \}}
\DoxyCodeLine{1507 }
\DoxyCodeLine{1508   \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1arg__formatter__base_1_1char__spec__handler}{char\_spec\_handler}} : \mbox{\hyperlink{structinternal_1_1error__handler}{internal::error\_handler}} \{}
\DoxyCodeLine{1509     \mbox{\hyperlink{classinternal_1_1arg__formatter__base}{arg\_formatter\_base}} \&\mbox{\hyperlink{structformatter}{formatter}};}
\DoxyCodeLine{1510     char\_type \mbox{\hyperlink{classinternal_1_1value}{value}};}
\DoxyCodeLine{1511 }
\DoxyCodeLine{1512     \mbox{\hyperlink{structinternal_1_1arg__formatter__base_1_1char__spec__handler}{char\_spec\_handler}}(\mbox{\hyperlink{classinternal_1_1arg__formatter__base}{arg\_formatter\_base}}\& f, char\_type val)}
\DoxyCodeLine{1513       : \mbox{\hyperlink{structformatter}{formatter}}(f), \mbox{\hyperlink{classinternal_1_1value}{value}}(val) \{\}}
\DoxyCodeLine{1514 }
\DoxyCodeLine{1515     \textcolor{keywordtype}{void} on\_int() \{}
\DoxyCodeLine{1516       \textcolor{keywordflow}{if} (\mbox{\hyperlink{structformatter}{formatter}}.specs\_)}
\DoxyCodeLine{1517         \mbox{\hyperlink{structformatter}{formatter}}.writer\_.write\_int(\mbox{\hyperlink{classinternal_1_1value}{value}}, *\mbox{\hyperlink{structformatter}{formatter}}.specs\_);}
\DoxyCodeLine{1518       \textcolor{keywordflow}{else}}
\DoxyCodeLine{1519         \mbox{\hyperlink{structformatter}{formatter}}.writer\_.write(\mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{1520     \}}
\DoxyCodeLine{1521     \textcolor{keywordtype}{void} on\_char() \{ \mbox{\hyperlink{structformatter}{formatter}}.write\_char(\mbox{\hyperlink{classinternal_1_1value}{value}}); \}}
\DoxyCodeLine{1522   \};}
\DoxyCodeLine{1523 }
\DoxyCodeLine{1524   \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1arg__formatter__base_1_1cstring__spec__handler}{cstring\_spec\_handler}} : \mbox{\hyperlink{structinternal_1_1error__handler}{internal::error\_handler}} \{}
\DoxyCodeLine{1525     \mbox{\hyperlink{classinternal_1_1arg__formatter__base}{arg\_formatter\_base}} \&\mbox{\hyperlink{structformatter}{formatter}};}
\DoxyCodeLine{1526     \textcolor{keyword}{const} char\_type *\mbox{\hyperlink{classinternal_1_1value}{value}};}
\DoxyCodeLine{1527 }
\DoxyCodeLine{1528     \mbox{\hyperlink{structinternal_1_1arg__formatter__base_1_1cstring__spec__handler}{cstring\_spec\_handler}}(\mbox{\hyperlink{classinternal_1_1arg__formatter__base}{arg\_formatter\_base}} \&f, \textcolor{keyword}{const} char\_type *val)}
\DoxyCodeLine{1529       : \mbox{\hyperlink{structformatter}{formatter}}(f), \mbox{\hyperlink{classinternal_1_1value}{value}}(val) \{\}}
\DoxyCodeLine{1530 }
\DoxyCodeLine{1531     \textcolor{keywordtype}{void} on\_string() \{ \mbox{\hyperlink{structformatter}{formatter}}.write(\mbox{\hyperlink{classinternal_1_1value}{value}}); \}}
\DoxyCodeLine{1532     \textcolor{keywordtype}{void} on\_pointer() \{ \mbox{\hyperlink{structformatter}{formatter}}.write\_pointer(\mbox{\hyperlink{classinternal_1_1value}{value}}); \}}
\DoxyCodeLine{1533   \};}
\DoxyCodeLine{1534 }
\DoxyCodeLine{1535   iterator operator()(\textcolor{keyword}{const} char\_type *\mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{1536     \textcolor{keywordflow}{if} (!specs\_) \textcolor{keywordflow}{return} write(\mbox{\hyperlink{classinternal_1_1value}{value}}), out();}
\DoxyCodeLine{1537     internal::handle\_cstring\_type\_spec(}
\DoxyCodeLine{1538           specs\_-\/>type\_, \mbox{\hyperlink{structinternal_1_1arg__formatter__base_1_1cstring__spec__handler}{cstring\_spec\_handler}}(*\textcolor{keyword}{this}, \mbox{\hyperlink{classinternal_1_1value}{value}}));}
\DoxyCodeLine{1539     \textcolor{keywordflow}{return} out();}
\DoxyCodeLine{1540   \}}
\DoxyCodeLine{1541 }
\DoxyCodeLine{1542   iterator operator()(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{1543     \textcolor{keywordflow}{if} (specs\_) \{}
\DoxyCodeLine{1544       internal::check\_string\_type\_spec(}
\DoxyCodeLine{1545             specs\_-\/>type\_, \mbox{\hyperlink{structinternal_1_1error__handler}{internal::error\_handler}}());}
\DoxyCodeLine{1546       writer\_.write\_str(\mbox{\hyperlink{classinternal_1_1value}{value}}, *specs\_);}
\DoxyCodeLine{1547     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1548       writer\_.write(value);}
\DoxyCodeLine{1549     \}}
\DoxyCodeLine{1550     \textcolor{keywordflow}{return} out();}
\DoxyCodeLine{1551   \}}
\DoxyCodeLine{1552 }
\DoxyCodeLine{1553   iterator operator()(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *value) \{}
\DoxyCodeLine{1554     \textcolor{keywordflow}{if} (specs\_)}
\DoxyCodeLine{1555       check\_pointer\_type\_spec(specs\_-\/>type\_, \mbox{\hyperlink{structinternal_1_1error__handler}{internal::error\_handler}}());}
\DoxyCodeLine{1556     write\_pointer(value);}
\DoxyCodeLine{1557     \textcolor{keywordflow}{return} out();}
\DoxyCodeLine{1558   \}}
\DoxyCodeLine{1559 \};}
\DoxyCodeLine{1560 }
\DoxyCodeLine{1561 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1562 FMT\_CONSTEXPR \textcolor{keywordtype}{bool} is\_name\_start(Char c) \{}
\DoxyCodeLine{1563   \textcolor{keywordflow}{return} (\textcolor{charliteral}{'a'} <= c \&\& c <= \textcolor{charliteral}{'z'}) || (\textcolor{charliteral}{'A'} <= c \&\& c <= \textcolor{charliteral}{'Z'}) || \textcolor{charliteral}{'\_'} == c;}
\DoxyCodeLine{1564 \}}
\DoxyCodeLine{1565 }
\DoxyCodeLine{1566 \textcolor{comment}{// DEPRECATED: Parses the input as an unsigned integer. This function assumes}}
\DoxyCodeLine{1567 \textcolor{comment}{// that the first character is a digit and presence of a non-\/digit character at}}
\DoxyCodeLine{1568 \textcolor{comment}{// the end.}}
\DoxyCodeLine{1569 \textcolor{comment}{// it: an iterator pointing to the beginning of the input range.}}
\DoxyCodeLine{1570 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator, \textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{1571 FMT\_CONSTEXPR \textcolor{keywordtype}{unsigned} parse\_nonnegative\_int(Iterator \&it, ErrorHandler \&\&eh) \{}
\DoxyCodeLine{1572   assert(\textcolor{charliteral}{'0'} <= *it \&\& *it <= \textcolor{charliteral}{'9'});}
\DoxyCodeLine{1573   \textcolor{keywordtype}{unsigned} value = 0;}
\DoxyCodeLine{1574   \textcolor{comment}{// Convert to unsigned to prevent a warning.}}
\DoxyCodeLine{1575   \textcolor{keywordtype}{unsigned} max\_int = (std::numeric\_limits<int>::max)();}
\DoxyCodeLine{1576   \textcolor{keywordtype}{unsigned} big = max\_int / 10;}
\DoxyCodeLine{1577   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{1578     \textcolor{comment}{// Check for overflow.}}
\DoxyCodeLine{1579     \textcolor{keywordflow}{if} (value > big) \{}
\DoxyCodeLine{1580       value = max\_int + 1;}
\DoxyCodeLine{1581       \textcolor{keywordflow}{break};}
\DoxyCodeLine{1582     \}}
\DoxyCodeLine{1583     value = value * 10 + unsigned(*it -\/ \textcolor{charliteral}{'0'});}
\DoxyCodeLine{1584     \textcolor{comment}{// Workaround for MSVC "{}setup\_exception stack overflow"{} error:}}
\DoxyCodeLine{1585     \textcolor{keyword}{auto} next = it;}
\DoxyCodeLine{1586     ++next;}
\DoxyCodeLine{1587     it = next;}
\DoxyCodeLine{1588   \} \textcolor{keywordflow}{while} (\textcolor{charliteral}{'0'} <= *it \&\& *it <= \textcolor{charliteral}{'9'});}
\DoxyCodeLine{1589   \textcolor{keywordflow}{if} (value > max\_int)}
\DoxyCodeLine{1590     eh.on\_error(\textcolor{stringliteral}{"{}number is too big"{}});}
\DoxyCodeLine{1591   \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{1592 \}}
\DoxyCodeLine{1593 }
\DoxyCodeLine{1594 \textcolor{comment}{// Parses the range [begin, end) as an unsigned integer. This function assumes}}
\DoxyCodeLine{1595 \textcolor{comment}{// that the range is non-\/empty and the first character is a digit.}}
\DoxyCodeLine{1596 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{1597 FMT\_CONSTEXPR \textcolor{keywordtype}{unsigned} parse\_nonnegative\_int(}
\DoxyCodeLine{1598     \textcolor{keyword}{const} Char *\&begin, \textcolor{keyword}{const} Char *end, ErrorHandler \&\&eh) \{}
\DoxyCodeLine{1599   assert(begin != end \&\& \textcolor{charliteral}{'0'} <= *begin \&\& *begin <= \textcolor{charliteral}{'9'});}
\DoxyCodeLine{1600   \textcolor{keywordtype}{unsigned} value = 0;}
\DoxyCodeLine{1601   \textcolor{comment}{// Convert to unsigned to prevent a warning.}}
\DoxyCodeLine{1602   \textcolor{keywordtype}{unsigned} max\_int = (std::numeric\_limits<int>::max)();}
\DoxyCodeLine{1603   \textcolor{keywordtype}{unsigned} big = max\_int / 10;}
\DoxyCodeLine{1604   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{1605     \textcolor{comment}{// Check for overflow.}}
\DoxyCodeLine{1606     \textcolor{keywordflow}{if} (value > big) \{}
\DoxyCodeLine{1607       value = max\_int + 1;}
\DoxyCodeLine{1608       \textcolor{keywordflow}{break};}
\DoxyCodeLine{1609     \}}
\DoxyCodeLine{1610     value = value * 10 + unsigned(*begin++ -\/ \textcolor{charliteral}{'0'});}
\DoxyCodeLine{1611   \} \textcolor{keywordflow}{while} (begin != end \&\& \textcolor{charliteral}{'0'} <= *begin \&\& *begin <= \textcolor{charliteral}{'9'});}
\DoxyCodeLine{1612   \textcolor{keywordflow}{if} (value > max\_int)}
\DoxyCodeLine{1613     eh.on\_error(\textcolor{stringliteral}{"{}number is too big"{}});}
\DoxyCodeLine{1614   \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{1615 \}}
\DoxyCodeLine{1616 }
\DoxyCodeLine{1617 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{1618 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1custom__formatter}{custom\_formatter}}: \textcolor{keyword}{public} \mbox{\hyperlink{structinternal_1_1function}{function}}<bool> \{}
\DoxyCodeLine{1619  \textcolor{keyword}{private}:}
\DoxyCodeLine{1620   Context \&ctx\_;}
\DoxyCodeLine{1621 }
\DoxyCodeLine{1622  \textcolor{keyword}{public}:}
\DoxyCodeLine{1623   \textcolor{keyword}{explicit} \mbox{\hyperlink{classinternal_1_1custom__formatter}{custom\_formatter}}(Context \&ctx): ctx\_(ctx) \{\}}
\DoxyCodeLine{1624 }
\DoxyCodeLine{1625   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__arg_1_1handle}{basic\_format\_arg<Context>::handle}} h)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1626     h.format(ctx\_);}
\DoxyCodeLine{1627     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1628   \}}
\DoxyCodeLine{1629 }
\DoxyCodeLine{1630   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1631   \textcolor{keywordtype}{bool} operator()(T)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{1632 \};}
\DoxyCodeLine{1633 }
\DoxyCodeLine{1634 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1635 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1is__integer}{is\_integer}} \{}
\DoxyCodeLine{1636   \textcolor{keyword}{enum} \{}
\DoxyCodeLine{1637     \mbox{\hyperlink{classinternal_1_1value}{value}} = std::is\_integral<T>::value \&\& !std::is\_same<T, bool>::value \&\&}
\DoxyCodeLine{1638             !std::is\_same<T, char>::value \&\& !std::is\_same<T, wchar\_t>::value}
\DoxyCodeLine{1639   \};}
\DoxyCodeLine{1640 \};}
\DoxyCodeLine{1641 }
\DoxyCodeLine{1642 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{1643 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1width__checker}{width\_checker}}: \textcolor{keyword}{public} \mbox{\hyperlink{structinternal_1_1function}{function}}<unsigned long long> \{}
\DoxyCodeLine{1644  \textcolor{keyword}{public}:}
\DoxyCodeLine{1645   \textcolor{keyword}{explicit} FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1width__checker}{width\_checker}}(ErrorHandler \&eh) : handler\_(eh) \{\}}
\DoxyCodeLine{1646 }
\DoxyCodeLine{1647   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1648   FMT\_CONSTEXPR}
\DoxyCodeLine{1649   \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1650       \mbox{\hyperlink{structinternal_1_1is__integer}{is\_integer<T>::value}}, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}>::type operator()(T \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{1651     \textcolor{keywordflow}{if} (is\_negative(\mbox{\hyperlink{classinternal_1_1value}{value}}))}
\DoxyCodeLine{1652       handler\_.on\_error(\textcolor{stringliteral}{"{}negative width"{}});}
\DoxyCodeLine{1653     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(\mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{1654   \}}
\DoxyCodeLine{1655 }
\DoxyCodeLine{1656   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1657   FMT\_CONSTEXPR \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1658       !\mbox{\hyperlink{structinternal_1_1is__integer}{is\_integer<T>::value}}, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}>::type operator()(T) \{}
\DoxyCodeLine{1659     handler\_.on\_error(\textcolor{stringliteral}{"{}width is not integer"{}});}
\DoxyCodeLine{1660     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1661   \}}
\DoxyCodeLine{1662 }
\DoxyCodeLine{1663  \textcolor{keyword}{private}:}
\DoxyCodeLine{1664   ErrorHandler \&handler\_;}
\DoxyCodeLine{1665 \};}
\DoxyCodeLine{1666 }
\DoxyCodeLine{1667 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{1668 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1precision__checker}{precision\_checker}}: \textcolor{keyword}{public} \mbox{\hyperlink{structinternal_1_1function}{function}}<unsigned long long> \{}
\DoxyCodeLine{1669  \textcolor{keyword}{public}:}
\DoxyCodeLine{1670   \textcolor{keyword}{explicit} FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1precision__checker}{precision\_checker}}(ErrorHandler \&eh) : handler\_(eh) \{\}}
\DoxyCodeLine{1671 }
\DoxyCodeLine{1672   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1673   FMT\_CONSTEXPR \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1674       \mbox{\hyperlink{structinternal_1_1is__integer}{is\_integer<T>::value}}, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}>::type operator()(T \mbox{\hyperlink{classinternal_1_1value}{value}}) \{}
\DoxyCodeLine{1675     \textcolor{keywordflow}{if} (is\_negative(\mbox{\hyperlink{classinternal_1_1value}{value}}))}
\DoxyCodeLine{1676       handler\_.on\_error(\textcolor{stringliteral}{"{}negative precision"{}});}
\DoxyCodeLine{1677     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(\mbox{\hyperlink{classinternal_1_1value}{value}});}
\DoxyCodeLine{1678   \}}
\DoxyCodeLine{1679 }
\DoxyCodeLine{1680   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1681   FMT\_CONSTEXPR \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1682       !\mbox{\hyperlink{structinternal_1_1is__integer}{is\_integer<T>::value}}, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}>::type operator()(T) \{}
\DoxyCodeLine{1683     handler\_.on\_error(\textcolor{stringliteral}{"{}precision is not integer"{}});}
\DoxyCodeLine{1684     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1685   \}}
\DoxyCodeLine{1686 }
\DoxyCodeLine{1687  \textcolor{keyword}{private}:}
\DoxyCodeLine{1688   ErrorHandler \&handler\_;}
\DoxyCodeLine{1689 \};}
\DoxyCodeLine{1690 }
\DoxyCodeLine{1691 \textcolor{comment}{// A format specifier handler that sets fields in basic\_format\_specs.}}
\DoxyCodeLine{1692 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1693 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1specs__setter}{specs\_setter}} \{}
\DoxyCodeLine{1694  \textcolor{keyword}{public}:}
\DoxyCodeLine{1695   \textcolor{keyword}{explicit} FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1specs__setter}{specs\_setter}}(\mbox{\hyperlink{classbasic__format__specs}{basic\_format\_specs<Char>}} \&specs):}
\DoxyCodeLine{1696     specs\_(specs) \{\}}
\DoxyCodeLine{1697 }
\DoxyCodeLine{1698   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1specs__setter}{specs\_setter}}(\textcolor{keyword}{const} \mbox{\hyperlink{classinternal_1_1specs__setter}{specs\_setter}} \&other) : specs\_(other.specs\_) \{\}}
\DoxyCodeLine{1699 }
\DoxyCodeLine{1700   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_align(alignment align) \{ specs\_.align\_ = align; \}}
\DoxyCodeLine{1701   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_fill(Char fill) \{ specs\_.fill\_ = fill; \}}
\DoxyCodeLine{1702   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_plus() \{ specs\_.flags\_ |= SIGN\_FLAG | PLUS\_FLAG; \}}
\DoxyCodeLine{1703   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_minus() \{ specs\_.flags\_ |= MINUS\_FLAG; \}}
\DoxyCodeLine{1704   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_space() \{ specs\_.flags\_ |= SIGN\_FLAG; \}}
\DoxyCodeLine{1705   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_hash() \{ specs\_.flags\_ |= HASH\_FLAG; \}}
\DoxyCodeLine{1706 }
\DoxyCodeLine{1707   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_zero() \{}
\DoxyCodeLine{1708     specs\_.align\_ = ALIGN\_NUMERIC;}
\DoxyCodeLine{1709     specs\_.fill\_ = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{1710   \}}
\DoxyCodeLine{1711 }
\DoxyCodeLine{1712   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_width(\textcolor{keywordtype}{unsigned} width) \{ specs\_.width\_ = width; \}}
\DoxyCodeLine{1713   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_precision(\textcolor{keywordtype}{unsigned} precision) \{}
\DoxyCodeLine{1714     specs\_.precision\_ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(precision);}
\DoxyCodeLine{1715   \}}
\DoxyCodeLine{1716   FMT\_CONSTEXPR \textcolor{keywordtype}{void} end\_precision() \{\}}
\DoxyCodeLine{1717 }
\DoxyCodeLine{1718   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_type(Char type) \{ specs\_.type\_ = type; \}}
\DoxyCodeLine{1719 }
\DoxyCodeLine{1720  \textcolor{keyword}{protected}:}
\DoxyCodeLine{1721   \mbox{\hyperlink{classbasic__format__specs}{basic\_format\_specs<Char>}} \&specs\_;}
\DoxyCodeLine{1722 \};}
\DoxyCodeLine{1723 }
\DoxyCodeLine{1724 \textcolor{comment}{// A format specifier handler that checks if specifiers are consistent with the}}
\DoxyCodeLine{1725 \textcolor{comment}{// argument type.}}
\DoxyCodeLine{1726 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{1727 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1specs__checker}{specs\_checker}} : \textcolor{keyword}{public} Handler \{}
\DoxyCodeLine{1728  \textcolor{keyword}{public}:}
\DoxyCodeLine{1729   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1specs__checker}{specs\_checker}}(\textcolor{keyword}{const} Handler\& handler, internal::type arg\_type)}
\DoxyCodeLine{1730     : Handler(handler), arg\_type\_(arg\_type) \{\}}
\DoxyCodeLine{1731 }
\DoxyCodeLine{1732   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1specs__checker}{specs\_checker}}(\textcolor{keyword}{const} \mbox{\hyperlink{classinternal_1_1specs__checker}{specs\_checker}} \&other)}
\DoxyCodeLine{1733     : Handler(other), arg\_type\_(other.arg\_type\_) \{\}}
\DoxyCodeLine{1734 }
\DoxyCodeLine{1735   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_align(alignment align) \{}
\DoxyCodeLine{1736     \textcolor{keywordflow}{if} (align == ALIGN\_NUMERIC)}
\DoxyCodeLine{1737       require\_numeric\_argument();}
\DoxyCodeLine{1738     Handler::on\_align(align);}
\DoxyCodeLine{1739   \}}
\DoxyCodeLine{1740 }
\DoxyCodeLine{1741   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_plus() \{}
\DoxyCodeLine{1742     check\_sign();}
\DoxyCodeLine{1743     Handler::on\_plus();}
\DoxyCodeLine{1744   \}}
\DoxyCodeLine{1745 }
\DoxyCodeLine{1746   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_minus() \{}
\DoxyCodeLine{1747     check\_sign();}
\DoxyCodeLine{1748     Handler::on\_minus();}
\DoxyCodeLine{1749   \}}
\DoxyCodeLine{1750 }
\DoxyCodeLine{1751   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_space() \{}
\DoxyCodeLine{1752     check\_sign();}
\DoxyCodeLine{1753     Handler::on\_space();}
\DoxyCodeLine{1754   \}}
\DoxyCodeLine{1755 }
\DoxyCodeLine{1756   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_hash() \{}
\DoxyCodeLine{1757     require\_numeric\_argument();}
\DoxyCodeLine{1758     Handler::on\_hash();}
\DoxyCodeLine{1759   \}}
\DoxyCodeLine{1760 }
\DoxyCodeLine{1761   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_zero() \{}
\DoxyCodeLine{1762     require\_numeric\_argument();}
\DoxyCodeLine{1763     Handler::on\_zero();}
\DoxyCodeLine{1764   \}}
\DoxyCodeLine{1765 }
\DoxyCodeLine{1766   FMT\_CONSTEXPR \textcolor{keywordtype}{void} end\_precision() \{}
\DoxyCodeLine{1767     \textcolor{keywordflow}{if} (is\_integral(arg\_type\_) || arg\_type\_ == pointer\_type)}
\DoxyCodeLine{1768       this-\/>on\_error(\textcolor{stringliteral}{"{}precision not allowed for this argument type"{}});}
\DoxyCodeLine{1769   \}}
\DoxyCodeLine{1770 }
\DoxyCodeLine{1771  \textcolor{keyword}{private}:}
\DoxyCodeLine{1772   FMT\_CONSTEXPR \textcolor{keywordtype}{void} require\_numeric\_argument() \{}
\DoxyCodeLine{1773     \textcolor{keywordflow}{if} (!is\_arithmetic(arg\_type\_))}
\DoxyCodeLine{1774       this-\/>on\_error(\textcolor{stringliteral}{"{}format specifier requires numeric argument"{}});}
\DoxyCodeLine{1775   \}}
\DoxyCodeLine{1776 }
\DoxyCodeLine{1777   FMT\_CONSTEXPR \textcolor{keywordtype}{void} check\_sign() \{}
\DoxyCodeLine{1778     require\_numeric\_argument();}
\DoxyCodeLine{1779     \textcolor{keywordflow}{if} (is\_integral(arg\_type\_) \&\& arg\_type\_ != int\_type \&\&}
\DoxyCodeLine{1780         arg\_type\_ != long\_long\_type \&\& arg\_type\_ != internal::char\_type) \{}
\DoxyCodeLine{1781       this-\/>on\_error(\textcolor{stringliteral}{"{}format specifier requires signed argument"{}});}
\DoxyCodeLine{1782     \}}
\DoxyCodeLine{1783   \}}
\DoxyCodeLine{1784 }
\DoxyCodeLine{1785   internal::type arg\_type\_;}
\DoxyCodeLine{1786 \};}
\DoxyCodeLine{1787 }
\DoxyCodeLine{1788 \textcolor{keyword}{template} <\textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{class }Handler, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{1789           \textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{1790 FMT\_CONSTEXPR \textcolor{keywordtype}{void} set\_dynamic\_spec(}
\DoxyCodeLine{1791     T \&\mbox{\hyperlink{classinternal_1_1value}{value}}, \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} arg, ErrorHandler eh) \{}
\DoxyCodeLine{1792   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} big\_value = fmt::visit(Handler<ErrorHandler>(eh), arg);}
\DoxyCodeLine{1793   \textcolor{keywordflow}{if} (big\_value > (std::numeric\_limits<int>::max)())}
\DoxyCodeLine{1794     eh.on\_error(\textcolor{stringliteral}{"{}number is too big"{}});}
\DoxyCodeLine{1795   \mbox{\hyperlink{classinternal_1_1value}{value}} = \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(big\_value);}
\DoxyCodeLine{1796 \}}
\DoxyCodeLine{1797 }
\DoxyCodeLine{1798 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1auto__id}{auto\_id}} \{\};}
\DoxyCodeLine{1799 }
\DoxyCodeLine{1800 \textcolor{comment}{// The standard format specifier handler with checking.}}
\DoxyCodeLine{1801 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{1802 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1specs__handler}{specs\_handler}}: \textcolor{keyword}{public} \mbox{\hyperlink{classinternal_1_1specs__setter}{specs\_setter}}<typename Context::char\_type> \{}
\DoxyCodeLine{1803  \textcolor{keyword}{public}:}
\DoxyCodeLine{1804   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Context::char\_type char\_type;}
\DoxyCodeLine{1805 }
\DoxyCodeLine{1806   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1specs__handler}{specs\_handler}}(}
\DoxyCodeLine{1807       \mbox{\hyperlink{classbasic__format__specs}{basic\_format\_specs<char\_type>}} \&specs, Context \&ctx)}
\DoxyCodeLine{1808     : \mbox{\hyperlink{classinternal_1_1specs__setter}{specs\_setter<char\_type>}}(specs), context\_(ctx) \{\}}
\DoxyCodeLine{1809 }
\DoxyCodeLine{1810   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Id>}
\DoxyCodeLine{1811   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dynamic\_width(Id arg\_id) \{}
\DoxyCodeLine{1812     set\_dynamic\_spec<width\_checker>(}
\DoxyCodeLine{1813           this-\/>specs\_.width\_, get\_arg(arg\_id), context\_.error\_handler());}
\DoxyCodeLine{1814   \}}
\DoxyCodeLine{1815 }
\DoxyCodeLine{1816   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Id>}
\DoxyCodeLine{1817   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dynamic\_precision(Id arg\_id) \{}
\DoxyCodeLine{1818     set\_dynamic\_spec<precision\_checker>(}
\DoxyCodeLine{1819           this-\/>specs\_.precision\_, get\_arg(arg\_id), context\_.error\_handler());}
\DoxyCodeLine{1820   \}}
\DoxyCodeLine{1821 }
\DoxyCodeLine{1822   \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *message) \{}
\DoxyCodeLine{1823     context\_.on\_error(message);}
\DoxyCodeLine{1824   \}}
\DoxyCodeLine{1825 }
\DoxyCodeLine{1826  \textcolor{keyword}{private}:}
\DoxyCodeLine{1827   FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} get\_arg(\mbox{\hyperlink{structinternal_1_1auto__id}{auto\_id}}) \{}
\DoxyCodeLine{1828     \textcolor{keywordflow}{return} context\_.next\_arg();}
\DoxyCodeLine{1829   \}}
\DoxyCodeLine{1830 }
\DoxyCodeLine{1831   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Id>}
\DoxyCodeLine{1832   FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} get\_arg(Id arg\_id) \{}
\DoxyCodeLine{1833     context\_.parse\_context().check\_arg\_id(arg\_id);}
\DoxyCodeLine{1834     \textcolor{keywordflow}{return} context\_.get\_arg(arg\_id);}
\DoxyCodeLine{1835   \}}
\DoxyCodeLine{1836 }
\DoxyCodeLine{1837   Context \&context\_;}
\DoxyCodeLine{1838 \};}
\DoxyCodeLine{1839 }
\DoxyCodeLine{1840 \textcolor{comment}{// An argument reference.}}
\DoxyCodeLine{1841 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1842 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref}} \{}
\DoxyCodeLine{1843   \textcolor{keyword}{enum} Kind \{ NONE, INDEX, NAME \};}
\DoxyCodeLine{1844 }
\DoxyCodeLine{1845   FMT\_CONSTEXPR \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref}}() : kind(NONE), index(0) \{\}}
\DoxyCodeLine{1846   FMT\_CONSTEXPR \textcolor{keyword}{explicit} \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref}}(\textcolor{keywordtype}{unsigned} index) : kind(INDEX), index(index) \{\}}
\DoxyCodeLine{1847   \textcolor{keyword}{explicit} \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name) : kind(NAME), name(name) \{\}}
\DoxyCodeLine{1848 }
\DoxyCodeLine{1849   FMT\_CONSTEXPR \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref}} \&operator=(\textcolor{keywordtype}{unsigned} idx) \{}
\DoxyCodeLine{1850     kind = INDEX;}
\DoxyCodeLine{1851     index = idx;}
\DoxyCodeLine{1852     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{1853   \}}
\DoxyCodeLine{1854 }
\DoxyCodeLine{1855   Kind kind;}
\DoxyCodeLine{1856   FMT\_UNION \{}
\DoxyCodeLine{1857     \textcolor{keywordtype}{unsigned} index;}
\DoxyCodeLine{1858     \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name;}
\DoxyCodeLine{1859   \};}
\DoxyCodeLine{1860 \};}
\DoxyCodeLine{1861 }
\DoxyCodeLine{1862 \textcolor{comment}{// Format specifiers with width and precision resolved at formatting rather}}
\DoxyCodeLine{1863 \textcolor{comment}{// than parsing time to allow re-\/using the same parsed specifiers with}}
\DoxyCodeLine{1864 \textcolor{comment}{// differents sets of arguments (precompilation of format strings).}}
\DoxyCodeLine{1865 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1866 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1dynamic__format__specs}{dynamic\_format\_specs}} : \mbox{\hyperlink{classbasic__format__specs}{basic\_format\_specs}}<Char> \{}
\DoxyCodeLine{1867   \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref<Char>}} width\_ref;}
\DoxyCodeLine{1868   \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref<Char>}} precision\_ref;}
\DoxyCodeLine{1869 \};}
\DoxyCodeLine{1870 }
\DoxyCodeLine{1871 \textcolor{comment}{// Format spec handler that saves references to arguments representing dynamic}}
\DoxyCodeLine{1872 \textcolor{comment}{// width and precision to be resolved at formatting time.}}
\DoxyCodeLine{1873 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{1874 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1dynamic__specs__handler}{dynamic\_specs\_handler}} :}
\DoxyCodeLine{1875     \textcolor{keyword}{public} \mbox{\hyperlink{classinternal_1_1specs__setter}{specs\_setter}}<typename ParseContext::char\_type> \{}
\DoxyCodeLine{1876  \textcolor{keyword}{public}:}
\DoxyCodeLine{1877   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ParseContext::char\_type char\_type;}
\DoxyCodeLine{1878 }
\DoxyCodeLine{1879   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1dynamic__specs__handler}{dynamic\_specs\_handler}}(}
\DoxyCodeLine{1880       \mbox{\hyperlink{structinternal_1_1dynamic__format__specs}{dynamic\_format\_specs<char\_type>}} \&specs, ParseContext \&ctx)}
\DoxyCodeLine{1881     : \mbox{\hyperlink{classinternal_1_1specs__setter}{specs\_setter<char\_type>}}(specs), specs\_(specs), context\_(ctx) \{\}}
\DoxyCodeLine{1882 }
\DoxyCodeLine{1883   FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1dynamic__specs__handler}{dynamic\_specs\_handler}}(\textcolor{keyword}{const} \mbox{\hyperlink{classinternal_1_1dynamic__specs__handler}{dynamic\_specs\_handler}} \&other)}
\DoxyCodeLine{1884     : \mbox{\hyperlink{classinternal_1_1specs__setter}{specs\_setter<char\_type>}}(other),}
\DoxyCodeLine{1885       specs\_(other.specs\_), context\_(other.context\_) \{\}}
\DoxyCodeLine{1886 }
\DoxyCodeLine{1887   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Id>}
\DoxyCodeLine{1888   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dynamic\_width(Id arg\_id) \{}
\DoxyCodeLine{1889     specs\_.width\_ref = make\_arg\_ref(arg\_id);}
\DoxyCodeLine{1890   \}}
\DoxyCodeLine{1891 }
\DoxyCodeLine{1892   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Id>}
\DoxyCodeLine{1893   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_dynamic\_precision(Id arg\_id) \{}
\DoxyCodeLine{1894     specs\_.precision\_ref = make\_arg\_ref(arg\_id);}
\DoxyCodeLine{1895   \}}
\DoxyCodeLine{1896 }
\DoxyCodeLine{1897   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *message) \{}
\DoxyCodeLine{1898     context\_.on\_error(message);}
\DoxyCodeLine{1899   \}}
\DoxyCodeLine{1900 }
\DoxyCodeLine{1901  \textcolor{keyword}{private}:}
\DoxyCodeLine{1902   \textcolor{keyword}{typedef} \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref<char\_type>}} \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref\_type}};}
\DoxyCodeLine{1903 }
\DoxyCodeLine{1904   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Id>}
\DoxyCodeLine{1905   FMT\_CONSTEXPR \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref\_type}} make\_arg\_ref(Id arg\_id) \{}
\DoxyCodeLine{1906     context\_.check\_arg\_id(arg\_id);}
\DoxyCodeLine{1907     \textcolor{keywordflow}{return} \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref\_type}}(arg\_id);}
\DoxyCodeLine{1908   \}}
\DoxyCodeLine{1909 }
\DoxyCodeLine{1910   FMT\_CONSTEXPR \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref\_type}} make\_arg\_ref(\mbox{\hyperlink{structinternal_1_1auto__id}{auto\_id}}) \{}
\DoxyCodeLine{1911     \textcolor{keywordflow}{return} \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref\_type}}(context\_.next\_arg\_id());}
\DoxyCodeLine{1912   \}}
\DoxyCodeLine{1913 }
\DoxyCodeLine{1914   \mbox{\hyperlink{structinternal_1_1dynamic__format__specs}{dynamic\_format\_specs<char\_type>}} \&specs\_;}
\DoxyCodeLine{1915   ParseContext \&context\_;}
\DoxyCodeLine{1916 \};}
\DoxyCodeLine{1917 }
\DoxyCodeLine{1918 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator, \textcolor{keyword}{typename} IDHandler>}
\DoxyCodeLine{1919 FMT\_CONSTEXPR Iterator parse\_arg\_id(Iterator it, IDHandler \&\&handler) \{}
\DoxyCodeLine{1920   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::iterator\_traits<Iterator>::value\_type char\_type;}
\DoxyCodeLine{1921   char\_type c = *it;}
\DoxyCodeLine{1922   \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\}'} || c == \textcolor{charliteral}{':'}) \{}
\DoxyCodeLine{1923     handler();}
\DoxyCodeLine{1924     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{1925   \}}
\DoxyCodeLine{1926   \textcolor{keywordflow}{if} (c >= \textcolor{charliteral}{'0'} \&\& c <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{1927     \textcolor{keywordtype}{unsigned} index = parse\_nonnegative\_int(it, handler);}
\DoxyCodeLine{1928     \textcolor{keywordflow}{if} (*it != \textcolor{charliteral}{'\}'} \&\& *it != \textcolor{charliteral}{':'}) \{}
\DoxyCodeLine{1929       handler.on\_error(\textcolor{stringliteral}{"{}invalid format string"{}});}
\DoxyCodeLine{1930       \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{1931     \}}
\DoxyCodeLine{1932     handler(index);}
\DoxyCodeLine{1933     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{1934   \}}
\DoxyCodeLine{1935   \textcolor{keywordflow}{if} (!is\_name\_start(c)) \{}
\DoxyCodeLine{1936     handler.on\_error(\textcolor{stringliteral}{"{}invalid format string"{}});}
\DoxyCodeLine{1937     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{1938   \}}
\DoxyCodeLine{1939   \textcolor{keyword}{auto} start = it;}
\DoxyCodeLine{1940   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{1941     c = *++it;}
\DoxyCodeLine{1942   \} \textcolor{keywordflow}{while} (is\_name\_start(c) || (\textcolor{charliteral}{'0'} <= c \&\& c <= \textcolor{charliteral}{'9'}));}
\DoxyCodeLine{1943   handler(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}}(}
\DoxyCodeLine{1944             pointer\_from(start), to\_unsigned(it -\/ start)));}
\DoxyCodeLine{1945   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{1946 \}}
\DoxyCodeLine{1947 }
\DoxyCodeLine{1948 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} IDHandler>}
\DoxyCodeLine{1949 FMT\_CONSTEXPR \textcolor{keyword}{const} Char *parse\_arg\_id(}
\DoxyCodeLine{1950     \textcolor{keyword}{const} Char *begin, \textcolor{keyword}{const} Char *end, IDHandler \&\&handler) \{}
\DoxyCodeLine{1951   assert(begin != end);}
\DoxyCodeLine{1952   Char c = *begin;}
\DoxyCodeLine{1953   \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\}'} || c == \textcolor{charliteral}{':'})}
\DoxyCodeLine{1954     \textcolor{keywordflow}{return} handler(), begin;}
\DoxyCodeLine{1955   \textcolor{keywordflow}{if} (c >= \textcolor{charliteral}{'0'} \&\& c <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{1956     \textcolor{keywordtype}{unsigned} index = parse\_nonnegative\_int(begin, end, handler);}
\DoxyCodeLine{1957     \textcolor{keywordflow}{if} (begin == end || (*begin != \textcolor{charliteral}{'\}'} \&\& *begin != \textcolor{charliteral}{':'}))}
\DoxyCodeLine{1958       \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}invalid format string"{}}), begin;}
\DoxyCodeLine{1959     handler(index);}
\DoxyCodeLine{1960     \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{1961   \}}
\DoxyCodeLine{1962   \textcolor{keywordflow}{if} (!is\_name\_start(c))}
\DoxyCodeLine{1963     \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}invalid format string"{}}), begin;}
\DoxyCodeLine{1964   \textcolor{keyword}{auto} it = begin;}
\DoxyCodeLine{1965   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{1966     c = *++it;}
\DoxyCodeLine{1967   \} \textcolor{keywordflow}{while} (it != end \&\& (is\_name\_start(c) || (\textcolor{charliteral}{'0'} <= c \&\& c <= \textcolor{charliteral}{'9'})));}
\DoxyCodeLine{1968   handler(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(begin, to\_unsigned(it -\/ begin)));}
\DoxyCodeLine{1969   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{1970 \}}
\DoxyCodeLine{1971 }
\DoxyCodeLine{1972 \textcolor{comment}{// Adapts SpecHandler to IDHandler API for dynamic width.}}
\DoxyCodeLine{1973 \textcolor{keyword}{template} <\textcolor{keyword}{typename} SpecHandler, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1974 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1width__adapter}{width\_adapter}} \{}
\DoxyCodeLine{1975   \textcolor{keyword}{explicit} FMT\_CONSTEXPR \mbox{\hyperlink{structinternal_1_1width__adapter}{width\_adapter}}(SpecHandler \&h) : handler(h) \{\}}
\DoxyCodeLine{1976 }
\DoxyCodeLine{1977   FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()() \{ handler.on\_dynamic\_width(\mbox{\hyperlink{structinternal_1_1auto__id}{auto\_id}}()); \}}
\DoxyCodeLine{1978   FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{id}) \{ handler.on\_dynamic\_width(\textcolor{keywordtype}{id}); \}}
\DoxyCodeLine{1979   FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{1980     handler.on\_dynamic\_width(\textcolor{keywordtype}{id});}
\DoxyCodeLine{1981   \}}
\DoxyCodeLine{1982 }
\DoxyCodeLine{1983   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *message) \{}
\DoxyCodeLine{1984     handler.on\_error(message);}
\DoxyCodeLine{1985   \}}
\DoxyCodeLine{1986 }
\DoxyCodeLine{1987   SpecHandler \&handler;}
\DoxyCodeLine{1988 \};}
\DoxyCodeLine{1989 }
\DoxyCodeLine{1990 \textcolor{comment}{// Adapts SpecHandler to IDHandler API for dynamic precision.}}
\DoxyCodeLine{1991 \textcolor{keyword}{template} <\textcolor{keyword}{typename} SpecHandler, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1992 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1precision__adapter}{precision\_adapter}} \{}
\DoxyCodeLine{1993   \textcolor{keyword}{explicit} FMT\_CONSTEXPR \mbox{\hyperlink{structinternal_1_1precision__adapter}{precision\_adapter}}(SpecHandler \&h) : handler(h) \{\}}
\DoxyCodeLine{1994 }
\DoxyCodeLine{1995   FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()() \{ handler.on\_dynamic\_precision(\mbox{\hyperlink{structinternal_1_1auto__id}{auto\_id}}()); \}}
\DoxyCodeLine{1996   FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{1997     handler.on\_dynamic\_precision(\textcolor{keywordtype}{id});}
\DoxyCodeLine{1998   \}}
\DoxyCodeLine{1999   FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{2000     handler.on\_dynamic\_precision(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2001   \}}
\DoxyCodeLine{2002 }
\DoxyCodeLine{2003   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *message) \{ handler.on\_error(message); \}}
\DoxyCodeLine{2004 }
\DoxyCodeLine{2005   SpecHandler \&handler;}
\DoxyCodeLine{2006 \};}
\DoxyCodeLine{2007 }
\DoxyCodeLine{2008 \textcolor{comment}{// Parses standard format specifiers and sends notifications about parsed}}
\DoxyCodeLine{2009 \textcolor{comment}{// components to handler.}}
\DoxyCodeLine{2010 \textcolor{comment}{// it: an iterator pointing to the beginning of a null-\/terminated range of}}
\DoxyCodeLine{2011 \textcolor{comment}{//     characters, possibly emulated via null\_terminating\_iterator, representing}}
\DoxyCodeLine{2012 \textcolor{comment}{//     format specifiers.}}
\DoxyCodeLine{2013 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator, \textcolor{keyword}{typename} SpecHandler>}
\DoxyCodeLine{2014 FMT\_CONSTEXPR Iterator parse\_format\_specs(Iterator it, SpecHandler \&\&handler) \{}
\DoxyCodeLine{2015   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::iterator\_traits<Iterator>::value\_type char\_type;}
\DoxyCodeLine{2016   char\_type c = *it;}
\DoxyCodeLine{2017   \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\}'} || !c)}
\DoxyCodeLine{2018     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2019 }
\DoxyCodeLine{2020   \textcolor{comment}{// Parse fill and alignment.}}
\DoxyCodeLine{2021   alignment align = ALIGN\_DEFAULT;}
\DoxyCodeLine{2022   \textcolor{keywordtype}{int} i = 1;}
\DoxyCodeLine{2023   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{2024     \textcolor{keyword}{auto} p = it + i;}
\DoxyCodeLine{2025     \textcolor{keywordflow}{switch} (*p) \{}
\DoxyCodeLine{2026       \textcolor{keywordflow}{case} \textcolor{charliteral}{'<'}:}
\DoxyCodeLine{2027         align = ALIGN\_LEFT;}
\DoxyCodeLine{2028         \textcolor{keywordflow}{break};}
\DoxyCodeLine{2029       \textcolor{keywordflow}{case} \textcolor{charliteral}{'>'}:}
\DoxyCodeLine{2030         align = ALIGN\_RIGHT;}
\DoxyCodeLine{2031         \textcolor{keywordflow}{break};}
\DoxyCodeLine{2032       \textcolor{keywordflow}{case} \textcolor{charliteral}{'='}:}
\DoxyCodeLine{2033         align = ALIGN\_NUMERIC;}
\DoxyCodeLine{2034         \textcolor{keywordflow}{break};}
\DoxyCodeLine{2035       \textcolor{keywordflow}{case} \textcolor{charliteral}{'\string^'}:}
\DoxyCodeLine{2036         align = ALIGN\_CENTER;}
\DoxyCodeLine{2037         \textcolor{keywordflow}{break};}
\DoxyCodeLine{2038     \}}
\DoxyCodeLine{2039     \textcolor{keywordflow}{if} (align != ALIGN\_DEFAULT) \{}
\DoxyCodeLine{2040       \textcolor{keywordflow}{if} (p != it) \{}
\DoxyCodeLine{2041         \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{2042           handler.on\_error(\textcolor{stringliteral}{"{}invalid fill character '\{'"{}});}
\DoxyCodeLine{2043           \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2044         \}}
\DoxyCodeLine{2045         it += 2;}
\DoxyCodeLine{2046         handler.on\_fill(c);}
\DoxyCodeLine{2047       \} \textcolor{keywordflow}{else} ++it;}
\DoxyCodeLine{2048       handler.on\_align(align);}
\DoxyCodeLine{2049       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2050     \}}
\DoxyCodeLine{2051   \} \textcolor{keywordflow}{while} (-\/-\/i >= 0);}
\DoxyCodeLine{2052 }
\DoxyCodeLine{2053   \textcolor{comment}{// Parse sign.}}
\DoxyCodeLine{2054   \textcolor{keywordflow}{switch} (*it) \{}
\DoxyCodeLine{2055     \textcolor{keywordflow}{case} \textcolor{charliteral}{'+'}:}
\DoxyCodeLine{2056       handler.on\_plus();}
\DoxyCodeLine{2057       ++it;}
\DoxyCodeLine{2058       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2059     \textcolor{keywordflow}{case} \textcolor{charliteral}{'-\/'}:}
\DoxyCodeLine{2060       handler.on\_minus();}
\DoxyCodeLine{2061       ++it;}
\DoxyCodeLine{2062       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2063     \textcolor{keywordflow}{case} \textcolor{charliteral}{' '}:}
\DoxyCodeLine{2064       handler.on\_space();}
\DoxyCodeLine{2065       ++it;}
\DoxyCodeLine{2066       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2067   \}}
\DoxyCodeLine{2068 }
\DoxyCodeLine{2069   \textcolor{keywordflow}{if} (*it == \textcolor{charliteral}{'\#'}) \{}
\DoxyCodeLine{2070     handler.on\_hash();}
\DoxyCodeLine{2071     ++it;}
\DoxyCodeLine{2072   \}}
\DoxyCodeLine{2073 }
\DoxyCodeLine{2074   \textcolor{comment}{// Parse zero flag.}}
\DoxyCodeLine{2075   \textcolor{keywordflow}{if} (*it == \textcolor{charliteral}{'0'}) \{}
\DoxyCodeLine{2076     handler.on\_zero();}
\DoxyCodeLine{2077     ++it;}
\DoxyCodeLine{2078   \}}
\DoxyCodeLine{2079 }
\DoxyCodeLine{2080   \textcolor{comment}{// Parse width.}}
\DoxyCodeLine{2081   \textcolor{keywordflow}{if} (\textcolor{charliteral}{'0'} <= *it \&\& *it <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{2082     handler.on\_width(parse\_nonnegative\_int(it, handler));}
\DoxyCodeLine{2083   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*it == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{2084     it = parse\_arg\_id(it + 1, width\_adapter<SpecHandler, char\_type>(handler));}
\DoxyCodeLine{2085     \textcolor{keywordflow}{if} (*it++ != \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{2086       handler.on\_error(\textcolor{stringliteral}{"{}invalid format string"{}});}
\DoxyCodeLine{2087       \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2088     \}}
\DoxyCodeLine{2089   \}}
\DoxyCodeLine{2090 }
\DoxyCodeLine{2091   \textcolor{comment}{// Parse precision.}}
\DoxyCodeLine{2092   \textcolor{keywordflow}{if} (*it == \textcolor{charliteral}{'.'}) \{}
\DoxyCodeLine{2093     ++it;}
\DoxyCodeLine{2094     \textcolor{keywordflow}{if} (\textcolor{charliteral}{'0'} <= *it \&\& *it <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{2095       handler.on\_precision(parse\_nonnegative\_int(it, handler));}
\DoxyCodeLine{2096     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*it == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{2097       it = parse\_arg\_id(}
\DoxyCodeLine{2098             it + 1, precision\_adapter<SpecHandler, char\_type>(handler));}
\DoxyCodeLine{2099       \textcolor{keywordflow}{if} (*it++ != \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{2100         handler.on\_error(\textcolor{stringliteral}{"{}invalid format string"{}});}
\DoxyCodeLine{2101         \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2102       \}}
\DoxyCodeLine{2103     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2104       handler.on\_error(\textcolor{stringliteral}{"{}missing precision specifier"{}});}
\DoxyCodeLine{2105       \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2106     \}}
\DoxyCodeLine{2107     handler.end\_precision();}
\DoxyCodeLine{2108   \}}
\DoxyCodeLine{2109 }
\DoxyCodeLine{2110   \textcolor{comment}{// Parse type.}}
\DoxyCodeLine{2111   \textcolor{keywordflow}{if} (*it != \textcolor{charliteral}{'\}'} \&\& *it)}
\DoxyCodeLine{2112     handler.on\_type(*it++);}
\DoxyCodeLine{2113   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2114 \}}
\DoxyCodeLine{2115 }
\DoxyCodeLine{2116 \textcolor{comment}{// Return the result via the out param to workaround gcc bug 77539.}}
\DoxyCodeLine{2117 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} IS\_CONSTEXPR, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Ptr = const T*>}
\DoxyCodeLine{2118 FMT\_CONSTEXPR \textcolor{keywordtype}{bool} find(Ptr first, Ptr last, T value, Ptr \&out) \{}
\DoxyCodeLine{2119   \textcolor{keywordflow}{for} (out = first; out != last; ++out) \{}
\DoxyCodeLine{2120     \textcolor{keywordflow}{if} (*out == value)}
\DoxyCodeLine{2121       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2122   \}}
\DoxyCodeLine{2123   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2124 \}}
\DoxyCodeLine{2125 }
\DoxyCodeLine{2126 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2127 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} find<false, char>(}
\DoxyCodeLine{2128     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *first, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *last, \textcolor{keywordtype}{char} value, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\&out) \{}
\DoxyCodeLine{2129   out = \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(std::memchr(first, value, last -\/ first));}
\DoxyCodeLine{2130   \textcolor{keywordflow}{return} out != FMT\_NULL;}
\DoxyCodeLine{2131 \}}
\DoxyCodeLine{2132 }
\DoxyCodeLine{2133 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Handler, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2134 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1id__adapter}{id\_adapter}} \{}
\DoxyCodeLine{2135   FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()() \{ handler.on\_arg\_id(); \}}
\DoxyCodeLine{2136   FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{id}) \{ handler.on\_arg\_id(\textcolor{keywordtype}{id}); \}}
\DoxyCodeLine{2137   FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{2138     handler.on\_arg\_id(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2139   \}}
\DoxyCodeLine{2140   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *message) \{}
\DoxyCodeLine{2141     handler.on\_error(message);}
\DoxyCodeLine{2142   \}}
\DoxyCodeLine{2143   Handler \&handler;}
\DoxyCodeLine{2144 \};}
\DoxyCodeLine{2145 }
\DoxyCodeLine{2146 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} IS\_CONSTEXPR, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{2147 FMT\_CONSTEXPR \textcolor{keywordtype}{void} parse\_format\_string(}
\DoxyCodeLine{2148         \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str, Handler \&\&handler) \{}
\DoxyCodeLine{2149   \textcolor{keyword}{struct }\mbox{\hyperlink{classbasic__writer}{writer}} \{}
\DoxyCodeLine{2150     FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} Char *begin, \textcolor{keyword}{const} Char *end) \{}
\DoxyCodeLine{2151       \textcolor{keywordflow}{if} (begin == end) \textcolor{keywordflow}{return};}
\DoxyCodeLine{2152       \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{2153         \textcolor{keyword}{const} Char *p = FMT\_NULL;}
\DoxyCodeLine{2154         \textcolor{keywordflow}{if} (!find<IS\_CONSTEXPR>(begin, end, \textcolor{charliteral}{'\}'}, p))}
\DoxyCodeLine{2155           \textcolor{keywordflow}{return} handler\_.on\_text(begin, end);}
\DoxyCodeLine{2156         ++p;}
\DoxyCodeLine{2157         \textcolor{keywordflow}{if} (p == end || *p != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{2158           \textcolor{keywordflow}{return} handler\_.on\_error(\textcolor{stringliteral}{"{}unmatched '\}' in format string"{}});}
\DoxyCodeLine{2159         handler\_.on\_text(begin, p);}
\DoxyCodeLine{2160         begin = p + 1;}
\DoxyCodeLine{2161       \}}
\DoxyCodeLine{2162     \}}
\DoxyCodeLine{2163     Handler \&handler\_;}
\DoxyCodeLine{2164   \} write\{handler\};}
\DoxyCodeLine{2165   \textcolor{keyword}{auto} begin = format\_str.\mbox{\hyperlink{classbasic__string__view_ae88f246f09d5ee5610e979d074ea74e1}{data}}(), end = begin + format\_str.\mbox{\hyperlink{classbasic__string__view_a7fd9f4dcac1782259b0cd217af69d737}{size}}();}
\DoxyCodeLine{2166   \textcolor{keywordflow}{while} (begin != end) \{}
\DoxyCodeLine{2167     \textcolor{comment}{// Doing two passes with memchr (one for '\{' and another for '\}') is up to}}
\DoxyCodeLine{2168     \textcolor{comment}{// 2.5x faster than the naive one-\/pass implementation on big format strings.}}
\DoxyCodeLine{2169     \textcolor{keyword}{const} Char *p = begin;}
\DoxyCodeLine{2170     \textcolor{keywordflow}{if} (*begin != \textcolor{charliteral}{'\{'} \&\& !find<IS\_CONSTEXPR>(begin, end, \textcolor{charliteral}{'\{'}, p))}
\DoxyCodeLine{2171       \textcolor{keywordflow}{return} write(begin, end);}
\DoxyCodeLine{2172     write(begin, p);}
\DoxyCodeLine{2173     ++p;}
\DoxyCodeLine{2174     \textcolor{keywordflow}{if} (p == end)}
\DoxyCodeLine{2175       \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}invalid format string"{}});}
\DoxyCodeLine{2176     \textcolor{keywordflow}{if} (*p == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{2177       handler.on\_arg\_id();}
\DoxyCodeLine{2178       handler.on\_replacement\_field(p);}
\DoxyCodeLine{2179     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*p == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{2180       handler.on\_text(p, p + 1);}
\DoxyCodeLine{2181     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2182       p = parse\_arg\_id(p, end, id\_adapter<Handler, Char>\{handler\});}
\DoxyCodeLine{2183       Char c = p != end ? *p : 0;}
\DoxyCodeLine{2184       \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{2185         handler.on\_replacement\_field(p);}
\DoxyCodeLine{2186       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{':'}) \{}
\DoxyCodeLine{2187         \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{internal::null\_terminating\_iterator<Char>}} it(p + 1, end);}
\DoxyCodeLine{2188         it = handler.on\_format\_specs(it);}
\DoxyCodeLine{2189         \textcolor{keywordflow}{if} (*it != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{2190           \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}unknown format specifier"{}});}
\DoxyCodeLine{2191         p = pointer\_from(it);}
\DoxyCodeLine{2192       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2193         \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}missing '\}' in format string"{}});}
\DoxyCodeLine{2194       \}}
\DoxyCodeLine{2195     \}}
\DoxyCodeLine{2196     begin = p + 1;}
\DoxyCodeLine{2197   \}}
\DoxyCodeLine{2198 \}}
\DoxyCodeLine{2199 }
\DoxyCodeLine{2200 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{2201 FMT\_CONSTEXPR \textcolor{keyword}{const} \textcolor{keyword}{typename} ParseContext::char\_type *}
\DoxyCodeLine{2202     parse\_format\_specs(ParseContext \&ctx) \{}
\DoxyCodeLine{2203   \textcolor{comment}{// GCC 7.2 requires initializer.}}
\DoxyCodeLine{2204   \mbox{\hyperlink{structformatter}{formatter<T, typename ParseContext::char\_type>}} f\{\};}
\DoxyCodeLine{2205   \textcolor{keywordflow}{return} f.parse(ctx);}
\DoxyCodeLine{2206 \}}
\DoxyCodeLine{2207 }
\DoxyCodeLine{2208 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} ErrorHandler, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{2209 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1format__string__checker}{format\_string\_checker}} \{}
\DoxyCodeLine{2210  \textcolor{keyword}{public}:}
\DoxyCodeLine{2211   \textcolor{keyword}{explicit} FMT\_CONSTEXPR \mbox{\hyperlink{classinternal_1_1format__string__checker}{format\_string\_checker}}(}
\DoxyCodeLine{2212       \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str, ErrorHandler eh)}
\DoxyCodeLine{2213     : arg\_id\_(-\/1), context\_(format\_str, eh),}
\DoxyCodeLine{2214       parse\_funcs\_\{\&parse\_format\_specs<Args, parse\_context\_type>...\} \{\}}
\DoxyCodeLine{2215 }
\DoxyCodeLine{2216   \textcolor{keyword}{typedef} \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{internal::null\_terminating\_iterator<Char>}} \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{iterator}};}
\DoxyCodeLine{2217 }
\DoxyCodeLine{2218   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_text(\textcolor{keyword}{const} Char *, \textcolor{keyword}{const} Char *) \{\}}
\DoxyCodeLine{2219 }
\DoxyCodeLine{2220   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_arg\_id() \{}
\DoxyCodeLine{2221     arg\_id\_ = context\_.next\_arg\_id();}
\DoxyCodeLine{2222     check\_arg\_id();}
\DoxyCodeLine{2223   \}}
\DoxyCodeLine{2224   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_arg\_id(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{2225     arg\_id\_ = id;}
\DoxyCodeLine{2226     context\_.check\_arg\_id(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2227     check\_arg\_id();}
\DoxyCodeLine{2228   \}}
\DoxyCodeLine{2229   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_arg\_id(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}) \{\}}
\DoxyCodeLine{2230 }
\DoxyCodeLine{2231   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_replacement\_field(\textcolor{keyword}{const} Char *) \{\}}
\DoxyCodeLine{2232 }
\DoxyCodeLine{2233   FMT\_CONSTEXPR \textcolor{keyword}{const} Char *on\_format\_specs(\mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{iterator}} it) \{}
\DoxyCodeLine{2234     \textcolor{keyword}{auto} p = pointer\_from(it);}
\DoxyCodeLine{2235     context\_.advance\_to(p);}
\DoxyCodeLine{2236     \textcolor{keywordflow}{return} to\_unsigned(arg\_id\_) < NUM\_ARGS ?}
\DoxyCodeLine{2237           parse\_funcs\_[arg\_id\_](context\_) : p;}
\DoxyCodeLine{2238   \}}
\DoxyCodeLine{2239 }
\DoxyCodeLine{2240   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *message) \{}
\DoxyCodeLine{2241     context\_.on\_error(message);}
\DoxyCodeLine{2242   \}}
\DoxyCodeLine{2243 }
\DoxyCodeLine{2244  \textcolor{keyword}{private}:}
\DoxyCodeLine{2245   \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__parse__context}{basic\_parse\_context<Char, ErrorHandler>}} \mbox{\hyperlink{classbasic__parse__context}{parse\_context\_type}};}
\DoxyCodeLine{2246   \textcolor{keyword}{enum} \{ NUM\_ARGS = \textcolor{keyword}{sizeof}...(Args) \};}
\DoxyCodeLine{2247 }
\DoxyCodeLine{2248   FMT\_CONSTEXPR \textcolor{keywordtype}{void} check\_arg\_id() \{}
\DoxyCodeLine{2249     \textcolor{keywordflow}{if} (internal::to\_unsigned(arg\_id\_) >= NUM\_ARGS)}
\DoxyCodeLine{2250       context\_.on\_error(\textcolor{stringliteral}{"{}argument index out of range"{}});}
\DoxyCodeLine{2251   \}}
\DoxyCodeLine{2252 }
\DoxyCodeLine{2253   \textcolor{comment}{// Format specifier parsing function.}}
\DoxyCodeLine{2254   \textcolor{keyword}{typedef} \textcolor{keyword}{const} Char *(*parse\_func)(\mbox{\hyperlink{classbasic__parse__context}{parse\_context\_type}} \&);}
\DoxyCodeLine{2255 }
\DoxyCodeLine{2256   \textcolor{keywordtype}{int} arg\_id\_;}
\DoxyCodeLine{2257   \mbox{\hyperlink{classbasic__parse__context}{parse\_context\_type}} context\_;}
\DoxyCodeLine{2258   parse\_func parse\_funcs\_[NUM\_ARGS > 0 ? NUM\_ARGS : 1];}
\DoxyCodeLine{2259 \};}
\DoxyCodeLine{2260 }
\DoxyCodeLine{2261 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} ErrorHandler, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{2262 FMT\_CONSTEXPR \textcolor{keywordtype}{bool} check\_format\_string(}
\DoxyCodeLine{2263     \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s, ErrorHandler eh = ErrorHandler()) \{}
\DoxyCodeLine{2264   \mbox{\hyperlink{classinternal_1_1format__string__checker}{format\_string\_checker}}<Char, ErrorHandler, Args...> checker(s, eh);}
\DoxyCodeLine{2265   parse\_format\_string<true>(s, checker);}
\DoxyCodeLine{2266   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2267 \}}
\DoxyCodeLine{2268 }
\DoxyCodeLine{2269 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args, \textcolor{keyword}{typename} String>}
\DoxyCodeLine{2270 \textcolor{keyword}{typename} std::enable\_if<is\_compile\_string<String>::value>::type}
\DoxyCodeLine{2271     check\_format\_string(String format\_str) \{}
\DoxyCodeLine{2272   FMT\_CONSTEXPR\_DECL \textcolor{keywordtype}{bool} invalid\_format =}
\DoxyCodeLine{2273       internal::check\_format\_string<char, \mbox{\hyperlink{structinternal_1_1error__handler}{internal::error\_handler}}, Args...>(}
\DoxyCodeLine{2274         \mbox{\hyperlink{classbasic__string__view}{string\_view}}(format\_str.data(), format\_str.size()));}
\DoxyCodeLine{2275   (void)invalid\_format;}
\DoxyCodeLine{2276 \}}
\DoxyCodeLine{2277 }
\DoxyCodeLine{2278 \textcolor{comment}{// Specifies whether to format T using the standard formatter.}}
\DoxyCodeLine{2279 \textcolor{comment}{// It is not possible to use get\_type in formatter specialization directly}}
\DoxyCodeLine{2280 \textcolor{comment}{// because of a bug in MSVC.}}
\DoxyCodeLine{2281 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{2282 \textcolor{keyword}{struct }\mbox{\hyperlink{structinternal_1_1format__type}{format\_type}} :}
\DoxyCodeLine{2283   std::integral\_constant<bool, get\_type<Context, T>::value != custom\_type> \{\};}
\DoxyCodeLine{2284 }
\DoxyCodeLine{2285 \textcolor{keyword}{template} <\textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{class }Handler, \textcolor{keyword}{typename} Spec, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{2286 \textcolor{keywordtype}{void} handle\_dynamic\_spec(}
\DoxyCodeLine{2287     Spec \&\mbox{\hyperlink{classinternal_1_1value}{value}}, \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref<typename Context::char\_type>}} ref, Context \&ctx) \{}
\DoxyCodeLine{2288   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Context::char\_type char\_type;}
\DoxyCodeLine{2289   \textcolor{keywordflow}{switch} (ref.kind) \{}
\DoxyCodeLine{2290   \textcolor{keywordflow}{case} \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref<char\_type>::NONE}}:}
\DoxyCodeLine{2291     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2292   \textcolor{keywordflow}{case} \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref<char\_type>::INDEX}}:}
\DoxyCodeLine{2293     internal::set\_dynamic\_spec<Handler>(}
\DoxyCodeLine{2294           \mbox{\hyperlink{classinternal_1_1value}{value}}, ctx.get\_arg(ref.index), ctx.error\_handler());}
\DoxyCodeLine{2295     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2296   \textcolor{keywordflow}{case} \mbox{\hyperlink{structinternal_1_1arg__ref}{arg\_ref<char\_type>::NAME}}:}
\DoxyCodeLine{2297     internal::set\_dynamic\_spec<Handler>(}
\DoxyCodeLine{2298           \mbox{\hyperlink{classinternal_1_1value}{value}}, ctx.get\_arg(ref.name), ctx.error\_handler());}
\DoxyCodeLine{2299     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2300   \}}
\DoxyCodeLine{2301 \}}
\DoxyCodeLine{2302 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{2303 }
\DoxyCodeLine{2305 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{2306 \textcolor{keyword}{class }\mbox{\hyperlink{classarg__formatter}{arg\_formatter}}:}
\DoxyCodeLine{2307   \textcolor{keyword}{public} \mbox{\hyperlink{structinternal_1_1function}{internal::function}}<}
\DoxyCodeLine{2308     typename internal::arg\_formatter\_base<Range>::iterator>,}
\DoxyCodeLine{2309   \textcolor{keyword}{public} \mbox{\hyperlink{classinternal_1_1arg__formatter__base}{internal::arg\_formatter\_base}}<Range> \{}
\DoxyCodeLine{2310  \textcolor{keyword}{private}:}
\DoxyCodeLine{2311   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Range::value\_type char\_type;}
\DoxyCodeLine{2312   \textcolor{keyword}{typedef} \mbox{\hyperlink{classinternal_1_1arg__formatter__base}{internal::arg\_formatter\_base<Range>}} \mbox{\hyperlink{classinternal_1_1arg__formatter__base}{base}};}
\DoxyCodeLine{2313   \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context<typename base::iterator, char\_type>}} \mbox{\hyperlink{classbasic__format__context}{context\_type}};}
\DoxyCodeLine{2314 }
\DoxyCodeLine{2315   \mbox{\hyperlink{classbasic__format__context}{context\_type}} \&ctx\_;}
\DoxyCodeLine{2316 }
\DoxyCodeLine{2317  \textcolor{keyword}{public}:}
\DoxyCodeLine{2318   \textcolor{keyword}{typedef} Range range;}
\DoxyCodeLine{2319   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} base::iterator iterator;}
\DoxyCodeLine{2320   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__specs}{base::format\_specs}} \mbox{\hyperlink{classbasic__format__specs}{format\_specs}};}
\DoxyCodeLine{2321 }
\DoxyCodeLine{2329   \textcolor{keyword}{explicit} \mbox{\hyperlink{classarg__formatter_a40cf56a01f9ba5f7e98adaf4acd164d7}{arg\_formatter}}(\mbox{\hyperlink{classbasic__format__context}{context\_type}} \&ctx, \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} *spec = \{\})}
\DoxyCodeLine{2330   : \mbox{\hyperlink{classbase}{base}}(Range(ctx.out()), spec), ctx\_(ctx) \{\}}
\DoxyCodeLine{2331 }
\DoxyCodeLine{2332   \textcolor{comment}{// Deprecated.}}
\DoxyCodeLine{2333   \mbox{\hyperlink{classarg__formatter_a40cf56a01f9ba5f7e98adaf4acd164d7}{arg\_formatter}}(context\_type \&ctx, \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&spec)}
\DoxyCodeLine{2334   : \mbox{\hyperlink{classbase}{base}}(Range(ctx.out()), \&spec), ctx\_(ctx) \{\}}
\DoxyCodeLine{2335 }
\DoxyCodeLine{2336   \textcolor{keyword}{using} base::operator();}
\DoxyCodeLine{2337 }
\DoxyCodeLine{2339   iterator \mbox{\hyperlink{classarg__formatter_ac8ddd9b78934fc951916a30d46114ab1}{operator()}}(\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__arg_1_1handle}{basic\_format\_arg<context\_type>::handle}} handle) \{}
\DoxyCodeLine{2340     handle.format(ctx\_);}
\DoxyCodeLine{2341     \textcolor{keywordflow}{return} this-\/>out();}
\DoxyCodeLine{2342   \}}
\DoxyCodeLine{2343 \};}
\DoxyCodeLine{2344 }
\DoxyCodeLine{2349 \textcolor{keyword}{class }\mbox{\hyperlink{classsystem__error}{system\_error}} : \textcolor{keyword}{public} std::runtime\_error \{}
\DoxyCodeLine{2350  \textcolor{keyword}{private}:}
\DoxyCodeLine{2351   FMT\_API \textcolor{keywordtype}{void} init(\textcolor{keywordtype}{int} err\_code, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \mbox{\hyperlink{structformat__args}{format\_args}} args);}
\DoxyCodeLine{2352 }
\DoxyCodeLine{2353  \textcolor{keyword}{protected}:}
\DoxyCodeLine{2354   \textcolor{keywordtype}{int} error\_code\_;}
\DoxyCodeLine{2355 }
\DoxyCodeLine{2356   \mbox{\hyperlink{classsystem__error}{system\_error}}() : std::runtime\_error(\textcolor{stringliteral}{"{}"{}}) \{\}}
\DoxyCodeLine{2357 }
\DoxyCodeLine{2358  \textcolor{keyword}{public}:}
\DoxyCodeLine{2377   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{2378   \mbox{\hyperlink{classsystem__error_a6761fd4c8604a59a7c79f6bfdfaf25cb}{system\_error}}(\textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}}, \mbox{\hyperlink{classbasic__string__view}{string\_view}} message, \textcolor{keyword}{const} Args \& ... args)}
\DoxyCodeLine{2379     : std::runtime\_error(\textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{2380     init(\mbox{\hyperlink{classerror__code}{error\_code}}, message, make\_format\_args(args...));}
\DoxyCodeLine{2381   \}}
\DoxyCodeLine{2382 }
\DoxyCodeLine{2383   \textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} error\_code\_; \}}
\DoxyCodeLine{2384 \};}
\DoxyCodeLine{2385 }
\DoxyCodeLine{2402 FMT\_API \textcolor{keywordtype}{void} format\_system\_error(\mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::buffer}} \&out, \textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}},}
\DoxyCodeLine{2403                                  fmt::string\_view message) FMT\_NOEXCEPT;}
\DoxyCodeLine{2404 }
\DoxyCodeLine{2409 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{2410 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__writer}{basic\_writer}} \{}
\DoxyCodeLine{2411  \textcolor{keyword}{public}:}
\DoxyCodeLine{2412   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Range::value\_type char\_type;}
\DoxyCodeLine{2413   \textcolor{keyword}{typedef} \textcolor{keyword}{decltype}(internal::declval<Range>().begin()) iterator;}
\DoxyCodeLine{2414   \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__specs}{basic\_format\_specs<char\_type>}} \mbox{\hyperlink{classbasic__format__specs}{format\_specs}};}
\DoxyCodeLine{2415 }
\DoxyCodeLine{2416  \textcolor{keyword}{private}:}
\DoxyCodeLine{2417   iterator out\_;  \textcolor{comment}{// Output iterator.}}
\DoxyCodeLine{2418   std::unique\_ptr<locale\_provider> locale\_;}
\DoxyCodeLine{2419 }
\DoxyCodeLine{2420   iterator out()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} out\_; \}}
\DoxyCodeLine{2421 }
\DoxyCodeLine{2422   \textcolor{comment}{// Attempts to reserve space for n extra characters in the output range.}}
\DoxyCodeLine{2423   \textcolor{comment}{// Returns a pointer to the reserved range or a reference to out\_.}}
\DoxyCodeLine{2424   \textcolor{keyword}{auto} reserve(std::size\_t n) -\/> \textcolor{keyword}{decltype}(internal::reserve(out\_, n)) \{}
\DoxyCodeLine{2425     \textcolor{keywordflow}{return} internal::reserve(out\_, n);}
\DoxyCodeLine{2426   \}}
\DoxyCodeLine{2427 }
\DoxyCodeLine{2428   \textcolor{comment}{// Writes a value in the format}}
\DoxyCodeLine{2429   \textcolor{comment}{//   <left-\/padding><value><right-\/padding>}}
\DoxyCodeLine{2430   \textcolor{comment}{// where <value> is written by f(it).}}
\DoxyCodeLine{2431   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{2432   \textcolor{keywordtype}{void} write\_padded(std::size\_t size, \textcolor{keyword}{const} \mbox{\hyperlink{structalign__spec}{align\_spec}} \&spec, F \&\&f);}
\DoxyCodeLine{2433 }
\DoxyCodeLine{2434   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{2435   \textcolor{keyword}{struct }padded\_int\_writer \{}
\DoxyCodeLine{2436     \mbox{\hyperlink{classbasic__string__view}{string\_view}} prefix;}
\DoxyCodeLine{2437     char\_type fill;}
\DoxyCodeLine{2438     std::size\_t padding;}
\DoxyCodeLine{2439     F f;}
\DoxyCodeLine{2440 }
\DoxyCodeLine{2441     \textcolor{keyword}{template} <\textcolor{keyword}{typename} It>}
\DoxyCodeLine{2442     \textcolor{keywordtype}{void} operator()(It \&\&it)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2443       \textcolor{keywordflow}{if} (prefix.\mbox{\hyperlink{classbasic__string__view_a7fd9f4dcac1782259b0cd217af69d737}{size}}() != 0)}
\DoxyCodeLine{2444         it = std::copy\_n(prefix.\mbox{\hyperlink{classbasic__string__view_ae88f246f09d5ee5610e979d074ea74e1}{data}}(), prefix.\mbox{\hyperlink{classbasic__string__view_a7fd9f4dcac1782259b0cd217af69d737}{size}}(), it);}
\DoxyCodeLine{2445       it = std::fill\_n(it, padding, fill);}
\DoxyCodeLine{2446       f(it);}
\DoxyCodeLine{2447     \}}
\DoxyCodeLine{2448   \};}
\DoxyCodeLine{2449 }
\DoxyCodeLine{2450   \textcolor{comment}{// Writes an integer in the format}}
\DoxyCodeLine{2451   \textcolor{comment}{//   <left-\/padding><prefix><numeric-\/padding><digits><right-\/padding>}}
\DoxyCodeLine{2452   \textcolor{comment}{// where <digits> are written by f(it).}}
\DoxyCodeLine{2453   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Spec, \textcolor{keyword}{typename} F>}
\DoxyCodeLine{2454   \textcolor{keywordtype}{void} write\_int(\textcolor{keywordtype}{unsigned} num\_digits, \mbox{\hyperlink{classbasic__string__view}{string\_view}} prefix,}
\DoxyCodeLine{2455                  \textcolor{keyword}{const} Spec \&spec, F f) \{}
\DoxyCodeLine{2456     std::size\_t size = prefix.\mbox{\hyperlink{classbasic__string__view_a7fd9f4dcac1782259b0cd217af69d737}{size}}() + num\_digits;}
\DoxyCodeLine{2457     char\_type fill = \textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(spec.fill());}
\DoxyCodeLine{2458     std::size\_t padding = 0;}
\DoxyCodeLine{2459     \textcolor{keywordflow}{if} (spec.align() == ALIGN\_NUMERIC) \{}
\DoxyCodeLine{2460       \textcolor{keywordflow}{if} (spec.width() > size) \{}
\DoxyCodeLine{2461         padding = spec.width() -\/ size;}
\DoxyCodeLine{2462         size = spec.width();}
\DoxyCodeLine{2463       \}}
\DoxyCodeLine{2464     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (spec.precision() > \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(num\_digits)) \{}
\DoxyCodeLine{2465       size = prefix.\mbox{\hyperlink{classbasic__string__view_a7fd9f4dcac1782259b0cd217af69d737}{size}}() + \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(spec.precision());}
\DoxyCodeLine{2466       padding = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(spec.precision()) -\/ num\_digits;}
\DoxyCodeLine{2467       fill = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{2468     \}}
\DoxyCodeLine{2469     \mbox{\hyperlink{structalign__spec}{align\_spec}} as = spec;}
\DoxyCodeLine{2470     \textcolor{keywordflow}{if} (spec.align() == ALIGN\_DEFAULT)}
\DoxyCodeLine{2471       as.align\_ = ALIGN\_RIGHT;}
\DoxyCodeLine{2472     write\_padded(size, as, padded\_int\_writer<F>\{prefix, fill, padding, f\});}
\DoxyCodeLine{2473   \}}
\DoxyCodeLine{2474 }
\DoxyCodeLine{2475   \textcolor{comment}{// Writes a decimal integer.}}
\DoxyCodeLine{2476   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Int>}
\DoxyCodeLine{2477   \textcolor{keywordtype}{void} write\_decimal(Int value) \{}
\DoxyCodeLine{2478     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structinternal_1_1int__traits}{internal::int\_traits<Int>::main\_type}} main\_type;}
\DoxyCodeLine{2479     main\_type abs\_value = \textcolor{keyword}{static\_cast<}main\_type\textcolor{keyword}{>}(value);}
\DoxyCodeLine{2480     \textcolor{keywordtype}{bool} is\_negative = internal::is\_negative(value);}
\DoxyCodeLine{2481     \textcolor{keywordflow}{if} (is\_negative)}
\DoxyCodeLine{2482       abs\_value = 0 -\/ abs\_value;}
\DoxyCodeLine{2483     \textcolor{keywordtype}{unsigned} num\_digits = internal::count\_digits(abs\_value);}
\DoxyCodeLine{2484     \textcolor{keyword}{auto} \&\&it = reserve((is\_negative ? 1 : 0) + num\_digits);}
\DoxyCodeLine{2485     \textcolor{keywordflow}{if} (is\_negative)}
\DoxyCodeLine{2486       *it++ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{2487     it = internal::format\_decimal(it, abs\_value, num\_digits);}
\DoxyCodeLine{2488   \}}
\DoxyCodeLine{2489 }
\DoxyCodeLine{2490   \textcolor{comment}{// The handle\_int\_type\_spec handler that writes an integer.}}
\DoxyCodeLine{2491   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Int, \textcolor{keyword}{typename} Spec>}
\DoxyCodeLine{2492   \textcolor{keyword}{struct }int\_writer \{}
\DoxyCodeLine{2493     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structinternal_1_1int__traits}{internal::int\_traits<Int>::main\_type}} unsigned\_type;}
\DoxyCodeLine{2494 }
\DoxyCodeLine{2495     \mbox{\hyperlink{classbasic__writer}{basic\_writer<Range>}} \&\mbox{\hyperlink{classbasic__writer}{writer}};}
\DoxyCodeLine{2496     \textcolor{keyword}{const} Spec \&spec;}
\DoxyCodeLine{2497     unsigned\_type abs\_value;}
\DoxyCodeLine{2498     \textcolor{keywordtype}{char} prefix[4];}
\DoxyCodeLine{2499     \textcolor{keywordtype}{unsigned} prefix\_size;}
\DoxyCodeLine{2500 }
\DoxyCodeLine{2501     \mbox{\hyperlink{classbasic__string__view}{string\_view}} get\_prefix()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__string__view}{string\_view}}(prefix, prefix\_size); \}}
\DoxyCodeLine{2502 }
\DoxyCodeLine{2503     \textcolor{comment}{// Counts the number of digits in abs\_value. BITS = log2(radix).}}
\DoxyCodeLine{2504     \textcolor{keyword}{template} <\textcolor{keywordtype}{unsigned} BITS>}
\DoxyCodeLine{2505     \textcolor{keywordtype}{unsigned} count\_digits()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2506       unsigned\_type n = abs\_value;}
\DoxyCodeLine{2507       \textcolor{keywordtype}{unsigned} num\_digits = 0;}
\DoxyCodeLine{2508       \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{2509         ++num\_digits;}
\DoxyCodeLine{2510       \} \textcolor{keywordflow}{while} ((n >>= BITS) != 0);}
\DoxyCodeLine{2511       \textcolor{keywordflow}{return} num\_digits;}
\DoxyCodeLine{2512     \}}
\DoxyCodeLine{2513 }
\DoxyCodeLine{2514     int\_writer(\mbox{\hyperlink{classbasic__writer}{basic\_writer<Range>}} \&w, Int value, \textcolor{keyword}{const} Spec \&s)}
\DoxyCodeLine{2515       : \mbox{\hyperlink{classbasic__writer}{writer}}(w), spec(s), abs\_value(\textcolor{keyword}{static\_cast<}unsigned\_type\textcolor{keyword}{>}(value)),}
\DoxyCodeLine{2516         prefix\_size(0) \{}
\DoxyCodeLine{2517       \textcolor{keywordflow}{if} (internal::is\_negative(value)) \{}
\DoxyCodeLine{2518         prefix[0] = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{2519         ++prefix\_size;}
\DoxyCodeLine{2520         abs\_value = 0 -\/ abs\_value;}
\DoxyCodeLine{2521       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (spec.flag(SIGN\_FLAG)) \{}
\DoxyCodeLine{2522         prefix[0] = spec.flag(PLUS\_FLAG) ? \textcolor{charliteral}{'+'} : \textcolor{charliteral}{' '};}
\DoxyCodeLine{2523         ++prefix\_size;}
\DoxyCodeLine{2524       \}}
\DoxyCodeLine{2525     \}}
\DoxyCodeLine{2526 }
\DoxyCodeLine{2527     \textcolor{keyword}{struct }\mbox{\hyperlink{structbasic__writer_1_1int__writer_1_1dec__writer}{dec\_writer}} \{}
\DoxyCodeLine{2528       unsigned\_type abs\_value;}
\DoxyCodeLine{2529       \textcolor{keywordtype}{unsigned} num\_digits;}
\DoxyCodeLine{2530 }
\DoxyCodeLine{2531       \textcolor{keyword}{template} <\textcolor{keyword}{typename} It>}
\DoxyCodeLine{2532       \textcolor{keywordtype}{void} operator()(It \&\&it)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2533         it = internal::format\_decimal(it, abs\_value, num\_digits);}
\DoxyCodeLine{2534       \}}
\DoxyCodeLine{2535     \};}
\DoxyCodeLine{2536 }
\DoxyCodeLine{2537     \textcolor{keywordtype}{void} on\_dec() \{}
\DoxyCodeLine{2538       \textcolor{keywordtype}{unsigned} num\_digits = internal::count\_digits(abs\_value);}
\DoxyCodeLine{2539       \mbox{\hyperlink{classbasic__writer}{writer}}.write\_int(num\_digits, get\_prefix(), spec,}
\DoxyCodeLine{2540                        \mbox{\hyperlink{structbasic__writer_1_1int__writer_1_1dec__writer}{dec\_writer}}\{abs\_value, num\_digits\});}
\DoxyCodeLine{2541     \}}
\DoxyCodeLine{2542 }
\DoxyCodeLine{2543     \textcolor{keyword}{struct }\mbox{\hyperlink{structbasic__writer_1_1int__writer_1_1hex__writer}{hex\_writer}} \{}
\DoxyCodeLine{2544       int\_writer \&\textcolor{keyword}{self};}
\DoxyCodeLine{2545       \textcolor{keywordtype}{unsigned} num\_digits;}
\DoxyCodeLine{2546 }
\DoxyCodeLine{2547       \textcolor{keyword}{template} <\textcolor{keyword}{typename} It>}
\DoxyCodeLine{2548       \textcolor{keywordtype}{void} operator()(It \&\&it)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2549         it = internal::format\_uint<4>(it, \textcolor{keyword}{self}.abs\_value, num\_digits,}
\DoxyCodeLine{2550                                       \textcolor{keyword}{self}.spec.type() != \textcolor{charliteral}{'x'});}
\DoxyCodeLine{2551       \}}
\DoxyCodeLine{2552     \};}
\DoxyCodeLine{2553 }
\DoxyCodeLine{2554     \textcolor{keywordtype}{void} on\_hex() \{}
\DoxyCodeLine{2555       \textcolor{keywordflow}{if} (spec.flag(HASH\_FLAG)) \{}
\DoxyCodeLine{2556         prefix[prefix\_size++] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{2557         prefix[prefix\_size++] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(spec.type());}
\DoxyCodeLine{2558       \}}
\DoxyCodeLine{2559       \textcolor{keywordtype}{unsigned} num\_digits = count\_digits<4>();}
\DoxyCodeLine{2560       \mbox{\hyperlink{classbasic__writer}{writer}}.write\_int(num\_digits, get\_prefix(), spec,}
\DoxyCodeLine{2561                        hex\_writer\{*\textcolor{keyword}{this}, num\_digits\});}
\DoxyCodeLine{2562     \}}
\DoxyCodeLine{2563 }
\DoxyCodeLine{2564     \textcolor{keyword}{template} <\textcolor{keywordtype}{int} BITS>}
\DoxyCodeLine{2565     \textcolor{keyword}{struct }\mbox{\hyperlink{structbasic__writer_1_1int__writer_1_1bin__writer}{bin\_writer}} \{}
\DoxyCodeLine{2566       unsigned\_type abs\_value;}
\DoxyCodeLine{2567       \textcolor{keywordtype}{unsigned} num\_digits;}
\DoxyCodeLine{2568 }
\DoxyCodeLine{2569       \textcolor{keyword}{template} <\textcolor{keyword}{typename} It>}
\DoxyCodeLine{2570       \textcolor{keywordtype}{void} operator()(It \&\&it)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2571         it = internal::format\_uint<BITS>(it, abs\_value, num\_digits);}
\DoxyCodeLine{2572       \}}
\DoxyCodeLine{2573     \};}
\DoxyCodeLine{2574 }
\DoxyCodeLine{2575     \textcolor{keywordtype}{void} on\_bin() \{}
\DoxyCodeLine{2576       \textcolor{keywordflow}{if} (spec.flag(HASH\_FLAG)) \{}
\DoxyCodeLine{2577         prefix[prefix\_size++] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{2578         prefix[prefix\_size++] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(spec.type());}
\DoxyCodeLine{2579       \}}
\DoxyCodeLine{2580       \textcolor{keywordtype}{unsigned} num\_digits = count\_digits<1>();}
\DoxyCodeLine{2581       \mbox{\hyperlink{classbasic__writer}{writer}}.write\_int(num\_digits, get\_prefix(), spec,}
\DoxyCodeLine{2582                        bin\_writer<1>\{abs\_value, num\_digits\});}
\DoxyCodeLine{2583     \}}
\DoxyCodeLine{2584 }
\DoxyCodeLine{2585     \textcolor{keywordtype}{void} on\_oct() \{}
\DoxyCodeLine{2586       \textcolor{keywordtype}{unsigned} num\_digits = count\_digits<3>();}
\DoxyCodeLine{2587       \textcolor{keywordflow}{if} (spec.flag(HASH\_FLAG) \&\&}
\DoxyCodeLine{2588           spec.precision() <= \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(num\_digits)) \{}
\DoxyCodeLine{2589         \textcolor{comment}{// Octal prefix '0' is counted as a digit, so only add it if precision}}
\DoxyCodeLine{2590         \textcolor{comment}{// is not greater than the number of digits.}}
\DoxyCodeLine{2591         prefix[prefix\_size++] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{2592       \}}
\DoxyCodeLine{2593       \mbox{\hyperlink{classbasic__writer}{writer}}.write\_int(num\_digits, get\_prefix(), spec,}
\DoxyCodeLine{2594                        bin\_writer<3>\{abs\_value, num\_digits\});}
\DoxyCodeLine{2595     \}}
\DoxyCodeLine{2596 }
\DoxyCodeLine{2597     \textcolor{keyword}{enum} \{ SEP\_SIZE = 1 \};}
\DoxyCodeLine{2598 }
\DoxyCodeLine{2599     \textcolor{keyword}{struct }\mbox{\hyperlink{structbasic__writer_1_1int__writer_1_1num__writer}{num\_writer}} \{}
\DoxyCodeLine{2600       unsigned\_type abs\_value;}
\DoxyCodeLine{2601       \textcolor{keywordtype}{unsigned} size;}
\DoxyCodeLine{2602       char\_type sep;}
\DoxyCodeLine{2603 }
\DoxyCodeLine{2604       \textcolor{keyword}{template} <\textcolor{keyword}{typename} It>}
\DoxyCodeLine{2605       \textcolor{keywordtype}{void} operator()(It \&\&it)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2606         \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} s(\&sep, SEP\_SIZE);}
\DoxyCodeLine{2607         it = format\_decimal(it, abs\_value, size,}
\DoxyCodeLine{2608                             \mbox{\hyperlink{classinternal_1_1add__thousands__sep}{internal::add\_thousands\_sep<char\_type>}}(s));}
\DoxyCodeLine{2609       \}}
\DoxyCodeLine{2610     \};}
\DoxyCodeLine{2611 }
\DoxyCodeLine{2612     \textcolor{keywordtype}{void} on\_num() \{}
\DoxyCodeLine{2613       \textcolor{keywordtype}{unsigned} num\_digits = internal::count\_digits(abs\_value);}
\DoxyCodeLine{2614       char\_type sep = internal::thousands\_sep<char\_type>(\mbox{\hyperlink{classbasic__writer}{writer}}.locale\_.get());}
\DoxyCodeLine{2615       \textcolor{keywordtype}{unsigned} size = num\_digits + SEP\_SIZE * ((num\_digits -\/ 1) / 3);}
\DoxyCodeLine{2616       \mbox{\hyperlink{classbasic__writer}{writer}}.write\_int(size, get\_prefix(), spec,}
\DoxyCodeLine{2617                        \mbox{\hyperlink{structbasic__writer_1_1int__writer_1_1num__writer}{num\_writer}}\{abs\_value, size, sep\});}
\DoxyCodeLine{2618     \}}
\DoxyCodeLine{2619 }
\DoxyCodeLine{2620     \textcolor{keywordtype}{void} on\_error() \{}
\DoxyCodeLine{2621       FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}invalid type specifier"{}}));}
\DoxyCodeLine{2622     \}}
\DoxyCodeLine{2623   \};}
\DoxyCodeLine{2624 }
\DoxyCodeLine{2625   \textcolor{comment}{// Writes a formatted integer.}}
\DoxyCodeLine{2626   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Spec>}
\DoxyCodeLine{2627   \textcolor{keywordtype}{void} write\_int(T value, \textcolor{keyword}{const} Spec \&spec) \{}
\DoxyCodeLine{2628     internal::handle\_int\_type\_spec(spec.type(),}
\DoxyCodeLine{2629                                    int\_writer<T, Spec>(*\textcolor{keyword}{this}, value, spec));}
\DoxyCodeLine{2630   \}}
\DoxyCodeLine{2631 }
\DoxyCodeLine{2632   \textcolor{keyword}{enum} \{INF\_SIZE = 3\}; \textcolor{comment}{// This is an enum to workaround a bug in MSVC.}}
\DoxyCodeLine{2633 }
\DoxyCodeLine{2634   \textcolor{keyword}{struct }inf\_or\_nan\_writer \{}
\DoxyCodeLine{2635     \textcolor{keywordtype}{char} sign;}
\DoxyCodeLine{2636     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *str;}
\DoxyCodeLine{2637 }
\DoxyCodeLine{2638     \textcolor{keyword}{template} <\textcolor{keyword}{typename} It>}
\DoxyCodeLine{2639     \textcolor{keywordtype}{void} operator()(It \&\&it)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2640       \textcolor{keywordflow}{if} (sign)}
\DoxyCodeLine{2641         *it++ = sign;}
\DoxyCodeLine{2642       it = std::copy\_n(str, \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(INF\_SIZE), it);}
\DoxyCodeLine{2643     \}}
\DoxyCodeLine{2644   \};}
\DoxyCodeLine{2645 }
\DoxyCodeLine{2646   \textcolor{keyword}{struct }double\_writer \{}
\DoxyCodeLine{2647     \textcolor{keywordtype}{size\_t} n;}
\DoxyCodeLine{2648     \textcolor{keywordtype}{char} sign;}
\DoxyCodeLine{2649     \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<char\_type>}} \&buffer;}
\DoxyCodeLine{2650 }
\DoxyCodeLine{2651     \textcolor{keyword}{template} <\textcolor{keyword}{typename} It>}
\DoxyCodeLine{2652     \textcolor{keywordtype}{void} operator()(It \&\&it) \{}
\DoxyCodeLine{2653       \textcolor{keywordflow}{if} (sign) \{}
\DoxyCodeLine{2654         *it++ = sign;}
\DoxyCodeLine{2655         -\/-\/n;}
\DoxyCodeLine{2656       \}}
\DoxyCodeLine{2657       it = std::copy\_n(buffer.begin(), n, it);}
\DoxyCodeLine{2658     \}}
\DoxyCodeLine{2659   \};}
\DoxyCodeLine{2660 }
\DoxyCodeLine{2661   \textcolor{comment}{// Formats a floating-\/point number (double or long double).}}
\DoxyCodeLine{2662   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2663   \textcolor{keywordtype}{void} write\_double(T value, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&spec);}
\DoxyCodeLine{2664   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2665   \textcolor{keywordtype}{void} write\_double\_sprintf(T value, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&spec,}
\DoxyCodeLine{2666                             \mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::basic\_buffer<char\_type>}}\& buffer);}
\DoxyCodeLine{2667 }
\DoxyCodeLine{2668   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2669   \textcolor{keyword}{struct }str\_writer \{}
\DoxyCodeLine{2670     \textcolor{keyword}{const} Char *s;}
\DoxyCodeLine{2671     std::size\_t size;}
\DoxyCodeLine{2672 }
\DoxyCodeLine{2673     \textcolor{keyword}{template} <\textcolor{keyword}{typename} It>}
\DoxyCodeLine{2674     \textcolor{keywordtype}{void} operator()(It \&\&it)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2675       it = std::copy\_n(s, size, it);}
\DoxyCodeLine{2676     \}}
\DoxyCodeLine{2677   \};}
\DoxyCodeLine{2678 }
\DoxyCodeLine{2679   \textcolor{comment}{// Writes a formatted string.}}
\DoxyCodeLine{2680   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2681   \textcolor{keywordtype}{void} write\_str(\textcolor{keyword}{const} Char *s, std::size\_t size, \textcolor{keyword}{const} \mbox{\hyperlink{structalign__spec}{align\_spec}} \&spec) \{}
\DoxyCodeLine{2682     write\_padded(size, spec, str\_writer<Char>\{s, size\});}
\DoxyCodeLine{2683   \}}
\DoxyCodeLine{2684 }
\DoxyCodeLine{2685   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2686   \textcolor{keywordtype}{void} write\_str(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&spec);}
\DoxyCodeLine{2687 }
\DoxyCodeLine{2688   \textcolor{comment}{// Appends floating-\/point length specifier to the format string.}}
\DoxyCodeLine{2689   \textcolor{comment}{// The second argument is only used for overload resolution.}}
\DoxyCodeLine{2690   \textcolor{keywordtype}{void} append\_float\_length(char\_type *\&format\_ptr, \textcolor{keywordtype}{long} \textcolor{keywordtype}{double}) \{}
\DoxyCodeLine{2691     *format\_ptr++ = \textcolor{charliteral}{'L'};}
\DoxyCodeLine{2692   \}}
\DoxyCodeLine{2693 }
\DoxyCodeLine{2694   \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2695   \textcolor{keywordtype}{void} append\_float\_length(char\_type *\&, T) \{\}}
\DoxyCodeLine{2696 }
\DoxyCodeLine{2697   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2698   \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1arg__formatter__base}{internal::arg\_formatter\_base}};}
\DoxyCodeLine{2699 }
\DoxyCodeLine{2700  \textcolor{keyword}{public}:}
\DoxyCodeLine{2702   \textcolor{keyword}{explicit} \mbox{\hyperlink{classbasic__writer_ac199107e2efca28166e75985e79d4c89}{basic\_writer}}(Range out): out\_(out.begin()) \{\}}
\DoxyCodeLine{2703 }
\DoxyCodeLine{2704   \textcolor{keywordtype}{void} write(\textcolor{keywordtype}{int} value) \{ write\_decimal(value); \}}
\DoxyCodeLine{2705   \textcolor{keywordtype}{void} write(\textcolor{keywordtype}{long} value) \{ write\_decimal(value); \}}
\DoxyCodeLine{2706   \textcolor{keywordtype}{void} write(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{ write\_decimal(value); \}}
\DoxyCodeLine{2707 }
\DoxyCodeLine{2708   \textcolor{keywordtype}{void} write(\textcolor{keywordtype}{unsigned} value) \{ write\_decimal(value); \}}
\DoxyCodeLine{2709   \textcolor{keywordtype}{void} write(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} value) \{ write\_decimal(value); \}}
\DoxyCodeLine{2710   \textcolor{keywordtype}{void} write(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{ write\_decimal(value); \}}
\DoxyCodeLine{2711 }
\DoxyCodeLine{2717   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} FormatSpec, \textcolor{keyword}{typename}... FormatSpecs>}
\DoxyCodeLine{2718   \textcolor{keyword}{typename} std::enable\_if<std::is\_integral<T>::value, \textcolor{keywordtype}{void}>::type}
\DoxyCodeLine{2719       \mbox{\hyperlink{classbasic__writer_aec5f34b26ea31c7caa4f22d89d269421}{write}}(T value, FormatSpec spec, FormatSpecs... specs) \{}
\DoxyCodeLine{2720     \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} s(spec, specs...);}
\DoxyCodeLine{2721     s.align\_ = ALIGN\_RIGHT;}
\DoxyCodeLine{2722     write\_int(value, s);}
\DoxyCodeLine{2723   \}}
\DoxyCodeLine{2724 }
\DoxyCodeLine{2725   \textcolor{keywordtype}{void} write(\textcolor{keywordtype}{double} value) \{}
\DoxyCodeLine{2726     write\_double(value, \mbox{\hyperlink{classbasic__format__specs}{format\_specs}}());}
\DoxyCodeLine{2727   \}}
\DoxyCodeLine{2728 }
\DoxyCodeLine{2735   \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__writer_a76b033a93868ee4692055c9567436c7a}{write}}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} value) \{}
\DoxyCodeLine{2736     write\_double(value, \mbox{\hyperlink{classbasic__format__specs}{format\_specs}}());}
\DoxyCodeLine{2737   \}}
\DoxyCodeLine{2738 }
\DoxyCodeLine{2740   \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__writer_a1046134b869e509059ab496f1f6e9ab9}{write}}(\textcolor{keywordtype}{char} value) \{}
\DoxyCodeLine{2741     *reserve(1) = value;}
\DoxyCodeLine{2742   \}}
\DoxyCodeLine{2743 }
\DoxyCodeLine{2744   \textcolor{keywordtype}{void} write(\textcolor{keywordtype}{wchar\_t} value) \{}
\DoxyCodeLine{2745     internal::require\_wchar<char\_type>();}
\DoxyCodeLine{2746     *reserve(1) = value;}
\DoxyCodeLine{2747   \}}
\DoxyCodeLine{2748 }
\DoxyCodeLine{2754   \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__writer_a9145dbe901036b8f1a35587faac5e74e}{write}}(\mbox{\hyperlink{classbasic__string__view}{string\_view}} value) \{}
\DoxyCodeLine{2755     \textcolor{keyword}{auto} \&\&it = reserve(value.size());}
\DoxyCodeLine{2756     it = \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{std::copy}}(value.begin(), value.end(), it);}
\DoxyCodeLine{2757   \}}
\DoxyCodeLine{2758 }
\DoxyCodeLine{2759   \textcolor{keywordtype}{void} write(\mbox{\hyperlink{classbasic__string__view}{wstring\_view}} value) \{}
\DoxyCodeLine{2760     internal::require\_wchar<char\_type>();}
\DoxyCodeLine{2761     \textcolor{keyword}{auto} \&\&it = reserve(value.size());}
\DoxyCodeLine{2762     it = \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{std::copy}}(value.begin(), value.end(), it);}
\DoxyCodeLine{2763   \}}
\DoxyCodeLine{2764 }
\DoxyCodeLine{2765   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... FormatSpecs>}
\DoxyCodeLine{2766   \textcolor{keywordtype}{void} write(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} str, FormatSpecs... specs) \{}
\DoxyCodeLine{2767     write\_str(str, \mbox{\hyperlink{classbasic__format__specs}{format\_specs}}(specs...));}
\DoxyCodeLine{2768   \}}
\DoxyCodeLine{2769 }
\DoxyCodeLine{2770   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2771   \textcolor{keyword}{typename} std::enable\_if<std::is\_same<T, void>::value>::type}
\DoxyCodeLine{2772       write(\textcolor{keyword}{const} T *p) \{}
\DoxyCodeLine{2773     \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} specs;}
\DoxyCodeLine{2774     specs.flags\_ = HASH\_FLAG;}
\DoxyCodeLine{2775     specs.type\_ = \textcolor{charliteral}{'x'};}
\DoxyCodeLine{2776     write\_int(\textcolor{keyword}{reinterpret\_cast<}uintptr\_t\textcolor{keyword}{>}(p), specs);}
\DoxyCodeLine{2777   \}}
\DoxyCodeLine{2778 \};}
\DoxyCodeLine{2779 }
\DoxyCodeLine{2780 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{2781 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{2782 \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__writer}{basic\_writer<Range>::write\_padded}}(}
\DoxyCodeLine{2783     std::size\_t size, \textcolor{keyword}{const} \mbox{\hyperlink{structalign__spec}{align\_spec}} \&spec, F \&\&f) \{}
\DoxyCodeLine{2784   \textcolor{keywordtype}{unsigned} width = spec.width();}
\DoxyCodeLine{2785   \textcolor{keywordflow}{if} (width <= size)}
\DoxyCodeLine{2786     \textcolor{keywordflow}{return} f(reserve(size));}
\DoxyCodeLine{2787   \textcolor{keyword}{auto} \&\&it = reserve(width);}
\DoxyCodeLine{2788   char\_type fill = \textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(spec.fill());}
\DoxyCodeLine{2789   std::size\_t padding = width -\/ size;}
\DoxyCodeLine{2790   \textcolor{keywordflow}{if} (spec.align() == ALIGN\_RIGHT) \{}
\DoxyCodeLine{2791     it = std::fill\_n(it, padding, fill);}
\DoxyCodeLine{2792     f(it);}
\DoxyCodeLine{2793   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (spec.align() == ALIGN\_CENTER) \{}
\DoxyCodeLine{2794     std::size\_t left\_padding = padding / 2;}
\DoxyCodeLine{2795     it = std::fill\_n(it, left\_padding, fill);}
\DoxyCodeLine{2796     f(it);}
\DoxyCodeLine{2797     it = std::fill\_n(it, padding -\/ left\_padding, fill);}
\DoxyCodeLine{2798   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2799     f(it);}
\DoxyCodeLine{2800     it = std::fill\_n(it, padding, fill);}
\DoxyCodeLine{2801   \}}
\DoxyCodeLine{2802 \}}
\DoxyCodeLine{2803 }
\DoxyCodeLine{2804 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{2805 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2806 \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__writer}{basic\_writer<Range>::write\_str}}(}
\DoxyCodeLine{2807     \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&spec) \{}
\DoxyCodeLine{2808   \textcolor{keyword}{const} Char *data = s.data();}
\DoxyCodeLine{2809   std::size\_t size = s.size();}
\DoxyCodeLine{2810   std::size\_t precision = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(spec.precision\_);}
\DoxyCodeLine{2811   \textcolor{keywordflow}{if} (spec.precision\_ >= 0 \&\& precision < size)}
\DoxyCodeLine{2812     size = precision;}
\DoxyCodeLine{2813   write\_str(data, size, spec);}
\DoxyCodeLine{2814 \}}
\DoxyCodeLine{2815 }
\DoxyCodeLine{2816 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2817 \textcolor{keyword}{struct }\mbox{\hyperlink{structfloat__spec__handler}{float\_spec\_handler}} \{}
\DoxyCodeLine{2818   Char type;}
\DoxyCodeLine{2819   \textcolor{keywordtype}{bool} upper;}
\DoxyCodeLine{2820 }
\DoxyCodeLine{2821   \textcolor{keyword}{explicit} \mbox{\hyperlink{structfloat__spec__handler}{float\_spec\_handler}}(Char t) : type(t), upper(\textcolor{keyword}{false}) \{\}}
\DoxyCodeLine{2822 }
\DoxyCodeLine{2823   \textcolor{keywordtype}{void} on\_general() \{}
\DoxyCodeLine{2824     \textcolor{keywordflow}{if} (type == \textcolor{charliteral}{'G'})}
\DoxyCodeLine{2825       upper = \textcolor{keyword}{true};}
\DoxyCodeLine{2826     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2827       type = \textcolor{charliteral}{'g'};}
\DoxyCodeLine{2828   \}}
\DoxyCodeLine{2829 }
\DoxyCodeLine{2830   \textcolor{keywordtype}{void} on\_exp() \{}
\DoxyCodeLine{2831     \textcolor{keywordflow}{if} (type == \textcolor{charliteral}{'E'})}
\DoxyCodeLine{2832       upper = \textcolor{keyword}{true};}
\DoxyCodeLine{2833   \}}
\DoxyCodeLine{2834 }
\DoxyCodeLine{2835   \textcolor{keywordtype}{void} on\_fixed() \{}
\DoxyCodeLine{2836     \textcolor{keywordflow}{if} (type == \textcolor{charliteral}{'F'}) \{}
\DoxyCodeLine{2837       upper = \textcolor{keyword}{true};}
\DoxyCodeLine{2838 \textcolor{preprocessor}{\#if FMT\_MSC\_VER}}
\DoxyCodeLine{2839       \textcolor{comment}{// MSVC's printf doesn't support 'F'.}}
\DoxyCodeLine{2840       type = \textcolor{charliteral}{'f'};}
\DoxyCodeLine{2841 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2842     \}}
\DoxyCodeLine{2843   \}}
\DoxyCodeLine{2844 }
\DoxyCodeLine{2845   \textcolor{keywordtype}{void} on\_hex() \{}
\DoxyCodeLine{2846     \textcolor{keywordflow}{if} (type == \textcolor{charliteral}{'A'})}
\DoxyCodeLine{2847       upper = \textcolor{keyword}{true};}
\DoxyCodeLine{2848   \}}
\DoxyCodeLine{2849 }
\DoxyCodeLine{2850   \textcolor{keywordtype}{void} on\_error() \{}
\DoxyCodeLine{2851     FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(\textcolor{stringliteral}{"{}invalid type specifier"{}}));}
\DoxyCodeLine{2852   \}}
\DoxyCodeLine{2853 \};}
\DoxyCodeLine{2854 }
\DoxyCodeLine{2855 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{2856 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2857 \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__writer}{basic\_writer<Range>::write\_double}}(T value, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&spec) \{}
\DoxyCodeLine{2858   \textcolor{comment}{// Check type.}}
\DoxyCodeLine{2859   \mbox{\hyperlink{structfloat__spec__handler}{float\_spec\_handler<char\_type>}} handler(spec.type());}
\DoxyCodeLine{2860   internal::handle\_float\_type\_spec(spec.type(), handler);}
\DoxyCodeLine{2861 }
\DoxyCodeLine{2862   \textcolor{keywordtype}{char} sign = 0;}
\DoxyCodeLine{2863   \textcolor{comment}{// Use isnegative instead of value < 0 because the latter is always}}
\DoxyCodeLine{2864   \textcolor{comment}{// false for NaN.}}
\DoxyCodeLine{2865   \textcolor{keywordflow}{if} (internal::fputil::isnegative(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value))) \{}
\DoxyCodeLine{2866     sign = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{2867     value = -\/value;}
\DoxyCodeLine{2868   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (spec.flag(SIGN\_FLAG)) \{}
\DoxyCodeLine{2869     sign = spec.flag(PLUS\_FLAG) ? \textcolor{charliteral}{'+'} : \textcolor{charliteral}{' '};}
\DoxyCodeLine{2870   \}}
\DoxyCodeLine{2871 }
\DoxyCodeLine{2872   \textcolor{keyword}{struct }write\_inf\_or\_nan\_t \{}
\DoxyCodeLine{2873     \mbox{\hyperlink{classbasic__writer}{basic\_writer}} \&\mbox{\hyperlink{classbasic__writer}{writer}};}
\DoxyCodeLine{2874     \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} spec;}
\DoxyCodeLine{2875     \textcolor{keywordtype}{char} sign;}
\DoxyCodeLine{2876     \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *str)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2877       \mbox{\hyperlink{classbasic__writer}{writer}}.write\_padded(INF\_SIZE + (sign ? 1 : 0), spec,}
\DoxyCodeLine{2878                           inf\_or\_nan\_writer\{sign, str\});}
\DoxyCodeLine{2879     \}}
\DoxyCodeLine{2880   \} write\_inf\_or\_nan = \{*\textcolor{keyword}{this}, spec, sign\};}
\DoxyCodeLine{2881 }
\DoxyCodeLine{2882   \textcolor{comment}{// Format NaN and ininity ourselves because sprintf's output is not consistent}}
\DoxyCodeLine{2883   \textcolor{comment}{// across platforms.}}
\DoxyCodeLine{2884   \textcolor{keywordflow}{if} (internal::fputil::isnotanumber(value))}
\DoxyCodeLine{2885     \textcolor{keywordflow}{return} write\_inf\_or\_nan(handler.upper ? \textcolor{stringliteral}{"{}NAN"{}} : \textcolor{stringliteral}{"{}nan"{}});}
\DoxyCodeLine{2886   \textcolor{keywordflow}{if} (internal::fputil::isinfinity(value))}
\DoxyCodeLine{2887     \textcolor{keywordflow}{return} write\_inf\_or\_nan(handler.upper ? \textcolor{stringliteral}{"{}INF"{}} : \textcolor{stringliteral}{"{}inf"{}});}
\DoxyCodeLine{2888 }
\DoxyCodeLine{2889   \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<char\_type>}} buffer;}
\DoxyCodeLine{2890   \textcolor{keywordtype}{char} type = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(spec.type());}
\DoxyCodeLine{2891   \textcolor{keywordflow}{if} (internal::const\_check(}
\DoxyCodeLine{2892         internal::use\_grisu() \&\& \textcolor{keyword}{sizeof}(T) <= \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double})) \&\&}
\DoxyCodeLine{2893       type != \textcolor{charliteral}{'a'} \&\& type != \textcolor{charliteral}{'A'}) \{}
\DoxyCodeLine{2894     \textcolor{keywordtype}{char} buf[100]; \textcolor{comment}{// TODO: correct buffer size}}
\DoxyCodeLine{2895     \textcolor{keywordtype}{size\_t} size = 0;}
\DoxyCodeLine{2896     internal::grisu2\_format(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value), buf, size, type,}
\DoxyCodeLine{2897                             spec.precision(), spec.flag(HASH\_FLAG));}
\DoxyCodeLine{2898     FMT\_ASSERT(size <= 100, \textcolor{stringliteral}{"{}buffer overflow"{}});}
\DoxyCodeLine{2899     buffer.append(buf, buf + size); \textcolor{comment}{// TODO: avoid extra copy}}
\DoxyCodeLine{2900   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2901     \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} normalized\_spec(spec);}
\DoxyCodeLine{2902     normalized\_spec.type\_ = handler.type;}
\DoxyCodeLine{2903     write\_double\_sprintf(value, normalized\_spec, buffer);}
\DoxyCodeLine{2904   \}}
\DoxyCodeLine{2905   \textcolor{keywordtype}{size\_t} n = buffer.size();}
\DoxyCodeLine{2906   \mbox{\hyperlink{structalign__spec}{align\_spec}} as = spec;}
\DoxyCodeLine{2907   \textcolor{keywordflow}{if} (spec.align() == ALIGN\_NUMERIC) \{}
\DoxyCodeLine{2908     \textcolor{keywordflow}{if} (sign) \{}
\DoxyCodeLine{2909       \textcolor{keyword}{auto} \&\&it = reserve(1);}
\DoxyCodeLine{2910       *it++ = sign;}
\DoxyCodeLine{2911       sign = 0;}
\DoxyCodeLine{2912       \textcolor{keywordflow}{if} (as.width\_)}
\DoxyCodeLine{2913         -\/-\/as.width\_;}
\DoxyCodeLine{2914     \}}
\DoxyCodeLine{2915     as.align\_ = ALIGN\_RIGHT;}
\DoxyCodeLine{2916   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2917     \textcolor{keywordflow}{if} (spec.align() == ALIGN\_DEFAULT)}
\DoxyCodeLine{2918       as.align\_ = ALIGN\_RIGHT;}
\DoxyCodeLine{2919     \textcolor{keywordflow}{if} (sign)}
\DoxyCodeLine{2920       ++n;}
\DoxyCodeLine{2921   \}}
\DoxyCodeLine{2922   write\_padded(n, as, double\_writer\{n, sign, buffer\});}
\DoxyCodeLine{2923 \}}
\DoxyCodeLine{2924 }
\DoxyCodeLine{2925 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{2926 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2927 \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__writer}{basic\_writer<Range>::write\_double\_sprintf}}(}
\DoxyCodeLine{2928     T value, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__specs}{format\_specs}} \&spec,}
\DoxyCodeLine{2929     \mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::basic\_buffer<char\_type>}}\& buffer) \{}
\DoxyCodeLine{2930   \textcolor{comment}{// Buffer capacity must be non-\/zero, otherwise MSVC's vsnprintf\_s will fail.}}
\DoxyCodeLine{2931   FMT\_ASSERT(buffer.capacity() != 0, \textcolor{stringliteral}{"{}empty buffer"{}});}
\DoxyCodeLine{2932 }
\DoxyCodeLine{2933   \textcolor{comment}{// Build format string.}}
\DoxyCodeLine{2934   \textcolor{keyword}{enum} \{ MAX\_FORMAT\_SIZE = 10\}; \textcolor{comment}{// longest format: \%\#-\/*.*Lg}}
\DoxyCodeLine{2935   char\_type format[MAX\_FORMAT\_SIZE];}
\DoxyCodeLine{2936   char\_type *format\_ptr = format;}
\DoxyCodeLine{2937   *format\_ptr++ = \textcolor{charliteral}{'\%'};}
\DoxyCodeLine{2938   \textcolor{keywordflow}{if} (spec.flag(HASH\_FLAG))}
\DoxyCodeLine{2939     *format\_ptr++ = \textcolor{charliteral}{'\#'};}
\DoxyCodeLine{2940   \textcolor{keywordflow}{if} (spec.precision() >= 0) \{}
\DoxyCodeLine{2941     *format\_ptr++ = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{2942     *format\_ptr++ = \textcolor{charliteral}{'*'};}
\DoxyCodeLine{2943   \}}
\DoxyCodeLine{2944 }
\DoxyCodeLine{2945   append\_float\_length(format\_ptr, value);}
\DoxyCodeLine{2946   *format\_ptr++ = spec.type();}
\DoxyCodeLine{2947   *format\_ptr = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{2948 }
\DoxyCodeLine{2949   \textcolor{comment}{// Format using snprintf.}}
\DoxyCodeLine{2950   char\_type *start = FMT\_NULL;}
\DoxyCodeLine{2951   \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{2952     std::size\_t buffer\_size = buffer.capacity();}
\DoxyCodeLine{2953     start = \&buffer[0];}
\DoxyCodeLine{2954     \textcolor{keywordtype}{int} result = \mbox{\hyperlink{structinternal_1_1char__traits}{internal::char\_traits<char\_type>::format\_float}}(}
\DoxyCodeLine{2955         start, buffer\_size, format, spec.precision(), value);}
\DoxyCodeLine{2956     \textcolor{keywordflow}{if} (result >= 0) \{}
\DoxyCodeLine{2957       \textcolor{keywordtype}{unsigned} n = internal::to\_unsigned(result);}
\DoxyCodeLine{2958       \textcolor{keywordflow}{if} (n < buffer.capacity()) \{}
\DoxyCodeLine{2959         buffer.resize(n);}
\DoxyCodeLine{2960         \textcolor{keywordflow}{break};  \textcolor{comment}{// The buffer is large enough -\/ continue with formatting.}}
\DoxyCodeLine{2961       \}}
\DoxyCodeLine{2962       buffer.reserve(n + 1);}
\DoxyCodeLine{2963     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2964       \textcolor{comment}{// If result is negative we ask to increase the capacity by at least 1,}}
\DoxyCodeLine{2965       \textcolor{comment}{// but as std::vector, the buffer grows exponentially.}}
\DoxyCodeLine{2966       buffer.reserve(buffer.capacity() + 1);}
\DoxyCodeLine{2967     \}}
\DoxyCodeLine{2968   \}}
\DoxyCodeLine{2969 \}}
\DoxyCodeLine{2970 }
\DoxyCodeLine{2971 \textcolor{comment}{// Reports a system error without throwing an exception.}}
\DoxyCodeLine{2972 \textcolor{comment}{// Can be used to report errors from destructors.}}
\DoxyCodeLine{2973 FMT\_API \textcolor{keywordtype}{void} report\_system\_error(\textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}},}
\DoxyCodeLine{2974                                  \mbox{\hyperlink{classbasic__string__view}{string\_view}} message) FMT\_NOEXCEPT;}
\DoxyCodeLine{2975 }
\DoxyCodeLine{2976 \textcolor{preprocessor}{\#if FMT\_USE\_WINDOWS\_H}}
\DoxyCodeLine{2977 }
\DoxyCodeLine{2979 \textcolor{keyword}{class }windows\_error : \textcolor{keyword}{public} \mbox{\hyperlink{classsystem__error}{system\_error}} \{}
\DoxyCodeLine{2980  \textcolor{keyword}{private}:}
\DoxyCodeLine{2981   FMT\_API \textcolor{keywordtype}{void} init(\textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}}, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \mbox{\hyperlink{structformat__args}{format\_args}} args);}
\DoxyCodeLine{2982 }
\DoxyCodeLine{2983  \textcolor{keyword}{public}:}
\DoxyCodeLine{3012   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3013   windows\_error(\textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}}, \mbox{\hyperlink{classbasic__string__view}{string\_view}} message, \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{3014     init(\mbox{\hyperlink{classerror__code}{error\_code}}, message, make\_format\_args(args...));}
\DoxyCodeLine{3015   \}}
\DoxyCodeLine{3016 \};}
\DoxyCodeLine{3017 }
\DoxyCodeLine{3018 \textcolor{comment}{// Reports a Windows error without throwing an exception.}}
\DoxyCodeLine{3019 \textcolor{comment}{// Can be used to report errors from destructors.}}
\DoxyCodeLine{3020 FMT\_API \textcolor{keywordtype}{void} report\_windows\_error(\textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}},}
\DoxyCodeLine{3021                                   \mbox{\hyperlink{classbasic__string__view}{string\_view}} message) FMT\_NOEXCEPT;}
\DoxyCodeLine{3022 }
\DoxyCodeLine{3023 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3024 }
\DoxyCodeLine{3026 \textcolor{keyword}{class }\mbox{\hyperlink{classformat__int}{format\_int}} \{}
\DoxyCodeLine{3027  \textcolor{keyword}{private}:}
\DoxyCodeLine{3028   \textcolor{comment}{// Buffer should be large enough to hold all digits (digits10 + 1),}}
\DoxyCodeLine{3029   \textcolor{comment}{// a sign and a null character.}}
\DoxyCodeLine{3030   \textcolor{keyword}{enum} \{BUFFER\_SIZE = std::numeric\_limits<unsigned long long>::digits10 + 3\};}
\DoxyCodeLine{3031   \textcolor{keyword}{mutable} \textcolor{keywordtype}{char} buffer\_[BUFFER\_SIZE];}
\DoxyCodeLine{3032   \textcolor{keywordtype}{char} *str\_;}
\DoxyCodeLine{3033 }
\DoxyCodeLine{3034   \textcolor{comment}{// Formats value in reverse and returns a pointer to the beginning.}}
\DoxyCodeLine{3035   \textcolor{keywordtype}{char} *format\_decimal(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{3036     \textcolor{keywordtype}{char} *ptr = buffer\_ + BUFFER\_SIZE -\/ 1;}
\DoxyCodeLine{3037     \textcolor{keywordflow}{while} (value >= 100) \{}
\DoxyCodeLine{3038       \textcolor{comment}{// Integer division is slow so do it for a group of two digits instead}}
\DoxyCodeLine{3039       \textcolor{comment}{// of for every digit. The idea comes from the talk by Alexandrescu}}
\DoxyCodeLine{3040       \textcolor{comment}{// "{}Three Optimization Tips for C++"{}. See speed-\/test for a comparison.}}
\DoxyCodeLine{3041       \textcolor{keywordtype}{unsigned} index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}((value \% 100) * 2);}
\DoxyCodeLine{3042       value /= 100;}
\DoxyCodeLine{3043       *-\/-\/ptr = internal::data::DIGITS[index + 1];}
\DoxyCodeLine{3044       *-\/-\/ptr = internal::data::DIGITS[index];}
\DoxyCodeLine{3045     \}}
\DoxyCodeLine{3046     \textcolor{keywordflow}{if} (value < 10) \{}
\DoxyCodeLine{3047       *-\/-\/ptr = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + value);}
\DoxyCodeLine{3048       \textcolor{keywordflow}{return} ptr;}
\DoxyCodeLine{3049     \}}
\DoxyCodeLine{3050     \textcolor{keywordtype}{unsigned} index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(value * 2);}
\DoxyCodeLine{3051     *-\/-\/ptr = internal::data::DIGITS[index + 1];}
\DoxyCodeLine{3052     *-\/-\/ptr = internal::data::DIGITS[index];}
\DoxyCodeLine{3053     \textcolor{keywordflow}{return} ptr;}
\DoxyCodeLine{3054   \}}
\DoxyCodeLine{3055 }
\DoxyCodeLine{3056   \textcolor{keywordtype}{void} format\_signed(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{3057     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} abs\_value = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value);}
\DoxyCodeLine{3058     \textcolor{keywordtype}{bool} negative = value < 0;}
\DoxyCodeLine{3059     \textcolor{keywordflow}{if} (negative)}
\DoxyCodeLine{3060       abs\_value = 0 -\/ abs\_value;}
\DoxyCodeLine{3061     str\_ = format\_decimal(abs\_value);}
\DoxyCodeLine{3062     \textcolor{keywordflow}{if} (negative)}
\DoxyCodeLine{3063       *-\/-\/str\_ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{3064   \}}
\DoxyCodeLine{3065 }
\DoxyCodeLine{3066  \textcolor{keyword}{public}:}
\DoxyCodeLine{3067   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{int} value) \{ format\_signed(value); \}}
\DoxyCodeLine{3068   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{long} value) \{ format\_signed(value); \}}
\DoxyCodeLine{3069   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{ format\_signed(value); \}}
\DoxyCodeLine{3070   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{unsigned} value) : str\_(format\_decimal(value)) \{\}}
\DoxyCodeLine{3071   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} value) : str\_(format\_decimal(value)) \{\}}
\DoxyCodeLine{3072   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) : str\_(format\_decimal(value)) \{\}}
\DoxyCodeLine{3073 }
\DoxyCodeLine{3075   std::size\_t \mbox{\hyperlink{classformat__int_a644fe6f2d0505d48ff08ab22448b5069}{size}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3076     \textcolor{keywordflow}{return} internal::to\_unsigned(buffer\_ -\/ str\_ + BUFFER\_SIZE -\/ 1);}
\DoxyCodeLine{3077   \}}
\DoxyCodeLine{3078 }
\DoxyCodeLine{3083   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\mbox{\hyperlink{classformat__int_aa29ffc91e940965375ce7c0f646282e8}{data}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} str\_; \}}
\DoxyCodeLine{3084 }
\DoxyCodeLine{3089   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *\mbox{\hyperlink{classformat__int_a82ba80fb78be4551245be3bb4623674d}{c\_str}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3090     buffer\_[BUFFER\_SIZE -\/ 1] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{3091     \textcolor{keywordflow}{return} str\_;}
\DoxyCodeLine{3092   \}}
\DoxyCodeLine{3093 }
\DoxyCodeLine{3099   std::string \mbox{\hyperlink{classformat__int_ab14204962423d35a320f15e673b08e06}{str}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} std::string(str\_, \mbox{\hyperlink{classformat__int_a644fe6f2d0505d48ff08ab22448b5069}{size}}()); \}}
\DoxyCodeLine{3100 \};}
\DoxyCodeLine{3101 }
\DoxyCodeLine{3102 \textcolor{comment}{// Formats a decimal integer value writing into buffer and returns}}
\DoxyCodeLine{3103 \textcolor{comment}{// a pointer to the end of the formatted string. This function doesn't}}
\DoxyCodeLine{3104 \textcolor{comment}{// write a terminating null character.}}
\DoxyCodeLine{3105 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3106 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} format\_decimal(\textcolor{keywordtype}{char} *\&buffer, T value) \{}
\DoxyCodeLine{3107   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structinternal_1_1int__traits}{internal::int\_traits<T>::main\_type}} main\_type;}
\DoxyCodeLine{3108   main\_type abs\_value = \textcolor{keyword}{static\_cast<}main\_type\textcolor{keyword}{>}(value);}
\DoxyCodeLine{3109   \textcolor{keywordflow}{if} (internal::is\_negative(value)) \{}
\DoxyCodeLine{3110     *buffer++ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{3111     abs\_value = 0 -\/ abs\_value;}
\DoxyCodeLine{3112   \}}
\DoxyCodeLine{3113   \textcolor{keywordflow}{if} (abs\_value < 100) \{}
\DoxyCodeLine{3114     \textcolor{keywordflow}{if} (abs\_value < 10) \{}
\DoxyCodeLine{3115       *buffer++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + abs\_value);}
\DoxyCodeLine{3116       \textcolor{keywordflow}{return};}
\DoxyCodeLine{3117     \}}
\DoxyCodeLine{3118     \textcolor{keywordtype}{unsigned} index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(abs\_value * 2);}
\DoxyCodeLine{3119     *buffer++ = internal::data::DIGITS[index];}
\DoxyCodeLine{3120     *buffer++ = internal::data::DIGITS[index + 1];}
\DoxyCodeLine{3121     \textcolor{keywordflow}{return};}
\DoxyCodeLine{3122   \}}
\DoxyCodeLine{3123   \textcolor{keywordtype}{unsigned} num\_digits = internal::count\_digits(abs\_value);}
\DoxyCodeLine{3124   internal::format\_decimal(buffer, abs\_value, num\_digits);}
\DoxyCodeLine{3125   buffer += num\_digits;}
\DoxyCodeLine{3126 \}}
\DoxyCodeLine{3127 }
\DoxyCodeLine{3128 \textcolor{comment}{// Formatter of objects of type T.}}
\DoxyCodeLine{3129 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{3130 \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<}
\DoxyCodeLine{3131     T, Char,}
\DoxyCodeLine{3132     typename std::enable\_if<internal::format\_type<}
\DoxyCodeLine{3133         typename buffer\_context<Char>::type, T>::value>::type> \{}
\DoxyCodeLine{3134 }
\DoxyCodeLine{3135   \textcolor{comment}{// Parses format specifiers stopping either at the end of the range or at the}}
\DoxyCodeLine{3136   \textcolor{comment}{// terminating '\}'.}}
\DoxyCodeLine{3137   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{3138   FMT\_CONSTEXPR \textcolor{keyword}{typename} ParseContext::iterator parse(ParseContext \&ctx) \{}
\DoxyCodeLine{3139     \textcolor{keyword}{auto} it = \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{internal::null\_terminating\_iterator<Char>}}(ctx);}
\DoxyCodeLine{3140     \textcolor{keyword}{typedef} \mbox{\hyperlink{classinternal_1_1dynamic__specs__handler}{internal::dynamic\_specs\_handler<ParseContext>}} handler\_type;}
\DoxyCodeLine{3141     \textcolor{keyword}{auto} type = \mbox{\hyperlink{structinternal_1_1get__type}{internal::get\_type}}<}
\DoxyCodeLine{3142       \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__context}{buffer\_context<Char>::type}}, T>::value;}
\DoxyCodeLine{3143     \mbox{\hyperlink{classinternal_1_1specs__checker}{internal::specs\_checker<handler\_type>}}}
\DoxyCodeLine{3144         handler(handler\_type(specs\_, ctx), type);}
\DoxyCodeLine{3145     it = parse\_format\_specs(it, handler);}
\DoxyCodeLine{3146     \textcolor{keyword}{auto} \mbox{\hyperlink{classformat__spec}{type\_spec}} = specs\_.type();}
\DoxyCodeLine{3147     \textcolor{keyword}{auto} eh = ctx.error\_handler();}
\DoxyCodeLine{3148     \textcolor{keywordflow}{switch} (type) \{}
\DoxyCodeLine{3149     \textcolor{keywordflow}{case} internal::none\_type:}
\DoxyCodeLine{3150     \textcolor{keywordflow}{case} internal::named\_arg\_type:}
\DoxyCodeLine{3151       FMT\_ASSERT(\textcolor{keyword}{false}, \textcolor{stringliteral}{"{}invalid argument type"{}});}
\DoxyCodeLine{3152       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3153     \textcolor{keywordflow}{case} internal::int\_type:}
\DoxyCodeLine{3154     \textcolor{keywordflow}{case} internal::uint\_type:}
\DoxyCodeLine{3155     \textcolor{keywordflow}{case} internal::long\_long\_type:}
\DoxyCodeLine{3156     \textcolor{keywordflow}{case} internal::ulong\_long\_type:}
\DoxyCodeLine{3157     \textcolor{keywordflow}{case} internal::bool\_type:}
\DoxyCodeLine{3158       handle\_int\_type\_spec(}
\DoxyCodeLine{3159             \mbox{\hyperlink{classformat__spec}{type\_spec}}, \mbox{\hyperlink{classinternal_1_1int__type__checker}{internal::int\_type\_checker}}<\textcolor{keyword}{decltype}(eh)>(eh));}
\DoxyCodeLine{3160       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3161     \textcolor{keywordflow}{case} internal::char\_type:}
\DoxyCodeLine{3162       handle\_char\_specs(}
\DoxyCodeLine{3163           \&specs\_,}
\DoxyCodeLine{3164           \mbox{\hyperlink{classinternal_1_1char__specs__checker}{internal::char\_specs\_checker}}<\textcolor{keyword}{decltype}(eh), \textcolor{keyword}{decltype}(\mbox{\hyperlink{classformat__spec}{type\_spec}})>(}
\DoxyCodeLine{3165               \mbox{\hyperlink{classformat__spec}{type\_spec}}, eh));}
\DoxyCodeLine{3166       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3167     \textcolor{keywordflow}{case} internal::double\_type:}
\DoxyCodeLine{3168     \textcolor{keywordflow}{case} internal::long\_double\_type:}
\DoxyCodeLine{3169       handle\_float\_type\_spec(}
\DoxyCodeLine{3170             \mbox{\hyperlink{classformat__spec}{type\_spec}}, \mbox{\hyperlink{classinternal_1_1float__type__checker}{internal::float\_type\_checker}}<\textcolor{keyword}{decltype}(eh)>(eh));}
\DoxyCodeLine{3171       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3172     \textcolor{keywordflow}{case} internal::cstring\_type:}
\DoxyCodeLine{3173       internal::handle\_cstring\_type\_spec(}
\DoxyCodeLine{3174             \mbox{\hyperlink{classformat__spec}{type\_spec}}, \mbox{\hyperlink{classinternal_1_1cstring__type__checker}{internal::cstring\_type\_checker}}<\textcolor{keyword}{decltype}(eh)>(eh));}
\DoxyCodeLine{3175       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3176     \textcolor{keywordflow}{case} internal::string\_type:}
\DoxyCodeLine{3177       internal::check\_string\_type\_spec(\mbox{\hyperlink{classformat__spec}{type\_spec}}, eh);}
\DoxyCodeLine{3178       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3179     \textcolor{keywordflow}{case} internal::pointer\_type:}
\DoxyCodeLine{3180       internal::check\_pointer\_type\_spec(\mbox{\hyperlink{classformat__spec}{type\_spec}}, eh);}
\DoxyCodeLine{3181       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3182     \textcolor{keywordflow}{case} internal::custom\_type:}
\DoxyCodeLine{3183       \textcolor{comment}{// Custom format specifiers should be checked in parse functions of}}
\DoxyCodeLine{3184       \textcolor{comment}{// formatter specializations.}}
\DoxyCodeLine{3185       \textcolor{keywordflow}{break};}
\DoxyCodeLine{3186     \}}
\DoxyCodeLine{3187     \textcolor{keywordflow}{return} pointer\_from(it);}
\DoxyCodeLine{3188   \}}
\DoxyCodeLine{3189 }
\DoxyCodeLine{3190   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{3191   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} T \&val, FormatContext \&ctx) -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{3192     internal::handle\_dynamic\_spec<internal::width\_checker>(}
\DoxyCodeLine{3193       specs\_.width\_, specs\_.width\_ref, ctx);}
\DoxyCodeLine{3194     internal::handle\_dynamic\_spec<internal::precision\_checker>(}
\DoxyCodeLine{3195       specs\_.precision\_, specs\_.precision\_ref, ctx);}
\DoxyCodeLine{3196     \textcolor{keyword}{typedef} \mbox{\hyperlink{classoutput__range}{output\_range}}<\textcolor{keyword}{typename} FormatContext::iterator,}
\DoxyCodeLine{3197                          \textcolor{keyword}{typename} FormatContext::char\_type> range\_type;}
\DoxyCodeLine{3198     \textcolor{keywordflow}{return} fmt::visit(\mbox{\hyperlink{classarg__formatter}{arg\_formatter<range\_type>}}(ctx, \&specs\_),}
\DoxyCodeLine{3199                       internal::make\_arg<FormatContext>(val));}
\DoxyCodeLine{3200   \}}
\DoxyCodeLine{3201 }
\DoxyCodeLine{3202  \textcolor{keyword}{private}:}
\DoxyCodeLine{3203   \mbox{\hyperlink{structinternal_1_1dynamic__format__specs}{internal::dynamic\_format\_specs<Char>}} specs\_;}
\DoxyCodeLine{3204 \};}
\DoxyCodeLine{3205 }
\DoxyCodeLine{3206 \textcolor{comment}{// A formatter for types known only at run time such as variant alternatives.}}
\DoxyCodeLine{3207 \textcolor{comment}{//}}
\DoxyCodeLine{3208 \textcolor{comment}{// Usage:}}
\DoxyCodeLine{3209 \textcolor{comment}{//   typedef std::variant<int, std::string> variant;}}
\DoxyCodeLine{3210 \textcolor{comment}{//   template <>}}
\DoxyCodeLine{3211 \textcolor{comment}{//   struct formatter<variant>: dynamic\_formatter<> \{}}
\DoxyCodeLine{3212 \textcolor{comment}{//     void format(buffer \&buf, const variant \&v, context \&ctx) \{}}
\DoxyCodeLine{3213 \textcolor{comment}{//       visit([\&](const auto \&val) \{ format(buf, val, ctx); \}, v);}}
\DoxyCodeLine{3214 \textcolor{comment}{//     \}}}
\DoxyCodeLine{3215 \textcolor{comment}{//   \};}}
\DoxyCodeLine{3216 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}>}
\DoxyCodeLine{3217 \textcolor{keyword}{class }\mbox{\hyperlink{classdynamic__formatter}{dynamic\_formatter}} \{}
\DoxyCodeLine{3218  \textcolor{keyword}{private}:}
\DoxyCodeLine{3219   \textcolor{keyword}{struct }null\_handler: \mbox{\hyperlink{structinternal_1_1error__handler}{internal::error\_handler}} \{}
\DoxyCodeLine{3220     \textcolor{keywordtype}{void} on\_align(alignment) \{\}}
\DoxyCodeLine{3221     \textcolor{keywordtype}{void} on\_plus() \{\}}
\DoxyCodeLine{3222     \textcolor{keywordtype}{void} on\_minus() \{\}}
\DoxyCodeLine{3223     \textcolor{keywordtype}{void} on\_space() \{\}}
\DoxyCodeLine{3224     \textcolor{keywordtype}{void} on\_hash() \{\}}
\DoxyCodeLine{3225   \};}
\DoxyCodeLine{3226 }
\DoxyCodeLine{3227  \textcolor{keyword}{public}:}
\DoxyCodeLine{3228   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{3229   \textcolor{keyword}{auto} parse(ParseContext \&ctx) -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{3230     \textcolor{keyword}{auto} it = \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{internal::null\_terminating\_iterator<Char>}}(ctx);}
\DoxyCodeLine{3231     \textcolor{comment}{// Checks are deferred to formatting time when the argument type is known.}}
\DoxyCodeLine{3232     \mbox{\hyperlink{classinternal_1_1dynamic__specs__handler}{internal::dynamic\_specs\_handler<ParseContext>}} handler(specs\_, ctx);}
\DoxyCodeLine{3233     it = parse\_format\_specs(it, handler);}
\DoxyCodeLine{3234     \textcolor{keywordflow}{return} pointer\_from(it);}
\DoxyCodeLine{3235   \}}
\DoxyCodeLine{3236 }
\DoxyCodeLine{3237   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{3238   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} T \&val, FormatContext \&ctx) -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{3239     handle\_specs(ctx);}
\DoxyCodeLine{3240     \mbox{\hyperlink{classinternal_1_1specs__checker}{internal::specs\_checker<null\_handler>}}}
\DoxyCodeLine{3241         checker(null\_handler(), \mbox{\hyperlink{structinternal_1_1get__type}{internal::get\_type<FormatContext, T>::value}});}
\DoxyCodeLine{3242     checker.on\_align(specs\_.align());}
\DoxyCodeLine{3243     \textcolor{keywordflow}{if} (specs\_.flags\_ == 0) \{}
\DoxyCodeLine{3244       \textcolor{comment}{// Do nothing.}}
\DoxyCodeLine{3245     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (specs\_.flag(SIGN\_FLAG)) \{}
\DoxyCodeLine{3246       \textcolor{keywordflow}{if} (specs\_.flag(PLUS\_FLAG))}
\DoxyCodeLine{3247         checker.on\_plus();}
\DoxyCodeLine{3248       \textcolor{keywordflow}{else}}
\DoxyCodeLine{3249         checker.on\_space();}
\DoxyCodeLine{3250     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (specs\_.flag(MINUS\_FLAG)) \{}
\DoxyCodeLine{3251       checker.on\_minus();}
\DoxyCodeLine{3252     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (specs\_.flag(HASH\_FLAG)) \{}
\DoxyCodeLine{3253       checker.on\_hash();}
\DoxyCodeLine{3254     \}}
\DoxyCodeLine{3255     \textcolor{keywordflow}{if} (specs\_.precision\_ != -\/1)}
\DoxyCodeLine{3256       checker.end\_precision();}
\DoxyCodeLine{3257     \textcolor{keyword}{typedef} \mbox{\hyperlink{classoutput__range}{output\_range}}<\textcolor{keyword}{typename} FormatContext::iterator,}
\DoxyCodeLine{3258                          \textcolor{keyword}{typename} FormatContext::char\_type> range;}
\DoxyCodeLine{3259     fmt::visit(\mbox{\hyperlink{classarg__formatter}{arg\_formatter<range>}}(ctx, \&specs\_),}
\DoxyCodeLine{3260                internal::make\_arg<FormatContext>(val));}
\DoxyCodeLine{3261     \textcolor{keywordflow}{return} ctx.out();}
\DoxyCodeLine{3262   \}}
\DoxyCodeLine{3263 }
\DoxyCodeLine{3264  \textcolor{keyword}{private}:}
\DoxyCodeLine{3265   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{3266   \textcolor{keywordtype}{void} handle\_specs(Context \&ctx) \{}
\DoxyCodeLine{3267     internal::handle\_dynamic\_spec<internal::width\_checker>(}
\DoxyCodeLine{3268       specs\_.width\_, specs\_.width\_ref, ctx);}
\DoxyCodeLine{3269     internal::handle\_dynamic\_spec<internal::precision\_checker>(}
\DoxyCodeLine{3270       specs\_.precision\_, specs\_.precision\_ref, ctx);}
\DoxyCodeLine{3271   \}}
\DoxyCodeLine{3272 }
\DoxyCodeLine{3273   \mbox{\hyperlink{structinternal_1_1dynamic__format__specs}{internal::dynamic\_format\_specs<Char>}} specs\_;}
\DoxyCodeLine{3274 \};}
\DoxyCodeLine{3275 }
\DoxyCodeLine{3276 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{3277 \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_context<Range, Char>::format\_arg}}}
\DoxyCodeLine{3278   \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context<Range, Char>::get\_arg}}(}
\DoxyCodeLine{3279     \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} name) \{}
\DoxyCodeLine{3280   map\_.init(this-\/>args());}
\DoxyCodeLine{3281   format\_arg arg = map\_.find(name);}
\DoxyCodeLine{3282   \textcolor{keywordflow}{if} (arg.type() == internal::none\_type)}
\DoxyCodeLine{3283     this-\/>on\_error(\textcolor{stringliteral}{"{}argument not found"{}});}
\DoxyCodeLine{3284   \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{3285 \}}
\DoxyCodeLine{3286 }
\DoxyCodeLine{3287 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ArgFormatter, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{3288 \textcolor{keyword}{struct }\mbox{\hyperlink{structformat__handler}{format\_handler}} : \mbox{\hyperlink{structinternal_1_1error__handler}{internal::error\_handler}} \{}
\DoxyCodeLine{3289   \textcolor{keyword}{typedef} \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{internal::null\_terminating\_iterator<Char>}} \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{iterator}};}
\DoxyCodeLine{3290   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ArgFormatter::range range;}
\DoxyCodeLine{3291 }
\DoxyCodeLine{3292   \mbox{\hyperlink{structformat__handler}{format\_handler}}(range r, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str,}
\DoxyCodeLine{3293                  \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<Context>}} \mbox{\hyperlink{structformat__args}{format\_args}})}
\DoxyCodeLine{3294     : context(r.begin(), str, \mbox{\hyperlink{structformat__args}{format\_args}}) \{\}}
\DoxyCodeLine{3295 }
\DoxyCodeLine{3296   \textcolor{keywordtype}{void} on\_text(\textcolor{keyword}{const} Char *begin, \textcolor{keyword}{const} Char *end) \{}
\DoxyCodeLine{3297     \textcolor{keyword}{auto} size = internal::to\_unsigned(end -\/ begin);}
\DoxyCodeLine{3298     \textcolor{keyword}{auto} out = context.out();}
\DoxyCodeLine{3299     \textcolor{keyword}{auto} \&\&it = internal::reserve(out, size);}
\DoxyCodeLine{3300     it = std::copy\_n(begin, size, it);}
\DoxyCodeLine{3301     context.advance\_to(out);}
\DoxyCodeLine{3302   \}}
\DoxyCodeLine{3303 }
\DoxyCodeLine{3304   \textcolor{keywordtype}{void} on\_arg\_id() \{ arg = context.next\_arg(); \}}
\DoxyCodeLine{3305   \textcolor{keywordtype}{void} on\_arg\_id(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{3306     context.parse\_context().check\_arg\_id(\textcolor{keywordtype}{id});}
\DoxyCodeLine{3307     arg = context.get\_arg(\textcolor{keywordtype}{id});}
\DoxyCodeLine{3308   \}}
\DoxyCodeLine{3309   \textcolor{keywordtype}{void} on\_arg\_id(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{3310     arg = context.get\_arg(\textcolor{keywordtype}{id});}
\DoxyCodeLine{3311   \}}
\DoxyCodeLine{3312 }
\DoxyCodeLine{3313   \textcolor{keywordtype}{void} on\_replacement\_field(\textcolor{keyword}{const} Char *p) \{}
\DoxyCodeLine{3314     context.parse\_context().advance\_to(p);}
\DoxyCodeLine{3315     \textcolor{keywordflow}{if} (!fmt::visit(\mbox{\hyperlink{classinternal_1_1custom__formatter}{internal::custom\_formatter<Char, Context>}}(context), arg))}
\DoxyCodeLine{3316       context.advance\_to(fmt::visit(ArgFormatter(context), arg));}
\DoxyCodeLine{3317   \}}
\DoxyCodeLine{3318 }
\DoxyCodeLine{3319   \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{iterator}} on\_format\_specs(\mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{iterator}} it) \{}
\DoxyCodeLine{3320     \textcolor{keyword}{auto}\& parse\_ctx = context.parse\_context();}
\DoxyCodeLine{3321     parse\_ctx.advance\_to(pointer\_from(it));}
\DoxyCodeLine{3322     \textcolor{keywordflow}{if} (fmt::visit(\mbox{\hyperlink{classinternal_1_1custom__formatter}{internal::custom\_formatter<Char, Context>}}(context), arg))}
\DoxyCodeLine{3323       \textcolor{keywordflow}{return} \mbox{\hyperlink{classinternal_1_1null__terminating__iterator}{iterator}}(parse\_ctx);}
\DoxyCodeLine{3324     \mbox{\hyperlink{classbasic__format__specs}{basic\_format\_specs<Char>}} specs;}
\DoxyCodeLine{3325     \textcolor{keyword}{using} \mbox{\hyperlink{classinternal_1_1specs__handler}{internal::specs\_handler}};}
\DoxyCodeLine{3326     \mbox{\hyperlink{classinternal_1_1specs__checker}{internal::specs\_checker<specs\_handler<Context>}}>}
\DoxyCodeLine{3327         handler(specs\_handler<Context>(specs, context), arg.type());}
\DoxyCodeLine{3328     it = parse\_format\_specs(it, handler);}
\DoxyCodeLine{3329     \textcolor{keywordflow}{if} (*it != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{3330       on\_error(\textcolor{stringliteral}{"{}missing '\}' in format string"{}});}
\DoxyCodeLine{3331     parse\_ctx.advance\_to(pointer\_from(it));}
\DoxyCodeLine{3332     context.advance\_to(fmt::visit(ArgFormatter(context, \&specs), arg));}
\DoxyCodeLine{3333     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{3334   \}}
\DoxyCodeLine{3335 }
\DoxyCodeLine{3336   Context context;}
\DoxyCodeLine{3337   \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} arg;}
\DoxyCodeLine{3338 \};}
\DoxyCodeLine{3339 }
\DoxyCodeLine{3341 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ArgFormatter, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{3342 \textcolor{keyword}{typename} Context::iterator vformat\_to(\textcolor{keyword}{typename} ArgFormatter::range out,}
\DoxyCodeLine{3343                                       \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str,}
\DoxyCodeLine{3344                                       \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<Context>}} args) \{}
\DoxyCodeLine{3345   \mbox{\hyperlink{structformat__handler}{format\_handler<ArgFormatter, Char, Context>}} h(out, format\_str, args);}
\DoxyCodeLine{3346   internal::parse\_format\_string<false>(format\_str, h);}
\DoxyCodeLine{3347   \textcolor{keywordflow}{return} h.context.out();}
\DoxyCodeLine{3348 \}}
\DoxyCodeLine{3349 }
\DoxyCodeLine{3350 \textcolor{comment}{// Casts ``p`` to ``const void*`` for pointer formatting.}}
\DoxyCodeLine{3351 \textcolor{comment}{// Example:}}
\DoxyCodeLine{3352 \textcolor{comment}{//   auto s = format("{}\{\}"{}, ptr(p));}}
\DoxyCodeLine{3353 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3354 \textcolor{keyword}{inline} \textcolor{keyword}{const} \textcolor{keywordtype}{void} *ptr(\textcolor{keyword}{const} T *p) \{ \textcolor{keywordflow}{return} p; \}}
\DoxyCodeLine{3355 }
\DoxyCodeLine{3356 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{3357 \textcolor{keyword}{struct }\mbox{\hyperlink{structarg__join}{arg\_join}} \{}
\DoxyCodeLine{3358   It begin;}
\DoxyCodeLine{3359   It end;}
\DoxyCodeLine{3360   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} sep;}
\DoxyCodeLine{3361 }
\DoxyCodeLine{3362   \mbox{\hyperlink{structarg__join}{arg\_join}}(It begin, It end, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} sep)}
\DoxyCodeLine{3363     : begin(begin), end(end), sep(sep) \{\}}
\DoxyCodeLine{3364 \};}
\DoxyCodeLine{3365 }
\DoxyCodeLine{3366 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{3367 \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<\mbox{\hyperlink{structarg__join}{arg\_join}}<It, Char>, Char>:}
\DoxyCodeLine{3368     \mbox{\hyperlink{structformatter}{formatter}}<typename std::iterator\_traits<It>::value\_type, Char> \{}
\DoxyCodeLine{3369   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{3370   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} \mbox{\hyperlink{structarg__join}{arg\_join<It, Char>}} \&value, FormatContext \&ctx)}
\DoxyCodeLine{3371       -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{3372     \textcolor{keyword}{typedef} \mbox{\hyperlink{structformatter}{formatter<typename std::iterator\_traits<It>::value\_type}}, Char> \mbox{\hyperlink{classbase}{base}};}
\DoxyCodeLine{3373     \textcolor{keyword}{auto} it = value.begin;}
\DoxyCodeLine{3374     \textcolor{keyword}{auto} out = ctx.out();}
\DoxyCodeLine{3375     \textcolor{keywordflow}{if} (it != value.end) \{}
\DoxyCodeLine{3376       out = base::format(*it++, ctx);}
\DoxyCodeLine{3377       \textcolor{keywordflow}{while} (it != value.end) \{}
\DoxyCodeLine{3378         out = \mbox{\hyperlink{namespacecl_a1197a833cdd6664f206b079f2bebd2eb}{std::copy}}(value.sep.begin(), value.sep.end(), out);}
\DoxyCodeLine{3379         ctx.advance\_to(out);}
\DoxyCodeLine{3380         out = base::format(*it++, ctx);}
\DoxyCodeLine{3381       \}}
\DoxyCodeLine{3382     \}}
\DoxyCodeLine{3383     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{3384   \}}
\DoxyCodeLine{3385 \};}
\DoxyCodeLine{3386 }
\DoxyCodeLine{3387 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It>}
\DoxyCodeLine{3388 \mbox{\hyperlink{structarg__join}{arg\_join<It, char>}} join(It begin, It end, \mbox{\hyperlink{classbasic__string__view}{string\_view}} sep) \{}
\DoxyCodeLine{3389   \textcolor{keywordflow}{return} \mbox{\hyperlink{structarg__join}{arg\_join<It, char>}}(begin, end, sep);}
\DoxyCodeLine{3390 \}}
\DoxyCodeLine{3391 }
\DoxyCodeLine{3392 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It>}
\DoxyCodeLine{3393 \mbox{\hyperlink{structarg__join}{arg\_join<It, wchar\_t>}} join(It begin, It end, \mbox{\hyperlink{classbasic__string__view}{wstring\_view}} sep) \{}
\DoxyCodeLine{3394   \textcolor{keywordflow}{return} \mbox{\hyperlink{structarg__join}{arg\_join<It, wchar\_t>}}(begin, end, sep);}
\DoxyCodeLine{3395 \}}
\DoxyCodeLine{3396 }
\DoxyCodeLine{3397 \textcolor{comment}{// The following causes ICE in gcc 4.4.}}
\DoxyCodeLine{3398 \textcolor{preprocessor}{\#if FMT\_USE\_TRAILING\_RETURN \&\& (!FMT\_GCC\_VERSION || FMT\_GCC\_VERSION >= 405)}}
\DoxyCodeLine{3399 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{3400 \textcolor{keyword}{auto} join(\textcolor{keyword}{const} Range \&range, \mbox{\hyperlink{classbasic__string__view}{string\_view}} sep)}
\DoxyCodeLine{3401     -\/> \mbox{\hyperlink{structarg__join}{arg\_join}}<\textcolor{keyword}{decltype}(internal::begin(range)), \textcolor{keywordtype}{char}> \{}
\DoxyCodeLine{3402   \textcolor{keywordflow}{return} join(internal::begin(range), internal::end(range), sep);}
\DoxyCodeLine{3403 \}}
\DoxyCodeLine{3404 }
\DoxyCodeLine{3405 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{3406 \textcolor{keyword}{auto} join(\textcolor{keyword}{const} Range \&range, \mbox{\hyperlink{classbasic__string__view}{wstring\_view}} sep)}
\DoxyCodeLine{3407     -\/> \mbox{\hyperlink{structarg__join}{arg\_join}}<\textcolor{keyword}{decltype}(internal::begin(range)), \textcolor{keywordtype}{wchar\_t}> \{}
\DoxyCodeLine{3408   \textcolor{keywordflow}{return} join(internal::begin(range), internal::end(range), sep);}
\DoxyCodeLine{3409 \}}
\DoxyCodeLine{3410 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3411 }
\DoxyCodeLine{3424 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3425 std::string to\_string(\textcolor{keyword}{const} T \&value) \{}
\DoxyCodeLine{3426   std::string str;}
\DoxyCodeLine{3427   \mbox{\hyperlink{classinternal_1_1container__buffer}{internal::container\_buffer<std::string>}} buf(str);}
\DoxyCodeLine{3428   \mbox{\hyperlink{classbasic__writer}{writer}}(buf).write(value);}
\DoxyCodeLine{3429   \textcolor{keywordflow}{return} str;}
\DoxyCodeLine{3430 \}}
\DoxyCodeLine{3431 }
\DoxyCodeLine{3435 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3436 std::wstring to\_wstring(\textcolor{keyword}{const} T \&value) \{}
\DoxyCodeLine{3437   std::wstring str;}
\DoxyCodeLine{3438   \mbox{\hyperlink{classinternal_1_1container__buffer}{internal::container\_buffer<std::wstring>}} buf(str);}
\DoxyCodeLine{3439   \mbox{\hyperlink{classbasic__writer}{wwriter}}(buf).write(value);}
\DoxyCodeLine{3440   \textcolor{keywordflow}{return} str;}
\DoxyCodeLine{3441 \}}
\DoxyCodeLine{3442 }
\DoxyCodeLine{3443 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, std::\textcolor{keywordtype}{size\_t} SIZE>}
\DoxyCodeLine{3444 std::basic\_string<Char> to\_string(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char, SIZE>}} \&buf) \{}
\DoxyCodeLine{3445   \textcolor{keywordflow}{return} std::basic\_string<Char>(buf.\mbox{\hyperlink{classinternal_1_1basic__buffer_a4716afee355656cd70e6719e5c0e6d62}{data}}(), buf.\mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}}());}
\DoxyCodeLine{3446 \}}
\DoxyCodeLine{3447 }
\DoxyCodeLine{3448 \textcolor{keyword}{inline} format\_context::iterator vformat\_to(}
\DoxyCodeLine{3449     \mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::buffer}} \&buf, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \mbox{\hyperlink{structformat__args}{format\_args}} args) \{}
\DoxyCodeLine{3450   \textcolor{keyword}{typedef} \mbox{\hyperlink{classback__insert__range}{back\_insert\_range<internal::buffer>}} range;}
\DoxyCodeLine{3451   \textcolor{keywordflow}{return} vformat\_to<arg\_formatter<range>>(buf, format\_str, args);}
\DoxyCodeLine{3452 \}}
\DoxyCodeLine{3453 }
\DoxyCodeLine{3454 \textcolor{keyword}{inline} wformat\_context::iterator vformat\_to(}
\DoxyCodeLine{3455     \mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::wbuffer}} \&buf, \mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str, \mbox{\hyperlink{structwformat__args}{wformat\_args}} args) \{}
\DoxyCodeLine{3456   \textcolor{keyword}{typedef} \mbox{\hyperlink{classback__insert__range}{back\_insert\_range<internal::wbuffer>}} range;}
\DoxyCodeLine{3457   \textcolor{keywordflow}{return} vformat\_to<arg\_formatter<range>>(buf, format\_str, args);}
\DoxyCodeLine{3458 \}}
\DoxyCodeLine{3459 }
\DoxyCodeLine{3460 \textcolor{keyword}{template} <}
\DoxyCodeLine{3461     \textcolor{keyword}{typename} String, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{3462     std::size\_t SIZE = inline\_buffer\_size,}
\DoxyCodeLine{3463     \textcolor{keyword}{typename} Char = \textcolor{keyword}{typename} \mbox{\hyperlink{structinternal_1_1format__string__traits}{internal::format\_string\_traits<String>::char\_type}}>}
\DoxyCodeLine{3464 \textcolor{keyword}{inline} \textcolor{keyword}{typename} buffer\_context<Char>::type::iterator format\_to(}
\DoxyCodeLine{3465     \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char, SIZE>}} \&buf, \textcolor{keyword}{const} String \&format\_str,}
\DoxyCodeLine{3466     \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{3467   internal::check\_format\_string<Args...>(format\_str);}
\DoxyCodeLine{3468   \textcolor{keywordflow}{return} vformat\_to(}
\DoxyCodeLine{3469         buf, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(format\_str),}
\DoxyCodeLine{3470         make\_format\_args<\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__context}{buffer\_context<Char>::type}}>(args...));}
\DoxyCodeLine{3471 \}}
\DoxyCodeLine{3472 }
\DoxyCodeLine{3473 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}>}
\DoxyCodeLine{3474 \textcolor{comment}{//using format\_context\_t = basic\_format\_context<OutputIt, Char>;}}
\DoxyCodeLine{3475 \textcolor{keyword}{struct }\mbox{\hyperlink{structformat__context__t}{format\_context\_t}} \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context<OutputIt, Char>}} \mbox{\hyperlink{classbasic__format__context}{type}}; \};}
\DoxyCodeLine{3476 }
\DoxyCodeLine{3477 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}>}
\DoxyCodeLine{3478 \textcolor{comment}{//using format\_args\_t = basic\_format\_args<format\_context\_t<OutputIt, Char>>;}}
\DoxyCodeLine{3479 \textcolor{keyword}{struct }\mbox{\hyperlink{structformat__args__t}{format\_args\_t}} \{}
\DoxyCodeLine{3480   \textcolor{keyword}{typedef} \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<}
\DoxyCodeLine{3481     \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__context}{format\_context\_t<OutputIt, Char>::type}}> \mbox{\hyperlink{classbasic__format__args}{type}};}
\DoxyCodeLine{3482 \};}
\DoxyCodeLine{3483 }
\DoxyCodeLine{3484 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3485 \textcolor{keyword}{inline} OutputIt vformat\_to(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str,}
\DoxyCodeLine{3486                            \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__args}{format\_args\_t<OutputIt>::type}} args) \{}
\DoxyCodeLine{3487   \textcolor{keyword}{typedef} \mbox{\hyperlink{classoutput__range}{output\_range<OutputIt, char>}} range;}
\DoxyCodeLine{3488   \textcolor{keywordflow}{return} vformat\_to<arg\_formatter<range>>(range(out), format\_str, args);}
\DoxyCodeLine{3489 \}}
\DoxyCodeLine{3490 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3491 \textcolor{keyword}{inline} OutputIt vformat\_to(}
\DoxyCodeLine{3492     OutputIt out, \mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str,}
\DoxyCodeLine{3493     \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__args}{format\_args\_t<OutputIt, wchar\_t>::type}} args) \{}
\DoxyCodeLine{3494   \textcolor{keyword}{typedef} \mbox{\hyperlink{classoutput__range}{output\_range<OutputIt, wchar\_t>}} range;}
\DoxyCodeLine{3495   \textcolor{keywordflow}{return} vformat\_to<arg\_formatter<range>>(range(out), format\_str, args);}
\DoxyCodeLine{3496 \}}
\DoxyCodeLine{3497 }
\DoxyCodeLine{3509 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3510 \textcolor{keyword}{inline} OutputIt format\_to(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str,}
\DoxyCodeLine{3511                           \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{3512   \textcolor{keywordflow}{return} vformat\_to(out, format\_str,}
\DoxyCodeLine{3513       make\_format\_args<\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__context}{format\_context\_t<OutputIt>::type}}>(args...));}
\DoxyCodeLine{3514 \}}
\DoxyCodeLine{3515 }
\DoxyCodeLine{3516 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{3517 \textcolor{keyword}{struct }\mbox{\hyperlink{structformat__to__n__result}{format\_to\_n\_result}} \{}
\DoxyCodeLine{3519   OutputIt \mbox{\hyperlink{structformat__to__n__result_a90597c6c1d23c7301aef16e756c6263b}{out}};}
\DoxyCodeLine{3521   std::size\_t \mbox{\hyperlink{structformat__to__n__result_a5d0924cddcfab39a1c38ff0e75cbe5bf}{size}};}
\DoxyCodeLine{3522 \};}
\DoxyCodeLine{3523 }
\DoxyCodeLine{3524 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{3525 \textcolor{keyword}{using} format\_to\_n\_context = \textcolor{keyword}{typename} fmt::format\_context\_t<}
\DoxyCodeLine{3526   fmt::internal::truncating\_iterator<OutputIt>>::type;}
\DoxyCodeLine{3527 }
\DoxyCodeLine{3528 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{3529 \textcolor{keyword}{using} format\_to\_n\_args = fmt::basic\_format\_args<format\_to\_n\_context<OutputIt>>;}
\DoxyCodeLine{3530 }
\DoxyCodeLine{3531 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} ...Args>}
\DoxyCodeLine{3532 \textcolor{keyword}{inline} \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store<format\_to\_n\_context<OutputIt>}}, Args...>}
\DoxyCodeLine{3533     make\_format\_to\_n\_args(\textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{3534   \textcolor{keywordflow}{return} \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store<format\_to\_n\_context<OutputIt>}}, Args...>(args...);}
\DoxyCodeLine{3535 \}}
\DoxyCodeLine{3536 }
\DoxyCodeLine{3537 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3538 \textcolor{keyword}{inline} \mbox{\hyperlink{structformat__to__n__result}{format\_to\_n\_result<OutputIt>}} vformat\_to\_n(}
\DoxyCodeLine{3539     OutputIt out, std::size\_t n, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str,}
\DoxyCodeLine{3540     format\_to\_n\_args<OutputIt> args) \{}
\DoxyCodeLine{3541   \textcolor{keyword}{typedef} \mbox{\hyperlink{classinternal_1_1truncating__iterator}{internal::truncating\_iterator<OutputIt>}} It;}
\DoxyCodeLine{3542   \textcolor{keyword}{auto} it = vformat\_to(It(out, n), format\_str, args);}
\DoxyCodeLine{3543   \textcolor{keywordflow}{return} \{it.base(), it.count()\};}
\DoxyCodeLine{3544 \}}
\DoxyCodeLine{3545 }
\DoxyCodeLine{3553 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3554 \textcolor{keyword}{inline} \mbox{\hyperlink{structformat__to__n__result}{format\_to\_n\_result<OutputIt>}} format\_to\_n(}
\DoxyCodeLine{3555     OutputIt out, std::size\_t n, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \textcolor{keyword}{const} Args \&... args) \{}
\DoxyCodeLine{3556   \textcolor{keywordflow}{return} vformat\_to\_n<OutputIt>(}
\DoxyCodeLine{3557     out, n, format\_str, make\_format\_to\_n\_args<OutputIt>(args...));}
\DoxyCodeLine{3558 \}}
\DoxyCodeLine{3559 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3560 \textcolor{keyword}{inline} \mbox{\hyperlink{structformat__to__n__result}{format\_to\_n\_result<OutputIt>}} format\_to\_n(}
\DoxyCodeLine{3561     OutputIt out, std::size\_t n, \mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str,}
\DoxyCodeLine{3562     \textcolor{keyword}{const} Args \&... args) \{}
\DoxyCodeLine{3563   \textcolor{keyword}{typedef} \mbox{\hyperlink{classinternal_1_1truncating__iterator}{internal::truncating\_iterator<OutputIt>}} It;}
\DoxyCodeLine{3564   \textcolor{keyword}{auto} it = vformat\_to(It(out, n), format\_str,}
\DoxyCodeLine{3565       make\_format\_args<\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__context}{format\_context\_t<It, wchar\_t>::type}}>(args...));}
\DoxyCodeLine{3566   \textcolor{keywordflow}{return} \{it.base(), it.count()\};}
\DoxyCodeLine{3567 \}}
\DoxyCodeLine{3568 }
\DoxyCodeLine{3569 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{3570 \textcolor{keyword}{inline} std::basic\_string<Char> internal::vformat(}
\DoxyCodeLine{3571     \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str,}
\DoxyCodeLine{3572     \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__context}{buffer\_context<Char>::type}}> args) \{}
\DoxyCodeLine{3573   \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char>}} buffer;}
\DoxyCodeLine{3574   vformat\_to(buffer, format\_str, args);}
\DoxyCodeLine{3575   \textcolor{keywordflow}{return} fmt::to\_string(buffer);}
\DoxyCodeLine{3576 \}}
\DoxyCodeLine{3577 }
\DoxyCodeLine{3578 \textcolor{keyword}{template} <\textcolor{keyword}{typename} String, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3579 \textcolor{keyword}{inline} \textcolor{keyword}{typename} std::enable\_if<internal::is\_compile\_string<String>::value>::type}
\DoxyCodeLine{3580     print(String format\_str, \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{3581   internal::check\_format\_string<Args...>(format\_str);}
\DoxyCodeLine{3582   \textcolor{keywordflow}{return} vprint(format\_str.data(), make\_format\_args(args...));}
\DoxyCodeLine{3583 \}}
\DoxyCodeLine{3584 }
\DoxyCodeLine{3589 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3590 \textcolor{keyword}{inline} std::size\_t formatted\_size(\mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str,}
\DoxyCodeLine{3591                                   \textcolor{keyword}{const} Args \& ... args) \{}
\DoxyCodeLine{3592   \textcolor{keyword}{auto} it = format\_to(\mbox{\hyperlink{classinternal_1_1counting__iterator}{internal::counting\_iterator<char>}}(), format\_str, args...);}
\DoxyCodeLine{3593   \textcolor{keywordflow}{return} it.count();}
\DoxyCodeLine{3594 \}}
\DoxyCodeLine{3595 }
\DoxyCodeLine{3596 \textcolor{preprocessor}{\#if FMT\_USE\_USER\_DEFINED\_LITERALS}}
\DoxyCodeLine{3597 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{3598 }
\DoxyCodeLine{3599 \textcolor{preprocessor}{\# if FMT\_UDL\_TEMPLATE}}
\DoxyCodeLine{3600 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, Char... CHARS>}
\DoxyCodeLine{3601 \textcolor{keyword}{class }udl\_formatter \{}
\DoxyCodeLine{3602  \textcolor{keyword}{public}:}
\DoxyCodeLine{3603   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3604   std::basic\_string<Char> operator()(\textcolor{keyword}{const} Args \&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3605     FMT\_CONSTEXPR\_DECL Char s[] = \{CHARS..., \textcolor{charliteral}{'\(\backslash\)0'}\};}
\DoxyCodeLine{3606     FMT\_CONSTEXPR\_DECL \textcolor{keywordtype}{bool} invalid\_format =}
\DoxyCodeLine{3607         check\_format\_string<Char, error\_handler, Args...>(}
\DoxyCodeLine{3608           \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(s, \textcolor{keyword}{sizeof}...(CHARS)));}
\DoxyCodeLine{3609     (void)invalid\_format;}
\DoxyCodeLine{3610     \textcolor{keywordflow}{return} format(s, args...);}
\DoxyCodeLine{3611   \}}
\DoxyCodeLine{3612 \};}
\DoxyCodeLine{3613 \textcolor{preprocessor}{\# else}}
\DoxyCodeLine{3614 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{3615 \textcolor{keyword}{struct }udl\_formatter \{}
\DoxyCodeLine{3616   \textcolor{keyword}{const} Char *str;}
\DoxyCodeLine{3617 }
\DoxyCodeLine{3618   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3619   \textcolor{keyword}{auto} operator()(Args \&\& ... args) \textcolor{keyword}{const}}
\DoxyCodeLine{3620                   -\/> \textcolor{keyword}{decltype}(format(str, std::forward<Args>(args)...)) \{}
\DoxyCodeLine{3621     \textcolor{keywordflow}{return} format(str, std::forward<Args>(args)...);}
\DoxyCodeLine{3622   \}}
\DoxyCodeLine{3623 \};}
\DoxyCodeLine{3624 \textcolor{preprocessor}{\# endif }\textcolor{comment}{// FMT\_UDL\_TEMPLATE}}
\DoxyCodeLine{3625 }
\DoxyCodeLine{3626 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{3627 \textcolor{keyword}{struct }udl\_arg \{}
\DoxyCodeLine{3628   \textcolor{keyword}{const} Char *str;}
\DoxyCodeLine{3629 }
\DoxyCodeLine{3630   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3631   named\_arg<T, Char> operator=(T \&\&value)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3632     \textcolor{keywordflow}{return} \{str, std::forward<T>(value)\};}
\DoxyCodeLine{3633   \}}
\DoxyCodeLine{3634 \};}
\DoxyCodeLine{3635 }
\DoxyCodeLine{3636 \} \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{3637 }
\DoxyCodeLine{3638 \textcolor{keyword}{inline} \textcolor{keyword}{namespace }literals \{}
\DoxyCodeLine{3639 }
\DoxyCodeLine{3640 \textcolor{preprocessor}{\# if FMT\_UDL\_TEMPLATE}}
\DoxyCodeLine{3641 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, Char... CHARS>}
\DoxyCodeLine{3642 FMT\_CONSTEXPR internal::udl\_formatter<Char, CHARS...> \textcolor{keyword}{operator}\textcolor{stringliteral}{"{}"{}}\_format() \{}
\DoxyCodeLine{3643   \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{3644 \}}
\DoxyCodeLine{3645 \textcolor{preprocessor}{\# else}}
\DoxyCodeLine{3656 \textcolor{keyword}{inline} internal::udl\_formatter<char>}
\DoxyCodeLine{3657 \textcolor{keyword}{operator}\textcolor{stringliteral}{"{}"{}} \_format(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, std::size\_t) \{ \textcolor{keywordflow}{return} \{s\}; \}}
\DoxyCodeLine{3658 \textcolor{keyword}{inline} internal::udl\_formatter<wchar\_t>}
\DoxyCodeLine{3659 \textcolor{keyword}{operator}\textcolor{stringliteral}{"{}"{}} \_format(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t} *s, std::size\_t) \{ \textcolor{keywordflow}{return} \{s\}; \}}
\DoxyCodeLine{3660 \textcolor{preprocessor}{\# endif }\textcolor{comment}{// FMT\_UDL\_TEMPLATE}}
\DoxyCodeLine{3661 }
\DoxyCodeLine{3672 \textcolor{keyword}{inline} internal::udl\_arg<char>}
\DoxyCodeLine{3673 \textcolor{keyword}{operator}\textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *s, std::size\_t) \{ \textcolor{keywordflow}{return} \{s\}; \}}
\DoxyCodeLine{3674 \textcolor{keyword}{inline} internal::udl\_arg<wchar\_t>}
\DoxyCodeLine{3675 \textcolor{keyword}{operator}\textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t} *s, std::size\_t) \{ \textcolor{keywordflow}{return} \{s\}; \}}
\DoxyCodeLine{3676 \} \textcolor{comment}{// inline namespace literals}}
\DoxyCodeLine{3677 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// FMT\_USE\_USER\_DEFINED\_LITERALS}}
\DoxyCodeLine{3678 FMT\_END\_NAMESPACE}
\DoxyCodeLine{3679 }
\DoxyCodeLine{3680 \textcolor{preprocessor}{\#define FMT\_STRING(s) [] \{ \(\backslash\)}}
\DoxyCodeLine{3681 \textcolor{preprocessor}{    typedef typename std::decay<decltype(s)>::type pointer; \(\backslash\)}}
\DoxyCodeLine{3682 \textcolor{preprocessor}{    struct S : fmt::compile\_string \{ \(\backslash\)}}
\DoxyCodeLine{3683 \textcolor{preprocessor}{      static FMT\_CONSTEXPR pointer data() \{ return s; \} \(\backslash\)}}
\DoxyCodeLine{3684 \textcolor{preprocessor}{      static FMT\_CONSTEXPR size\_t size() \{ return sizeof(s); \} \(\backslash\)}}
\DoxyCodeLine{3685 \textcolor{preprocessor}{      explicit operator fmt::string\_view() const \{ return s; \} \(\backslash\)}}
\DoxyCodeLine{3686 \textcolor{preprocessor}{    \}; \(\backslash\)}}
\DoxyCodeLine{3687 \textcolor{preprocessor}{    return S\{\}; \(\backslash\)}}
\DoxyCodeLine{3688 \textcolor{preprocessor}{  \}()}}
\DoxyCodeLine{3689 }
\DoxyCodeLine{3690 \textcolor{preprocessor}{\#if defined(FMT\_STRING\_ALIAS) \&\& FMT\_STRING\_ALIAS}}
\DoxyCodeLine{3705 \textcolor{preprocessor}{\# define fmt(s) FMT\_STRING(s)}}
\DoxyCodeLine{3706 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3707 }
\DoxyCodeLine{3708 \textcolor{preprocessor}{\#ifdef FMT\_HEADER\_ONLY}}
\DoxyCodeLine{3709 \textcolor{preprocessor}{\# define FMT\_FUNC inline}}
\DoxyCodeLine{3710 \textcolor{preprocessor}{\# include "{}format-\/inl.h"{}}}
\DoxyCodeLine{3711 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3712 \textcolor{preprocessor}{\# define FMT\_FUNC}}
\DoxyCodeLine{3713 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3714 }
\DoxyCodeLine{3715 \textcolor{comment}{// Restore warnings.}}
\DoxyCodeLine{3716 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION >= 406 || FMT\_CLANG\_VERSION}}
\DoxyCodeLine{3717 \textcolor{preprocessor}{\# pragma GCC diagnostic pop}}
\DoxyCodeLine{3718 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3719 }
\DoxyCodeLine{3720 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_FORMAT\_H\_}}

\end{DoxyCode}
