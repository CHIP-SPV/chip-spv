\hypertarget{format-inl_8h_source}{}\doxysection{format-\/inl.h}
\label{format-inl_8h_source}\index{/Users/pvelesko/local/CHIP-\/SPV/spdlog/fmt/bundled/format-\/inl.h@{/Users/pvelesko/local/CHIP-\/SPV/spdlog/fmt/bundled/format-\/inl.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Formatting library for C++}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{// Copyright (c) 2012 -\/ 2016, Victor Zverovich}}
\DoxyCodeLine{4 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// For the license information refer to format.h.}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 \textcolor{preprocessor}{\#ifndef FMT\_FORMAT\_INL\_H\_}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#define FMT\_FORMAT\_INL\_H\_}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include "{}format.h"{}}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <string.h>}}
\DoxyCodeLine{14 }
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <cerrno>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <climits>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <cstdarg>}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <cstddef>}  \textcolor{comment}{// for std::ptrdiff\_t}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <cstring>}  \textcolor{comment}{// for std::memmove}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#if !defined(FMT\_STATIC\_THOUSANDS\_SEPARATOR)}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\# include <locale>}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{preprocessor}{\#if FMT\_USE\_WINDOWS\_H}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\# if !defined(FMT\_HEADER\_ONLY) \&\& !defined(WIN32\_LEAN\_AND\_MEAN)}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#  define WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\# if defined(NOMINMAX) || defined(FMT\_WIN\_MINMAX)}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#  include <windows.h>}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\# else}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#  define NOMINMAX}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#  include <windows.h>}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#  undef NOMINMAX}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{38 }
\DoxyCodeLine{39 \textcolor{preprocessor}{\#if FMT\_EXCEPTIONS}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\# define FMT\_TRY try}}
\DoxyCodeLine{41 \textcolor{preprocessor}{\# define FMT\_CATCH(x) catch (x)}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{43 \textcolor{preprocessor}{\# define FMT\_TRY if (true)}}
\DoxyCodeLine{44 \textcolor{preprocessor}{\# define FMT\_CATCH(x) if (false)}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{46 }
\DoxyCodeLine{47 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{48 \textcolor{preprocessor}{\# pragma warning(push)}}
\DoxyCodeLine{49 \textcolor{preprocessor}{\# pragma warning(disable: 4127)  }\textcolor{comment}{// conditional expression is constant}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\# pragma warning(disable: 4702)  }\textcolor{comment}{// unreachable code}}
\DoxyCodeLine{51 \textcolor{comment}{// Disable deprecation warning for strerror. The latter is not called but}}
\DoxyCodeLine{52 \textcolor{comment}{// MSVC fails to detect it.}}
\DoxyCodeLine{53 \textcolor{preprocessor}{\# pragma warning(disable: 4996)}}
\DoxyCodeLine{54 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{55 }
\DoxyCodeLine{56 \textcolor{comment}{// Dummy implementations of strerror\_r and strerror\_s called if corresponding}}
\DoxyCodeLine{57 \textcolor{comment}{// system functions are not available.}}
\DoxyCodeLine{58 \textcolor{keyword}{inline} fmt::internal::null<> strerror\_r(\textcolor{keywordtype}{int}, \textcolor{keywordtype}{char} *, ...) \{}
\DoxyCodeLine{59   \textcolor{keywordflow}{return} fmt::internal::null<>();}
\DoxyCodeLine{60 \}}
\DoxyCodeLine{61 \textcolor{keyword}{inline} fmt::internal::null<> strerror\_s(\textcolor{keywordtype}{char} *, std::size\_t, ...) \{}
\DoxyCodeLine{62   \textcolor{keywordflow}{return} fmt::internal::null<>();}
\DoxyCodeLine{63 \}}
\DoxyCodeLine{64 }
\DoxyCodeLine{65 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{66 }
\DoxyCodeLine{67 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{68 }
\DoxyCodeLine{69 \textcolor{preprocessor}{\#ifndef \_MSC\_VER}}
\DoxyCodeLine{70 \textcolor{preprocessor}{\# define FMT\_SNPRINTF snprintf}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\#else  }\textcolor{comment}{// \_MSC\_VER}}
\DoxyCodeLine{72 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} fmt\_snprintf(\textcolor{keywordtype}{char} *buffer, \textcolor{keywordtype}{size\_t} size, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *format, ...) \{}
\DoxyCodeLine{73   va\_list args;}
\DoxyCodeLine{74   va\_start(args, format);}
\DoxyCodeLine{75   \textcolor{keywordtype}{int} result = vsnprintf\_s(buffer, size, \_TRUNCATE, format, args);}
\DoxyCodeLine{76   va\_end(args);}
\DoxyCodeLine{77   \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{78 \}}
\DoxyCodeLine{79 \textcolor{preprocessor}{\# define FMT\_SNPRINTF fmt\_snprintf}}
\DoxyCodeLine{80 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// \_MSC\_VER}}
\DoxyCodeLine{81 }
\DoxyCodeLine{82 \textcolor{preprocessor}{\#if defined(\_WIN32) \&\& defined(\_\_MINGW32\_\_) \&\& !defined(\_\_NO\_ISOCEXT)}}
\DoxyCodeLine{83 \textcolor{preprocessor}{\# define FMT\_SWPRINTF snwprintf}}
\DoxyCodeLine{84 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{85 \textcolor{preprocessor}{\# define FMT\_SWPRINTF swprintf}}
\DoxyCodeLine{86 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// defined(\_WIN32) \&\& defined(\_\_MINGW32\_\_) \&\& !defined(\_\_NO\_ISOCEXT)}}
\DoxyCodeLine{87 }
\DoxyCodeLine{88 \textcolor{keyword}{typedef} void (*FormatFunc)(\mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::buffer}} \&, int, \mbox{\hyperlink{classbasic__string__view}{string\_view}});}
\DoxyCodeLine{89 }
\DoxyCodeLine{90 \textcolor{comment}{// Portable thread-\/safe version of strerror.}}
\DoxyCodeLine{91 \textcolor{comment}{// Sets buffer to point to a string describing the error code.}}
\DoxyCodeLine{92 \textcolor{comment}{// This can be either a pointer to a string stored in buffer,}}
\DoxyCodeLine{93 \textcolor{comment}{// or a pointer to some static immutable string.}}
\DoxyCodeLine{94 \textcolor{comment}{// Returns one of the following values:}}
\DoxyCodeLine{95 \textcolor{comment}{//   0      -\/ success}}
\DoxyCodeLine{96 \textcolor{comment}{//   ERANGE -\/ buffer is not large enough to store the error message}}
\DoxyCodeLine{97 \textcolor{comment}{//   other  -\/ failure}}
\DoxyCodeLine{98 \textcolor{comment}{// Buffer should be at least of size 1.}}
\DoxyCodeLine{99 \textcolor{keywordtype}{int} safe\_strerror(}
\DoxyCodeLine{100     \textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}}, \textcolor{keywordtype}{char} *\&buffer, std::size\_t buffer\_size) FMT\_NOEXCEPT \{}
\DoxyCodeLine{101   FMT\_ASSERT(buffer != FMT\_NULL \&\& buffer\_size != 0, \textcolor{stringliteral}{"{}invalid buffer"{}});}
\DoxyCodeLine{102 }
\DoxyCodeLine{103   \textcolor{keyword}{class }dispatcher \{}
\DoxyCodeLine{104    \textcolor{keyword}{private}:}
\DoxyCodeLine{105     \textcolor{keywordtype}{int} error\_code\_;}
\DoxyCodeLine{106     \textcolor{keywordtype}{char} *\&buffer\_;}
\DoxyCodeLine{107     std::size\_t buffer\_size\_;}
\DoxyCodeLine{108 }
\DoxyCodeLine{109     \textcolor{comment}{// A noop assignment operator to avoid bogus warnings.}}
\DoxyCodeLine{110     \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} dispatcher \&) \{\}}
\DoxyCodeLine{111 }
\DoxyCodeLine{112     \textcolor{comment}{// Handle the result of XSI-\/compliant version of strerror\_r.}}
\DoxyCodeLine{113     \textcolor{keywordtype}{int} handle(\textcolor{keywordtype}{int} result) \{}
\DoxyCodeLine{114       \textcolor{comment}{// glibc versions before 2.13 return result in errno.}}
\DoxyCodeLine{115       \textcolor{keywordflow}{return} result == -\/1 ? errno : result;}
\DoxyCodeLine{116     \}}
\DoxyCodeLine{117 }
\DoxyCodeLine{118     \textcolor{comment}{// Handle the result of GNU-\/specific version of strerror\_r.}}
\DoxyCodeLine{119     \textcolor{keywordtype}{int} handle(\textcolor{keywordtype}{char} *message) \{}
\DoxyCodeLine{120       \textcolor{comment}{// If the buffer is full then the message is probably truncated.}}
\DoxyCodeLine{121       \textcolor{keywordflow}{if} (message == buffer\_ \&\& strlen(buffer\_) == buffer\_size\_ -\/ 1)}
\DoxyCodeLine{122         \textcolor{keywordflow}{return} ERANGE;}
\DoxyCodeLine{123       buffer\_ = message;}
\DoxyCodeLine{124       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{125     \}}
\DoxyCodeLine{126 }
\DoxyCodeLine{127     \textcolor{comment}{// Handle the case when strerror\_r is not available.}}
\DoxyCodeLine{128     \textcolor{keywordtype}{int} handle(\mbox{\hyperlink{structinternal_1_1null}{internal::null<>}}) \{}
\DoxyCodeLine{129       \textcolor{keywordflow}{return} fallback(strerror\_s(buffer\_, buffer\_size\_, error\_code\_));}
\DoxyCodeLine{130     \}}
\DoxyCodeLine{131 }
\DoxyCodeLine{132     \textcolor{comment}{// Fallback to strerror\_s when strerror\_r is not available.}}
\DoxyCodeLine{133     \textcolor{keywordtype}{int} fallback(\textcolor{keywordtype}{int} result) \{}
\DoxyCodeLine{134       \textcolor{comment}{// If the buffer is full then the message is probably truncated.}}
\DoxyCodeLine{135       \textcolor{keywordflow}{return} result == 0 \&\& strlen(buffer\_) == buffer\_size\_ -\/ 1 ?}
\DoxyCodeLine{136             ERANGE : result;}
\DoxyCodeLine{137     \}}
\DoxyCodeLine{138 }
\DoxyCodeLine{139     \textcolor{comment}{// Fallback to strerror if strerror\_r and strerror\_s are not available.}}
\DoxyCodeLine{140     \textcolor{keywordtype}{int} fallback(\mbox{\hyperlink{structinternal_1_1null}{internal::null<>}}) \{}
\DoxyCodeLine{141       errno = 0;}
\DoxyCodeLine{142       buffer\_ = strerror(error\_code\_);}
\DoxyCodeLine{143       \textcolor{keywordflow}{return} errno;}
\DoxyCodeLine{144     \}}
\DoxyCodeLine{145 }
\DoxyCodeLine{146    \textcolor{keyword}{public}:}
\DoxyCodeLine{147     dispatcher(\textcolor{keywordtype}{int} err\_code, \textcolor{keywordtype}{char} *\&buf, std::size\_t buf\_size)}
\DoxyCodeLine{148       : error\_code\_(err\_code), buffer\_(buf), buffer\_size\_(buf\_size) \{\}}
\DoxyCodeLine{149 }
\DoxyCodeLine{150     \textcolor{keywordtype}{int} run() \{}
\DoxyCodeLine{151       \textcolor{keywordflow}{return} handle(strerror\_r(error\_code\_, buffer\_, buffer\_size\_));}
\DoxyCodeLine{152     \}}
\DoxyCodeLine{153   \};}
\DoxyCodeLine{154   \textcolor{keywordflow}{return} dispatcher(\mbox{\hyperlink{classerror__code}{error\_code}}, buffer, buffer\_size).run();}
\DoxyCodeLine{155 \}}
\DoxyCodeLine{156 }
\DoxyCodeLine{157 \textcolor{keywordtype}{void} format\_error\_code(\mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::buffer}} \&out, \textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}},}
\DoxyCodeLine{158                        \mbox{\hyperlink{classbasic__string__view}{string\_view}} message) FMT\_NOEXCEPT \{}
\DoxyCodeLine{159   \textcolor{comment}{// Report error code making sure that the output fits into}}
\DoxyCodeLine{160   \textcolor{comment}{// inline\_buffer\_size to avoid dynamic memory allocation and potential}}
\DoxyCodeLine{161   \textcolor{comment}{// bad\_alloc.}}
\DoxyCodeLine{162   out.resize(0);}
\DoxyCodeLine{163   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} SEP[] = \textcolor{stringliteral}{"{}: "{}};}
\DoxyCodeLine{164   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} ERROR\_STR[] = \textcolor{stringliteral}{"{}error "{}};}
\DoxyCodeLine{165   \textcolor{comment}{// Subtract 2 to account for terminating null characters in SEP and ERROR\_STR.}}
\DoxyCodeLine{166   std::size\_t error\_code\_size = \textcolor{keyword}{sizeof}(SEP) + \textcolor{keyword}{sizeof}(ERROR\_STR) -\/ 2;}
\DoxyCodeLine{167   \textcolor{keyword}{typedef} \mbox{\hyperlink{structinternal_1_1int__traits}{internal::int\_traits<int>::main\_type}} main\_type;}
\DoxyCodeLine{168   main\_type abs\_value = \textcolor{keyword}{static\_cast<}main\_type\textcolor{keyword}{>}(\mbox{\hyperlink{classerror__code}{error\_code}});}
\DoxyCodeLine{169   \textcolor{keywordflow}{if} (internal::is\_negative(\mbox{\hyperlink{classerror__code}{error\_code}})) \{}
\DoxyCodeLine{170     abs\_value = 0 -\/ abs\_value;}
\DoxyCodeLine{171     ++error\_code\_size;}
\DoxyCodeLine{172   \}}
\DoxyCodeLine{173   error\_code\_size += internal::count\_digits(abs\_value);}
\DoxyCodeLine{174   \mbox{\hyperlink{classbasic__writer}{writer}} w(out);}
\DoxyCodeLine{175   \textcolor{keywordflow}{if} (message.size() <= inline\_buffer\_size -\/ error\_code\_size) \{}
\DoxyCodeLine{176     w.write(message);}
\DoxyCodeLine{177     w.write(SEP);}
\DoxyCodeLine{178   \}}
\DoxyCodeLine{179   w.write(ERROR\_STR);}
\DoxyCodeLine{180   w.write(\mbox{\hyperlink{classerror__code}{error\_code}});}
\DoxyCodeLine{181   assert(out.size() <= inline\_buffer\_size);}
\DoxyCodeLine{182 \}}
\DoxyCodeLine{183 }
\DoxyCodeLine{184 \textcolor{keywordtype}{void} report\_error(FormatFunc func, \textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}},}
\DoxyCodeLine{185                   \mbox{\hyperlink{classbasic__string__view}{string\_view}} message) FMT\_NOEXCEPT \{}
\DoxyCodeLine{186   \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}} full\_message;}
\DoxyCodeLine{187   func(full\_message, \mbox{\hyperlink{classerror__code}{error\_code}}, message);}
\DoxyCodeLine{188   \textcolor{comment}{// Use Writer::data instead of Writer::c\_str to avoid potential memory}}
\DoxyCodeLine{189   \textcolor{comment}{// allocation.}}
\DoxyCodeLine{190   std::fwrite(full\_message.\mbox{\hyperlink{classinternal_1_1basic__buffer_a4716afee355656cd70e6719e5c0e6d62}{data}}(), full\_message.\mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}}(), 1, stderr);}
\DoxyCodeLine{191   std::fputc(\textcolor{charliteral}{'\(\backslash\)n'}, stderr);}
\DoxyCodeLine{192 \}}
\DoxyCodeLine{193 \}  \textcolor{comment}{// namespace}}
\DoxyCodeLine{194 }
\DoxyCodeLine{195 \textcolor{preprocessor}{\#if !defined(FMT\_STATIC\_THOUSANDS\_SEPARATOR)}}
\DoxyCodeLine{196 \textcolor{keyword}{class }\mbox{\hyperlink{classlocale}{locale}} \{}
\DoxyCodeLine{197  \textcolor{keyword}{private}:}
\DoxyCodeLine{198   std::locale locale\_;}
\DoxyCodeLine{199 }
\DoxyCodeLine{200  \textcolor{keyword}{public}:}
\DoxyCodeLine{201   \textcolor{keyword}{explicit} \mbox{\hyperlink{classlocale}{locale}}(std::locale loc = std::locale()) : locale\_(loc) \{\}}
\DoxyCodeLine{202   std::locale get() \{ \textcolor{keywordflow}{return} locale\_; \}}
\DoxyCodeLine{203 \};}
\DoxyCodeLine{204 }
\DoxyCodeLine{205 FMT\_FUNC \textcolor{keywordtype}{size\_t} internal::count\_code\_points(\mbox{\hyperlink{classu8string__view}{u8string\_view}} s) \{}
\DoxyCodeLine{206   \textcolor{keyword}{const} \mbox{\hyperlink{structchar8__t}{char8\_t}} *data = s.data();}
\DoxyCodeLine{207   \textcolor{keywordtype}{int} num\_code\_points = 0;}
\DoxyCodeLine{208   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0, size = s.size(); i != size; ++i) \{}
\DoxyCodeLine{209     \textcolor{keywordflow}{if} ((data[i].value \& 0xc0) != 0x80)}
\DoxyCodeLine{210       ++num\_code\_points;}
\DoxyCodeLine{211   \}}
\DoxyCodeLine{212   \textcolor{keywordflow}{return} num\_code\_points;}
\DoxyCodeLine{213 \}}
\DoxyCodeLine{214 }
\DoxyCodeLine{215 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{216 FMT\_FUNC Char internal::thousands\_sep(\mbox{\hyperlink{classlocale__provider}{locale\_provider}} *lp) \{}
\DoxyCodeLine{217   std::locale loc = lp ? lp-\/>locale().get() : std::locale();}
\DoxyCodeLine{218   \textcolor{keywordflow}{return} std::use\_facet<std::numpunct<Char>>(loc).thousands\_sep();}
\DoxyCodeLine{219 \}}
\DoxyCodeLine{220 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{221 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{222 FMT\_FUNC Char internal::thousands\_sep(\mbox{\hyperlink{classlocale__provider}{locale\_provider}} *lp) \{}
\DoxyCodeLine{223   \textcolor{keywordflow}{return} FMT\_STATIC\_THOUSANDS\_SEPARATOR;}
\DoxyCodeLine{224 \}}
\DoxyCodeLine{225 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{226 }
\DoxyCodeLine{227 FMT\_FUNC \textcolor{keywordtype}{void} system\_error::init(}
\DoxyCodeLine{228     \textcolor{keywordtype}{int} err\_code, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \mbox{\hyperlink{structformat__args}{format\_args}} args) \{}
\DoxyCodeLine{229   error\_code\_ = err\_code;}
\DoxyCodeLine{230   \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}} buffer;}
\DoxyCodeLine{231   format\_system\_error(buffer, err\_code, vformat(format\_str, args));}
\DoxyCodeLine{232   std::runtime\_error \&\mbox{\hyperlink{classbase}{base}} = *\textcolor{keyword}{this};}
\DoxyCodeLine{233   \mbox{\hyperlink{classbase}{base}} = std::runtime\_error(to\_string(buffer));}
\DoxyCodeLine{234 \}}
\DoxyCodeLine{235 }
\DoxyCodeLine{236 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{237 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{238 \textcolor{keywordtype}{int} char\_traits<char>::format\_float(}
\DoxyCodeLine{239     \textcolor{keywordtype}{char} *buffer, std::size\_t size, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *format, \textcolor{keywordtype}{int} precision, T value) \{}
\DoxyCodeLine{240   \textcolor{keywordflow}{return} precision < 0 ?}
\DoxyCodeLine{241       FMT\_SNPRINTF(buffer, size, format, value) :}
\DoxyCodeLine{242       FMT\_SNPRINTF(buffer, size, format, precision, value);}
\DoxyCodeLine{243 \}}
\DoxyCodeLine{244 }
\DoxyCodeLine{245 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{246 \textcolor{keywordtype}{int} char\_traits<wchar\_t>::format\_float(}
\DoxyCodeLine{247     \textcolor{keywordtype}{wchar\_t} *buffer, std::size\_t size, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t} *format, \textcolor{keywordtype}{int} precision,}
\DoxyCodeLine{248     T value) \{}
\DoxyCodeLine{249   \textcolor{keywordflow}{return} precision < 0 ?}
\DoxyCodeLine{250       FMT\_SWPRINTF(buffer, size, format, value) :}
\DoxyCodeLine{251       FMT\_SWPRINTF(buffer, size, format, precision, value);}
\DoxyCodeLine{252 \}}
\DoxyCodeLine{253 }
\DoxyCodeLine{254 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{255 \textcolor{keyword}{const} \textcolor{keywordtype}{char} basic\_data<T>::DIGITS[] =}
\DoxyCodeLine{256     \textcolor{stringliteral}{"{}0001020304050607080910111213141516171819"{}}}
\DoxyCodeLine{257     \textcolor{stringliteral}{"{}2021222324252627282930313233343536373839"{}}}
\DoxyCodeLine{258     \textcolor{stringliteral}{"{}4041424344454647484950515253545556575859"{}}}
\DoxyCodeLine{259     \textcolor{stringliteral}{"{}6061626364656667686970717273747576777879"{}}}
\DoxyCodeLine{260     \textcolor{stringliteral}{"{}8081828384858687888990919293949596979899"{}};}
\DoxyCodeLine{261 }
\DoxyCodeLine{262 \textcolor{preprocessor}{\#define FMT\_POWERS\_OF\_10(factor) \(\backslash\)}}
\DoxyCodeLine{263 \textcolor{preprocessor}{  factor * 10, \(\backslash\)}}
\DoxyCodeLine{264 \textcolor{preprocessor}{  factor * 100, \(\backslash\)}}
\DoxyCodeLine{265 \textcolor{preprocessor}{  factor * 1000, \(\backslash\)}}
\DoxyCodeLine{266 \textcolor{preprocessor}{  factor * 10000, \(\backslash\)}}
\DoxyCodeLine{267 \textcolor{preprocessor}{  factor * 100000, \(\backslash\)}}
\DoxyCodeLine{268 \textcolor{preprocessor}{  factor * 1000000, \(\backslash\)}}
\DoxyCodeLine{269 \textcolor{preprocessor}{  factor * 10000000, \(\backslash\)}}
\DoxyCodeLine{270 \textcolor{preprocessor}{  factor * 100000000, \(\backslash\)}}
\DoxyCodeLine{271 \textcolor{preprocessor}{  factor * 1000000000}}
\DoxyCodeLine{272 }
\DoxyCodeLine{273 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{274 \textcolor{keyword}{const} uint32\_t basic\_data<T>::POWERS\_OF\_10\_32[] = \{}
\DoxyCodeLine{275   1, FMT\_POWERS\_OF\_10(1)}
\DoxyCodeLine{276 \};}
\DoxyCodeLine{277 }
\DoxyCodeLine{278 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{279 \textcolor{keyword}{const} uint32\_t basic\_data<T>::ZERO\_OR\_POWERS\_OF\_10\_32[] = \{}
\DoxyCodeLine{280   0, FMT\_POWERS\_OF\_10(1)}
\DoxyCodeLine{281 \};}
\DoxyCodeLine{282 }
\DoxyCodeLine{283 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{284 \textcolor{keyword}{const} uint64\_t basic\_data<T>::ZERO\_OR\_POWERS\_OF\_10\_64[] = \{}
\DoxyCodeLine{285   0,}
\DoxyCodeLine{286   FMT\_POWERS\_OF\_10(1),}
\DoxyCodeLine{287   FMT\_POWERS\_OF\_10(1000000000ull),}
\DoxyCodeLine{288   10000000000000000000ull}
\DoxyCodeLine{289 \};}
\DoxyCodeLine{290 }
\DoxyCodeLine{291 \textcolor{comment}{// Normalized 64-\/bit significands of pow(10, k), for k = -\/348, -\/340, ..., 340.}}
\DoxyCodeLine{292 \textcolor{comment}{// These are generated by support/compute-\/powers.py.}}
\DoxyCodeLine{293 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{294 \textcolor{keyword}{const} uint64\_t basic\_data<T>::POW10\_SIGNIFICANDS[] = \{}
\DoxyCodeLine{295   0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76,}
\DoxyCodeLine{296   0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d, 0xe61acf033d1a45df,}
\DoxyCodeLine{297   0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c,}
\DoxyCodeLine{298   0x8dd01fad907ffc3c, 0xd3515c2831559a83, 0x9d71ac8fada6c9b5,}
\DoxyCodeLine{299   0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,}
\DoxyCodeLine{300   0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7,}
\DoxyCodeLine{301   0xa086cfcd97bf97f4, 0xef340a98172aace5, 0xb23867fb2a35b28e,}
\DoxyCodeLine{302   0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996,}
\DoxyCodeLine{303   0xdbac6c247d62a584, 0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126,}
\DoxyCodeLine{304   0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,}
\DoxyCodeLine{305   0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f,}
\DoxyCodeLine{306   0xf8a95fcf88747d94, 0xb94470938fa89bcf, 0x8a08f0f8bf0f156b,}
\DoxyCodeLine{307   0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06,}
\DoxyCodeLine{308   0xaa242499697392d3, 0xfd87b5f28300ca0e, 0xbce5086492111aeb,}
\DoxyCodeLine{309   0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,}
\DoxyCodeLine{310   0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984,}
\DoxyCodeLine{311   0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70, 0xd5d238a4abe98068,}
\DoxyCodeLine{312   0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8,}
\DoxyCodeLine{313   0x83c7088e1aab65db, 0xc45d1df942711d9a, 0x924d692ca61be758,}
\DoxyCodeLine{314   0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,}
\DoxyCodeLine{315   0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d,}
\DoxyCodeLine{316   0x952ab45cfa97a0b3, 0xde469fbd99a05fe3, 0xa59bc234db398c25,}
\DoxyCodeLine{317   0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2,}
\DoxyCodeLine{318   0xcc20ce9bd35c78a5, 0x98165af37b2153df, 0xe2a0b5dc971f303a,}
\DoxyCodeLine{319   0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,}
\DoxyCodeLine{320   0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129,}
\DoxyCodeLine{321   0xe7109bfba19c0c9d, 0xac2820d9623bf429, 0x80444b5e7aa7cf85,}
\DoxyCodeLine{322   0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841,}
\DoxyCodeLine{323   0x9e19db92b4e31ba9, 0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,}
\DoxyCodeLine{324 \};}
\DoxyCodeLine{325 }
\DoxyCodeLine{326 \textcolor{comment}{// Binary exponents of pow(10, k), for k = -\/348, -\/340, ..., 340, corresponding}}
\DoxyCodeLine{327 \textcolor{comment}{// to significands above.}}
\DoxyCodeLine{328 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{329 \textcolor{keyword}{const} int16\_t basic\_data<T>::POW10\_EXPONENTS[] = \{}
\DoxyCodeLine{330   -\/1220, -\/1193, -\/1166, -\/1140, -\/1113, -\/1087, -\/1060, -\/1034, -\/1007,  -\/980,  -\/954,}
\DoxyCodeLine{331    -\/927,  -\/901,  -\/874,  -\/847,  -\/821,  -\/794,  -\/768,  -\/741,  -\/715,  -\/688,  -\/661,}
\DoxyCodeLine{332    -\/635,  -\/608,  -\/582,  -\/555,  -\/529,  -\/502,  -\/475,  -\/449,  -\/422,  -\/396,  -\/369,}
\DoxyCodeLine{333    -\/343,  -\/316,  -\/289,  -\/263,  -\/236,  -\/210,  -\/183,  -\/157,  -\/130,  -\/103,   -\/77,}
\DoxyCodeLine{334     -\/50,   -\/24,     3,    30,    56,    83,   109,   136,   162,   189,   216,}
\DoxyCodeLine{335     242,   269,   295,   322,   348,   375,   402,   428,   455,   481,   508,}
\DoxyCodeLine{336     534,   561,   588,   614,   641,   667,   694,   720,   747,   774,   800,}
\DoxyCodeLine{337     827,   853,   880,   907,   933,   960,   986,  1013,  1039,  1066}
\DoxyCodeLine{338 \};}
\DoxyCodeLine{339 }
\DoxyCodeLine{340 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{const} \textcolor{keywordtype}{char} basic\_data<T>::RESET\_COLOR[] = \textcolor{stringliteral}{"{}\(\backslash\)x1b[0m"{}};}
\DoxyCodeLine{341 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t} basic\_data<T>::WRESET\_COLOR[] = L\textcolor{stringliteral}{"{}\(\backslash\)x1b[0m"{}};}
\DoxyCodeLine{342 }
\DoxyCodeLine{343 \textcolor{comment}{// A handmade floating-\/point number f * pow(2, e).}}
\DoxyCodeLine{344 \textcolor{keyword}{class }\mbox{\hyperlink{classinternal_1_1fp}{fp}} \{}
\DoxyCodeLine{345  \textcolor{keyword}{private}:}
\DoxyCodeLine{346   \textcolor{keyword}{typedef} uint64\_t significand\_type;}
\DoxyCodeLine{347 }
\DoxyCodeLine{348   \textcolor{comment}{// All sizes are in bits.}}
\DoxyCodeLine{349   \textcolor{keyword}{static} FMT\_CONSTEXPR\_DECL \textcolor{keyword}{const} \textcolor{keywordtype}{int} char\_size =}
\DoxyCodeLine{350     std::numeric\_limits<unsigned char>::digits;}
\DoxyCodeLine{351   \textcolor{comment}{// Subtract 1 to account for an implicit most significant bit in the}}
\DoxyCodeLine{352   \textcolor{comment}{// normalized form.}}
\DoxyCodeLine{353   \textcolor{keyword}{static} FMT\_CONSTEXPR\_DECL \textcolor{keyword}{const} \textcolor{keywordtype}{int} double\_significand\_size =}
\DoxyCodeLine{354     std::numeric\_limits<double>::digits -\/ 1;}
\DoxyCodeLine{355   \textcolor{keyword}{static} FMT\_CONSTEXPR\_DECL \textcolor{keyword}{const} uint64\_t implicit\_bit =}
\DoxyCodeLine{356     1ull << double\_significand\_size;}
\DoxyCodeLine{357 }
\DoxyCodeLine{358  \textcolor{keyword}{public}:}
\DoxyCodeLine{359   significand\_type f;}
\DoxyCodeLine{360   \textcolor{keywordtype}{int} e;}
\DoxyCodeLine{361 }
\DoxyCodeLine{362   \textcolor{keyword}{static} FMT\_CONSTEXPR\_DECL \textcolor{keyword}{const} \textcolor{keywordtype}{int} significand\_size =}
\DoxyCodeLine{363     \textcolor{keyword}{sizeof}(significand\_type) * char\_size;}
\DoxyCodeLine{364 }
\DoxyCodeLine{365   \mbox{\hyperlink{classinternal_1_1fp}{fp}}(): f(0), e(0) \{\}}
\DoxyCodeLine{366   \mbox{\hyperlink{classinternal_1_1fp}{fp}}(uint64\_t f, \textcolor{keywordtype}{int} e): f(f), e(e) \{\}}
\DoxyCodeLine{367 }
\DoxyCodeLine{368   \textcolor{comment}{// Constructs fp from an IEEE754 double. It is a template to prevent compile}}
\DoxyCodeLine{369   \textcolor{comment}{// errors on platforms where double is not IEEE754.}}
\DoxyCodeLine{370   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Double>}
\DoxyCodeLine{371   \textcolor{keyword}{explicit} \mbox{\hyperlink{classinternal_1_1fp}{fp}}(Double d) \{}
\DoxyCodeLine{372     \textcolor{comment}{// Assume double is in the format [sign][exponent][significand].}}
\DoxyCodeLine{373     \textcolor{keyword}{typedef} std::numeric\_limits<Double> limits;}
\DoxyCodeLine{374     \textcolor{keyword}{const} \textcolor{keywordtype}{int} double\_size = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\textcolor{keyword}{sizeof}(Double) * char\_size);}
\DoxyCodeLine{375     \textcolor{keyword}{const} \textcolor{keywordtype}{int} exponent\_size =}
\DoxyCodeLine{376       double\_size -\/ double\_significand\_size -\/ 1;  \textcolor{comment}{// -\/1 for sign}}
\DoxyCodeLine{377     \textcolor{keyword}{const} uint64\_t significand\_mask = implicit\_bit -\/ 1;}
\DoxyCodeLine{378     \textcolor{keyword}{const} uint64\_t exponent\_mask = (\string~0ull >> 1) \& \string~significand\_mask;}
\DoxyCodeLine{379     \textcolor{keyword}{const} \textcolor{keywordtype}{int} exponent\_bias = (1 << exponent\_size) -\/ limits::max\_exponent -\/ 1;}
\DoxyCodeLine{380     \textcolor{keyword}{auto} u = bit\_cast<uint64\_t>(d);}
\DoxyCodeLine{381     \textcolor{keyword}{auto} biased\_e = (u \& exponent\_mask) >> double\_significand\_size;}
\DoxyCodeLine{382     f = u \& significand\_mask;}
\DoxyCodeLine{383     \textcolor{keywordflow}{if} (biased\_e != 0)}
\DoxyCodeLine{384       f += implicit\_bit;}
\DoxyCodeLine{385     \textcolor{keywordflow}{else}}
\DoxyCodeLine{386       biased\_e = 1;  \textcolor{comment}{// Subnormals use biased exponent 1 (min exponent).}}
\DoxyCodeLine{387     e = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(biased\_e -\/ exponent\_bias -\/ double\_significand\_size);}
\DoxyCodeLine{388   \}}
\DoxyCodeLine{389 }
\DoxyCodeLine{390   \textcolor{comment}{// Normalizes the value converted from double and multiplied by (1 << SHIFT).}}
\DoxyCodeLine{391   \textcolor{keyword}{template} <\textcolor{keywordtype}{int} SHIFT = 0>}
\DoxyCodeLine{392   \textcolor{keywordtype}{void} normalize() \{}
\DoxyCodeLine{393     \textcolor{comment}{// Handle subnormals.}}
\DoxyCodeLine{394     \textcolor{keyword}{auto} shifted\_implicit\_bit = implicit\_bit << SHIFT;}
\DoxyCodeLine{395     \textcolor{keywordflow}{while} ((f \& shifted\_implicit\_bit) == 0) \{}
\DoxyCodeLine{396       f <<= 1;}
\DoxyCodeLine{397       -\/-\/e;}
\DoxyCodeLine{398     \}}
\DoxyCodeLine{399     \textcolor{comment}{// Subtract 1 to account for hidden bit.}}
\DoxyCodeLine{400     \textcolor{keyword}{auto} offset = significand\_size -\/ double\_significand\_size -\/ SHIFT -\/ 1;}
\DoxyCodeLine{401     f <<= offset;}
\DoxyCodeLine{402     e -\/= offset;}
\DoxyCodeLine{403   \}}
\DoxyCodeLine{404 }
\DoxyCodeLine{405   \textcolor{comment}{// Compute lower and upper boundaries (m\string^-\/ and m\string^+ in the Grisu paper), where}}
\DoxyCodeLine{406   \textcolor{comment}{// a boundary is a value half way between the number and its predecessor}}
\DoxyCodeLine{407   \textcolor{comment}{// (lower) or successor (upper). The upper boundary is normalized and lower}}
\DoxyCodeLine{408   \textcolor{comment}{// has the same exponent but may be not normalized.}}
\DoxyCodeLine{409   \textcolor{keywordtype}{void} compute\_boundaries(\mbox{\hyperlink{classinternal_1_1fp}{fp}} \&lower, \mbox{\hyperlink{classinternal_1_1fp}{fp}} \&upper)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{410     lower = f == implicit\_bit ?}
\DoxyCodeLine{411           \mbox{\hyperlink{classinternal_1_1fp}{fp}}((f << 2) -\/ 1, e -\/ 2) : \mbox{\hyperlink{classinternal_1_1fp}{fp}}((f << 1) -\/ 1, e -\/ 1);}
\DoxyCodeLine{412     upper = \mbox{\hyperlink{classinternal_1_1fp}{fp}}((f << 1) + 1, e -\/ 1);}
\DoxyCodeLine{413     upper.normalize<1>();  \textcolor{comment}{// 1 is to account for the exponent shift above.}}
\DoxyCodeLine{414     lower.f <<= lower.e -\/ upper.e;}
\DoxyCodeLine{415     lower.e = upper.e;}
\DoxyCodeLine{416   \}}
\DoxyCodeLine{417 \};}
\DoxyCodeLine{418 }
\DoxyCodeLine{419 \textcolor{comment}{// Returns an fp number representing x -\/ y. Result may not be normalized.}}
\DoxyCodeLine{420 \textcolor{keyword}{inline} \mbox{\hyperlink{classinternal_1_1fp}{fp}} operator-\/(\mbox{\hyperlink{classinternal_1_1fp}{fp}} x, \mbox{\hyperlink{classinternal_1_1fp}{fp}} y) \{}
\DoxyCodeLine{421   FMT\_ASSERT(x.f >= y.f \&\& x.e == y.e, \textcolor{stringliteral}{"{}invalid operands"{}});}
\DoxyCodeLine{422   \textcolor{keywordflow}{return} \mbox{\hyperlink{classinternal_1_1fp}{fp}}(x.f -\/ y.f, x.e);}
\DoxyCodeLine{423 \}}
\DoxyCodeLine{424 }
\DoxyCodeLine{425 \textcolor{comment}{// Computes an fp number r with r.f = x.f * y.f / pow(2, 64) rounded to nearest}}
\DoxyCodeLine{426 \textcolor{comment}{// with half-\/up tie breaking, r.e = x.e + y.e + 64. Result may not be normalized.}}
\DoxyCodeLine{427 FMT\_API fp operator*(fp x, fp y);}
\DoxyCodeLine{428 }
\DoxyCodeLine{429 \textcolor{comment}{// Returns cached power (of 10) c\_k = c\_k.f * pow(2, c\_k.e) such that its}}
\DoxyCodeLine{430 \textcolor{comment}{// (binary) exponent satisfies min\_exponent <= c\_k.e <= min\_exponent + 3.}}
\DoxyCodeLine{431 FMT\_API fp get\_cached\_power(\textcolor{keywordtype}{int} min\_exponent, \textcolor{keywordtype}{int} \&pow10\_exponent);}
\DoxyCodeLine{432 }
\DoxyCodeLine{433 FMT\_FUNC fp operator*(fp x, fp y) \{}
\DoxyCodeLine{434   \textcolor{comment}{// Multiply 32-\/bit parts of significands.}}
\DoxyCodeLine{435   uint64\_t mask = (1ULL << 32) -\/ 1;}
\DoxyCodeLine{436   uint64\_t a = x.f >> 32, b = x.f \& mask;}
\DoxyCodeLine{437   uint64\_t c = y.f >> 32, d = y.f \& mask;}
\DoxyCodeLine{438   uint64\_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;}
\DoxyCodeLine{439   \textcolor{comment}{// Compute mid 64-\/bit of result and round.}}
\DoxyCodeLine{440   uint64\_t mid = (bd >> 32) + (ad \& mask) + (bc \& mask) + (1U << 31);}
\DoxyCodeLine{441   \textcolor{keywordflow}{return} fp(ac + (ad >> 32) + (bc >> 32) + (mid >> 32), x.e + y.e + 64);}
\DoxyCodeLine{442 \}}
\DoxyCodeLine{443 }
\DoxyCodeLine{444 FMT\_FUNC fp get\_cached\_power(\textcolor{keywordtype}{int} min\_exponent, \textcolor{keywordtype}{int} \&pow10\_exponent) \{}
\DoxyCodeLine{445   \textcolor{keyword}{const} \textcolor{keywordtype}{double} one\_over\_log2\_10 = 0.30102999566398114;  \textcolor{comment}{// 1 / log2(10)}}
\DoxyCodeLine{446   \textcolor{keywordtype}{int} index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(std::ceil(}
\DoxyCodeLine{447         (min\_exponent + fp::significand\_size -\/ 1) * one\_over\_log2\_10));}
\DoxyCodeLine{448   \textcolor{comment}{// Decimal exponent of the first (smallest) cached power of 10.}}
\DoxyCodeLine{449   \textcolor{keyword}{const} \textcolor{keywordtype}{int} first\_dec\_exp = -\/348;}
\DoxyCodeLine{450   \textcolor{comment}{// Difference between 2 consecutive decimal exponents in cached powers of 10.}}
\DoxyCodeLine{451   \textcolor{keyword}{const} \textcolor{keywordtype}{int} dec\_exp\_step = 8;}
\DoxyCodeLine{452   index = (index -\/ first\_dec\_exp -\/ 1) / dec\_exp\_step + 1;}
\DoxyCodeLine{453   pow10\_exponent = first\_dec\_exp + index * dec\_exp\_step;}
\DoxyCodeLine{454   \textcolor{keywordflow}{return} fp(data::POW10\_SIGNIFICANDS[index], data::POW10\_EXPONENTS[index]);}
\DoxyCodeLine{455 \}}
\DoxyCodeLine{456 }
\DoxyCodeLine{457 \textcolor{comment}{// Generates output using Grisu2 digit-\/gen algorithm.}}
\DoxyCodeLine{458 FMT\_FUNC \textcolor{keywordtype}{void} grisu2\_gen\_digits(}
\DoxyCodeLine{459     \textcolor{keyword}{const} fp \&scaled\_value, \textcolor{keyword}{const} fp \&scaled\_upper, uint64\_t delta,}
\DoxyCodeLine{460     \textcolor{keywordtype}{char} *buffer, \textcolor{keywordtype}{size\_t} \&size, \textcolor{keywordtype}{int} \&dec\_exp) \{}
\DoxyCodeLine{461   \mbox{\hyperlink{classinternal_1_1fp}{internal::fp}} one(1ull << -\/scaled\_upper.e, scaled\_upper.e);}
\DoxyCodeLine{462   \textcolor{comment}{// hi (p1 in Grisu) contains the most significant digits of scaled\_upper.}}
\DoxyCodeLine{463   \textcolor{comment}{// hi = floor(scaled\_upper / one).}}
\DoxyCodeLine{464   uint32\_t hi = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(scaled\_upper.f >> -\/one.e);}
\DoxyCodeLine{465   \textcolor{comment}{// lo (p2 in Grisu) contains the least significants digits of scaled\_upper.}}
\DoxyCodeLine{466   \textcolor{comment}{// lo = scaled\_upper mod 1.}}
\DoxyCodeLine{467   uint64\_t lo = scaled\_upper.f \& (one.f -\/ 1);}
\DoxyCodeLine{468   size = 0;}
\DoxyCodeLine{469   \textcolor{keyword}{auto} exp = count\_digits(hi);  \textcolor{comment}{// kappa in Grisu.}}
\DoxyCodeLine{470   \textcolor{keywordflow}{while} (exp > 0) \{}
\DoxyCodeLine{471     uint32\_t digit = 0;}
\DoxyCodeLine{472     \textcolor{comment}{// This optimization by miloyip reduces the number of integer divisions by}}
\DoxyCodeLine{473     \textcolor{comment}{// one per iteration.}}
\DoxyCodeLine{474     \textcolor{keywordflow}{switch} (exp) \{}
\DoxyCodeLine{475     \textcolor{keywordflow}{case} 10: digit = hi / 1000000000; hi \%= 1000000000; \textcolor{keywordflow}{break};}
\DoxyCodeLine{476     \textcolor{keywordflow}{case}  9: digit = hi /  100000000; hi \%=  100000000; \textcolor{keywordflow}{break};}
\DoxyCodeLine{477     \textcolor{keywordflow}{case}  8: digit = hi /   10000000; hi \%=   10000000; \textcolor{keywordflow}{break};}
\DoxyCodeLine{478     \textcolor{keywordflow}{case}  7: digit = hi /    1000000; hi \%=    1000000; \textcolor{keywordflow}{break};}
\DoxyCodeLine{479     \textcolor{keywordflow}{case}  6: digit = hi /     100000; hi \%=     100000; \textcolor{keywordflow}{break};}
\DoxyCodeLine{480     \textcolor{keywordflow}{case}  5: digit = hi /      10000; hi \%=      10000; \textcolor{keywordflow}{break};}
\DoxyCodeLine{481     \textcolor{keywordflow}{case}  4: digit = hi /       1000; hi \%=       1000; \textcolor{keywordflow}{break};}
\DoxyCodeLine{482     \textcolor{keywordflow}{case}  3: digit = hi /        100; hi \%=        100; \textcolor{keywordflow}{break};}
\DoxyCodeLine{483     \textcolor{keywordflow}{case}  2: digit = hi /         10; hi \%=         10; \textcolor{keywordflow}{break};}
\DoxyCodeLine{484     \textcolor{keywordflow}{case}  1: digit = hi;              hi =           0; \textcolor{keywordflow}{break};}
\DoxyCodeLine{485     \textcolor{keywordflow}{default}:}
\DoxyCodeLine{486       FMT\_ASSERT(\textcolor{keyword}{false}, \textcolor{stringliteral}{"{}invalid number of digits"{}});}
\DoxyCodeLine{487     \}}
\DoxyCodeLine{488     \textcolor{keywordflow}{if} (digit != 0 || size != 0)}
\DoxyCodeLine{489       buffer[size++] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + digit);}
\DoxyCodeLine{490     -\/-\/exp;}
\DoxyCodeLine{491     uint64\_t remainder = (\textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(hi) << -\/one.e) + lo;}
\DoxyCodeLine{492     \textcolor{keywordflow}{if} (remainder <= delta) \{}
\DoxyCodeLine{493       dec\_exp += exp;}
\DoxyCodeLine{494       \textcolor{comment}{// TODO: use scaled\_value}}
\DoxyCodeLine{495       (void)scaled\_value;}
\DoxyCodeLine{496       \textcolor{keywordflow}{return};}
\DoxyCodeLine{497     \}}
\DoxyCodeLine{498   \}}
\DoxyCodeLine{499   \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{500     lo *= 10;}
\DoxyCodeLine{501     delta *= 10;}
\DoxyCodeLine{502     \textcolor{keywordtype}{char} digit = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(lo >> -\/one.e);}
\DoxyCodeLine{503     \textcolor{keywordflow}{if} (digit != 0 || size != 0)}
\DoxyCodeLine{504       buffer[size++] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + digit);}
\DoxyCodeLine{505     lo \&= one.f -\/ 1;}
\DoxyCodeLine{506     -\/-\/exp;}
\DoxyCodeLine{507     \textcolor{keywordflow}{if} (lo < delta) \{}
\DoxyCodeLine{508       dec\_exp += exp;}
\DoxyCodeLine{509       \textcolor{keywordflow}{return};}
\DoxyCodeLine{510     \}}
\DoxyCodeLine{511   \}}
\DoxyCodeLine{512 \}}
\DoxyCodeLine{513 }
\DoxyCodeLine{514 FMT\_FUNC \textcolor{keywordtype}{void} grisu2\_format\_positive(\textcolor{keywordtype}{double} value, \textcolor{keywordtype}{char} *buffer, \textcolor{keywordtype}{size\_t} \&size,}
\DoxyCodeLine{515                                      \textcolor{keywordtype}{int} \&dec\_exp) \{}
\DoxyCodeLine{516   FMT\_ASSERT(value > 0, \textcolor{stringliteral}{"{}value is nonpositive"{}});}
\DoxyCodeLine{517   fp fp\_value(value);}
\DoxyCodeLine{518   fp lower, upper;  \textcolor{comment}{// w\string^-\/ and w\string^+ in the Grisu paper.}}
\DoxyCodeLine{519   fp\_value.compute\_boundaries(lower, upper);}
\DoxyCodeLine{520   \textcolor{comment}{// Find a cached power of 10 close to 1 / upper.}}
\DoxyCodeLine{521   \textcolor{keyword}{const} \textcolor{keywordtype}{int} min\_exp = -\/60;  \textcolor{comment}{// alpha in Grisu.}}
\DoxyCodeLine{522   \textcolor{keyword}{auto} dec\_pow = get\_cached\_power(  \textcolor{comment}{// \(\backslash\)tilde\{c\}\_\{-\/k\} in Grisu.}}
\DoxyCodeLine{523       min\_exp -\/ (upper.e + fp::significand\_size), dec\_exp);}
\DoxyCodeLine{524   dec\_exp = -\/dec\_exp;}
\DoxyCodeLine{525   fp\_value.normalize();}
\DoxyCodeLine{526   fp scaled\_value = fp\_value * dec\_pow;}
\DoxyCodeLine{527   fp scaled\_lower = lower * dec\_pow;  \textcolor{comment}{// \(\backslash\)tilde\{M\}\string^-\/ in Grisu.}}
\DoxyCodeLine{528   fp scaled\_upper = upper * dec\_pow;  \textcolor{comment}{// \(\backslash\)tilde\{M\}\string^+ in Grisu.}}
\DoxyCodeLine{529   ++scaled\_lower.f;  \textcolor{comment}{// \(\backslash\)tilde\{M\}\string^-\/ + 1 ulp -\/> M\string^-\/\_\{\(\backslash\)uparrow\}.}}
\DoxyCodeLine{530   -\/-\/scaled\_upper.f;  \textcolor{comment}{// \(\backslash\)tilde\{M\}\string^+ -\/ 1 ulp -\/> M\string^+\_\{\(\backslash\)downarrow\}.}}
\DoxyCodeLine{531   uint64\_t delta = scaled\_upper.f -\/ scaled\_lower.f;}
\DoxyCodeLine{532   grisu2\_gen\_digits(scaled\_value, scaled\_upper, delta, buffer, size, dec\_exp);}
\DoxyCodeLine{533 \}}
\DoxyCodeLine{534 }
\DoxyCodeLine{535 FMT\_FUNC \textcolor{keywordtype}{void} round(\textcolor{keywordtype}{char} *buffer, \textcolor{keywordtype}{size\_t} \&size, \textcolor{keywordtype}{int} \&exp,}
\DoxyCodeLine{536                     \textcolor{keywordtype}{int} digits\_to\_remove) \{}
\DoxyCodeLine{537   size -\/= to\_unsigned(digits\_to\_remove);}
\DoxyCodeLine{538   exp += digits\_to\_remove;}
\DoxyCodeLine{539   \textcolor{keywordtype}{int} digit = buffer[size] -\/ \textcolor{charliteral}{'0'};}
\DoxyCodeLine{540   \textcolor{comment}{// TODO: proper rounding and carry}}
\DoxyCodeLine{541   \textcolor{keywordflow}{if} (digit > 5 || (digit == 5 \&\& (digits\_to\_remove > 1 ||}
\DoxyCodeLine{542                                    (buffer[size -\/ 1] -\/ \textcolor{charliteral}{'0'}) \% 2) != 0)) \{}
\DoxyCodeLine{543     ++buffer[size -\/ 1];}
\DoxyCodeLine{544   \}}
\DoxyCodeLine{545 \}}
\DoxyCodeLine{546 }
\DoxyCodeLine{547 \textcolor{comment}{// Writes the exponent exp in the form "{}[+-\/]d\{1,3\}"{} to buffer.}}
\DoxyCodeLine{548 FMT\_FUNC \textcolor{keywordtype}{char} *write\_exponent(\textcolor{keywordtype}{char} *buffer, \textcolor{keywordtype}{int} exp) \{}
\DoxyCodeLine{549   FMT\_ASSERT(-\/1000 < exp \&\& exp < 1000, \textcolor{stringliteral}{"{}exponent out of range"{}});}
\DoxyCodeLine{550   \textcolor{keywordflow}{if} (exp < 0) \{}
\DoxyCodeLine{551     *buffer++ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{552     exp = -\/exp;}
\DoxyCodeLine{553   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{554     *buffer++ = \textcolor{charliteral}{'+'};}
\DoxyCodeLine{555   \}}
\DoxyCodeLine{556   \textcolor{keywordflow}{if} (exp >= 100) \{}
\DoxyCodeLine{557     *buffer++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + exp / 100);}
\DoxyCodeLine{558     exp \%= 100;}
\DoxyCodeLine{559     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *d = data::DIGITS + exp * 2;}
\DoxyCodeLine{560     *buffer++ = d[0];}
\DoxyCodeLine{561     *buffer++ = d[1];}
\DoxyCodeLine{562   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{563     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *d = data::DIGITS + exp * 2;}
\DoxyCodeLine{564     *buffer++ = d[0];}
\DoxyCodeLine{565     *buffer++ = d[1];}
\DoxyCodeLine{566   \}}
\DoxyCodeLine{567   \textcolor{keywordflow}{return} buffer;}
\DoxyCodeLine{568 \}}
\DoxyCodeLine{569 }
\DoxyCodeLine{570 FMT\_FUNC \textcolor{keywordtype}{void} format\_exp\_notation(}
\DoxyCodeLine{571     \textcolor{keywordtype}{char} *buffer, \textcolor{keywordtype}{size\_t} \&size, \textcolor{keywordtype}{int} exp, \textcolor{keywordtype}{int} precision, \textcolor{keywordtype}{bool} upper) \{}
\DoxyCodeLine{572   \textcolor{comment}{// Insert a decimal point after the first digit and add an exponent.}}
\DoxyCodeLine{573   std::memmove(buffer + 2, buffer + 1, size -\/ 1);}
\DoxyCodeLine{574   buffer[1] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{575   exp += \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(size) -\/ 1;}
\DoxyCodeLine{576   \textcolor{keywordtype}{int} num\_digits = precision -\/ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(size) + 1;}
\DoxyCodeLine{577   \textcolor{keywordflow}{if} (num\_digits > 0) \{}
\DoxyCodeLine{578     std::uninitialized\_fill\_n(buffer + size + 1, num\_digits, \textcolor{charliteral}{'0'});}
\DoxyCodeLine{579     size += to\_unsigned(num\_digits);}
\DoxyCodeLine{580   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (num\_digits < 0) \{}
\DoxyCodeLine{581     round(buffer, size, exp, -\/num\_digits);}
\DoxyCodeLine{582   \}}
\DoxyCodeLine{583   \textcolor{keywordtype}{char} *p = buffer + size + 1;}
\DoxyCodeLine{584   *p++ = upper ? \textcolor{charliteral}{'E'} : \textcolor{charliteral}{'e'};}
\DoxyCodeLine{585   size = to\_unsigned(write\_exponent(p, exp) -\/ buffer);}
\DoxyCodeLine{586 \}}
\DoxyCodeLine{587 }
\DoxyCodeLine{588 \textcolor{comment}{// Prettifies the output of the Grisu2 algorithm.}}
\DoxyCodeLine{589 \textcolor{comment}{// The number is given as v = buffer * 10\string^exp.}}
\DoxyCodeLine{590 FMT\_FUNC \textcolor{keywordtype}{void} grisu2\_prettify(\textcolor{keywordtype}{char} *buffer, \textcolor{keywordtype}{size\_t} \&size, \textcolor{keywordtype}{int} exp,}
\DoxyCodeLine{591                               \textcolor{keywordtype}{int} precision, \textcolor{keywordtype}{bool} upper) \{}
\DoxyCodeLine{592   \textcolor{comment}{// pow(10, full\_exp -\/ 1) <= v <= pow(10, full\_exp).}}
\DoxyCodeLine{593   \textcolor{keywordtype}{int} int\_size = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(size);}
\DoxyCodeLine{594   \textcolor{keywordtype}{int} full\_exp = int\_size + exp;}
\DoxyCodeLine{595   \textcolor{keyword}{const} \textcolor{keywordtype}{int} exp\_threshold = 21;}
\DoxyCodeLine{596   \textcolor{keywordflow}{if} (int\_size <= full\_exp \&\& full\_exp <= exp\_threshold) \{}
\DoxyCodeLine{597     \textcolor{comment}{// 1234e7 -\/> 12340000000[.0+]}}
\DoxyCodeLine{598     std::uninitialized\_fill\_n(buffer + int\_size, full\_exp -\/ int\_size, \textcolor{charliteral}{'0'});}
\DoxyCodeLine{599     \textcolor{keywordtype}{char} *p = buffer + full\_exp;}
\DoxyCodeLine{600     \textcolor{keywordflow}{if} (precision > 0) \{}
\DoxyCodeLine{601       *p++ = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{602       std::uninitialized\_fill\_n(p, precision, \textcolor{charliteral}{'0'});}
\DoxyCodeLine{603       p += precision;}
\DoxyCodeLine{604     \}}
\DoxyCodeLine{605     size = to\_unsigned(p -\/ buffer);}
\DoxyCodeLine{606   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (0 < full\_exp \&\& full\_exp <= exp\_threshold) \{}
\DoxyCodeLine{607     \textcolor{comment}{// 1234e-\/2 -\/> 12.34[0+]}}
\DoxyCodeLine{608     \textcolor{keywordtype}{int} fractional\_size = -\/exp;}
\DoxyCodeLine{609     std::memmove(buffer + full\_exp + 1, buffer + full\_exp,}
\DoxyCodeLine{610                  to\_unsigned(fractional\_size));}
\DoxyCodeLine{611     buffer[full\_exp] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{612     \textcolor{keywordtype}{int} num\_zeros = precision -\/ fractional\_size;}
\DoxyCodeLine{613     \textcolor{keywordflow}{if} (num\_zeros > 0) \{}
\DoxyCodeLine{614       std::uninitialized\_fill\_n(buffer + size + 1, num\_zeros, \textcolor{charliteral}{'0'});}
\DoxyCodeLine{615       size += to\_unsigned(num\_zeros);}
\DoxyCodeLine{616     \}}
\DoxyCodeLine{617     ++size;}
\DoxyCodeLine{618   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (-\/6 < full\_exp \&\& full\_exp <= 0) \{}
\DoxyCodeLine{619     \textcolor{comment}{// 1234e-\/6 -\/> 0.001234}}
\DoxyCodeLine{620     \textcolor{keywordtype}{int} offset = 2 -\/ full\_exp;}
\DoxyCodeLine{621     std::memmove(buffer + offset, buffer, size);}
\DoxyCodeLine{622     buffer[0] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{623     buffer[1] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{624     std::uninitialized\_fill\_n(buffer + 2, -\/full\_exp, \textcolor{charliteral}{'0'});}
\DoxyCodeLine{625     size = to\_unsigned(int\_size + offset);}
\DoxyCodeLine{626   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{627     format\_exp\_notation(buffer, size, exp, precision, upper);}
\DoxyCodeLine{628   \}}
\DoxyCodeLine{629 \}}
\DoxyCodeLine{630 }
\DoxyCodeLine{631 \textcolor{preprocessor}{\#if FMT\_CLANG\_VERSION}}
\DoxyCodeLine{632 \textcolor{preprocessor}{\# define FMT\_FALLTHROUGH [[clang::fallthrough]];}}
\DoxyCodeLine{633 \textcolor{preprocessor}{\#elif FMT\_GCC\_VERSION >= 700}}
\DoxyCodeLine{634 \textcolor{preprocessor}{\# define FMT\_FALLTHROUGH [[gnu::fallthrough]];}}
\DoxyCodeLine{635 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{636 \textcolor{preprocessor}{\# define FMT\_FALLTHROUGH}}
\DoxyCodeLine{637 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{638 }
\DoxyCodeLine{639 \textcolor{comment}{// Formats a nonnegative value using Grisu2 algorithm. Grisu2 doesn't give any}}
\DoxyCodeLine{640 \textcolor{comment}{// guarantees on the shortness of the result.}}
\DoxyCodeLine{641 FMT\_FUNC \textcolor{keywordtype}{void} grisu2\_format(\textcolor{keywordtype}{double} value, \textcolor{keywordtype}{char} *buffer, \textcolor{keywordtype}{size\_t} \&size, \textcolor{keywordtype}{char} type,}
\DoxyCodeLine{642                             \textcolor{keywordtype}{int} precision, \textcolor{keywordtype}{bool} write\_decimal\_point) \{}
\DoxyCodeLine{643   FMT\_ASSERT(value >= 0, \textcolor{stringliteral}{"{}value is negative"{}});}
\DoxyCodeLine{644   \textcolor{keywordtype}{int} dec\_exp = 0;  \textcolor{comment}{// K in Grisu.}}
\DoxyCodeLine{645   \textcolor{keywordflow}{if} (value > 0) \{}
\DoxyCodeLine{646     grisu2\_format\_positive(value, buffer, size, dec\_exp);}
\DoxyCodeLine{647   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{648     *buffer = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{649     size = 1;}
\DoxyCodeLine{650   \}}
\DoxyCodeLine{651   \textcolor{keyword}{const} \textcolor{keywordtype}{int} default\_precision = 6;}
\DoxyCodeLine{652   \textcolor{keywordflow}{if} (precision < 0)}
\DoxyCodeLine{653     precision = default\_precision;}
\DoxyCodeLine{654   \textcolor{keywordtype}{bool} upper = \textcolor{keyword}{false};}
\DoxyCodeLine{655   \textcolor{keywordflow}{switch} (type) \{}
\DoxyCodeLine{656   \textcolor{keywordflow}{case} \textcolor{charliteral}{'G'}:}
\DoxyCodeLine{657     upper = \textcolor{keyword}{true};}
\DoxyCodeLine{658     FMT\_FALLTHROUGH}
\DoxyCodeLine{659   \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)0'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'g'}: \{}
\DoxyCodeLine{660     \textcolor{keywordtype}{int} digits\_to\_remove = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(size) -\/ precision;}
\DoxyCodeLine{661     \textcolor{keywordflow}{if} (digits\_to\_remove > 0) \{}
\DoxyCodeLine{662       round(buffer, size, dec\_exp, digits\_to\_remove);}
\DoxyCodeLine{663       \textcolor{comment}{// Remove trailing zeros.}}
\DoxyCodeLine{664       \textcolor{keywordflow}{while} (size > 0 \&\& buffer[size -\/ 1] == \textcolor{charliteral}{'0'}) \{}
\DoxyCodeLine{665         -\/-\/size;}
\DoxyCodeLine{666         ++dec\_exp;}
\DoxyCodeLine{667       \}}
\DoxyCodeLine{668     \}}
\DoxyCodeLine{669     precision = 0;}
\DoxyCodeLine{670     \textcolor{keywordflow}{break};}
\DoxyCodeLine{671   \}}
\DoxyCodeLine{672   \textcolor{keywordflow}{case} \textcolor{charliteral}{'F'}:}
\DoxyCodeLine{673     upper = \textcolor{keyword}{true};}
\DoxyCodeLine{674     FMT\_FALLTHROUGH}
\DoxyCodeLine{675   \textcolor{keywordflow}{case} \textcolor{charliteral}{'f'}: \{}
\DoxyCodeLine{676     \textcolor{keywordtype}{int} digits\_to\_remove = -\/dec\_exp -\/ precision;}
\DoxyCodeLine{677     \textcolor{keywordflow}{if} (digits\_to\_remove > 0) \{}
\DoxyCodeLine{678       \textcolor{keywordflow}{if} (digits\_to\_remove >= \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(size))}
\DoxyCodeLine{679         digits\_to\_remove = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(size) -\/ 1;}
\DoxyCodeLine{680       round(buffer, size, dec\_exp, digits\_to\_remove);}
\DoxyCodeLine{681     \}}
\DoxyCodeLine{682     \textcolor{keywordflow}{break};}
\DoxyCodeLine{683   \}}
\DoxyCodeLine{684   \textcolor{keywordflow}{case} \textcolor{charliteral}{'e'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'E'}:}
\DoxyCodeLine{685     format\_exp\_notation(buffer, size, dec\_exp, precision, type == \textcolor{charliteral}{'E'});}
\DoxyCodeLine{686     \textcolor{keywordflow}{return};}
\DoxyCodeLine{687   \}}
\DoxyCodeLine{688   \textcolor{keywordflow}{if} (write\_decimal\_point \&\& precision < 1)}
\DoxyCodeLine{689     precision = 1;}
\DoxyCodeLine{690   grisu2\_prettify(buffer, size, dec\_exp, precision, upper);}
\DoxyCodeLine{691 \}}
\DoxyCodeLine{692 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{693 }
\DoxyCodeLine{694 \textcolor{preprocessor}{\#if FMT\_USE\_WINDOWS\_H}}
\DoxyCodeLine{695 }
\DoxyCodeLine{696 FMT\_FUNC internal::utf8\_to\_utf16::utf8\_to\_utf16(\mbox{\hyperlink{classbasic__string__view}{string\_view}} s) \{}
\DoxyCodeLine{697   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} ERROR\_MSG[] = \textcolor{stringliteral}{"{}cannot convert string from UTF-\/8 to UTF-\/16"{}};}
\DoxyCodeLine{698   \textcolor{keywordflow}{if} (s.size() > INT\_MAX)}
\DoxyCodeLine{699     FMT\_THROW(windows\_error(ERROR\_INVALID\_PARAMETER, ERROR\_MSG));}
\DoxyCodeLine{700   \textcolor{keywordtype}{int} s\_size = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(s.size());}
\DoxyCodeLine{701   \textcolor{keywordflow}{if} (s\_size == 0) \{}
\DoxyCodeLine{702     \textcolor{comment}{// MultiByteToWideChar does not support zero length, handle separately.}}
\DoxyCodeLine{703     buffer\_.resize(1);}
\DoxyCodeLine{704     buffer\_[0] = 0;}
\DoxyCodeLine{705     \textcolor{keywordflow}{return};}
\DoxyCodeLine{706   \}}
\DoxyCodeLine{707 }
\DoxyCodeLine{708   \textcolor{keywordtype}{int} length = MultiByteToWideChar(}
\DoxyCodeLine{709       CP\_UTF8, MB\_ERR\_INVALID\_CHARS, s.data(), s\_size, FMT\_NULL, 0);}
\DoxyCodeLine{710   \textcolor{keywordflow}{if} (length == 0)}
\DoxyCodeLine{711     FMT\_THROW(windows\_error(GetLastError(), ERROR\_MSG));}
\DoxyCodeLine{712   buffer\_.resize(length + 1);}
\DoxyCodeLine{713   length = MultiByteToWideChar(}
\DoxyCodeLine{714     CP\_UTF8, MB\_ERR\_INVALID\_CHARS, s.data(), s\_size, \&buffer\_[0], length);}
\DoxyCodeLine{715   \textcolor{keywordflow}{if} (length == 0)}
\DoxyCodeLine{716     FMT\_THROW(windows\_error(GetLastError(), ERROR\_MSG));}
\DoxyCodeLine{717   buffer\_[length] = 0;}
\DoxyCodeLine{718 \}}
\DoxyCodeLine{719 }
\DoxyCodeLine{720 FMT\_FUNC internal::utf16\_to\_utf8::utf16\_to\_utf8(\mbox{\hyperlink{classbasic__string__view}{wstring\_view}} s) \{}
\DoxyCodeLine{721   \textcolor{keywordflow}{if} (\textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}} = convert(s)) \{}
\DoxyCodeLine{722     FMT\_THROW(windows\_error(\mbox{\hyperlink{classerror__code}{error\_code}},}
\DoxyCodeLine{723         \textcolor{stringliteral}{"{}cannot convert string from UTF-\/16 to UTF-\/8"{}}));}
\DoxyCodeLine{724   \}}
\DoxyCodeLine{725 \}}
\DoxyCodeLine{726 }
\DoxyCodeLine{727 FMT\_FUNC \textcolor{keywordtype}{int} internal::utf16\_to\_utf8::convert(\mbox{\hyperlink{classbasic__string__view}{wstring\_view}} s) \{}
\DoxyCodeLine{728   \textcolor{keywordflow}{if} (s.size() > INT\_MAX)}
\DoxyCodeLine{729     \textcolor{keywordflow}{return} ERROR\_INVALID\_PARAMETER;}
\DoxyCodeLine{730   \textcolor{keywordtype}{int} s\_size = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(s.size());}
\DoxyCodeLine{731   \textcolor{keywordflow}{if} (s\_size == 0) \{}
\DoxyCodeLine{732     \textcolor{comment}{// WideCharToMultiByte does not support zero length, handle separately.}}
\DoxyCodeLine{733     buffer\_.resize(1);}
\DoxyCodeLine{734     buffer\_[0] = 0;}
\DoxyCodeLine{735     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{736   \}}
\DoxyCodeLine{737 }
\DoxyCodeLine{738   \textcolor{keywordtype}{int} length = WideCharToMultiByte(}
\DoxyCodeLine{739         CP\_UTF8, 0, s.data(), s\_size, FMT\_NULL, 0, FMT\_NULL, FMT\_NULL);}
\DoxyCodeLine{740   \textcolor{keywordflow}{if} (length == 0)}
\DoxyCodeLine{741     \textcolor{keywordflow}{return} GetLastError();}
\DoxyCodeLine{742   buffer\_.resize(length + 1);}
\DoxyCodeLine{743   length = WideCharToMultiByte(}
\DoxyCodeLine{744     CP\_UTF8, 0, s.data(), s\_size, \&buffer\_[0], length, FMT\_NULL, FMT\_NULL);}
\DoxyCodeLine{745   \textcolor{keywordflow}{if} (length == 0)}
\DoxyCodeLine{746     \textcolor{keywordflow}{return} GetLastError();}
\DoxyCodeLine{747   buffer\_[length] = 0;}
\DoxyCodeLine{748   \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{749 \}}
\DoxyCodeLine{750 }
\DoxyCodeLine{751 FMT\_FUNC \textcolor{keywordtype}{void} windows\_error::init(}
\DoxyCodeLine{752     \textcolor{keywordtype}{int} err\_code, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \mbox{\hyperlink{structformat__args}{format\_args}} args) \{}
\DoxyCodeLine{753   error\_code\_ = err\_code;}
\DoxyCodeLine{754   \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}} buffer;}
\DoxyCodeLine{755   internal::format\_windows\_error(buffer, err\_code, vformat(format\_str, args));}
\DoxyCodeLine{756   std::runtime\_error \&\mbox{\hyperlink{classbase}{base}} = *\textcolor{keyword}{this};}
\DoxyCodeLine{757   \mbox{\hyperlink{classbase}{base}} = std::runtime\_error(to\_string(buffer));}
\DoxyCodeLine{758 \}}
\DoxyCodeLine{759 }
\DoxyCodeLine{760 FMT\_FUNC \textcolor{keywordtype}{void} internal::format\_windows\_error(}
\DoxyCodeLine{761     \mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::buffer}} \&out, \textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}}, \mbox{\hyperlink{classbasic__string__view}{string\_view}} message) FMT\_NOEXCEPT \{}
\DoxyCodeLine{762   FMT\_TRY \{}
\DoxyCodeLine{763     \mbox{\hyperlink{classbasic__memory__buffer}{wmemory\_buffer}} buf;}
\DoxyCodeLine{764     buf.\mbox{\hyperlink{classinternal_1_1basic__buffer_adbd2b147e114f0cc4573f734d4326669}{resize}}(inline\_buffer\_size);}
\DoxyCodeLine{765     \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{766       \textcolor{keywordtype}{wchar\_t} *system\_message = \&buf[0];}
\DoxyCodeLine{767       \textcolor{keywordtype}{int} result = FormatMessageW(}
\DoxyCodeLine{768           FORMAT\_MESSAGE\_FROM\_SYSTEM | FORMAT\_MESSAGE\_IGNORE\_INSERTS,}
\DoxyCodeLine{769           FMT\_NULL, \mbox{\hyperlink{classerror__code}{error\_code}}, MAKELANGID(LANG\_NEUTRAL, SUBLANG\_DEFAULT),}
\DoxyCodeLine{770           system\_message, \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(buf.\mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}}()), FMT\_NULL);}
\DoxyCodeLine{771       \textcolor{keywordflow}{if} (result != 0) \{}
\DoxyCodeLine{772         utf16\_to\_utf8 utf8\_message;}
\DoxyCodeLine{773         \textcolor{keywordflow}{if} (utf8\_message.convert(system\_message) == ERROR\_SUCCESS) \{}
\DoxyCodeLine{774           \mbox{\hyperlink{classbasic__writer}{writer}} w(out);}
\DoxyCodeLine{775           w.write(message);}
\DoxyCodeLine{776           w.write(\textcolor{stringliteral}{"{}: "{}});}
\DoxyCodeLine{777           w.write(utf8\_message);}
\DoxyCodeLine{778           \textcolor{keywordflow}{return};}
\DoxyCodeLine{779         \}}
\DoxyCodeLine{780         \textcolor{keywordflow}{break};}
\DoxyCodeLine{781       \}}
\DoxyCodeLine{782       \textcolor{keywordflow}{if} (GetLastError() != ERROR\_INSUFFICIENT\_BUFFER)}
\DoxyCodeLine{783         \textcolor{keywordflow}{break};  \textcolor{comment}{// Can't get error message, report error code instead.}}
\DoxyCodeLine{784       buf.\mbox{\hyperlink{classinternal_1_1basic__buffer_adbd2b147e114f0cc4573f734d4326669}{resize}}(buf.\mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}}() * 2);}
\DoxyCodeLine{785     \}}
\DoxyCodeLine{786   \} FMT\_CATCH(...) \{\}}
\DoxyCodeLine{787   format\_error\_code(out, \mbox{\hyperlink{classerror__code}{error\_code}}, message);}
\DoxyCodeLine{788 \}}
\DoxyCodeLine{789 }
\DoxyCodeLine{790 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_USE\_WINDOWS\_H}}
\DoxyCodeLine{791 }
\DoxyCodeLine{792 FMT\_FUNC \textcolor{keywordtype}{void} format\_system\_error(}
\DoxyCodeLine{793     \mbox{\hyperlink{classinternal_1_1basic__buffer}{internal::buffer}} \&out, \textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}}, \mbox{\hyperlink{classbasic__string__view}{string\_view}} message) FMT\_NOEXCEPT \{}
\DoxyCodeLine{794   FMT\_TRY \{}
\DoxyCodeLine{795     \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}} buf;}
\DoxyCodeLine{796     buf.\mbox{\hyperlink{classinternal_1_1basic__buffer_adbd2b147e114f0cc4573f734d4326669}{resize}}(inline\_buffer\_size);}
\DoxyCodeLine{797     \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{798       \textcolor{keywordtype}{char} *system\_message = \&buf[0];}
\DoxyCodeLine{799       \textcolor{keywordtype}{int} result = safe\_strerror(\mbox{\hyperlink{classerror__code}{error\_code}}, system\_message, buf.\mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}}());}
\DoxyCodeLine{800       \textcolor{keywordflow}{if} (result == 0) \{}
\DoxyCodeLine{801         \mbox{\hyperlink{classbasic__writer}{writer}} w(out);}
\DoxyCodeLine{802         w.write(message);}
\DoxyCodeLine{803         w.write(\textcolor{stringliteral}{"{}: "{}});}
\DoxyCodeLine{804         w.write(system\_message);}
\DoxyCodeLine{805         \textcolor{keywordflow}{return};}
\DoxyCodeLine{806       \}}
\DoxyCodeLine{807       \textcolor{keywordflow}{if} (result != ERANGE)}
\DoxyCodeLine{808         \textcolor{keywordflow}{break};  \textcolor{comment}{// Can't get error message, report error code instead.}}
\DoxyCodeLine{809       buf.\mbox{\hyperlink{classinternal_1_1basic__buffer_adbd2b147e114f0cc4573f734d4326669}{resize}}(buf.\mbox{\hyperlink{classinternal_1_1basic__buffer_abc95713c3873c5820f10105fe7c7af93}{size}}() * 2);}
\DoxyCodeLine{810     \}}
\DoxyCodeLine{811   \} FMT\_CATCH(...) \{\}}
\DoxyCodeLine{812   format\_error\_code(out, \mbox{\hyperlink{classerror__code}{error\_code}}, message);}
\DoxyCodeLine{813 \}}
\DoxyCodeLine{814 }
\DoxyCodeLine{815 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{816 \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__fixed__buffer_aa806637adc0d00c33902eba220961f9b}{basic\_fixed\_buffer<Char>::grow}}(std::size\_t) \{}
\DoxyCodeLine{817   FMT\_THROW(std::runtime\_error(\textcolor{stringliteral}{"{}buffer overflow"{}}));}
\DoxyCodeLine{818 \}}
\DoxyCodeLine{819 }
\DoxyCodeLine{820 FMT\_FUNC \textcolor{keywordtype}{void} internal::error\_handler::on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *message) \{}
\DoxyCodeLine{821   FMT\_THROW(\mbox{\hyperlink{classformat__error}{format\_error}}(message));}
\DoxyCodeLine{822 \}}
\DoxyCodeLine{823 }
\DoxyCodeLine{824 FMT\_FUNC \textcolor{keywordtype}{void} report\_system\_error(}
\DoxyCodeLine{825     \textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}}, fmt::string\_view message) FMT\_NOEXCEPT \{}
\DoxyCodeLine{826   report\_error(format\_system\_error, \mbox{\hyperlink{classerror__code}{error\_code}}, message);}
\DoxyCodeLine{827 \}}
\DoxyCodeLine{828 }
\DoxyCodeLine{829 \textcolor{preprocessor}{\#if FMT\_USE\_WINDOWS\_H}}
\DoxyCodeLine{830 FMT\_FUNC \textcolor{keywordtype}{void} report\_windows\_error(}
\DoxyCodeLine{831     \textcolor{keywordtype}{int} \mbox{\hyperlink{classerror__code}{error\_code}}, fmt::string\_view message) FMT\_NOEXCEPT \{}
\DoxyCodeLine{832   report\_error(internal::format\_windows\_error, \mbox{\hyperlink{classerror__code}{error\_code}}, message);}
\DoxyCodeLine{833 \}}
\DoxyCodeLine{834 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{835 }
\DoxyCodeLine{836 FMT\_FUNC \textcolor{keywordtype}{void} vprint(std::FILE *f, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \mbox{\hyperlink{structformat__args}{format\_args}} args) \{}
\DoxyCodeLine{837   \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}} buffer;}
\DoxyCodeLine{838   vformat\_to(buffer, format\_str, args);}
\DoxyCodeLine{839   std::fwrite(buffer.data(), 1, buffer.size(), f);}
\DoxyCodeLine{840 \}}
\DoxyCodeLine{841 }
\DoxyCodeLine{842 FMT\_FUNC \textcolor{keywordtype}{void} vprint(std::FILE *f, \mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str, \mbox{\hyperlink{structwformat__args}{wformat\_args}} args) \{}
\DoxyCodeLine{843   \mbox{\hyperlink{classbasic__memory__buffer}{wmemory\_buffer}} buffer;}
\DoxyCodeLine{844   vformat\_to(buffer, format\_str, args);}
\DoxyCodeLine{845   std::fwrite(buffer.data(), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t}), buffer.size(), f);}
\DoxyCodeLine{846 \}}
\DoxyCodeLine{847 }
\DoxyCodeLine{848 FMT\_FUNC \textcolor{keywordtype}{void} vprint(\mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str, \mbox{\hyperlink{structformat__args}{format\_args}} args) \{}
\DoxyCodeLine{849   vprint(stdout, format\_str, args);}
\DoxyCodeLine{850 \}}
\DoxyCodeLine{851 }
\DoxyCodeLine{852 FMT\_FUNC \textcolor{keywordtype}{void} vprint(\mbox{\hyperlink{classbasic__string__view}{wstring\_view}} format\_str, \mbox{\hyperlink{structwformat__args}{wformat\_args}} args) \{}
\DoxyCodeLine{853   vprint(stdout, format\_str, args);}
\DoxyCodeLine{854 \}}
\DoxyCodeLine{855 }
\DoxyCodeLine{856 \textcolor{preprocessor}{\#if !defined(FMT\_STATIC\_THOUSANDS\_SEPARATOR)}}
\DoxyCodeLine{857 FMT\_FUNC \mbox{\hyperlink{classlocale}{locale}} locale\_provider::locale() \{ \textcolor{keywordflow}{return} fmt::locale(); \}}
\DoxyCodeLine{858 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{859 }
\DoxyCodeLine{860 FMT\_END\_NAMESPACE}
\DoxyCodeLine{861 }
\DoxyCodeLine{862 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{863 \textcolor{preprocessor}{\# pragma warning(pop)}}
\DoxyCodeLine{864 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{865 }
\DoxyCodeLine{866 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_FORMAT\_INL\_H\_}}

\end{DoxyCode}
